// ### AUTO-GENERATED ###

enum class MouseButton {
	Unknown = 0xFF,
	Left = 0x0,
	Middle = 0x1,
	Right = 0x2,
};

enum class FadeMode {
	eFadeColor = 0x0,
	eFadeTexture = 0x1,
};

enum class DriverActions {
	eLookingLeft = 0x0,
	eLookingRight = 0x1,
	eDeprecated_2 = 0x2,
	eDeprecated_1 = 0x3,
	eHeadlightsSwitch = 0x4,
	eChangingCamera = 0x5,
	eHorn = 0x6,
	eShiftingUp = 0x7,
	eShiftingDown = 0x8,
	eLookingBack = 0x9,
	eHeadlightsFlash = 0xA,
	eTcUp = 0xB,
	eTcDown = 0xC,
	eAbsUp = 0xD,
	eAbsDown = 0xE,
	eTurboUp = 0xF,
	eTurboDown = 0x10,
	eBrakeBiasUp = 0x11,
	eBrakeBiasDown = 0x12,
	eDRS = 0x13,
	eKERS = 0x14,
	eEngineBrakeUp = 0x15,
	eEngineBrakeDown = 0x16,
	eMGUKDeliveryUp = 0x17,
	eMGUKDeliveryDown = 0x18,
	eMGUKRecoveryUp = 0x19,
	eMGUKRecoveryDown = 0x1A,
	eMGUHMode = 0x1B,
};

enum class JumpStartPenaltyMode {
	eLockOnGridMode = 0x0,
	eTeleportToPitMode = 0x1,
	eDriveThroughMode = 0x2,
};

enum class SessionType {
	Undefined = 0x0,
	Pratice = 0x1,
	Qualify = 0x2,
	Race = 0x3,
	Hotlap = 0x4,
	TimeAttack = 0x5,
	Drift = 0x6,
	Drag = 0x7,
};

enum class DifferentialType {
	LSD = 0x0,
	Spool = 0x1,
};

enum class GearChangeRequest {
	eNoGearRequest = 0x0,
	eChangeUp = 0x1,
	eChangeDown = 0x2,
	eChangeToGear = 0x3,
};

enum class eReplayStatus {
	eReplayPlay = 0x0,
	eReplayPause = 0x1,
	eReplayStop = 0x2,
	eReplayRewind = 0x3,
	eReplayFastForward = 0x4,
	eReplaySlowMotion = 0x5,
	eReplayModeEnter = 0x6,
	eReplayModeExit = 0x7,
	eReplayChangeCar = 0x8,
	eReplayClearing = 0x9,
	eReplaySliderInteraction = 0xA,
	ePhotoMode = 0xB,
	eSingleFrame = 0xC,
};

enum class VoteType {
	eVoteNextSession = 0x0,
	eVoteRestartSession = 0x1,
	eVoteKickUser = 0x2,
	eVoteUnkonw = 0x3,
};

enum class eTimeLineCheckResponse {
	eOutOfRange = 0x0,
	eNegativeSide = 0x1,
	ePositiveSide = 0x2,
};

enum class PenaltyDescription {
	eNothing = 0x0,
	eJumpStart = 0x1,
	eCantPitPenalty = 0x2,
	eMandatoryPit = 0x3,
	eCut = 0x4,
};

enum class eACEventType {
	acEvent_OnCollision = 0x0,
};

enum class DrivableCamera {
	eChase = 0x0,
	eChase2 = 0x1,
	eBonnet = 0x2,
	eBumper = 0x3,
	eDash = 0x4,
};

enum class CameraMode {
	eCockpit = 0x0,
	eCar = 0x1,
	eDrivable = 0x2,
	eTrack = 0x3,
	eHelicopter = 0x4,
	eOnBoardFree = 0x5,
	eFree = 0x6,
	eDeprecated = 0x7,
	eImageGeneratorCamera = 0x8,
	eStart = 0x9,
};

enum class DRWWingConnectionMode {
	UseEffect = 0x0,
	UseAngle = 0x1,
};

enum class KGLTexture_ImageFileFormat {
	eDDS = 0x0,
	ePNG = 0x1,
	eJPG = 0x2,
	eBMP = 0x3,
	eUnknown = 0x4,
};

enum class TelemetryUnits {
	eUnitMeters = 0x0,
	eUnitC = 0x1,
	eUnitG = 0x2,
	eUnitRadSec = 0x3,
	eUnitGeneric = 0x4,
	eUnitMeterSec = 0x5,
	eUnitBar = 0x6,
	eUnitMS = 0x7,
	eUnitNumber = 0x8,
	eUnitPercentage = 0x9,
	eUnitPowerWatt = 0xA,
	eUnitVolumeMQ = 0xB,
	eUnitVoltageV = 0xC,
	eUnitTorqueNM = 0xD,
	eUnitRad = 0xE,
	eUnitForceN = 0xF,
	eUnitMillimiters = 0x10,
	eUnitDeg = 0x11,
	eUnitForceKG = 0x12,
	eUnitRPM = 0x13,
};

enum class PenaltyType {
	eNothing = 0x0,
	eSecsOnResult5 = 0x1,
	eSecsOnResult10 = 0x2,
	eSecsOnResult20 = 0x3,
	eSecsOnResult30 = 0x4,
	eDriveThrough = 0x5,
	eStopAndGo = 0x6,
};

enum class eRenderTargetFormat {
	eOriginalTarget = 0x0,
	eR8G8B8A8 = 0x1,
	eR16G16B16A16 = 0x2,
	eR32F = 0x3,
	eR32Typeless = 0x4,
	eR32Typeless_MS = 0x5,
	eR16F = 0x6,
	eR16G16B16A16_MS = 0x7,
	eR8G8B8A8_MS = 0x8,
};

enum class FlagEventType {
	BlackFlag = 0x0,
	BlackFlagClear = 0x1,
};

enum class eVariableType {
	eFloat = 0x0,
	eFloat2 = 0x1,
	eFloat3 = 0x2,
	eFloat4 = 0x3,
	eMatrix = 0x4,
	eTypeUndefined = 0x5,
};

enum class TimeLineType {
	Default = 0x0,
	ABStart = 0x1,
	ABFinish = 0x2,
};

enum class ILType {
	Default = 0x0,
	Skinned = 0x1,
	Particle = 0x2,
	GUI2D = 0x3,
};

enum class PixelFormat {
	eUnknownFormat = 0x0,
	eRGBA8 = 0x1,
	eRGBA32 = 0x2,
	eBC3Unorm = 0x3,
};

enum class OpenTrackTimeState {
	NotStarted = 0x0,
	Started = 0x1,
};

enum class eFontAlign {
	eAlignLeft = 0x0,
	eAlignRight = 0x1,
	eAlignCenter = 0x2,
};

enum class eFontType {
	eFontProportional = 0x0,
	eFontMonospaced = 0x1,
	eFontCustom = 0x2,
};

enum class CarSetupState {
	UnKnown = 0x0,
	Legal = 0x1,
	Illegal = 0x2,
};

enum class FFPostProcessType {
	Gamma = 0x0,
	Lut = 0x1,
};

enum class RenderPassID {
	Opaque = 0x0,
	Transparent = 0x1,
	Shadowgen = 0x2,
};

enum class DynamicControllerInput {
	UndefinedInput = 0x0,
	Brake = 0x1,
	Gas = 0x2,
	LatG = 0x3,
	LonG = 0x4,
	Steer = 0x5,
	Speed = 0x6,
	Gear = 0x7,
	SlipRatioMAX = 0x8,
	SlipRatioAVG = 0x9,
	SlipAngleFrontAVG = 0xA,
	SlipAngleRearAVG = 0xB,
	SlipAngleFrontMAX = 0xC,
	SlipAngleRearMAX = 0xD,
	OversteerFactor = 0xE,
	RearSpeedRatio = 0xF,
	SteerDEG = 0x10,
	Const = 0x11,
	RPMS = 0x12,
	WheelSteerDEG = 0x13,
	LoadSpreadLF = 0x14,
	LoadSpreadRF = 0x15,
	AvgTravelRear = 0x16,
	SusTravelLR = 0x17,
	SusTravelRR = 0x18,
};

enum class DynamicControllerCombinatorMode {
	eUndefinedMode = 0x0,
	eAdd = 0x1,
	eMult = 0x2,
};

enum class BlendMode {
	eOpaque = 0x0,
	eAlphaBlend = 0x1,
	eAlphaToCoverage = 0x2,
};

enum class CullMode {
	eCullFront = 0x0,
	eCullBack = 0x1,
	eCullNone = 0x2,
	eCullBiased = 0x3,
	eCullWireFrame = 0x4,
	eCullFrontNoMS = 0x5,
};

enum class DepthMode {
	eDepthNormal = 0x0,
	eDepthNoWrite = 0x1,
	eDepthOff = 0x2,
	eDepthLessEqual = 0x3,
};

enum class ksgui_VariableConnection {
	ConnectFloat = 0x0,
	ConnectInt = 0x1,
};

enum class CustomSpinnerMode {
	eStandardSpinner = 0x0,
	eCircularSpinner = 0x1,
	eVerticalSpinBar = 0x2,
};

enum class DynamicWingController_eInputVar {
	eUndefined = 0x0,
	eBrake = 0x1,
	eGas = 0x2,
	eLatG = 0x3,
	eLonG = 0x4,
	eSteer = 0x5,
	eSpeed = 0x6,
	SusTravelLR = 0x7,
	SusTravelRR = 0x8,
};

enum class DynamicWingController_eCombinatorMode {
	eUndefinedMode = 0x0,
	eAdd = 0x1,
	eMult = 0x2,
};

enum class ksgui_eActiveButtonStates {
	eABUnselected = 0x0,
	eABSelected = 0x1,
	eABRollOver = 0x2,
};

enum class eAISplineInterpolationMode {
	eLinear = 0x0,
	eBezier = 0x1,
	eCatmulRom = 0x2,
	eBSpline = 0x3,
	eNThBezier = 0x4,
	eCubicSpline = 0x5,
};

enum class eTaskBarStatus {
	eSelected = 0x0,
	eUnselected = 0x1,
};

enum class ksgui_eArrowsDirection {
	eLeft = 0x0,
	eRight = 0x1,
	eUp = 0x2,
	eDown = 0x3,
};

enum class RigidAxleSide {
	Left = 0x0,
	Right = 0x1,
};

enum class eGLPrimitiveType {
	eLines = 0x0,
	eLinesStrip = 0x1,
	eTriangles = 0x2,
	eQuads = 0x3,
};

enum class ksgui_eListBoxSelectionMode {
	eLineSelected = 0x0,
	eTextHighlighted = 0x1,
};

enum class PenaltyMode {
	CutGas = 0x0,
	InvalidateLap = 0x1,
	RecoverTime = 0x2,
	Nothing = 0x3,
	CutDetection = 0x4,
};

enum class KersAttachment {
	Engine = 0x0,
	Wheels = 0x1,
};

enum class eCameraClearMode {
	eColor = 0x0,
	eDepth = 0x1,
	eColorAndDepth = 0x2,
	eDontClear = 0x3,
};

enum class eAxisRendering {
	eAxisNone = 0x0,
	eAxisBefore3d = 0x1,
	eAxisAfter3d = 0x2,
	eAxisModelBefore3d = 0x3,
	eAxisModelAfter3d = 0x4,
};

enum class FindTyreCompoundLogic {
	Random = 0x0,
	Fastest = 0x1,
	Preferred = 0x2,
};

enum class SamplerState {
	eDefaultSampler = 0x0,
	eLinearClamped = 0x1,
};

enum class EBBMode {
	Disabled = 0x0,
	Internal = 0x1,
	DynamicController = 0x2,
};

enum class TractionType {
	RWD = 0x0,
	FWD = 0x1,
	AWD = 0x2,
	AWD_NEW = 0x3,
};

enum class TorqueModeEX {
	original = 0x0,
	reactionTorques = 0x1,
	driveTorques = 0x2,
};

enum class SuspensionType {
	DoubleWishbone = 0x0,
	Strut = 0x1,
	Axle = 0x2,
	Multilink = 0x3,
};

class CarAvatar;
class ESCMenu;
class Car;
struct SVar;
struct dxGeom;
class RenderWindow;
class ksgui_ScrollBar;
class ksgui_Control;
class ksgui_Slider;
struct TyreThermalPatch;
class ksgui_Spinner;
class ksgui_CheckBox;
struct HWND__;
struct HINSTANCE__;
class IJoint;
class ICollisionObject;
class IRigidBody;
class Camera;
class Node;
class IMaterialOptionChangeListener;
class ksgui_ListBox;
struct ksgui_ListBoxRowData;
class ICarControlsProvider;
class NetCarStateProvider;
class Wing;
class GraphicsManager;
struct SurfaceDef;
class InputDevice;
class DirectInput;
struct RayCastResult;
class IRayCaster;
class Shader;
class Game;
class GameObject;
class CBuffer;
class RaceManager;
class ShaderVariable;
class ShaderResource;
class Joypad;
class Task;
class Sim;
class CameraForward;
class Suspension;
class CarControls;
struct CarControlsInput;
class Track;
class AISpline;
struct dxTriMeshData;
class PhysicsCore;
class SetupItem;
struct KGLShaderVar;
struct KGLShaderTexture;
struct ACPluginContext;
struct ACCarState;
class Renderable;
class ISphereCollisionCallback;
class PhysicsEngine;
class Spline;
struct TimeTransponder;
class Damper;
class ACClient;
class PhysicsAvatar;
class IRayTrackCollisionProvider;
class Material;
class MaterialVar;
class ICollisionCallback;
struct CompileContext;
struct RenderContext;
class LapDB;
class IVarCallback;
class Font;
class ConsoleCommand;
class ksgui_GUI;
class GLRenderer;
class ksgui_Label;
class ksgui_TextBox;
struct CarPhysicsState;
struct CameraValue;
struct dxBody;
struct GridData;
class ksgui_ActiveButton;
class ksgui_MovingBar;
class ksgui_PopOver;
class ksgui_Form;
class ksgui_TaskBarIcon;
class IndexBuffer;
struct MeshVertex;
class ksgui_ListBoxRow;
class MaterialResource;
struct dxWorld;
struct dxSpace;
struct dxJointGroup;
struct dxThreadingImplementation;
struct dxThreadingThreadPool;
struct dContactGeom;
class CinematicFreeCamera;
class CameraMouseControl;
class CameraHelicopter;
class CameraOnBoard;
class CameraTrack;
class CameraOnBoardFree;
class CameraCarManager;
class CameraDrivableManager;
class CameraModeStart;
class ImageGeneratorCamera;
struct SlipStream;
class IDebugVisualizer;
class IPhysicsCore;
class ICarPhysicsStateProvider;
class Turbo;
class ISuspension;
class IKeyEventListener;
struct ksgui_ValueSerie;
class SkyBox;
class RenderTarget;
struct Tyre;
class ITyreModel;
class RaceTimingServices;
class AudioEngine;
class ksgui_Taskbar;
class KeyboardManager;
class PvsProcessor;
class GPUProfiler;
class CubeMap;
class IVertexBuffer;
class ACClientVotingManager;
class WrongWayIndicator;
class NodeDirtCamera;
class SessionLeaderboard;
class MirrorTextureRenderer;
class ksgui_GameScreen;
class ACErrorHandler;
class PauseMenu;
class CarNodeSorter;
class SystemMessage;
class NodeEvent;
class TrackAvatar;
class DrivingAssistManager;
class ACCameraManager;
class DebugVisualizer;
class SystemNotification;
class ReplayManager;
class ScreenCapturer;
class ksgui_FormRenderStats;
class VirtualMirrorRenderer;
class PitStop;
class TimeLimitedTest;
class QuickMenu;
class Console;
class MicroSectors;
class SimScreen;
class EndSessionDisplayer;
class Texture;
class ICoastGenerator;
class ITorqueGenerator;
class CarAnimations;
class ConstrainedObjectsManager;
class NodeBoundingSphere;
class CarAudioFMOD;
class SkidMarkBuffer;
struct CarColliderManager;
class DriverModel;
class ISuspensionAvatar;
class CarLodManager;
struct BackfireParams;
class IEventTrigger;
struct SetupManager;
class PostProcess;
class HDR;
class PostProcessFXAA;
class TimerProcess;
struct TyreThermalState;
struct AIState;
class Mesh;
class TrackObject;
class IdealLine;
class DynamicTrackManager;
class Model;
class DisplayList;
class AISplineRecorder;
class GridSpaceDisplayer;
class LollipopCrew;
class SurfacesManager;

//UDT: struct NetCarQoS @len=8
	//_Data: this+0x0, Member, Type: int, goodPackets
	//_Data: this+0x4, Member, Type: int, badPackets
	//_Func: public void NetCarQoS(); @loc=optimized @len=0 @rva=0
//UDT;

struct NetCarQoS {
public:
	int goodPackets;
	int badPackets;
	inline NetCarQoS() { }
	inline NetCarQoS(const NetCarQoS& other) = default;
	inline NetCarQoS& operator=(const NetCarQoS& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(NetCarQoS)==8),"bad size");
		static_assert((offsetof(NetCarQoS,goodPackets)==0x0),"bad off");
		static_assert((offsetof(NetCarQoS,badPackets)==0x4),"bad off");
	};
};

//UDT: struct TyrePatchData @len=20
	//_Func: public void TyrePatchData(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: float, surfaceTransfer
	//_Data: this+0x4, Member, Type: float, patchTransfer
	//_Data: this+0x8, Member, Type: float, patchCoreTransfer
	//_Data: this+0xC, Member, Type: float, internalCoreTransfer
	//_Data: this+0x10, Member, Type: float, coolFactorGain
//UDT;

struct TyrePatchData {
public:
	float surfaceTransfer;
	float patchTransfer;
	float patchCoreTransfer;
	float internalCoreTransfer;
	float coolFactorGain;
	inline TyrePatchData() { }
	inline TyrePatchData(const TyrePatchData& other) = default;
	inline TyrePatchData& operator=(const TyrePatchData& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(TyrePatchData)==20),"bad size");
		static_assert((offsetof(TyrePatchData,surfaceTransfer)==0x0),"bad off");
		static_assert((offsetof(TyrePatchData,patchTransfer)==0x4),"bad off");
		static_assert((offsetof(TyrePatchData,patchCoreTransfer)==0x8),"bad off");
		static_assert((offsetof(TyrePatchData,internalCoreTransfer)==0xC),"bad off");
		static_assert((offsetof(TyrePatchData,coolFactorGain)==0x10),"bad off");
	};
};

//UDT: struct KGLShaderTextureDesc @len=16
	//_Data: this+0x0, Member, Type: const wchar_t *, name
	//_Data: this+0x8, Member, Type: unsigned int, slot
//UDT;

struct KGLShaderTextureDesc {
public:
	const wchar_t * name;
	unsigned int slot;
	inline KGLShaderTextureDesc() { }
	inline KGLShaderTextureDesc(const KGLShaderTextureDesc& other) = default;
	inline KGLShaderTextureDesc& operator=(const KGLShaderTextureDesc& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(KGLShaderTextureDesc)==16),"bad size");
		static_assert((offsetof(KGLShaderTextureDesc,name)==0x0),"bad off");
		static_assert((offsetof(KGLShaderTextureDesc,slot)==0x8),"bad off");
	};
};

//UDT: struct RendererFlags @len=8
	//_Func: public void RendererFlags(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: int, maxFrameLatency
	//_Data: this+0x4, Member, Type: float, mipLodBias
//UDT;

struct RendererFlags {
public:
	int maxFrameLatency;
	float mipLodBias;
	inline RendererFlags() { }
	inline RendererFlags(const RendererFlags& other) = default;
	inline RendererFlags& operator=(const RendererFlags& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(RendererFlags)==8),"bad size");
		static_assert((offsetof(RendererFlags,maxFrameLatency)==0x0),"bad off");
		static_assert((offsetof(RendererFlags,mipLodBias)==0x4),"bad off");
	};
};

//UDT: struct AccelerationProfile @len=8
	//_Data: this+0x0, Member, Type: float, zero
	//_Data: this+0x4, Member, Type: float, maxTyres
//UDT;

struct AccelerationProfile {
public:
	float zero;
	float maxTyres;
	inline AccelerationProfile() { }
	inline AccelerationProfile(const AccelerationProfile& other) = default;
	inline AccelerationProfile& operator=(const AccelerationProfile& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(AccelerationProfile)==8),"bad size");
		static_assert((offsetof(AccelerationProfile,zero)==0x0),"bad off");
		static_assert((offsetof(AccelerationProfile,maxTyres)==0x4),"bad off");
	};
};

//UDT: struct KPI @len=8
	//_Data: this+0x0, Member, Type: float, angleRAD
	//_Data: this+0x4, Member, Type: float, scrubRadius
	//_Func: public void KPI(); @loc=optimized @len=0 @rva=0
//UDT;

struct KPI {
public:
	float angleRAD;
	float scrubRadius;
	inline KPI() { }
	inline KPI(const KPI& other) = default;
	inline KPI& operator=(const KPI& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(KPI)==8),"bad size");
		static_assert((offsetof(KPI,angleRAD)==0x0),"bad off");
		static_assert((offsetof(KPI,scrubRadius)==0x4),"bad off");
	};
};

//UDT: struct AISplineDanger @len=16
	//_Data: this+0x0, Member, Type: float, startPos
	//_Data: this+0x4, Member, Type: float, endPos
	//_Data: this+0x8, Member, Type: float, left
	//_Data: this+0xC, Member, Type: float, right
	//_Func: public void AISplineDanger(); @loc=optimized @len=0 @rva=0
//UDT;

struct AISplineDanger {
public:
	float startPos;
	float endPos;
	float left;
	float right;
	inline AISplineDanger() { }
	inline AISplineDanger(const AISplineDanger& other) = default;
	inline AISplineDanger& operator=(const AISplineDanger& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(AISplineDanger)==16),"bad size");
		static_assert((offsetof(AISplineDanger,startPos)==0x0),"bad off");
		static_assert((offsetof(AISplineDanger,endPos)==0x4),"bad off");
		static_assert((offsetof(AISplineDanger,left)==0x8),"bad off");
		static_assert((offsetof(AISplineDanger,right)==0xC),"bad off");
	};
};

//UDT: struct ACPluginContext @len=1
//UDT;

struct ACPluginContext {
public:
	inline ACPluginContext() { }
	inline ACPluginContext(const ACPluginContext& other) = default;
	inline ACPluginContext& operator=(const ACPluginContext& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(ACPluginContext)==1),"bad size");
	};
};

//UDT: struct SuspensionStatus @len=8
	//_Data: this+0x0, Member, Type: float, travel
	//_Data: this+0x4, Member, Type: float, damperSpeedMS
	//_Func: public void SuspensionStatus(); @loc=optimized @len=0 @rva=0
//UDT;

struct SuspensionStatus {
public:
	float travel;
	float damperSpeedMS;
	inline SuspensionStatus() { }
	inline SuspensionStatus(const SuspensionStatus& other) = default;
	inline SuspensionStatus& operator=(const SuspensionStatus& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(SuspensionStatus)==8),"bad size");
		static_assert((offsetof(SuspensionStatus,travel)==0x0),"bad off");
		static_assert((offsetof(SuspensionStatus,damperSpeedMS)==0x4),"bad off");
	};
};

//UDT: struct GearElement @len=24
	//_Data: this+0x0, Member, Type: double, velocity
	//_Data: this+0x8, Member, Type: double, inertia
	//_Data: this+0x10, Member, Type: double, oldVelocity
	//_Func: public void GearElement(); @loc=optimized @len=0 @rva=0
//UDT;

struct GearElement {
public:
	double velocity;
	double inertia;
	double oldVelocity;
	inline GearElement() { }
	inline GearElement(const GearElement& other) = default;
	inline GearElement& operator=(const GearElement& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(GearElement)==24),"bad size");
		static_assert((offsetof(GearElement,velocity)==0x0),"bad off");
		static_assert((offsetof(GearElement,inertia)==0x8),"bad off");
		static_assert((offsetof(GearElement,oldVelocity)==0x10),"bad off");
	};
};

//UDT: struct WreckerProtection @len=16
	//_Data: this+0x0, Member, Type: float, maxContactsPerKM
	//_Data: this+0x4, Member, Type: int, warningCount
	//_Data: this+0x8, Member, Type: int, contacts
	//_Data: this+0xC, Member, Type: bool, blackListRequested
	//_Func: public void WreckerProtection(); @loc=optimized @len=0 @rva=0
//UDT;

struct WreckerProtection {
public:
	float maxContactsPerKM;
	int warningCount;
	int contacts;
	bool blackListRequested;
	inline WreckerProtection() { }
	inline WreckerProtection(const WreckerProtection& other) = default;
	inline WreckerProtection& operator=(const WreckerProtection& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(WreckerProtection)==16),"bad size");
		static_assert((offsetof(WreckerProtection,maxContactsPerKM)==0x0),"bad off");
		static_assert((offsetof(WreckerProtection,warningCount)==0x4),"bad off");
		static_assert((offsetof(WreckerProtection,contacts)==0x8),"bad off");
		static_assert((offsetof(WreckerProtection,blackListRequested)==0xC),"bad off");
	};
};

//UDT: struct SplineIndexBound @len=8
	//_Func: public void SplineIndexBound(unsigned int  _arg0, unsigned int  _arg1); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: unsigned int, minIndex
	//_Data: this+0x4, Member, Type: unsigned int, maxIndex
//UDT;

struct SplineIndexBound {
public:
	unsigned int minIndex;
	unsigned int maxIndex;
	inline SplineIndexBound() { }
	inline SplineIndexBound(const SplineIndexBound& other) = default;
	inline SplineIndexBound& operator=(const SplineIndexBound& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(SplineIndexBound)==8),"bad size");
		static_assert((offsetof(SplineIndexBound,minIndex)==0x0),"bad off");
		static_assert((offsetof(SplineIndexBound,maxIndex)==0x4),"bad off");
	};
};

//UDT: struct SamplerStates @len=56
	//_Data: this+0x0, Member, Type: void *, samplerAniso
	//_Data: this+0x8, Member, Type: void *, samplerLinearShadow
	//_Data: this+0x10, Member, Type: void *, samplerShadow
	//_Data: this+0x18, Member, Type: void *, samplerPoint
	//_Data: this+0x20, Member, Type: void *, samplerPointClamp
	//_Data: this+0x28, Member, Type: void *, samplerLinearSimple
	//_Data: this+0x30, Member, Type: void *, samplerLinearClamp
//UDT;

struct SamplerStates {
public:
	void * samplerAniso;
	void * samplerLinearShadow;
	void * samplerShadow;
	void * samplerPoint;
	void * samplerPointClamp;
	void * samplerLinearSimple;
	void * samplerLinearClamp;
	inline SamplerStates() { }
	inline SamplerStates(const SamplerStates& other) = default;
	inline SamplerStates& operator=(const SamplerStates& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(SamplerStates)==56),"bad size");
		static_assert((offsetof(SamplerStates,samplerAniso)==0x0),"bad off");
		static_assert((offsetof(SamplerStates,samplerLinearShadow)==0x8),"bad off");
		static_assert((offsetof(SamplerStates,samplerShadow)==0x10),"bad off");
		static_assert((offsetof(SamplerStates,samplerPoint)==0x18),"bad off");
		static_assert((offsetof(SamplerStates,samplerPointClamp)==0x20),"bad off");
		static_assert((offsetof(SamplerStates,samplerLinearSimple)==0x28),"bad off");
		static_assert((offsetof(SamplerStates,samplerLinearClamp)==0x30),"bad off");
	};
};

//UDT: struct PerformancePair @len=8
	//_Func: public void PerformancePair(unsigned int  _arg0, float  _arg1); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: unsigned int, t
	//_Data: this+0x4, Member, Type: float, speedMS
//UDT;

struct PerformancePair {
public:
	unsigned int t;
	float speedMS;
	inline PerformancePair() { }
	inline PerformancePair(const PerformancePair& other) = default;
	inline PerformancePair& operator=(const PerformancePair& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(PerformancePair)==8),"bad size");
		static_assert((offsetof(PerformancePair,t)==0x0),"bad off");
		static_assert((offsetof(PerformancePair,speedMS)==0x4),"bad off");
	};
};

//UDT: struct DynamicTrackData @len=24
	//_Data: this+0x0, Member, Type: bool, isExternal
	//_Data: this+0x1, Member, Type: bool, enabled
	//_Data: this+0x4, Member, Type: float, sessionStartGrip
	//_Data: this+0x8, Member, Type: float, baseGrip
	//_Data: this+0xC, Member, Type: float, randomGrip
	//_Data: this+0x10, Member, Type: float, gripPerLap
	//_Data: this+0x14, Member, Type: float, sessionTransfer
	//_Func: public void DynamicTrackData(); @loc=optimized @len=0 @rva=0
//UDT;

struct DynamicTrackData {
public:
	bool isExternal;
	bool enabled;
	float sessionStartGrip;
	float baseGrip;
	float randomGrip;
	float gripPerLap;
	float sessionTransfer;
	inline DynamicTrackData() { }
	inline DynamicTrackData(const DynamicTrackData& other) = default;
	inline DynamicTrackData& operator=(const DynamicTrackData& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(DynamicTrackData)==24),"bad size");
		static_assert((offsetof(DynamicTrackData,isExternal)==0x0),"bad off");
		static_assert((offsetof(DynamicTrackData,enabled)==0x1),"bad off");
		static_assert((offsetof(DynamicTrackData,sessionStartGrip)==0x4),"bad off");
		static_assert((offsetof(DynamicTrackData,baseGrip)==0x8),"bad off");
		static_assert((offsetof(DynamicTrackData,randomGrip)==0xC),"bad off");
		static_assert((offsetof(DynamicTrackData,gripPerLap)==0x10),"bad off");
		static_assert((offsetof(DynamicTrackData,sessionTransfer)==0x14),"bad off");
	};
};

//UDT: struct OnSectorSplitEvent @len=16
	//_Data: this+0x0, Member, Type: unsigned int, carIndex
	//_Data: this+0x4, Member, Type: unsigned int, sectorIndex
	//_Data: this+0x8, Member, Type: unsigned int, sectorTime
	//_Data: this+0xC, Member, Type: unsigned int, cuts
//UDT;

struct OnSectorSplitEvent {
public:
	unsigned int carIndex;
	unsigned int sectorIndex;
	unsigned int sectorTime;
	unsigned int cuts;
	inline OnSectorSplitEvent() { }
	inline OnSectorSplitEvent(const OnSectorSplitEvent& other) = default;
	inline OnSectorSplitEvent& operator=(const OnSectorSplitEvent& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(OnSectorSplitEvent)==16),"bad size");
		static_assert((offsetof(OnSectorSplitEvent,carIndex)==0x0),"bad off");
		static_assert((offsetof(OnSectorSplitEvent,sectorIndex)==0x4),"bad off");
		static_assert((offsetof(OnSectorSplitEvent,sectorTime)==0x8),"bad off");
		static_assert((offsetof(OnSectorSplitEvent,cuts)==0xC),"bad off");
	};
};

//UDT: struct KGLShaderCBufferDesc @len=16
	//_Data: this+0x0, Member, Type: const wchar_t *, name
	//_Data: this+0x8, Member, Type: unsigned int, size
	//_Data: this+0xC, Member, Type: unsigned int, slot
//UDT;

struct KGLShaderCBufferDesc {
public:
	const wchar_t * name;
	unsigned int size;
	unsigned int slot;
	inline KGLShaderCBufferDesc() { }
	inline KGLShaderCBufferDesc(const KGLShaderCBufferDesc& other) = default;
	inline KGLShaderCBufferDesc& operator=(const KGLShaderCBufferDesc& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(KGLShaderCBufferDesc)==16),"bad size");
		static_assert((offsetof(KGLShaderCBufferDesc,name)==0x0),"bad off");
		static_assert((offsetof(KGLShaderCBufferDesc,size)==0x8),"bad off");
		static_assert((offsetof(KGLShaderCBufferDesc,slot)==0xC),"bad off");
	};
};

//UDT: struct DIShifter @len=48
	//_Func: public void DIShifter(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: bool, isActive
	//_Data: this+0x1, Member, Type: bool, isShifterPrefered
	//_Data: this+0x4, Member, Type: int, joy
	//_Data: this+0x8, Member, Type: int[0xA], buttons
//UDT;

struct DIShifter {
public:
	bool isActive;
	bool isShifterPrefered;
	int joy;
	int buttons[10];
	inline DIShifter() { }
	inline DIShifter(const DIShifter& other) = default;
	inline DIShifter& operator=(const DIShifter& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(DIShifter)==48),"bad size");
		static_assert((offsetof(DIShifter,isActive)==0x0),"bad off");
		static_assert((offsetof(DIShifter,isShifterPrefered)==0x1),"bad off");
		static_assert((offsetof(DIShifter,joy)==0x4),"bad off");
		static_assert((offsetof(DIShifter,buttons)==0x8),"bad off");
	};
};

//UDT: class ICollisionObject @len=8 @vfcount=6
	//_VTable: 
	//_Func: public void release(); @intro @pure @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Func: public void setUserPointer(void *  _arg0); @intro @pure @virtual vtpo=0 vfid=1 @loc=optimized @len=0 @rva=0
	//_Func: public void * getUserPointer(); @intro @pure @virtual vtpo=0 vfid=2 @loc=optimized @len=0 @rva=0
	//_Func: public unsigned long getGroup(); @intro @pure @virtual vtpo=0 vfid=3 @loc=optimized @len=0 @rva=0
	//_Func: public unsigned long getMask(); @intro @pure @virtual vtpo=0 vfid=4 @loc=optimized @len=0 @rva=0
	//_Func: protected void ~ICollisionObject(); @intro @virtual vtpo=0 vfid=5 @loc=static @len=11 @rva=2939088
	//_Func: public void ICollisionObject(const ICollisionObject &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void ICollisionObject(); @loc=optimized @len=0 @rva=0
	//_Func: public ICollisionObject & operator=(const ICollisionObject &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: protected void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=5 @loc=optimized @len=0 @rva=0
//UDT;

class ICollisionObject {
public:
	inline ICollisionObject() { }
	inline ICollisionObject(const ICollisionObject& other) = default;
	inline ICollisionObject& operator=(const ICollisionObject& other) = default;
	virtual void release_vf0() = 0;
	inline void release() { typedef void (ICollisionObject::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 0)); return (this->*_f)(); }
	virtual void setUserPointer_vf1(void *  _arg0) = 0;
	inline void setUserPointer(void *  _arg0) { typedef void (ICollisionObject::*_fpt)(void *); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)( _arg0); }
	virtual void * getUserPointer_vf2() = 0;
	inline void * getUserPointer() { typedef void * (ICollisionObject::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)(); }
	virtual unsigned long getGroup_vf3() = 0;
	inline unsigned long getGroup() { typedef unsigned long (ICollisionObject::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(); }
	virtual unsigned long getMask_vf4() = 0;
	inline unsigned long getMask() { typedef unsigned long (ICollisionObject::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 4)); return (this->*_f)(); }
	virtual ~ICollisionObject();
	inline void dtor() { typedef void (ICollisionObject::*_fpt)(); auto _f=xcast<_fpt>(_drva(2939088)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(ICollisionObject)==8),"bad size");
	};
};

//UDT: struct TyreStatus @len=184
	//_Func: public void TyreStatus(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: float, depth
	//_Data: this+0x4, Member, Type: float, load
	//_Data: this+0x8, Member, Type: float, camberRAD
	//_Data: this+0xC, Member, Type: float, slipAngleRAD
	//_Data: this+0x10, Member, Type: float, slipRatio
	//_Data: this+0x14, Member, Type: float, angularVelocity
	//_Data: this+0x18, Member, Type: float, Fy
	//_Data: this+0x1C, Member, Type: float, Fx
	//_Data: this+0x20, Member, Type: float, Mz
	//_Data: this+0x24, Member, Type: bool, isLocked
	//_Data: this+0x28, Member, Type: float, slipFactor
	//_Data: this+0x2C, Member, Type: float, ndSlip
	//_Data: this+0x30, Member, Type: float, distToGround
	//_Data: this+0x34, Member, Type: float, Dy
	//_Data: this+0x38, Member, Type: float, Dx
	//_Data: this+0x3C, Member, Type: float, D
	//_Data: this+0x40, Member, Type: float, dirtyLevel
	//_Data: this+0x44, Member, Type: float, rollingResistence
	//_Data: this+0x48, Member, Type: float, thermalInput
	//_Data: this+0x4C, Member, Type: float, feedbackTorque
	//_Data: this+0x50, Member, Type: float, loadedRadius
	//_Data: this+0x54, Member, Type: float, effectiveRadius
	//_Data: this+0x58, Member, Type: float, liveRadius
	//_Data: this+0x5C, Member, Type: float, pressureStatic
	//_Data: this+0x60, Member, Type: float, pressureDynamic
	//_Data: this+0x68, Member, Type: double, virtualKM
	//_Data: this+0x70, Member, Type: float[0x3], lastTempIMO
	//_Data: this+0x7C, Member, Type: float, peakSA
	//_Data: this+0x80, Member, Type: double, grain
	//_Data: this+0x88, Member, Type: double, blister
	//_Data: this+0x90, Member, Type: float, inflation
	//_Data: this+0x98, Member, Type: double, flatSpot
	//_Data: this+0xA0, Member, Type: float, lastGrain
	//_Data: this+0xA4, Member, Type: float, lastBlister
	//_Data: this+0xA8, Member, Type: float, normalizedSlideX
	//_Data: this+0xAC, Member, Type: float, normalizedSlideY
	//_Data: this+0xB0, Member, Type: float, finalDY
	//_Data: this+0xB4, Member, Type: float, wearMult
//UDT;

struct TyreStatus {
public:
	float depth;
	float load;
	float camberRAD;
	float slipAngleRAD;
	float slipRatio;
	float angularVelocity;
	float Fy;
	float Fx;
	float Mz;
	bool isLocked;
	float slipFactor;
	float ndSlip;
	float distToGround;
	float Dy;
	float Dx;
	float D;
	float dirtyLevel;
	float rollingResistence;
	float thermalInput;
	float feedbackTorque;
	float loadedRadius;
	float effectiveRadius;
	float liveRadius;
	float pressureStatic;
	float pressureDynamic;
	double virtualKM;
	float lastTempIMO[3];
	float peakSA;
	double grain;
	double blister;
	float inflation;
	double flatSpot;
	float lastGrain;
	float lastBlister;
	float normalizedSlideX;
	float normalizedSlideY;
	float finalDY;
	float wearMult;
	inline TyreStatus() { }
	inline TyreStatus(const TyreStatus& other) = default;
	inline TyreStatus& operator=(const TyreStatus& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(TyreStatus)==184),"bad size");
		static_assert((offsetof(TyreStatus,depth)==0x0),"bad off");
		static_assert((offsetof(TyreStatus,load)==0x4),"bad off");
		static_assert((offsetof(TyreStatus,camberRAD)==0x8),"bad off");
		static_assert((offsetof(TyreStatus,slipAngleRAD)==0xC),"bad off");
		static_assert((offsetof(TyreStatus,slipRatio)==0x10),"bad off");
		static_assert((offsetof(TyreStatus,angularVelocity)==0x14),"bad off");
		static_assert((offsetof(TyreStatus,Fy)==0x18),"bad off");
		static_assert((offsetof(TyreStatus,Fx)==0x1C),"bad off");
		static_assert((offsetof(TyreStatus,Mz)==0x20),"bad off");
		static_assert((offsetof(TyreStatus,isLocked)==0x24),"bad off");
		static_assert((offsetof(TyreStatus,slipFactor)==0x28),"bad off");
		static_assert((offsetof(TyreStatus,ndSlip)==0x2C),"bad off");
		static_assert((offsetof(TyreStatus,distToGround)==0x30),"bad off");
		static_assert((offsetof(TyreStatus,Dy)==0x34),"bad off");
		static_assert((offsetof(TyreStatus,Dx)==0x38),"bad off");
		static_assert((offsetof(TyreStatus,D)==0x3C),"bad off");
		static_assert((offsetof(TyreStatus,dirtyLevel)==0x40),"bad off");
		static_assert((offsetof(TyreStatus,rollingResistence)==0x44),"bad off");
		static_assert((offsetof(TyreStatus,thermalInput)==0x48),"bad off");
		static_assert((offsetof(TyreStatus,feedbackTorque)==0x4C),"bad off");
		static_assert((offsetof(TyreStatus,loadedRadius)==0x50),"bad off");
		static_assert((offsetof(TyreStatus,effectiveRadius)==0x54),"bad off");
		static_assert((offsetof(TyreStatus,liveRadius)==0x58),"bad off");
		static_assert((offsetof(TyreStatus,pressureStatic)==0x5C),"bad off");
		static_assert((offsetof(TyreStatus,pressureDynamic)==0x60),"bad off");
		static_assert((offsetof(TyreStatus,virtualKM)==0x68),"bad off");
		static_assert((offsetof(TyreStatus,lastTempIMO)==0x70),"bad off");
		static_assert((offsetof(TyreStatus,peakSA)==0x7C),"bad off");
		static_assert((offsetof(TyreStatus,grain)==0x80),"bad off");
		static_assert((offsetof(TyreStatus,blister)==0x88),"bad off");
		static_assert((offsetof(TyreStatus,inflation)==0x90),"bad off");
		static_assert((offsetof(TyreStatus,flatSpot)==0x98),"bad off");
		static_assert((offsetof(TyreStatus,lastGrain)==0xA0),"bad off");
		static_assert((offsetof(TyreStatus,lastBlister)==0xA4),"bad off");
		static_assert((offsetof(TyreStatus,normalizedSlideX)==0xA8),"bad off");
		static_assert((offsetof(TyreStatus,normalizedSlideY)==0xAC),"bad off");
		static_assert((offsetof(TyreStatus,finalDY)==0xB0),"bad off");
		static_assert((offsetof(TyreStatus,wearMult)==0xB4),"bad off");
	};
};

//UDT: struct ShadowMapSettings @len=12
	//_Data: this+0x0, Member, Type: float, nearSplit
	//_Data: this+0x4, Member, Type: float, farSplit
	//_Data: this+0x8, Member, Type: float, height
	//_Func: public void ShadowMapSettings(); @loc=optimized @len=0 @rva=0
//UDT;

struct ShadowMapSettings {
public:
	float nearSplit;
	float farSplit;
	float height;
	inline ShadowMapSettings() { }
	inline ShadowMapSettings(const ShadowMapSettings& other) = default;
	inline ShadowMapSettings& operator=(const ShadowMapSettings& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(ShadowMapSettings)==12),"bad size");
		static_assert((offsetof(ShadowMapSettings,nearSplit)==0x0),"bad off");
		static_assert((offsetof(ShadowMapSettings,farSplit)==0x4),"bad off");
		static_assert((offsetof(ShadowMapSettings,height)==0x8),"bad off");
	};
};

//UDT: struct PerformanceSplit @len=16
	//_Data: this+0x0, Member, Type: double, t
	//_Data: this+0x8, Member, Type: float, speedMS
	//_Func: public void PerformanceSplit(); @loc=optimized @len=0 @rva=0
//UDT;

struct PerformanceSplit {
public:
	double t;
	float speedMS;
	inline PerformanceSplit() { }
	inline PerformanceSplit(const PerformanceSplit& other) = default;
	inline PerformanceSplit& operator=(const PerformanceSplit& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(PerformanceSplit)==16),"bad size");
		static_assert((offsetof(PerformanceSplit,t)==0x0),"bad off");
		static_assert((offsetof(PerformanceSplit,speedMS)==0x8),"bad off");
	};
};

//UDT: struct SusDamageDef @len=28
	//_Data: this+0x0, Member, Type: float, damageAmount
	//_Data: this+0x4, Member, Type: float, damageDirection
	//_Data: this+0x8, Member, Type: float, minVelocity
	//_Data: this+0xC, Member, Type: float, damageGain
	//_Data: this+0x10, Member, Type: float, maxDamage
	//_Data: this+0x14, Member, Type: bool, isDebug
	//_Data: this+0x18, Member, Type: float, lastAmount
	//_Func: public void SusDamageDef(); @loc=optimized @len=0 @rva=0
//UDT;

struct SusDamageDef {
public:
	float damageAmount;
	float damageDirection;
	float minVelocity;
	float damageGain;
	float maxDamage;
	bool isDebug;
	float lastAmount;
	inline SusDamageDef() { }
	inline SusDamageDef(const SusDamageDef& other) = default;
	inline SusDamageDef& operator=(const SusDamageDef& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(SusDamageDef)==28),"bad size");
		static_assert((offsetof(SusDamageDef,damageAmount)==0x0),"bad off");
		static_assert((offsetof(SusDamageDef,damageDirection)==0x4),"bad off");
		static_assert((offsetof(SusDamageDef,minVelocity)==0x8),"bad off");
		static_assert((offsetof(SusDamageDef,damageGain)==0xC),"bad off");
		static_assert((offsetof(SusDamageDef,maxDamage)==0x10),"bad off");
		static_assert((offsetof(SusDamageDef,isDebug)==0x14),"bad off");
		static_assert((offsetof(SusDamageDef,lastAmount)==0x18),"bad off");
	};
};

//UDT: struct GameStats @len=40
	//_Func: public void GameStats(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: double, cpuTime
	//_Data: this+0x8, Member, Type: double, updateTime
	//_Data: this+0x10, Member, Type: double, renderHUDTime
	//_Data: this+0x18, Member, Type: double, renderTime
	//_Data: this+0x20, Member, Type: double, renderAudioTime
//UDT;

struct GameStats {
public:
	double cpuTime;
	double updateTime;
	double renderHUDTime;
	double renderTime;
	double renderAudioTime;
	inline GameStats() { }
	inline GameStats(const GameStats& other) = default;
	inline GameStats& operator=(const GameStats& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(GameStats)==40),"bad size");
		static_assert((offsetof(GameStats,cpuTime)==0x0),"bad off");
		static_assert((offsetof(GameStats,updateTime)==0x8),"bad off");
		static_assert((offsetof(GameStats,renderHUDTime)==0x10),"bad off");
		static_assert((offsetof(GameStats,renderTime)==0x18),"bad off");
		static_assert((offsetof(GameStats,renderAudioTime)==0x20),"bad off");
	};
};

//UDT: struct DRSDetectionStatus @len=16
	//_Data: this+0x0, Member, Type: double, time
	//_Data: this+0x8, Member, Type: int, laps
	//_Data: this+0xC, Member, Type: bool, isRaceAvailable
	//_Data: this+0xD, Member, Type: bool, hasBeenSwitchedOnThisStep
	//_Func: public void DRSDetectionStatus(); @loc=optimized @len=0 @rva=0
//UDT;

struct DRSDetectionStatus {
public:
	double time;
	int laps;
	bool isRaceAvailable;
	bool hasBeenSwitchedOnThisStep;
	inline DRSDetectionStatus() { }
	inline DRSDetectionStatus(const DRSDetectionStatus& other) = default;
	inline DRSDetectionStatus& operator=(const DRSDetectionStatus& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(DRSDetectionStatus)==16),"bad size");
		static_assert((offsetof(DRSDetectionStatus,time)==0x0),"bad off");
		static_assert((offsetof(DRSDetectionStatus,laps)==0x8),"bad off");
		static_assert((offsetof(DRSDetectionStatus,isRaceAvailable)==0xC),"bad off");
		static_assert((offsetof(DRSDetectionStatus,hasBeenSwitchedOnThisStep)==0xD),"bad off");
	};
};

//UDT: struct VideoSettings @len=80
	//_Func: public void VideoSettings(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: int, aaSamples
	//_Data: this+0x4, Member, Type: int, width
	//_Data: this+0x8, Member, Type: int, height
	//_Data: this+0x10, Member, Type: void *, hWnd
	//_Data: this+0x18, Member, Type: bool, isFullscreen
	//_Data: this+0x19, Member, Type: bool, vSync
	//_Data: this+0x1C, Member, Type: int, anisotropic
	//_Data: this+0x20, Member, Type: int, aaQuality
	//_Data: this+0x24, Member, Type: int, shadowMapSize
	//_Data: this+0x28, Member, Type: double, fpsCapMS
	//_Data: this+0x30, Member, Type: int, dxgiModeIndex
	//_Data: this+0x34, Member, Type: int, worldDetail
	//_Data: this+0x38, Member, Type: bool, ppHDREnabled
	//_Data: this+0x39, Member, Type: bool, ppHeatShimmer
	//_Data: this+0x3A, Member, Type: bool, ppFXAA
	//_Data: this+0x3B, Member, Type: bool, ppRaysOfGod
	//_Data: this+0x3C, Member, Type: int, ppQuality
	//_Data: this+0x40, Member, Type: int, ppGlare
	//_Data: this+0x44, Member, Type: int, ppDof
	//_Data: this+0x48, Member, Type: bool, tripleBuffer
	//_Data: this+0x4C, Member, Type: float, refresh
//UDT;

struct VideoSettings {
public:
	int aaSamples;
	int width;
	int height;
	void * hWnd;
	bool isFullscreen;
	bool vSync;
	int anisotropic;
	int aaQuality;
	int shadowMapSize;
	double fpsCapMS;
	int dxgiModeIndex;
	int worldDetail;
	bool ppHDREnabled;
	bool ppHeatShimmer;
	bool ppFXAA;
	bool ppRaysOfGod;
	int ppQuality;
	int ppGlare;
	int ppDof;
	bool tripleBuffer;
	float refresh;
	inline VideoSettings() { }
	inline VideoSettings(const VideoSettings& other) = default;
	inline VideoSettings& operator=(const VideoSettings& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(VideoSettings)==80),"bad size");
		static_assert((offsetof(VideoSettings,aaSamples)==0x0),"bad off");
		static_assert((offsetof(VideoSettings,width)==0x4),"bad off");
		static_assert((offsetof(VideoSettings,height)==0x8),"bad off");
		static_assert((offsetof(VideoSettings,hWnd)==0x10),"bad off");
		static_assert((offsetof(VideoSettings,isFullscreen)==0x18),"bad off");
		static_assert((offsetof(VideoSettings,vSync)==0x19),"bad off");
		static_assert((offsetof(VideoSettings,anisotropic)==0x1C),"bad off");
		static_assert((offsetof(VideoSettings,aaQuality)==0x20),"bad off");
		static_assert((offsetof(VideoSettings,shadowMapSize)==0x24),"bad off");
		static_assert((offsetof(VideoSettings,fpsCapMS)==0x28),"bad off");
		static_assert((offsetof(VideoSettings,dxgiModeIndex)==0x30),"bad off");
		static_assert((offsetof(VideoSettings,worldDetail)==0x34),"bad off");
		static_assert((offsetof(VideoSettings,ppHDREnabled)==0x38),"bad off");
		static_assert((offsetof(VideoSettings,ppHeatShimmer)==0x39),"bad off");
		static_assert((offsetof(VideoSettings,ppFXAA)==0x3A),"bad off");
		static_assert((offsetof(VideoSettings,ppRaysOfGod)==0x3B),"bad off");
		static_assert((offsetof(VideoSettings,ppQuality)==0x3C),"bad off");
		static_assert((offsetof(VideoSettings,ppGlare)==0x40),"bad off");
		static_assert((offsetof(VideoSettings,ppDof)==0x44),"bad off");
		static_assert((offsetof(VideoSettings,tripleBuffer)==0x48),"bad off");
		static_assert((offsetof(VideoSettings,refresh)==0x4C),"bad off");
	};
};

//UDT: class GameTime @len=56 @vfcount=1
	//_VTable: 
	//_Func: public void GameTime(const GameTime &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void GameTime(); @loc=static @len=62 @rva=4506064
	//_Func: public void ~GameTime(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=11 @rva=4506128
	//_Data: this+0x8, Member, Type: double, now
	//_Data: this+0x10, Member, Type: float, deltaT
	//_Data: this+0x14, Member, Type: float, smoothDeltaT
	//_Data: this+0x18, Member, Type: float, fps
	//_Data: this+0x1C, Member, Type: bool, useStabilizer
	//_Data: this+0x20, Member, Type: double, cappedFPS
	//_Data: this+0x28, Member, Type: double, startTime
	//_Func: public void update(); @loc=static @len=341 @rva=4506192
	//_Func: public bool isUsingHRT(); @loc=optimized @len=0 @rva=0
	//_Func: protected void initTimer(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x30, Member, Type: bool, m_isUsingHRT
	//_Func: public GameTime & operator=(const GameTime &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class GameTime {
public:
	double now;
	float deltaT;
	float smoothDeltaT;
	float fps;
	bool useStabilizer;
	double cappedFPS;
	double startTime;
	bool m_isUsingHRT;
	inline GameTime() { }
	inline GameTime(const GameTime& other) = default;
	inline GameTime& operator=(const GameTime& other) = default;
	inline void ctor() { typedef void (GameTime::*_fpt)(); auto _f=xcast<_fpt>(_drva(4506064)); (this->*_f)(); }
	virtual ~GameTime();
	inline void dtor() { typedef void (GameTime::*_fpt)(); auto _f=xcast<_fpt>(_drva(4506128)); (this->*_f)(); }
	inline void update() { typedef void (GameTime::*_fpt)(); auto _f=xcast<_fpt>(_drva(4506192)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(GameTime)==56),"bad size");
		static_assert((offsetof(GameTime,now)==0x8),"bad off");
		static_assert((offsetof(GameTime,deltaT)==0x10),"bad off");
		static_assert((offsetof(GameTime,smoothDeltaT)==0x14),"bad off");
		static_assert((offsetof(GameTime,fps)==0x18),"bad off");
		static_assert((offsetof(GameTime,useStabilizer)==0x1C),"bad off");
		static_assert((offsetof(GameTime,cappedFPS)==0x20),"bad off");
		static_assert((offsetof(GameTime,startTime)==0x28),"bad off");
		static_assert((offsetof(GameTime,m_isUsingHRT)==0x30),"bad off");
	};
};

//UDT: class ITorqueGenerator @len=8 @vfcount=2
	//_VTable: 
	//_Func: public void ~ITorqueGenerator(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=11 @rva=2549840
	//_Func: public float getOutputTorque(); @intro @pure @virtual vtpo=0 vfid=1 @loc=optimized @len=0 @rva=0
	//_Func: public void ITorqueGenerator(const ITorqueGenerator &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void ITorqueGenerator(); @loc=optimized @len=0 @rva=0
	//_Func: public ITorqueGenerator & operator=(const ITorqueGenerator &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ITorqueGenerator {
public:
	inline ITorqueGenerator() { }
	inline ITorqueGenerator(const ITorqueGenerator& other) = default;
	inline ITorqueGenerator& operator=(const ITorqueGenerator& other) = default;
	virtual ~ITorqueGenerator();
	inline void dtor() { typedef void (ITorqueGenerator::*_fpt)(); auto _f=xcast<_fpt>(_drva(2549840)); (this->*_f)(); }
	virtual float getOutputTorque_vf1() = 0;
	inline float getOutputTorque() { typedef float (ITorqueGenerator::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(ITorqueGenerator)==8),"bad size");
	};
};

//UDT: struct ERSCockpitControls @len=3
	//_Data: this+0x0, Member, Type: bool, recovery
	//_Data: this+0x1, Member, Type: bool, mguHMode
	//_Data: this+0x2, Member, Type: bool, deliveryProfile
	//_Func: public void ERSCockpitControls(); @loc=optimized @len=0 @rva=0
//UDT;

struct ERSCockpitControls {
public:
	bool recovery;
	bool mguHMode;
	bool deliveryProfile;
	inline ERSCockpitControls() { }
	inline ERSCockpitControls(const ERSCockpitControls& other) = default;
	inline ERSCockpitControls& operator=(const ERSCockpitControls& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(ERSCockpitControls)==3),"bad size");
		static_assert((offsetof(ERSCockpitControls,recovery)==0x0),"bad off");
		static_assert((offsetof(ERSCockpitControls,mguHMode)==0x1),"bad off");
		static_assert((offsetof(ERSCockpitControls,deliveryProfile)==0x2),"bad off");
	};
};

//UDT: struct ACClient::ClientEndSession @len=12
	//_Data: this+0x0, Member, Type: bool, isConnectionFinished
	//_Data: this+0x4, Member, Type: float, sendToPitsTimer
	//_Data: this+0x8, Member, Type: float, shutdownTimer
	//_Func: public void ClientEndSession(); @loc=optimized @len=0 @rva=0
//UDT;

struct ACClient_ClientEndSession {
public:
	bool isConnectionFinished;
	float sendToPitsTimer;
	float shutdownTimer;
	inline ACClient_ClientEndSession() { }
	inline ACClient_ClientEndSession(const ACClient_ClientEndSession& other) = default;
	inline ACClient_ClientEndSession& operator=(const ACClient_ClientEndSession& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(ACClient_ClientEndSession)==12),"bad size");
		static_assert((offsetof(ACClient_ClientEndSession,isConnectionFinished)==0x0),"bad off");
		static_assert((offsetof(ACClient_ClientEndSession,sendToPitsTimer)==0x4),"bad off");
		static_assert((offsetof(ACClient_ClientEndSession,shutdownTimer)==0x8),"bad off");
	};
};

//UDT: struct SplineLocatorData @len=40
	//_Data: this+0x0, Member, Type: float, npos
	//_Data: this+0x4, Member, Type: unsigned int, currentIndex
	//_Data: this+0x8, Member, Type: float, lateralOffset
	//_Data: this+0xC, Member, Type: float, splineLength
	//_Data: this+0x10, Member, Type: float[0x2], sides
	//_Data: this+0x18, Member, Type: float[0x2], sidesFromIL
	//_Data: this+0x20, Member, Type: float, sideVelocity
	//_Data: this+0x24, Member, Type: bool, isOutsideTrackLimits
	//_Func: public void SplineLocatorData(); @loc=optimized @len=0 @rva=0
//UDT;

struct SplineLocatorData {
public:
	float npos;
	unsigned int currentIndex;
	float lateralOffset;
	float splineLength;
	float sides[2];
	float sidesFromIL[2];
	float sideVelocity;
	bool isOutsideTrackLimits;
	inline SplineLocatorData() { }
	inline SplineLocatorData(const SplineLocatorData& other) = default;
	inline SplineLocatorData& operator=(const SplineLocatorData& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(SplineLocatorData)==40),"bad size");
		static_assert((offsetof(SplineLocatorData,npos)==0x0),"bad off");
		static_assert((offsetof(SplineLocatorData,currentIndex)==0x4),"bad off");
		static_assert((offsetof(SplineLocatorData,lateralOffset)==0x8),"bad off");
		static_assert((offsetof(SplineLocatorData,splineLength)==0xC),"bad off");
		static_assert((offsetof(SplineLocatorData,sides)==0x10),"bad off");
		static_assert((offsetof(SplineLocatorData,sidesFromIL)==0x18),"bad off");
		static_assert((offsetof(SplineLocatorData,sideVelocity)==0x20),"bad off");
		static_assert((offsetof(SplineLocatorData,isOutsideTrackLimits)==0x24),"bad off");
	};
};

//UDT: struct ClientQOSData @len=24
	//_Data: this+0x0, Member, Type: bool, usingMegapackets
	//_Data: this+0x4, Member, Type: int, counter
	//_Data: this+0x8, Member, Type: double, startTime
	//_Data: this+0x10, Member, Type: int, lastQOS
	//_Func: public void ClientQOSData(); @loc=optimized @len=0 @rva=0
//UDT;

struct ClientQOSData {
public:
	bool usingMegapackets;
	int counter;
	double startTime;
	int lastQOS;
	inline ClientQOSData() { }
	inline ClientQOSData(const ClientQOSData& other) = default;
	inline ClientQOSData& operator=(const ClientQOSData& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(ClientQOSData)==24),"bad size");
		static_assert((offsetof(ClientQOSData,usingMegapackets)==0x0),"bad off");
		static_assert((offsetof(ClientQOSData,counter)==0x4),"bad off");
		static_assert((offsetof(ClientQOSData,startTime)==0x8),"bad off");
		static_assert((offsetof(ClientQOSData,lastQOS)==0x10),"bad off");
	};
};

//UDT: struct CameraOnBoardCustomSettings @len=8
	//_Data: this+0x0, Member, Type: float, pitch
	//_Data: this+0x4, Member, Type: float, yaw
	//_Func: public void CameraOnBoardCustomSettings(); @loc=optimized @len=0 @rva=0
//UDT;

struct CameraOnBoardCustomSettings {
public:
	float pitch;
	float yaw;
	inline CameraOnBoardCustomSettings() { }
	inline CameraOnBoardCustomSettings(const CameraOnBoardCustomSettings& other) = default;
	inline CameraOnBoardCustomSettings& operator=(const CameraOnBoardCustomSettings& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(CameraOnBoardCustomSettings)==8),"bad size");
		static_assert((offsetof(CameraOnBoardCustomSettings,pitch)==0x0),"bad off");
		static_assert((offsetof(CameraOnBoardCustomSettings,yaw)==0x4),"bad off");
	};
};

//UDT: struct TyreData @len=72
	//_Func: public void TyreData(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: float, width
	//_Data: this+0x4, Member, Type: float, radius
	//_Data: this+0x8, Member, Type: float, k
	//_Data: this+0xC, Member, Type: float, d
	//_Data: this+0x10, Member, Type: float, angularInertia
	//_Data: this+0x14, Member, Type: float, thermalFrictionK
	//_Data: this+0x18, Member, Type: float, thermalRollingK
	//_Data: this+0x1C, Member, Type: float, thermalRollingSurfaceK
	//_Data: this+0x20, Member, Type: float, grainThreshold
	//_Data: this+0x24, Member, Type: float, blisterThreshold
	//_Data: this+0x28, Member, Type: float, grainGamma
	//_Data: this+0x2C, Member, Type: float, blisterGamma
	//_Data: this+0x30, Member, Type: float, grainGain
	//_Data: this+0x34, Member, Type: float, blisterGain
	//_Data: this+0x38, Member, Type: float, rimRadius
	//_Data: this+0x3C, Member, Type: float, optimumTemp
	//_Data: this+0x40, Member, Type: float, softnessIndex
	//_Data: this+0x44, Member, Type: float, radiusRaiseK
//UDT;

struct TyreData {
public:
	float width;
	float radius;
	float k;
	float d;
	float angularInertia;
	float thermalFrictionK;
	float thermalRollingK;
	float thermalRollingSurfaceK;
	float grainThreshold;
	float blisterThreshold;
	float grainGamma;
	float blisterGamma;
	float grainGain;
	float blisterGain;
	float rimRadius;
	float optimumTemp;
	float softnessIndex;
	float radiusRaiseK;
	inline TyreData() { }
	inline TyreData(const TyreData& other) = default;
	inline TyreData& operator=(const TyreData& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(TyreData)==72),"bad size");
		static_assert((offsetof(TyreData,width)==0x0),"bad off");
		static_assert((offsetof(TyreData,radius)==0x4),"bad off");
		static_assert((offsetof(TyreData,k)==0x8),"bad off");
		static_assert((offsetof(TyreData,d)==0xC),"bad off");
		static_assert((offsetof(TyreData,angularInertia)==0x10),"bad off");
		static_assert((offsetof(TyreData,thermalFrictionK)==0x14),"bad off");
		static_assert((offsetof(TyreData,thermalRollingK)==0x18),"bad off");
		static_assert((offsetof(TyreData,thermalRollingSurfaceK)==0x1C),"bad off");
		static_assert((offsetof(TyreData,grainThreshold)==0x20),"bad off");
		static_assert((offsetof(TyreData,blisterThreshold)==0x24),"bad off");
		static_assert((offsetof(TyreData,grainGamma)==0x28),"bad off");
		static_assert((offsetof(TyreData,blisterGamma)==0x2C),"bad off");
		static_assert((offsetof(TyreData,grainGain)==0x30),"bad off");
		static_assert((offsetof(TyreData,blisterGain)==0x34),"bad off");
		static_assert((offsetof(TyreData,rimRadius)==0x38),"bad off");
		static_assert((offsetof(TyreData,optimumTemp)==0x3C),"bad off");
		static_assert((offsetof(TyreData,softnessIndex)==0x40),"bad off");
		static_assert((offsetof(TyreData,radiusRaiseK)==0x44),"bad off");
	};
};

//UDT: struct TyreSlipInput @len=24
	//_Func: public void TyreSlipInput(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: float, slip
	//_Data: this+0x4, Member, Type: float, friction
	//_Data: this+0x8, Member, Type: float, load
	//_Data: this+0xC, Member, Type: float, normalizedSlipX
	//_Data: this+0x10, Member, Type: float, normalizedSlipY
	//_Data: this+0x14, Member, Type: float, D
//UDT;

struct TyreSlipInput {
public:
	float slip;
	float friction;
	float load;
	float normalizedSlipX;
	float normalizedSlipY;
	float D;
	inline TyreSlipInput() { }
	inline TyreSlipInput(const TyreSlipInput& other) = default;
	inline TyreSlipInput& operator=(const TyreSlipInput& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(TyreSlipInput)==24),"bad size");
		static_assert((offsetof(TyreSlipInput,slip)==0x0),"bad off");
		static_assert((offsetof(TyreSlipInput,friction)==0x4),"bad off");
		static_assert((offsetof(TyreSlipInput,load)==0x8),"bad off");
		static_assert((offsetof(TyreSlipInput,normalizedSlipX)==0xC),"bad off");
		static_assert((offsetof(TyreSlipInput,normalizedSlipY)==0x10),"bad off");
		static_assert((offsetof(TyreSlipInput,D)==0x14),"bad off");
	};
};

//UDT: class IJoint @len=8 @vfcount=3
	//_VTable: 
	//_Func: public void release(); @intro @pure @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Func: public void setERPCFM(float  _arg0, float  _arg1); @intro @pure @virtual vtpo=0 vfid=1 @loc=optimized @len=0 @rva=0
	//_Func: protected void ~IJoint(); @intro @virtual vtpo=0 vfid=2 @loc=optimized @len=0 @rva=0
	//_Func: public void IJoint(const IJoint &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void IJoint(); @loc=optimized @len=0 @rva=0
	//_Func: public IJoint & operator=(const IJoint &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: protected void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=2 @loc=optimized @len=0 @rva=0
//UDT;

class IJoint {
public:
	inline IJoint() { }
	inline IJoint(const IJoint& other) = default;
	inline IJoint& operator=(const IJoint& other) = default;
	virtual void release_vf0() = 0;
	inline void release() { typedef void (IJoint::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 0)); return (this->*_f)(); }
	virtual void setERPCFM_vf1(float  _arg0, float  _arg1) = 0;
	inline void setERPCFM(float  _arg0, float  _arg1) { typedef void (IJoint::*_fpt)(float, float); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)( _arg0,  _arg1); }
	virtual ~IJoint();
	inline void _guard_obj() {
		static_assert((sizeof(IJoint)==8),"bad size");
	};
};

//UDT: struct DICommand @len=24
	//_Data: this+0x0, Member, Type: int, index
	//_Data: this+0x4, Member, Type: int, button
	//_Data: this+0x8, Member, Type: bool, status
	//_Data: this+0xC, Member, Type: unsigned int, keyCode
	//_Data: this+0x10, Member, Type: int, powIndex
	//_Data: this+0x14, Member, Type: int, powValue
	//_Func: public void DICommand(int  _arg0, int  _arg1, int  _arg2, int  _arg3, unsigned int  _arg4); @loc=optimized @len=0 @rva=0
	//_Func: public void DICommand(); @loc=optimized @len=0 @rva=0
//UDT;

struct DICommand {
public:
	int index;
	int button;
	bool status;
	unsigned int keyCode;
	int powIndex;
	int powValue;
	inline DICommand() { }
	inline DICommand(const DICommand& other) = default;
	inline DICommand& operator=(const DICommand& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(DICommand)==24),"bad size");
		static_assert((offsetof(DICommand,index)==0x0),"bad off");
		static_assert((offsetof(DICommand,button)==0x4),"bad off");
		static_assert((offsetof(DICommand,status)==0x8),"bad off");
		static_assert((offsetof(DICommand,keyCode)==0xC),"bad off");
		static_assert((offsetof(DICommand,powIndex)==0x10),"bad off");
		static_assert((offsetof(DICommand,powValue)==0x14),"bad off");
	};
};

//UDT: class ICoastGenerator @len=8 @vfcount=2
	//_VTable: 
	//_Func: public void ~ICoastGenerator(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=11 @rva=2693184
	//_Func: public float getCoastTorque(); @intro @pure @virtual vtpo=0 vfid=1 @loc=optimized @len=0 @rva=0
	//_Func: public void ICoastGenerator(const ICoastGenerator &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void ICoastGenerator(); @loc=optimized @len=0 @rva=0
	//_Func: public ICoastGenerator & operator=(const ICoastGenerator &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ICoastGenerator {
public:
	inline ICoastGenerator() { }
	inline ICoastGenerator(const ICoastGenerator& other) = default;
	inline ICoastGenerator& operator=(const ICoastGenerator& other) = default;
	virtual ~ICoastGenerator();
	inline void dtor() { typedef void (ICoastGenerator::*_fpt)(); auto _f=xcast<_fpt>(_drva(2693184)); (this->*_f)(); }
	virtual float getCoastTorque_vf1() = 0;
	inline float getCoastTorque() { typedef float (ICoastGenerator::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(ICoastGenerator)==8),"bad size");
	};
};

//UDT: struct ksgui::ksRect @len=16
	//_Func: public void ksRect(); @loc=optimized @len=0 @rva=0
	//_Func: public void ksRect(float  _arg0, float  _arg1, float  _arg2, float  _arg3); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: float, left
	//_Data: this+0x4, Member, Type: float, right
	//_Data: this+0x8, Member, Type: float, top
	//_Data: this+0xC, Member, Type: float, bottom
	//_Func: public float getWidth(); @loc=static @len=10 @rva=694320
	//_Func: public float getHeight(); @loc=static @len=11 @rva=220096
	//_Func: public void scaleByMult(float  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct ksgui_ksRect {
public:
	float left;
	float right;
	float top;
	float bottom;
	inline ksgui_ksRect() { }
	inline ksgui_ksRect(const ksgui_ksRect& other) = default;
	inline ksgui_ksRect& operator=(const ksgui_ksRect& other) = default;
	inline float getWidth() { typedef float (ksgui_ksRect::*_fpt)(); auto _f=xcast<_fpt>(_drva(694320)); return (this->*_f)(); }
	inline float getHeight() { typedef float (ksgui_ksRect::*_fpt)(); auto _f=xcast<_fpt>(_drva(220096)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_ksRect)==16),"bad size");
		static_assert((offsetof(ksgui_ksRect,left)==0x0),"bad off");
		static_assert((offsetof(ksgui_ksRect,right)==0x4),"bad off");
		static_assert((offsetof(ksgui_ksRect,top)==0x8),"bad off");
		static_assert((offsetof(ksgui_ksRect,bottom)==0xC),"bad off");
	};
};

//UDT: struct ksgui::GUI::FormData @len=16
	//_Data: this+0x0, Member, Type: float, x
	//_Data: this+0x4, Member, Type: float, y
	//_Data: this+0x8, Member, Type: bool, visible
	//_Data: this+0x9, Member, Type: bool, blocked
	//_Data: this+0xC, Member, Type: float, scale
	//_Func: public void FormData(); @loc=optimized @len=0 @rva=0
//UDT;

struct ksgui_GUI_FormData {
public:
	float x;
	float y;
	bool visible;
	bool blocked;
	float scale;
	inline ksgui_GUI_FormData() { }
	inline ksgui_GUI_FormData(const ksgui_GUI_FormData& other) = default;
	inline ksgui_GUI_FormData& operator=(const ksgui_GUI_FormData& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_GUI_FormData)==16),"bad size");
		static_assert((offsetof(ksgui_GUI_FormData,x)==0x0),"bad off");
		static_assert((offsetof(ksgui_GUI_FormData,y)==0x4),"bad off");
		static_assert((offsetof(ksgui_GUI_FormData,visible)==0x8),"bad off");
		static_assert((offsetof(ksgui_GUI_FormData,blocked)==0x9),"bad off");
		static_assert((offsetof(ksgui_GUI_FormData,scale)==0xC),"bad off");
	};
};

//UDT: struct MovementDelays @len=32
	//_Func: public void MovementDelays(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: float, delayRight
	//_Data: this+0x4, Member, Type: float, delayLeft
	//_Data: this+0x8, Member, Type: float, delayForward
	//_Data: this+0xC, Member, Type: float, delayBack
	//_Data: this+0x10, Member, Type: float, mouseDelayX
	//_Data: this+0x14, Member, Type: float, mouseDelayY
	//_Data: this+0x18, Member, Type: float, delayPitch
	//_Data: this+0x1C, Member, Type: float, delayYaw
//UDT;

struct MovementDelays {
public:
	float delayRight;
	float delayLeft;
	float delayForward;
	float delayBack;
	float mouseDelayX;
	float mouseDelayY;
	float delayPitch;
	float delayYaw;
	inline MovementDelays() { }
	inline MovementDelays(const MovementDelays& other) = default;
	inline MovementDelays& operator=(const MovementDelays& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(MovementDelays)==32),"bad size");
		static_assert((offsetof(MovementDelays,delayRight)==0x0),"bad off");
		static_assert((offsetof(MovementDelays,delayLeft)==0x4),"bad off");
		static_assert((offsetof(MovementDelays,delayForward)==0x8),"bad off");
		static_assert((offsetof(MovementDelays,delayBack)==0xC),"bad off");
		static_assert((offsetof(MovementDelays,mouseDelayX)==0x10),"bad off");
		static_assert((offsetof(MovementDelays,mouseDelayY)==0x14),"bad off");
		static_assert((offsetof(MovementDelays,delayPitch)==0x18),"bad off");
		static_assert((offsetof(MovementDelays,delayYaw)==0x1C),"bad off");
	};
};

//UDT: struct CoreCPUTimes @len=24
	//_Data: this+0x0, Member, Type: double, solverTime
	//_Data: this+0x8, Member, Type: double, collisionTime
	//_Data: this+0x10, Member, Type: int, contactPoints
	//_Data: this+0x14, Member, Type: int, narrowPhaseTests
	//_Func: public void CoreCPUTimes(); @loc=optimized @len=0 @rva=0
//UDT;

struct CoreCPUTimes {
public:
	double solverTime;
	double collisionTime;
	int contactPoints;
	int narrowPhaseTests;
	inline CoreCPUTimes() { }
	inline CoreCPUTimes(const CoreCPUTimes& other) = default;
	inline CoreCPUTimes& operator=(const CoreCPUTimes& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(CoreCPUTimes)==24),"bad size");
		static_assert((offsetof(CoreCPUTimes,solverTime)==0x0),"bad off");
		static_assert((offsetof(CoreCPUTimes,collisionTime)==0x8),"bad off");
		static_assert((offsetof(CoreCPUTimes,contactPoints)==0x10),"bad off");
		static_assert((offsetof(CoreCPUTimes,narrowPhaseTests)==0x14),"bad off");
	};
};

//UDT: class ThreadMutex @len=40
	//_Data: this+0x0, Member, Type: struct _RTL_CRITICAL_SECTION, criticalSection
	//_Func: public void ThreadMutex(); @loc=optimized @len=0 @rva=0
	//_Func: public void ~ThreadMutex(); @loc=static @len=7 @rva=783552
	//_Func: public bool take(); @loc=optimized @len=0 @rva=0
	//_Func: public void release(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class ThreadMutex {
public:
	_RTL_CRITICAL_SECTION criticalSection;
	inline ThreadMutex() { }
	inline ThreadMutex(const ThreadMutex& other) = default;
	inline ThreadMutex& operator=(const ThreadMutex& other) = default;
	inline void dtor() { typedef void (ThreadMutex::*_fpt)(); auto _f=xcast<_fpt>(_drva(783552)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(ThreadMutex)==40),"bad size");
		static_assert((offsetof(ThreadMutex,criticalSection)==0x0),"bad off");
	};
};

//UDT: class PIDController @len=20
	//_Func: public void PIDController(); @loc=static @len=16 @rva=4515600
	//_Func: public void PIDController(float  _arg0, float  _arg1, float  _arg2); @loc=optimized @len=0 @rva=0
	//_Func: public void ~PIDController(); @loc=static @len=3 @rva=96368
	//_Data: this+0x0, Member, Type: float, P
	//_Data: this+0x4, Member, Type: float, I
	//_Data: this+0x8, Member, Type: float, D
	//_Data: this+0xC, Member, Type: float, currentError
	//_Func: public float eval(float targetv, float currentv, float dt); @loc=static @len=182 @rva=4515616
	//_Func: public void setPID(float p, float i, float d); @loc=static @len=15 @rva=4515824
	//_Func: public void reset(); @loc=static @len=7 @rva=4515808
	//_Data: this+0x10, Member, Type: float, integral
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class PIDController {
public:
	float P;
	float I;
	float D;
	float currentError;
	float integral;
	inline PIDController() { }
	inline PIDController(const PIDController& other) = default;
	inline PIDController& operator=(const PIDController& other) = default;
	inline void ctor() { typedef void (PIDController::*_fpt)(); auto _f=xcast<_fpt>(_drva(4515600)); (this->*_f)(); }
	inline void dtor() { typedef void (PIDController::*_fpt)(); auto _f=xcast<_fpt>(_drva(96368)); (this->*_f)(); }
	inline float eval(float targetv, float currentv, float dt) { typedef float (PIDController::*_fpt)(float, float, float); auto _f=xcast<_fpt>(_drva(4515616)); return (this->*_f)(targetv, currentv, dt); }
	inline void setPID(float p, float i, float d) { typedef void (PIDController::*_fpt)(float, float, float); auto _f=xcast<_fpt>(_drva(4515824)); return (this->*_f)(p, i, d); }
	inline void reset() { typedef void (PIDController::*_fpt)(); auto _f=xcast<_fpt>(_drva(4515808)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(PIDController)==20),"bad size");
		static_assert((offsetof(PIDController,P)==0x0),"bad off");
		static_assert((offsetof(PIDController,I)==0x4),"bad off");
		static_assert((offsetof(PIDController,D)==0x8),"bad off");
		static_assert((offsetof(PIDController,currentError)==0xC),"bad off");
		static_assert((offsetof(PIDController,integral)==0x10),"bad off");
	};
};

//UDT: class KGLIndexBuffer @len=8
	//_Func: public void KGLIndexBuffer(ID3D11Device * device, unsigned int size, unsigned short * data); @loc=static @len=128 @rva=147296
	//_Func: public void ~KGLIndexBuffer(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: struct ID3D11Buffer *, buffer
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class KGLIndexBuffer {
public:
	ID3D11Buffer * buffer;
	inline KGLIndexBuffer() { }
	inline KGLIndexBuffer(const KGLIndexBuffer& other) = default;
	inline KGLIndexBuffer& operator=(const KGLIndexBuffer& other) = default;
	inline void ctor(ID3D11Device * device, unsigned int size, unsigned short * data) { typedef void (KGLIndexBuffer::*_fpt)(ID3D11Device *, unsigned int, unsigned short *); auto _f=xcast<_fpt>(_drva(147296)); (this->*_f)(device, size, data); }
	inline void _guard_obj() {
		static_assert((sizeof(KGLIndexBuffer)==8),"bad size");
		static_assert((offsetof(KGLIndexBuffer,buffer)==0x0),"bad off");
	};
};

//UDT: struct PitStopTimings @len=20
	//_Data: this+0x0, Member, Type: float, tyreChangeTimeSec
	//_Data: this+0x4, Member, Type: float, fuelChangeTimeSec
	//_Data: this+0x8, Member, Type: float, bodyRepairTimeSec
	//_Data: this+0xC, Member, Type: float, engineRepairTimeSec
	//_Data: this+0x10, Member, Type: float, suspRepairTimeSec
	//_Func: public void PitStopTimings(); @loc=optimized @len=0 @rva=0
//UDT;

struct PitStopTimings {
public:
	float tyreChangeTimeSec;
	float fuelChangeTimeSec;
	float bodyRepairTimeSec;
	float engineRepairTimeSec;
	float suspRepairTimeSec;
	inline PitStopTimings() { }
	inline PitStopTimings(const PitStopTimings& other) = default;
	inline PitStopTimings& operator=(const PitStopTimings& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(PitStopTimings)==20),"bad size");
		static_assert((offsetof(PitStopTimings,tyreChangeTimeSec)==0x0),"bad off");
		static_assert((offsetof(PitStopTimings,fuelChangeTimeSec)==0x4),"bad off");
		static_assert((offsetof(PitStopTimings,bodyRepairTimeSec)==0x8),"bad off");
		static_assert((offsetof(PitStopTimings,engineRepairTimeSec)==0xC),"bad off");
		static_assert((offsetof(PitStopTimings,suspRepairTimeSec)==0x10),"bad off");
	};
};

//UDT: struct KGLShaderVarDesc @len=32
	//_Data: this+0x0, Member, Type: const wchar_t *, name
	//_Data: this+0x8, Member, Type: const wchar_t *, cBufferName
	//_Data: this+0x10, Member, Type: unsigned int, cBufferSlot
	//_Data: this+0x14, Member, Type: unsigned int, size
	//_Data: this+0x18, Member, Type: unsigned int, offset
//UDT;

struct KGLShaderVarDesc {
public:
	const wchar_t * name;
	const wchar_t * cBufferName;
	unsigned int cBufferSlot;
	unsigned int size;
	unsigned int offset;
	inline KGLShaderVarDesc() { }
	inline KGLShaderVarDesc(const KGLShaderVarDesc& other) = default;
	inline KGLShaderVarDesc& operator=(const KGLShaderVarDesc& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(KGLShaderVarDesc)==32),"bad size");
		static_assert((offsetof(KGLShaderVarDesc,name)==0x0),"bad off");
		static_assert((offsetof(KGLShaderVarDesc,cBufferName)==0x8),"bad off");
		static_assert((offsetof(KGLShaderVarDesc,cBufferSlot)==0x10),"bad off");
		static_assert((offsetof(KGLShaderVarDesc,size)==0x14),"bad off");
		static_assert((offsetof(KGLShaderVarDesc,offset)==0x18),"bad off");
	};
};

//UDT: class KGLRenderTarget @len=48
	//_Func: public void KGLRenderTarget(ID3D11DepthStencilView *  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void KGLRenderTarget(ID3D11RenderTargetView *  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void KGLRenderTarget(ID3D11Device * device, DXGI_FORMAT fmt, unsigned int iwidth, unsigned int iheight, bool isDepth, int aSamples, int mips); @loc=static @len=608 @rva=144080
	//_Func: public void ~KGLRenderTarget(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: struct ID3D11Texture2D *, rtTexture
	//_Data: this+0x8, Member, Type: struct ID3D11RenderTargetView *, renderTargetView
	//_Data: this+0x10, Member, Type: struct ID3D11ShaderResourceView *, shaderResourceView
	//_Data: this+0x18, Member, Type: struct ID3D11DepthStencilView *, renderTargetViewDepth
	//_Data: this+0x20, Member, Type: enum DXGI_FORMAT, format
	//_Data: this+0x24, Member, Type: unsigned int, width
	//_Data: this+0x28, Member, Type: unsigned int, height
	//_Data: this+0x2C, Member, Type: int, samples
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class KGLRenderTarget {
public:
	ID3D11Texture2D * rtTexture;
	ID3D11RenderTargetView * renderTargetView;
	ID3D11ShaderResourceView * shaderResourceView;
	ID3D11DepthStencilView * renderTargetViewDepth;
	DXGI_FORMAT format;
	unsigned int width;
	unsigned int height;
	int samples;
	inline KGLRenderTarget() { }
	inline KGLRenderTarget(const KGLRenderTarget& other) = default;
	inline KGLRenderTarget& operator=(const KGLRenderTarget& other) = default;
	inline void ctor(ID3D11Device * device, DXGI_FORMAT fmt, unsigned int iwidth, unsigned int iheight, bool isDepth, int aSamples, int mips) { typedef void (KGLRenderTarget::*_fpt)(ID3D11Device *, DXGI_FORMAT, unsigned int, unsigned int, bool, int, int); auto _f=xcast<_fpt>(_drva(144080)); (this->*_f)(device, fmt, iwidth, iheight, isDepth, aSamples, mips); }
	inline void _guard_obj() {
		static_assert((sizeof(KGLRenderTarget)==48),"bad size");
		static_assert((offsetof(KGLRenderTarget,rtTexture)==0x0),"bad off");
		static_assert((offsetof(KGLRenderTarget,renderTargetView)==0x8),"bad off");
		static_assert((offsetof(KGLRenderTarget,shaderResourceView)==0x10),"bad off");
		static_assert((offsetof(KGLRenderTarget,renderTargetViewDepth)==0x18),"bad off");
		static_assert((offsetof(KGLRenderTarget,format)==0x20),"bad off");
		static_assert((offsetof(KGLRenderTarget,width)==0x24),"bad off");
		static_assert((offsetof(KGLRenderTarget,height)==0x28),"bad off");
		static_assert((offsetof(KGLRenderTarget,samples)==0x2C),"bad off");
	};
};

//UDT: struct SteerMzLowSpeedReduction @len=8
	//_Data: this+0x0, Member, Type: float, speedKMH
	//_Data: this+0x4, Member, Type: float, minValue
	//_Func: public void SteerMzLowSpeedReduction(); @loc=optimized @len=0 @rva=0
//UDT;

struct SteerMzLowSpeedReduction {
public:
	float speedKMH;
	float minValue;
	inline SteerMzLowSpeedReduction() { }
	inline SteerMzLowSpeedReduction(const SteerMzLowSpeedReduction& other) = default;
	inline SteerMzLowSpeedReduction& operator=(const SteerMzLowSpeedReduction& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(SteerMzLowSpeedReduction)==8),"bad size");
		static_assert((offsetof(SteerMzLowSpeedReduction,speedKMH)==0x0),"bad off");
		static_assert((offsetof(SteerMzLowSpeedReduction,minValue)==0x4),"bad off");
	};
};

//UDT: struct RenderStats @len=20
	//_Func: public void RenderStats(); @loc=optimized @len=0 @rva=0
	//_Func: public void reset(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: int, dipCalls
	//_Data: this+0x4, Member, Type: int, sceneDipCalls
	//_Data: this+0x8, Member, Type: int, triangles
	//_Data: this+0xC, Member, Type: int, sceneTriangles
	//_Data: this+0x10, Member, Type: bool, isInMainRenderPass
//UDT;

struct RenderStats {
public:
	int dipCalls;
	int sceneDipCalls;
	int triangles;
	int sceneTriangles;
	bool isInMainRenderPass;
	inline RenderStats() { }
	inline RenderStats(const RenderStats& other) = default;
	inline RenderStats& operator=(const RenderStats& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(RenderStats)==20),"bad size");
		static_assert((offsetof(RenderStats,dipCalls)==0x0),"bad off");
		static_assert((offsetof(RenderStats,sceneDipCalls)==0x4),"bad off");
		static_assert((offsetof(RenderStats,triangles)==0x8),"bad off");
		static_assert((offsetof(RenderStats,sceneTriangles)==0xC),"bad off");
		static_assert((offsetof(RenderStats,isInMainRenderPass)==0x10),"bad off");
	};
};

//UDT: struct HDRLevels @len=8
	//_Func: public void HDRLevels(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: float, minExposure
	//_Data: this+0x4, Member, Type: float, maxExposure
//UDT;

struct HDRLevels {
public:
	float minExposure;
	float maxExposure;
	inline HDRLevels() { }
	inline HDRLevels(const HDRLevels& other) = default;
	inline HDRLevels& operator=(const HDRLevels& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(HDRLevels)==8),"bad size");
		static_assert((offsetof(HDRLevels,minExposure)==0x0),"bad off");
		static_assert((offsetof(HDRLevels,maxExposure)==0x4),"bad off");
	};
};

//UDT: struct WindSettings @len=8
	//_Data: this+0x0, Member, Type: float, baseSpeed
	//_Data: this+0x4, Member, Type: float, baseDirection
	//_Func: public void WindSettings(); @loc=optimized @len=0 @rva=0
//UDT;

struct WindSettings {
public:
	float baseSpeed;
	float baseDirection;
	inline WindSettings() { }
	inline WindSettings(const WindSettings& other) = default;
	inline WindSettings& operator=(const WindSettings& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(WindSettings)==8),"bad size");
		static_assert((offsetof(WindSettings,baseSpeed)==0x0),"bad off");
		static_assert((offsetof(WindSettings,baseDirection)==0x4),"bad off");
	};
};

//UDT: struct SplineLocationData @len=4
	//_Func: public void SplineLocationData(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: int, currentIndex
//UDT;

struct SplineLocationData {
public:
	int currentIndex;
	inline SplineLocationData() { }
	inline SplineLocationData(const SplineLocationData& other) = default;
	inline SplineLocationData& operator=(const SplineLocationData& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(SplineLocationData)==4),"bad size");
		static_assert((offsetof(SplineLocationData,currentIndex)==0x0),"bad off");
	};
};

//UDT: struct OnKeyCharEvent @len=4
	//_Func: public void OnKeyCharEvent(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: unsigned int, key
//UDT;

struct OnKeyCharEvent {
public:
	unsigned int key;
	inline OnKeyCharEvent() { }
	inline OnKeyCharEvent(const OnKeyCharEvent& other) = default;
	inline OnKeyCharEvent& operator=(const OnKeyCharEvent& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(OnKeyCharEvent)==4),"bad size");
		static_assert((offsetof(OnKeyCharEvent,key)==0x0),"bad off");
	};
};

//UDT: struct CommandItem @len=4
	//_Func: public void CommandItem(int akey); @loc=static @len=6 @rva=953184
	//_Func: public void CommandItem(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: int, key
//UDT;

struct CommandItem {
public:
	int key;
	inline CommandItem() { }
	inline CommandItem(const CommandItem& other) = default;
	inline CommandItem& operator=(const CommandItem& other) = default;
	inline void ctor(int akey) { typedef void (CommandItem::*_fpt)(int); auto _f=xcast<_fpt>(_drva(953184)); (this->*_f)(akey); }
	inline void _guard_obj() {
		static_assert((sizeof(CommandItem)==4),"bad size");
		static_assert((offsetof(CommandItem,key)==0x0),"bad off");
	};
};

//UDT: struct AWD2Data @len=24
	//_Data: this+0x0, Member, Type: double, ramp
	//_Data: this+0x8, Member, Type: double, maxTorque
	//_Data: this+0x10, Member, Type: float, currentLockTorque
	//_Func: public void AWD2Data(); @loc=optimized @len=0 @rva=0
//UDT;

struct AWD2Data {
public:
	double ramp;
	double maxTorque;
	float currentLockTorque;
	inline AWD2Data() { }
	inline AWD2Data(const AWD2Data& other) = default;
	inline AWD2Data& operator=(const AWD2Data& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(AWD2Data)==24),"bad size");
		static_assert((offsetof(AWD2Data,ramp)==0x0),"bad off");
		static_assert((offsetof(AWD2Data,maxTorque)==0x8),"bad off");
		static_assert((offsetof(AWD2Data,currentLockTorque)==0x10),"bad off");
	};
};

//UDT: struct NetCarPushToPass @len=20
	//_Data: this+0x0, Member, Type: bool, enabled
	//_Data: this+0x1, Member, Type: bool, active
	//_Data: this+0x4, Member, Type: float, coolDownS
	//_Data: this+0x8, Member, Type: float, timeS
	//_Data: this+0xC, Member, Type: float, timeAccum
	//_Data: this+0x10, Member, Type: int, activations
	//_Func: public void NetCarPushToPass(); @loc=optimized @len=0 @rva=0
//UDT;

struct NetCarPushToPass {
public:
	bool enabled;
	bool active;
	float coolDownS;
	float timeS;
	float timeAccum;
	int activations;
	inline NetCarPushToPass() { }
	inline NetCarPushToPass(const NetCarPushToPass& other) = default;
	inline NetCarPushToPass& operator=(const NetCarPushToPass& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(NetCarPushToPass)==20),"bad size");
		static_assert((offsetof(NetCarPushToPass,enabled)==0x0),"bad off");
		static_assert((offsetof(NetCarPushToPass,active)==0x1),"bad off");
		static_assert((offsetof(NetCarPushToPass,coolDownS)==0x4),"bad off");
		static_assert((offsetof(NetCarPushToPass,timeS)==0x8),"bad off");
		static_assert((offsetof(NetCarPushToPass,timeAccum)==0xC),"bad off");
		static_assert((offsetof(NetCarPushToPass,activations)==0x10),"bad off");
	};
};

//UDT: struct OnRaceInitEvent @len=4
	//_Func: public void OnRaceInitEvent(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: int, laps
//UDT;

struct OnRaceInitEvent {
public:
	int laps;
	inline OnRaceInitEvent() { }
	inline OnRaceInitEvent(const OnRaceInitEvent& other) = default;
	inline OnRaceInitEvent& operator=(const OnRaceInitEvent& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(OnRaceInitEvent)==4),"bad size");
		static_assert((offsetof(OnRaceInitEvent,laps)==0x0),"bad off");
	};
};

//UDT: class Trigger @len=12
	//_Func: public void Trigger(); @loc=static @len=13 @rva=2339728
	//_Func: public void ~Trigger(); @loc=static @len=3 @rva=96368
	//_Func: public bool hasSwitchedState(bool  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public bool ignoreSubsequentTrue(bool value); @loc=static @len=32 @rva=2339744
	//_Func: public bool keepSteady(float dt, bool value); @loc=static @len=60 @rva=2339776
	//_Func: public bool turnOn(bool  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public bool turnOff(bool  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void setAccumulatorLimit(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: bool, state
	//_Data: this+0x1, Member, Type: bool, lastState
	//_Data: this+0x4, Member, Type: float, accumulator
	//_Data: this+0x8, Member, Type: float, accumulatorLimit
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class Trigger {
public:
	bool state;
	bool lastState;
	float accumulator;
	float accumulatorLimit;
	inline Trigger() { }
	inline Trigger(const Trigger& other) = default;
	inline Trigger& operator=(const Trigger& other) = default;
	inline void ctor() { typedef void (Trigger::*_fpt)(); auto _f=xcast<_fpt>(_drva(2339728)); (this->*_f)(); }
	inline void dtor() { typedef void (Trigger::*_fpt)(); auto _f=xcast<_fpt>(_drva(96368)); (this->*_f)(); }
	inline bool ignoreSubsequentTrue(bool value) { typedef bool (Trigger::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(2339744)); return (this->*_f)(value); }
	inline bool keepSteady(float dt, bool value) { typedef bool (Trigger::*_fpt)(float, bool); auto _f=xcast<_fpt>(_drva(2339776)); return (this->*_f)(dt, value); }
	inline void _guard_obj() {
		static_assert((sizeof(Trigger)==12),"bad size");
		static_assert((offsetof(Trigger,state)==0x0),"bad off");
		static_assert((offsetof(Trigger,lastState)==0x1),"bad off");
		static_assert((offsetof(Trigger,accumulator)==0x4),"bad off");
		static_assert((offsetof(Trigger,accumulatorLimit)==0x8),"bad off");
	};
};

//UDT: class CBuffer @len=40
	//_Func: public void CBuffer(); @loc=static @len=27 @rva=2201856
	//_Func: public void CBuffer(int islot, int isize); @loc=static @len=104 @rva=2201744
	//_Func: public void ~CBuffer(); @loc=static @len=55 @rva=2202128
	//_Data: this+0x0, Member, Type: int, size
	//_Data: this+0x4, Member, Type: int, slot
	//_Data: this+0x8, Member, Type: bool, isSystem
	//_Data: this+0x9, Member, Type: bool, isPS
	//_Data: this+0xA, Member, Type: bool, isVS
	//_Data: this+0x10, Member, Type: void *, kid
	//_Func: public void set(int * value, int offset, int size); @loc=static @len=37 @rva=2202192
	//_Func: public void set(float * value, int offset, int size); @loc=static @len=37 @rva=2202192
	//_Func: public void get(int *  _arg0, int  _arg1, int  _arg2); @loc=optimized @len=0 @rva=0
	//_Func: public void get(float * value, int offset, int size); @loc=static @len=24 @rva=2201968
	//_Func: public void commit(); @loc=static @len=77 @rva=2201888
	//_Func: public void touch(); @loc=static @len=5 @rva=2202240
	//_Func: public void map(void * bdata, int bsize); @loc=static @len=28 @rva=2202096
	//_Func: public void init(int islot, int isize); @loc=static @len=82 @rva=2202000
	//_Func: public void release(); @loc=static @len=55 @rva=2202128
	//_Data: this+0x18, Member, Type: unsigned char *, data
	//_Data: this+0x20, Member, Type: bool, touched
	//_Func: public void __autoclassinit2(unsigned __int64  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class CBuffer {
public:
	int size;
	int slot;
	bool isSystem;
	bool isPS;
	bool isVS;
	void * kid;
	unsigned char * data;
	bool touched;
	inline CBuffer() { }
	inline CBuffer(const CBuffer& other) = default;
	inline CBuffer& operator=(const CBuffer& other) = default;
	inline void ctor() { typedef void (CBuffer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2201856)); (this->*_f)(); }
	inline void ctor(int islot, int isize) { typedef void (CBuffer::*_fpt)(int, int); auto _f=xcast<_fpt>(_drva(2201744)); (this->*_f)(islot, isize); }
	inline void dtor() { typedef void (CBuffer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2202128)); (this->*_f)(); }
	inline void set(int * value, int offset, int size) { typedef void (CBuffer::*_fpt)(int *, int, int); auto _f=xcast<_fpt>(_drva(2202192)); return (this->*_f)(value, offset, size); }
	inline void set(float * value, int offset, int size) { typedef void (CBuffer::*_fpt)(float *, int, int); auto _f=xcast<_fpt>(_drva(2202192)); return (this->*_f)(value, offset, size); }
	inline void get(float * value, int offset, int size) { typedef void (CBuffer::*_fpt)(float *, int, int); auto _f=xcast<_fpt>(_drva(2201968)); return (this->*_f)(value, offset, size); }
	inline void commit() { typedef void (CBuffer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2201888)); return (this->*_f)(); }
	inline void touch() { typedef void (CBuffer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2202240)); return (this->*_f)(); }
	inline void map(void * bdata, int bsize) { typedef void (CBuffer::*_fpt)(void *, int); auto _f=xcast<_fpt>(_drva(2202096)); return (this->*_f)(bdata, bsize); }
	inline void init(int islot, int isize) { typedef void (CBuffer::*_fpt)(int, int); auto _f=xcast<_fpt>(_drva(2202000)); return (this->*_f)(islot, isize); }
	inline void release() { typedef void (CBuffer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2202128)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(CBuffer)==40),"bad size");
		static_assert((offsetof(CBuffer,size)==0x0),"bad off");
		static_assert((offsetof(CBuffer,slot)==0x4),"bad off");
		static_assert((offsetof(CBuffer,isSystem)==0x8),"bad off");
		static_assert((offsetof(CBuffer,isPS)==0x9),"bad off");
		static_assert((offsetof(CBuffer,isVS)==0xA),"bad off");
		static_assert((offsetof(CBuffer,kid)==0x10),"bad off");
		static_assert((offsetof(CBuffer,data)==0x18),"bad off");
		static_assert((offsetof(CBuffer,touched)==0x20),"bad off");
	};
};

//UDT: struct TyreModelInput @len=48
	//_Data: this+0x0, Member, Type: float, load
	//_Data: this+0x4, Member, Type: float, slipAngleRAD
	//_Data: this+0x8, Member, Type: float, slipRatio
	//_Data: this+0xC, Member, Type: float, camberRAD
	//_Data: this+0x10, Member, Type: float, speed
	//_Data: this+0x14, Member, Type: float, u
	//_Data: this+0x18, Member, Type: int, tyreIndex
	//_Data: this+0x1C, Member, Type: float, cpLength
	//_Data: this+0x20, Member, Type: float, grain
	//_Data: this+0x24, Member, Type: float, blister
	//_Data: this+0x28, Member, Type: float, pressureRatio
	//_Data: this+0x2C, Member, Type: bool, useSimpleModel
//UDT;

struct TyreModelInput {
public:
	float load;
	float slipAngleRAD;
	float slipRatio;
	float camberRAD;
	float speed;
	float u;
	int tyreIndex;
	float cpLength;
	float grain;
	float blister;
	float pressureRatio;
	bool useSimpleModel;
	inline TyreModelInput() { }
	inline TyreModelInput(const TyreModelInput& other) = default;
	inline TyreModelInput& operator=(const TyreModelInput& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(TyreModelInput)==48),"bad size");
		static_assert((offsetof(TyreModelInput,load)==0x0),"bad off");
		static_assert((offsetof(TyreModelInput,slipAngleRAD)==0x4),"bad off");
		static_assert((offsetof(TyreModelInput,slipRatio)==0x8),"bad off");
		static_assert((offsetof(TyreModelInput,camberRAD)==0xC),"bad off");
		static_assert((offsetof(TyreModelInput,speed)==0x10),"bad off");
		static_assert((offsetof(TyreModelInput,u)==0x14),"bad off");
		static_assert((offsetof(TyreModelInput,tyreIndex)==0x18),"bad off");
		static_assert((offsetof(TyreModelInput,cpLength)==0x1C),"bad off");
		static_assert((offsetof(TyreModelInput,grain)==0x20),"bad off");
		static_assert((offsetof(TyreModelInput,blister)==0x24),"bad off");
		static_assert((offsetof(TyreModelInput,pressureRatio)==0x28),"bad off");
		static_assert((offsetof(TyreModelInput,useSimpleModel)==0x2C),"bad off");
	};
};

//UDT: struct SurfaceDef @len=200
	//_Func: public void SurfaceDef(const SurfaceDef &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void SurfaceDef(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: wchar_t[0x40], wavString
	//_Data: this+0x80, Member, Type: float, wavPitchSpeed
	//_Data: this+0x88, Member, Type: void *, userPointer
	//_Data: this+0x90, Member, Type: float, gripMod
	//_Data: this+0x94, Member, Type: int, sectorID
	//_Data: this+0x98, Member, Type: float, dirtAdditiveK
	//_Data: this+0x9C, Member, Type: unsigned int, collisionCategory
	//_Data: this+0xA0, Member, Type: bool, isValidTrack
	//_Data: this+0xA4, Member, Type: float, blackFlagTime
	//_Data: this+0xA8, Member, Type: float, sinHeight
	//_Data: this+0xAC, Member, Type: float, sinLength
	//_Data: this+0xB0, Member, Type: bool, isPitlane
	//_Data: this+0xB4, Member, Type: float, damping
	//_Data: this+0xB8, Member, Type: float, granularity
	//_Data: this+0xBC, Member, Type: float, vibrationGain
	//_Data: this+0xC0, Member, Type: float, vibrationLength
//UDT;

struct SurfaceDef {
public:
	wchar_t wavString[64];
	float wavPitchSpeed;
	void * userPointer;
	float gripMod;
	int sectorID;
	float dirtAdditiveK;
	unsigned int collisionCategory;
	bool isValidTrack;
	float blackFlagTime;
	float sinHeight;
	float sinLength;
	bool isPitlane;
	float damping;
	float granularity;
	float vibrationGain;
	float vibrationLength;
	inline SurfaceDef() { }
	inline SurfaceDef(const SurfaceDef& other) = default;
	inline SurfaceDef& operator=(const SurfaceDef& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(SurfaceDef)==200),"bad size");
		static_assert((offsetof(SurfaceDef,wavString)==0x0),"bad off");
		static_assert((offsetof(SurfaceDef,wavPitchSpeed)==0x80),"bad off");
		static_assert((offsetof(SurfaceDef,userPointer)==0x88),"bad off");
		static_assert((offsetof(SurfaceDef,gripMod)==0x90),"bad off");
		static_assert((offsetof(SurfaceDef,sectorID)==0x94),"bad off");
		static_assert((offsetof(SurfaceDef,dirtAdditiveK)==0x98),"bad off");
		static_assert((offsetof(SurfaceDef,collisionCategory)==0x9C),"bad off");
		static_assert((offsetof(SurfaceDef,isValidTrack)==0xA0),"bad off");
		static_assert((offsetof(SurfaceDef,blackFlagTime)==0xA4),"bad off");
		static_assert((offsetof(SurfaceDef,sinHeight)==0xA8),"bad off");
		static_assert((offsetof(SurfaceDef,sinLength)==0xAC),"bad off");
		static_assert((offsetof(SurfaceDef,isPitlane)==0xB0),"bad off");
		static_assert((offsetof(SurfaceDef,damping)==0xB4),"bad off");
		static_assert((offsetof(SurfaceDef,granularity)==0xB8),"bad off");
		static_assert((offsetof(SurfaceDef,vibrationGain)==0xBC),"bad off");
		static_assert((offsetof(SurfaceDef,vibrationLength)==0xC0),"bad off");
	};
};

//UDT: struct TrackInfo @len=4
	//_Data: this+0x0, Member, Type: float, length
	//_Func: public void TrackInfo(); @loc=optimized @len=0 @rva=0
//UDT;

struct TrackInfo {
public:
	float length;
	inline TrackInfo() { }
	inline TrackInfo(const TrackInfo& other) = default;
	inline TrackInfo& operator=(const TrackInfo& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(TrackInfo)==4),"bad size");
		static_assert((offsetof(TrackInfo,length)==0x0),"bad off");
	};
};

//UDT: struct SusStrutDamageDef @len=28
	//_Data: this+0x0, Member, Type: float, damageAmount
	//_Data: this+0x4, Member, Type: float, damageDirection
	//_Data: this+0x8, Member, Type: float, minVelocity
	//_Data: this+0xC, Member, Type: float, damageGain
	//_Data: this+0x10, Member, Type: float, maxDamage
	//_Data: this+0x14, Member, Type: bool, isDebug
	//_Data: this+0x18, Member, Type: float, lastAmount
	//_Func: public void SusStrutDamageDef(); @loc=optimized @len=0 @rva=0
//UDT;

struct SusStrutDamageDef {
public:
	float damageAmount;
	float damageDirection;
	float minVelocity;
	float damageGain;
	float maxDamage;
	bool isDebug;
	float lastAmount;
	inline SusStrutDamageDef() { }
	inline SusStrutDamageDef(const SusStrutDamageDef& other) = default;
	inline SusStrutDamageDef& operator=(const SusStrutDamageDef& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(SusStrutDamageDef)==28),"bad size");
		static_assert((offsetof(SusStrutDamageDef,damageAmount)==0x0),"bad off");
		static_assert((offsetof(SusStrutDamageDef,damageDirection)==0x4),"bad off");
		static_assert((offsetof(SusStrutDamageDef,minVelocity)==0x8),"bad off");
		static_assert((offsetof(SusStrutDamageDef,damageGain)==0xC),"bad off");
		static_assert((offsetof(SusStrutDamageDef,maxDamage)==0x10),"bad off");
		static_assert((offsetof(SusStrutDamageDef,isDebug)==0x14),"bad off");
		static_assert((offsetof(SusStrutDamageDef,lastAmount)==0x18),"bad off");
	};
};

//UDT: struct AISplineSlimPayload @len=16
	//_Data: this+0x0, Member, Type: float, camber
	//_Data: this+0x4, Member, Type: float, grip
	//_Data: this+0x8, Member, Type: float, grade
	//_Data: this+0xC, Member, Type: bool, isPitlane
	//_Func: public void AISplineSlimPayload(); @loc=optimized @len=0 @rva=0
//UDT;

struct AISplineSlimPayload {
public:
	float camber;
	float grip;
	float grade;
	bool isPitlane;
	inline AISplineSlimPayload() { }
	inline AISplineSlimPayload(const AISplineSlimPayload& other) = default;
	inline AISplineSlimPayload& operator=(const AISplineSlimPayload& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(AISplineSlimPayload)==16),"bad size");
		static_assert((offsetof(AISplineSlimPayload,camber)==0x0),"bad off");
		static_assert((offsetof(AISplineSlimPayload,grip)==0x4),"bad off");
		static_assert((offsetof(AISplineSlimPayload,grade)==0x8),"bad off");
		static_assert((offsetof(AISplineSlimPayload,isPitlane)==0xC),"bad off");
	};
};

//UDT: struct AIStraightData @len=12
	//_Data: this+0x0, Member, Type: float, start
	//_Data: this+0x4, Member, Type: float, end
	//_Data: this+0x8, Member, Type: float, length
	//_Func: public void AIStraightData(); @loc=optimized @len=0 @rva=0
//UDT;

struct AIStraightData {
public:
	float start;
	float end;
	float length;
	inline AIStraightData() { }
	inline AIStraightData(const AIStraightData& other) = default;
	inline AIStraightData& operator=(const AIStraightData& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(AIStraightData)==12),"bad size");
		static_assert((offsetof(AIStraightData,start)==0x0),"bad off");
		static_assert((offsetof(AIStraightData,end)==0x4),"bad off");
		static_assert((offsetof(AIStraightData,length)==0x8),"bad off");
	};
};

//UDT: class Speed @len=4
	//_Func: private void Speed(float v); @loc=static @len=8 @rva=2333072
	//_Func: public void Speed(); @loc=static @len=10 @rva=2333024
	//_Func: public void ~Speed(); @loc=static @len=3 @rva=96368
	//_Func: public Speed fromMS(float ms); @pure @loc=static @len=8 @rva=2333072
	//_Func: public Speed fromKMH(float ms); @pure @loc=static @len=16 @rva=2333040
	//_Func: public Speed fromMPH(float ms); @pure @loc=static @len=16 @rva=2333056
	//_Data: static, [0155A5AE][0003:000475AE], Static Member, Type: bool, useMPH
	//_Func: public float ms(); @loc=optimized @len=0 @rva=0
	//_Func: public float kmh(); @loc=static @len=13 @rva=364368
	//_Func: public float mph(); @loc=optimized @len=0 @rva=0
	//_Func: public float toSystemDefault(); @loc=optimized @len=0 @rva=0
	//_Func: public Speed operator-(const Speed &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public Speed operator+(const Speed &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public Speed operator*(float v2); @loc=static @len=41 @rva=2502224
	//_Func: public Speed operator/(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: float, value
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class Speed {
public:
	float value;
	inline Speed() { }
	inline Speed(const Speed& other) = default;
	inline Speed& operator=(const Speed& other) = default;
	inline void ctor(float v) { typedef void (Speed::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2333072)); (this->*_f)(v); }
	inline void ctor() { typedef void (Speed::*_fpt)(); auto _f=xcast<_fpt>(_drva(2333024)); (this->*_f)(); }
	inline void dtor() { typedef void (Speed::*_fpt)(); auto _f=xcast<_fpt>(_drva(96368)); (this->*_f)(); }
	inline static Speed fromMS(float ms) { typedef Speed (*_fpt)(float); auto _f=(_fpt)_drva(2333072); return _f(ms); }
	inline static Speed fromKMH(float ms) { typedef Speed (*_fpt)(float); auto _f=(_fpt)_drva(2333040); return _f(ms); }
	inline static Speed fromMPH(float ms) { typedef Speed (*_fpt)(float); auto _f=(_fpt)_drva(2333056); return _f(ms); }
	inline float kmh() { typedef float (Speed::*_fpt)(); auto _f=xcast<_fpt>(_drva(364368)); return (this->*_f)(); }
	inline Speed operator*(float v2) { typedef Speed (Speed::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2502224)); return (this->*_f)(v2); }
	inline void _guard_obj() {
		static_assert((sizeof(Speed)==4),"bad size");
		static_assert((offsetof(Speed,value)==0x0),"bad off");
	};
};

//UDT: struct ACCarState @len=328
	//_Data: this+0x0, Member, Type: float[0x3], wheelLF_localPos
	//_Data: this+0xC, Member, Type: float[0x3], wheelRF_localPos
	//_Data: this+0x18, Member, Type: float[0x3], wheelLR_localPos
	//_Data: this+0x24, Member, Type: float[0x3], wheelRR_localPos
	//_Data: this+0x30, Member, Type: float[0x3], localVelocity
	//_Data: this+0x3C, Member, Type: float[0x3], worldVelocity
	//_Data: this+0x48, Member, Type: float[0x3], accG
	//_Data: this+0x54, Member, Type: float, engineRPMS
	//_Data: this+0x58, Member, Type: float[0x3], worldPosition
	//_Data: this+0x64, Member, Type: float[0x10], bodyMatrix
	//_Data: this+0xA4, Member, Type: int, gear
	//_Data: this+0xA8, Member, Type: bool, isEngineLimiterOn
	//_Data: this+0xAC, Member, Type: float[0x4], wheelAngularSpeed
	//_Data: this+0xBC, Member, Type: float, steer
	//_Data: this+0xC0, Member, Type: float, gas
	//_Data: this+0xC4, Member, Type: float, brake
	//_Data: this+0xC8, Member, Type: float, clutch
	//_Data: this+0xCC, Member, Type: float[0x3], localAngularVelocity
	//_Data: this+0xD8, Member, Type: float[0x4], ndSlip
	//_Data: this+0xE8, Member, Type: float[0x4], load
	//_Data: this+0xF8, Member, Type: float[0x4], Mz
	//_Data: this+0x108, Member, Type: float[0x4], tyreDirtyLevel
	//_Data: this+0x118, Member, Type: float, lastFF
	//_Data: this+0x11C, Member, Type: float, drivetrainSpeed
	//_Data: this+0x120, Member, Type: float, turboBoost
	//_Data: this+0x124, Member, Type: float, performanceMeter
	//_Data: this+0x128, Member, Type: bool, isGearGrinding
	//_Data: this+0x12C, Member, Type: float[0x5], damageZoneLevel
	//_Data: this+0x140, Member, Type: int, limiterRPM
	//_Data: this+0x144, Member, Type: float, speedMS
//UDT;

struct ACCarState {
public:
	float wheelLF_localPos[3];
	float wheelRF_localPos[3];
	float wheelLR_localPos[3];
	float wheelRR_localPos[3];
	float localVelocity[3];
	float worldVelocity[3];
	float accG[3];
	float engineRPMS;
	float worldPosition[3];
	float bodyMatrix[16];
	int gear;
	bool isEngineLimiterOn;
	float wheelAngularSpeed[4];
	float steer;
	float gas;
	float brake;
	float clutch;
	float localAngularVelocity[3];
	float ndSlip[4];
	float load[4];
	float Mz[4];
	float tyreDirtyLevel[4];
	float lastFF;
	float drivetrainSpeed;
	float turboBoost;
	float performanceMeter;
	bool isGearGrinding;
	float damageZoneLevel[5];
	int limiterRPM;
	float speedMS;
	inline ACCarState() { }
	inline ACCarState(const ACCarState& other) = default;
	inline ACCarState& operator=(const ACCarState& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(ACCarState)==328),"bad size");
		static_assert((offsetof(ACCarState,wheelLF_localPos)==0x0),"bad off");
		static_assert((offsetof(ACCarState,wheelRF_localPos)==0xC),"bad off");
		static_assert((offsetof(ACCarState,wheelLR_localPos)==0x18),"bad off");
		static_assert((offsetof(ACCarState,wheelRR_localPos)==0x24),"bad off");
		static_assert((offsetof(ACCarState,localVelocity)==0x30),"bad off");
		static_assert((offsetof(ACCarState,worldVelocity)==0x3C),"bad off");
		static_assert((offsetof(ACCarState,accG)==0x48),"bad off");
		static_assert((offsetof(ACCarState,engineRPMS)==0x54),"bad off");
		static_assert((offsetof(ACCarState,worldPosition)==0x58),"bad off");
		static_assert((offsetof(ACCarState,bodyMatrix)==0x64),"bad off");
		static_assert((offsetof(ACCarState,gear)==0xA4),"bad off");
		static_assert((offsetof(ACCarState,isEngineLimiterOn)==0xA8),"bad off");
		static_assert((offsetof(ACCarState,wheelAngularSpeed)==0xAC),"bad off");
		static_assert((offsetof(ACCarState,steer)==0xBC),"bad off");
		static_assert((offsetof(ACCarState,gas)==0xC0),"bad off");
		static_assert((offsetof(ACCarState,brake)==0xC4),"bad off");
		static_assert((offsetof(ACCarState,clutch)==0xC8),"bad off");
		static_assert((offsetof(ACCarState,localAngularVelocity)==0xCC),"bad off");
		static_assert((offsetof(ACCarState,ndSlip)==0xD8),"bad off");
		static_assert((offsetof(ACCarState,load)==0xE8),"bad off");
		static_assert((offsetof(ACCarState,Mz)==0xF8),"bad off");
		static_assert((offsetof(ACCarState,tyreDirtyLevel)==0x108),"bad off");
		static_assert((offsetof(ACCarState,lastFF)==0x118),"bad off");
		static_assert((offsetof(ACCarState,drivetrainSpeed)==0x11C),"bad off");
		static_assert((offsetof(ACCarState,turboBoost)==0x120),"bad off");
		static_assert((offsetof(ACCarState,performanceMeter)==0x124),"bad off");
		static_assert((offsetof(ACCarState,isGearGrinding)==0x128),"bad off");
		static_assert((offsetof(ACCarState,damageZoneLevel)==0x12C),"bad off");
		static_assert((offsetof(ACCarState,limiterRPM)==0x140),"bad off");
		static_assert((offsetof(ACCarState,speedMS)==0x144),"bad off");
	};
};

//UDT: struct ServerDrivingAssists @len=12
	//_Data: this+0x0, Member, Type: int, tc
	//_Data: this+0x4, Member, Type: int, abs
	//_Data: this+0x8, Member, Type: bool, stability
	//_Data: this+0x9, Member, Type: bool, autoClutch
	//_Func: public void ServerDrivingAssists(); @loc=optimized @len=0 @rva=0
//UDT;

struct ServerDrivingAssists {
public:
	int tc;
	int abs;
	bool stability;
	bool autoClutch;
	inline ServerDrivingAssists() { }
	inline ServerDrivingAssists(const ServerDrivingAssists& other) = default;
	inline ServerDrivingAssists& operator=(const ServerDrivingAssists& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(ServerDrivingAssists)==12),"bad size");
		static_assert((offsetof(ServerDrivingAssists,tc)==0x0),"bad off");
		static_assert((offsetof(ServerDrivingAssists,abs)==0x4),"bad off");
		static_assert((offsetof(ServerDrivingAssists,stability)==0x8),"bad off");
		static_assert((offsetof(ServerDrivingAssists,autoClutch)==0x9),"bad off");
	};
};

//UDT: struct DRSZone @len=12
	//_Data: this+0x0, Member, Type: float, detection
	//_Data: this+0x4, Member, Type: float, start
	//_Data: this+0x8, Member, Type: float, end
	//_Func: public void DRSZone(); @loc=optimized @len=0 @rva=0
//UDT;

struct DRSZone {
public:
	float detection;
	float start;
	float end;
	inline DRSZone() { }
	inline DRSZone(const DRSZone& other) = default;
	inline DRSZone& operator=(const DRSZone& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(DRSZone)==12),"bad size");
		static_assert((offsetof(DRSZone,detection)==0x0),"bad off");
		static_assert((offsetof(DRSZone,start)==0x4),"bad off");
		static_assert((offsetof(DRSZone,end)==0x8),"bad off");
	};
};

//UDT: struct FFUpgrades @len=16
	//_Data: this+0x0, Member, Type: float, curbsGain
	//_Data: this+0x4, Member, Type: float, gforceGain
	//_Data: this+0x8, Member, Type: float, slipsGain
	//_Data: this+0xC, Member, Type: float, absGain
	//_Func: public void FFUpgrades(); @loc=optimized @len=0 @rva=0
//UDT;

struct FFUpgrades {
public:
	float curbsGain;
	float gforceGain;
	float slipsGain;
	float absGain;
	inline FFUpgrades() { }
	inline FFUpgrades(const FFUpgrades& other) = default;
	inline FFUpgrades& operator=(const FFUpgrades& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(FFUpgrades)==16),"bad size");
		static_assert((offsetof(FFUpgrades,curbsGain)==0x0),"bad off");
		static_assert((offsetof(FFUpgrades,gforceGain)==0x4),"bad off");
		static_assert((offsetof(FFUpgrades,slipsGain)==0x8),"bad off");
		static_assert((offsetof(FFUpgrades,absGain)==0xC),"bad off");
	};
};

//UDT: struct PitStopTime @len=16
	//_Data: this+0x0, Member, Type: float, total
	//_Data: this+0x4, Member, Type: float, tyres
	//_Data: this+0x8, Member, Type: float, repair
	//_Data: this+0xC, Member, Type: float, fuel
	//_Func: public void PitStopTime(); @loc=optimized @len=0 @rva=0
//UDT;

struct PitStopTime {
public:
	float total;
	float tyres;
	float repair;
	float fuel;
	inline PitStopTime() { }
	inline PitStopTime(const PitStopTime& other) = default;
	inline PitStopTime& operator=(const PitStopTime& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(PitStopTime)==16),"bad size");
		static_assert((offsetof(PitStopTime,total)==0x0),"bad off");
		static_assert((offsetof(PitStopTime,tyres)==0x4),"bad off");
		static_assert((offsetof(PitStopTime,repair)==0x8),"bad off");
		static_assert((offsetof(PitStopTime,fuel)==0xC),"bad off");
	};
};

//UDT: struct TyreInputs @len=12
	//_Func: public void TyreInputs(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: float, brakeTorque
	//_Data: this+0x4, Member, Type: float, handBrakeTorque
	//_Data: this+0x8, Member, Type: float, electricTorque
//UDT;

struct TyreInputs {
public:
	float brakeTorque;
	float handBrakeTorque;
	float electricTorque;
	inline TyreInputs() { }
	inline TyreInputs(const TyreInputs& other) = default;
	inline TyreInputs& operator=(const TyreInputs& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(TyreInputs)==12),"bad size");
		static_assert((offsetof(TyreInputs,brakeTorque)==0x0),"bad off");
		static_assert((offsetof(TyreInputs,handBrakeTorque)==0x4),"bad off");
		static_assert((offsetof(TyreInputs,electricTorque)==0x8),"bad off");
	};
};

//UDT: struct TyreExternalInputs @len=16
	//_Data: this+0x0, Member, Type: bool, isActive
	//_Data: this+0x4, Member, Type: float, load
	//_Data: this+0x8, Member, Type: float, slipAngle
	//_Data: this+0xC, Member, Type: float, slipRatio
	//_Func: public void TyreExternalInputs(); @loc=optimized @len=0 @rva=0
//UDT;

struct TyreExternalInputs {
public:
	bool isActive;
	float load;
	float slipAngle;
	float slipRatio;
	inline TyreExternalInputs() { }
	inline TyreExternalInputs(const TyreExternalInputs& other) = default;
	inline TyreExternalInputs& operator=(const TyreExternalInputs& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(TyreExternalInputs)==16),"bad size");
		static_assert((offsetof(TyreExternalInputs,isActive)==0x0),"bad off");
		static_assert((offsetof(TyreExternalInputs,load)==0x4),"bad off");
		static_assert((offsetof(TyreExternalInputs,slipAngle)==0x8),"bad off");
		static_assert((offsetof(TyreExternalInputs,slipRatio)==0xC),"bad off");
	};
};

//UDT: class KGLVertexBuffer @len=16
	//_Func: public void KGLVertexBuffer(ID3D11Device * device, unsigned int size, unsigned int stride, void * data, bool isDynamic); @loc=static @len=239 @rva=146752
	//_Func: public void ~KGLVertexBuffer(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: struct ID3D11Buffer *, buffer
	//_Data: this+0x8, Member, Type: unsigned int, stride
	//_Func: public void map(void * data, unsigned int size, ID3D11DeviceContext * context); @loc=static @len=129 @rva=146992
	//_Func: public void mapNoOverWrite(void * data, unsigned int offset, unsigned int size, ID3D11DeviceContext * context); @loc=static @len=146 @rva=147136
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class KGLVertexBuffer {
public:
	ID3D11Buffer * buffer;
	unsigned int stride;
	inline KGLVertexBuffer() { }
	inline KGLVertexBuffer(const KGLVertexBuffer& other) = default;
	inline KGLVertexBuffer& operator=(const KGLVertexBuffer& other) = default;
	inline void ctor(ID3D11Device * device, unsigned int size, unsigned int stride, void * data, bool isDynamic) { typedef void (KGLVertexBuffer::*_fpt)(ID3D11Device *, unsigned int, unsigned int, void *, bool); auto _f=xcast<_fpt>(_drva(146752)); (this->*_f)(device, size, stride, data, isDynamic); }
	inline void map(void * data, unsigned int size, ID3D11DeviceContext * context) { typedef void (KGLVertexBuffer::*_fpt)(void *, unsigned int, ID3D11DeviceContext *); auto _f=xcast<_fpt>(_drva(146992)); return (this->*_f)(data, size, context); }
	inline void mapNoOverWrite(void * data, unsigned int offset, unsigned int size, ID3D11DeviceContext * context) { typedef void (KGLVertexBuffer::*_fpt)(void *, unsigned int, unsigned int, ID3D11DeviceContext *); auto _f=xcast<_fpt>(_drva(147136)); return (this->*_f)(data, offset, size, context); }
	inline void _guard_obj() {
		static_assert((sizeof(KGLVertexBuffer)==16),"bad size");
		static_assert((offsetof(KGLVertexBuffer,buffer)==0x0),"bad off");
		static_assert((offsetof(KGLVertexBuffer,stride)==0x8),"bad off");
	};
};

//UDT: struct TyreModelOutput @len=28
	//_Data: this+0x0, Member, Type: float, Fy
	//_Data: this+0x4, Member, Type: float, Fx
	//_Data: this+0x8, Member, Type: float, Mz
	//_Data: this+0xC, Member, Type: float, trail
	//_Data: this+0x10, Member, Type: float, ndSlip
	//_Data: this+0x14, Member, Type: float, Dy
	//_Data: this+0x18, Member, Type: float, Dx
//UDT;

struct TyreModelOutput {
public:
	float Fy;
	float Fx;
	float Mz;
	float trail;
	float ndSlip;
	float Dy;
	float Dx;
	inline TyreModelOutput() { }
	inline TyreModelOutput(const TyreModelOutput& other) = default;
	inline TyreModelOutput& operator=(const TyreModelOutput& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(TyreModelOutput)==28),"bad size");
		static_assert((offsetof(TyreModelOutput,Fy)==0x0),"bad off");
		static_assert((offsetof(TyreModelOutput,Fx)==0x4),"bad off");
		static_assert((offsetof(TyreModelOutput,Mz)==0x8),"bad off");
		static_assert((offsetof(TyreModelOutput,trail)==0xC),"bad off");
		static_assert((offsetof(TyreModelOutput,ndSlip)==0x10),"bad off");
		static_assert((offsetof(TyreModelOutput,Dy)==0x14),"bad off");
		static_assert((offsetof(TyreModelOutput,Dx)==0x18),"bad off");
	};
};

//UDT: struct AISplineHint @len=12
	//_Data: this+0x0, Member, Type: float, startPos
	//_Data: this+0x4, Member, Type: float, endPos
	//_Data: this+0x8, Member, Type: float, value
	//_Func: public void AISplineHint(); @loc=optimized @len=0 @rva=0
//UDT;

struct AISplineHint {
public:
	float startPos;
	float endPos;
	float value;
	inline AISplineHint() { }
	inline AISplineHint(const AISplineHint& other) = default;
	inline AISplineHint& operator=(const AISplineHint& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(AISplineHint)==12),"bad size");
		static_assert((offsetof(AISplineHint,startPos)==0x0),"bad off");
		static_assert((offsetof(AISplineHint,endPos)==0x4),"bad off");
		static_assert((offsetof(AISplineHint,value)==0x8),"bad off");
	};
};

//UDT: struct SCarStateAero @len=12
	//_Func: public void SCarStateAero(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: float, CD
	//_Data: this+0x4, Member, Type: float, CL_Front
	//_Data: this+0x8, Member, Type: float, CL_Rear
//UDT;

struct SCarStateAero {
public:
	float CD;
	float CL_Front;
	float CL_Rear;
	inline SCarStateAero() { }
	inline SCarStateAero(const SCarStateAero& other) = default;
	inline SCarStateAero& operator=(const SCarStateAero& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(SCarStateAero)==12),"bad size");
		static_assert((offsetof(SCarStateAero,CD)==0x0),"bad off");
		static_assert((offsetof(SCarStateAero,CL_Front)==0x4),"bad off");
		static_assert((offsetof(SCarStateAero,CL_Rear)==0x8),"bad off");
	};
};

//UDT: class SignalGenerator @len=16 @vfcount=3
	//_VTable: 
	//_Func: public void SignalGenerator(const SignalGenerator &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void SignalGenerator(); @loc=static @len=22 @rva=2282048
	//_Func: public void ~SignalGenerator(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=11 @rva=2282080
	//_Data: this+0x8, Member, Type: float, freqScale
	//_Func: public void step(float dt); @intro @virtual vtpo=0 vfid=1 @loc=static @len=21 @rva=2282240
	//_Func: public float getValue(); @intro @pure @virtual vtpo=0 vfid=2 @loc=optimized @len=0 @rva=0
	//_Data: this+0xC, Member, Type: int, value
	//_Func: public SignalGenerator & operator=(const SignalGenerator &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class SignalGenerator {
public:
	float freqScale;
	int value;
	inline SignalGenerator() { }
	inline SignalGenerator(const SignalGenerator& other) = default;
	inline SignalGenerator& operator=(const SignalGenerator& other) = default;
	inline void ctor() { typedef void (SignalGenerator::*_fpt)(); auto _f=xcast<_fpt>(_drva(2282048)); (this->*_f)(); }
	virtual ~SignalGenerator();
	inline void dtor() { typedef void (SignalGenerator::*_fpt)(); auto _f=xcast<_fpt>(_drva(2282080)); (this->*_f)(); }
	virtual void step_vf1(float dt);
	inline void step_impl(float dt) { typedef void (SignalGenerator::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2282240)); return (this->*_f)(dt); }
	inline void step(float dt) { typedef void (SignalGenerator::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(dt); }
	virtual float getValue_vf2() = 0;
	inline float getValue() { typedef float (SignalGenerator::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(SignalGenerator)==16),"bad size");
		static_assert((offsetof(SignalGenerator,freqScale)==0x8),"bad off");
		static_assert((offsetof(SignalGenerator,value)==0xC),"bad off");
	};
};

//UDT: struct CoastSettings @len=8
	//_Data: this+0x0, Member, Type: float, coast1
	//_Data: this+0x4, Member, Type: float, coast2
//UDT;

struct CoastSettings {
public:
	float coast1;
	float coast2;
	inline CoastSettings() { }
	inline CoastSettings(const CoastSettings& other) = default;
	inline CoastSettings& operator=(const CoastSettings& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(CoastSettings)==8),"bad size");
		static_assert((offsetof(CoastSettings,coast1)==0x0),"bad off");
		static_assert((offsetof(CoastSettings,coast2)==0x4),"bad off");
	};
};

//UDT: struct TurboDef @len=28
	//_Func: public void TurboDef(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: float, maxBoost
	//_Data: this+0x4, Member, Type: float, lagUP
	//_Data: this+0x8, Member, Type: float, lagDN
	//_Data: this+0xC, Member, Type: float, rpmRef
	//_Data: this+0x10, Member, Type: float, gamma
	//_Data: this+0x14, Member, Type: float, wastegate
	//_Data: this+0x18, Member, Type: bool, isAdjustable
//UDT;

struct TurboDef {
public:
	float maxBoost;
	float lagUP;
	float lagDN;
	float rpmRef;
	float gamma;
	float wastegate;
	bool isAdjustable;
	inline TurboDef() { }
	inline TurboDef(const TurboDef& other) = default;
	inline TurboDef& operator=(const TurboDef& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(TurboDef)==28),"bad size");
		static_assert((offsetof(TurboDef,maxBoost)==0x0),"bad off");
		static_assert((offsetof(TurboDef,lagUP)==0x4),"bad off");
		static_assert((offsetof(TurboDef,lagDN)==0x8),"bad off");
		static_assert((offsetof(TurboDef,rpmRef)==0xC),"bad off");
		static_assert((offsetof(TurboDef,gamma)==0x10),"bad off");
		static_assert((offsetof(TurboDef,wastegate)==0x14),"bad off");
		static_assert((offsetof(TurboDef,isAdjustable)==0x18),"bad off");
	};
};

//UDT: struct ClientRules @len=4
	//_Data: this+0x0, Member, Type: float, maxMetersWrongWay
	//_Func: public void ClientRules(); @loc=optimized @len=0 @rva=0
//UDT;

struct ClientRules {
public:
	float maxMetersWrongWay;
	inline ClientRules() { }
	inline ClientRules(const ClientRules& other) = default;
	inline ClientRules& operator=(const ClientRules& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(ClientRules)==4),"bad size");
		static_assert((offsetof(ClientRules,maxMetersWrongWay)==0x0),"bad off");
	};
};

//UDT: struct OnWindowResize @len=8
	//_Data: this+0x0, Member, Type: int, width
	//_Data: this+0x4, Member, Type: int, height
//UDT;

struct OnWindowResize {
public:
	int width;
	int height;
	inline OnWindowResize() { }
	inline OnWindowResize(const OnWindowResize& other) = default;
	inline OnWindowResize& operator=(const OnWindowResize& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(OnWindowResize)==8),"bad size");
		static_assert((offsetof(OnWindowResize,width)==0x0),"bad off");
		static_assert((offsetof(OnWindowResize,height)==0x4),"bad off");
	};
};

//UDT: struct Axis @len=16
	//_Func: public void Axis(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: int, joy
	//_Data: this+0x4, Member, Type: int, index
	//_Data: this+0x8, Member, Type: float, minv
	//_Data: this+0xC, Member, Type: float, maxv
//UDT;

struct Axis {
public:
	int joy;
	int index;
	float minv;
	float maxv;
	inline Axis() { }
	inline Axis(const Axis& other) = default;
	inline Axis& operator=(const Axis& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(Axis)==16),"bad size");
		static_assert((offsetof(Axis,joy)==0x0),"bad off");
		static_assert((offsetof(Axis,index)==0x4),"bad off");
		static_assert((offsetof(Axis,minv)==0x8),"bad off");
		static_assert((offsetof(Axis,maxv)==0xC),"bad off");
	};
};

//UDT: struct VibrationDef @len=20
	//_Data: this+0x0, Member, Type: float, curbs
	//_Data: this+0x4, Member, Type: float, gforce
	//_Data: this+0x8, Member, Type: float, slips
	//_Data: this+0xC, Member, Type: float, engine
	//_Data: this+0x10, Member, Type: float, abs
	//_Func: public void VibrationDef(); @loc=optimized @len=0 @rva=0
//UDT;

struct VibrationDef {
public:
	float curbs;
	float gforce;
	float slips;
	float engine;
	float abs;
	inline VibrationDef() { }
	inline VibrationDef(const VibrationDef& other) = default;
	inline VibrationDef& operator=(const VibrationDef& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(VibrationDef)==20),"bad size");
		static_assert((offsetof(VibrationDef,curbs)==0x0),"bad off");
		static_assert((offsetof(VibrationDef,gforce)==0x4),"bad off");
		static_assert((offsetof(VibrationDef,slips)==0x8),"bad off");
		static_assert((offsetof(VibrationDef,engine)==0xC),"bad off");
		static_assert((offsetof(VibrationDef,abs)==0x10),"bad off");
	};
};

//UDT: struct DamageReportDef @len=32
	//_Func: public void DamageReportDef(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: double, lastSendTime
	//_Data: this+0x8, Member, Type: float[0x5], damageZoneLevel
//UDT;

struct DamageReportDef {
public:
	double lastSendTime;
	float damageZoneLevel[5];
	inline DamageReportDef() { }
	inline DamageReportDef(const DamageReportDef& other) = default;
	inline DamageReportDef& operator=(const DamageReportDef& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(DamageReportDef)==32),"bad size");
		static_assert((offsetof(DamageReportDef,lastSendTime)==0x0),"bad off");
		static_assert((offsetof(DamageReportDef,damageZoneLevel)==0x8),"bad off");
	};
};

//UDT: struct TyreThermalState @len=192
	//_Data: this+0x0, Member, Type: float[0x3][0xC], temps
	//_Data: this+0x90, Member, Type: float, coreTemp
	//_Data: this+0x94, Member, Type: float, thermalInput
	//_Data: this+0x98, Member, Type: float, dynamicPressure
	//_Data: this+0x9C, Member, Type: float, staticPressure
	//_Data: this+0xA0, Member, Type: float[0x3], lastSetIMO
	//_Data: this+0xAC, Member, Type: float, cpTemperature
	//_Data: this+0xB0, Member, Type: float, lastGrain
	//_Data: this+0xB4, Member, Type: float, lastBlister
	//_Data: this+0xB8, Member, Type: float, mult
	//_Data: this+0xBC, Member, Type: bool, isHot
	//_Func: public void TyreThermalState(); @loc=optimized @len=0 @rva=0
//UDT;

struct TyreThermalState {
public:
	float temps[3][12];
	float coreTemp;
	float thermalInput;
	float dynamicPressure;
	float staticPressure;
	float lastSetIMO[3];
	float cpTemperature;
	float lastGrain;
	float lastBlister;
	float mult;
	bool isHot;
	inline TyreThermalState() { }
	inline TyreThermalState(const TyreThermalState& other) = default;
	inline TyreThermalState& operator=(const TyreThermalState& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(TyreThermalState)==192),"bad size");
		static_assert((offsetof(TyreThermalState,temps)==0x0),"bad off");
		static_assert((offsetof(TyreThermalState,coreTemp)==0x90),"bad off");
		static_assert((offsetof(TyreThermalState,thermalInput)==0x94),"bad off");
		static_assert((offsetof(TyreThermalState,dynamicPressure)==0x98),"bad off");
		static_assert((offsetof(TyreThermalState,staticPressure)==0x9C),"bad off");
		static_assert((offsetof(TyreThermalState,lastSetIMO)==0xA0),"bad off");
		static_assert((offsetof(TyreThermalState,cpTemperature)==0xAC),"bad off");
		static_assert((offsetof(TyreThermalState,lastGrain)==0xB0),"bad off");
		static_assert((offsetof(TyreThermalState,lastBlister)==0xB4),"bad off");
		static_assert((offsetof(TyreThermalState,mult)==0xB8),"bad off");
		static_assert((offsetof(TyreThermalState,isHot)==0xBC),"bad off");
	};
};

//UDT: struct PushToPass @len=40
	//_Data: this+0x0, Member, Type: bool, enabled
	//_Data: this+0x1, Member, Type: bool, active
	//_Data: this+0x4, Member, Type: float, overboost
	//_Data: this+0x8, Member, Type: float, timeS
	//_Data: this+0xC, Member, Type: float, coolDownS
	//_Data: this+0x10, Member, Type: float, timeAccum
	//_Data: this+0x14, Member, Type: int, activations
	//_Data: this+0x18, Member, Type: float, baseWastegate
	//_Data: this+0x1C, Member, Type: int, baseActivations
	//_Data: this+0x20, Member, Type: int, basePositionCoeff
	//_Data: this+0x24, Member, Type: int, maxActivations
	//_Func: public void PushToPass(); @loc=optimized @len=0 @rva=0
//UDT;

struct PushToPass {
public:
	bool enabled;
	bool active;
	float overboost;
	float timeS;
	float coolDownS;
	float timeAccum;
	int activations;
	float baseWastegate;
	int baseActivations;
	int basePositionCoeff;
	int maxActivations;
	inline PushToPass() { }
	inline PushToPass(const PushToPass& other) = default;
	inline PushToPass& operator=(const PushToPass& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(PushToPass)==40),"bad size");
		static_assert((offsetof(PushToPass,enabled)==0x0),"bad off");
		static_assert((offsetof(PushToPass,active)==0x1),"bad off");
		static_assert((offsetof(PushToPass,overboost)==0x4),"bad off");
		static_assert((offsetof(PushToPass,timeS)==0x8),"bad off");
		static_assert((offsetof(PushToPass,coolDownS)==0xC),"bad off");
		static_assert((offsetof(PushToPass,timeAccum)==0x10),"bad off");
		static_assert((offsetof(PushToPass,activations)==0x14),"bad off");
		static_assert((offsetof(PushToPass,baseWastegate)==0x18),"bad off");
		static_assert((offsetof(PushToPass,baseActivations)==0x1C),"bad off");
		static_assert((offsetof(PushToPass,basePositionCoeff)==0x20),"bad off");
		static_assert((offsetof(PushToPass,maxActivations)==0x24),"bad off");
	};
};

//UDT: struct SACEngineInput @len=16
	//_Data: this+0x0, Member, Type: float, gasInput
	//_Data: this+0x4, Member, Type: float, carSpeed
	//_Data: this+0x8, Member, Type: float, altitude
	//_Data: this+0xC, Member, Type: float, rpm
	//_Func: public void SACEngineInput(); @loc=optimized @len=0 @rva=0
//UDT;

struct SACEngineInput {
public:
	float gasInput;
	float carSpeed;
	float altitude;
	float rpm;
	inline SACEngineInput() { }
	inline SACEngineInput(const SACEngineInput& other) = default;
	inline SACEngineInput& operator=(const SACEngineInput& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(SACEngineInput)==16),"bad size");
		static_assert((offsetof(SACEngineInput,gasInput)==0x0),"bad off");
		static_assert((offsetof(SACEngineInput,carSpeed)==0x4),"bad off");
		static_assert((offsetof(SACEngineInput,altitude)==0x8),"bad off");
		static_assert((offsetof(SACEngineInput,rpm)==0xC),"bad off");
	};
};

//UDT: struct DownshiftProtection @len=12
	//_Data: this+0x0, Member, Type: bool, isActive
	//_Data: this+0x1, Member, Type: bool, isDebug
	//_Data: this+0x4, Member, Type: int, overrev
	//_Data: this+0x8, Member, Type: bool, lockN
	//_Func: public void DownshiftProtection(); @loc=optimized @len=0 @rva=0
//UDT;

struct DownshiftProtection {
public:
	bool isActive;
	bool isDebug;
	int overrev;
	bool lockN;
	inline DownshiftProtection() { }
	inline DownshiftProtection(const DownshiftProtection& other) = default;
	inline DownshiftProtection& operator=(const DownshiftProtection& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(DownshiftProtection)==12),"bad size");
		static_assert((offsetof(DownshiftProtection,isActive)==0x0),"bad off");
		static_assert((offsetof(DownshiftProtection,isDebug)==0x1),"bad off");
		static_assert((offsetof(DownshiftProtection,overrev)==0x4),"bad off");
		static_assert((offsetof(DownshiftProtection,lockN)==0x8),"bad off");
	};
};

//UDT: struct EngineStatus @len=24
	//_Data: this+0x0, Member, Type: double, outTorque
	//_Data: this+0x8, Member, Type: double, externalCoastTorque
	//_Data: this+0x10, Member, Type: float, turboBoost
	//_Data: this+0x14, Member, Type: bool, isLimiterOn
	//_Func: public void EngineStatus(); @loc=optimized @len=0 @rva=0
//UDT;

struct EngineStatus {
public:
	double outTorque;
	double externalCoastTorque;
	float turboBoost;
	bool isLimiterOn;
	inline EngineStatus() { }
	inline EngineStatus(const EngineStatus& other) = default;
	inline EngineStatus& operator=(const EngineStatus& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(EngineStatus)==24),"bad size");
		static_assert((offsetof(EngineStatus,outTorque)==0x0),"bad off");
		static_assert((offsetof(EngineStatus,externalCoastTorque)==0x8),"bad off");
		static_assert((offsetof(EngineStatus,turboBoost)==0x10),"bad off");
		static_assert((offsetof(EngineStatus,isLimiterOn)==0x14),"bad off");
	};
};

//UDT: struct HeaveSpringStatus @len=4
	//_Func: public void HeaveSpringStatus(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: float, travel
//UDT;

struct HeaveSpringStatus {
public:
	float travel;
	inline HeaveSpringStatus() { }
	inline HeaveSpringStatus(const HeaveSpringStatus& other) = default;
	inline HeaveSpringStatus& operator=(const HeaveSpringStatus& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(HeaveSpringStatus)==4),"bad size");
		static_assert((offsetof(HeaveSpringStatus,travel)==0x0),"bad off");
	};
};

//UDT: class CarControls @len=52
	//_Func: public void CarControls(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: bool, gearUp
	//_Data: this+0x1, Member, Type: bool, gearDn
	//_Data: this+0x2, Member, Type: bool, drs
	//_Data: this+0x3, Member, Type: bool, kers
	//_Data: this+0x4, Member, Type: bool, brakeBalanceUp
	//_Data: this+0x5, Member, Type: bool, brakeBalanceDn
	//_Data: this+0x8, Member, Type: int, requestedGearIndex
	//_Data: this+0xC, Member, Type: bool, isShifterSupported
	//_Data: this+0x10, Member, Type: float, handBrake
	//_Data: this+0x14, Member, Type: bool, absUp
	//_Data: this+0x15, Member, Type: bool, absDn
	//_Data: this+0x16, Member, Type: bool, tcUp
	//_Data: this+0x17, Member, Type: bool, tcDn
	//_Data: this+0x18, Member, Type: bool, turboUp
	//_Data: this+0x19, Member, Type: bool, turboDn
	//_Data: this+0x1A, Member, Type: bool, engineBrakeUp
	//_Data: this+0x1B, Member, Type: bool, engineBrakeDn
	//_Data: this+0x1C, Member, Type: bool, MGUKDeliveryUp
	//_Data: this+0x1D, Member, Type: bool, MGUKDeliveryDn
	//_Data: this+0x1E, Member, Type: bool, MGUKRecoveryUp
	//_Data: this+0x1F, Member, Type: bool, MGUKRecoveryDn
	//_Data: this+0x20, Member, Type: bool, MGUHMode
	//_Func: public void setSteer(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public float getSteer(); @loc=optimized @len=0 @rva=0
	//_Func: public void setGas(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public float getGas(); @loc=optimized @len=0 @rva=0
	//_Func: public void setBrake(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public float getBrake(); @loc=optimized @len=0 @rva=0
	//_Func: public void setClutch(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public float getClutch(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x24, Member, Type: float, gas
	//_Data: this+0x28, Member, Type: float, brake
	//_Data: this+0x2C, Member, Type: float, steer
	//_Data: this+0x30, Member, Type: float, clutch
//UDT;

class CarControls {
public:
	bool gearUp;
	bool gearDn;
	bool drs;
	bool kers;
	bool brakeBalanceUp;
	bool brakeBalanceDn;
	int requestedGearIndex;
	bool isShifterSupported;
	float handBrake;
	bool absUp;
	bool absDn;
	bool tcUp;
	bool tcDn;
	bool turboUp;
	bool turboDn;
	bool engineBrakeUp;
	bool engineBrakeDn;
	bool MGUKDeliveryUp;
	bool MGUKDeliveryDn;
	bool MGUKRecoveryUp;
	bool MGUKRecoveryDn;
	bool MGUHMode;
	float gas;
	float brake;
	float steer;
	float clutch;
	inline CarControls() { }
	inline CarControls(const CarControls& other) = default;
	inline CarControls& operator=(const CarControls& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(CarControls)==52),"bad size");
		static_assert((offsetof(CarControls,gearUp)==0x0),"bad off");
		static_assert((offsetof(CarControls,gearDn)==0x1),"bad off");
		static_assert((offsetof(CarControls,drs)==0x2),"bad off");
		static_assert((offsetof(CarControls,kers)==0x3),"bad off");
		static_assert((offsetof(CarControls,brakeBalanceUp)==0x4),"bad off");
		static_assert((offsetof(CarControls,brakeBalanceDn)==0x5),"bad off");
		static_assert((offsetof(CarControls,requestedGearIndex)==0x8),"bad off");
		static_assert((offsetof(CarControls,isShifterSupported)==0xC),"bad off");
		static_assert((offsetof(CarControls,handBrake)==0x10),"bad off");
		static_assert((offsetof(CarControls,absUp)==0x14),"bad off");
		static_assert((offsetof(CarControls,absDn)==0x15),"bad off");
		static_assert((offsetof(CarControls,tcUp)==0x16),"bad off");
		static_assert((offsetof(CarControls,tcDn)==0x17),"bad off");
		static_assert((offsetof(CarControls,turboUp)==0x18),"bad off");
		static_assert((offsetof(CarControls,turboDn)==0x19),"bad off");
		static_assert((offsetof(CarControls,engineBrakeUp)==0x1A),"bad off");
		static_assert((offsetof(CarControls,engineBrakeDn)==0x1B),"bad off");
		static_assert((offsetof(CarControls,MGUKDeliveryUp)==0x1C),"bad off");
		static_assert((offsetof(CarControls,MGUKDeliveryDn)==0x1D),"bad off");
		static_assert((offsetof(CarControls,MGUKRecoveryUp)==0x1E),"bad off");
		static_assert((offsetof(CarControls,MGUKRecoveryDn)==0x1F),"bad off");
		static_assert((offsetof(CarControls,MGUHMode)==0x20),"bad off");
		static_assert((offsetof(CarControls,gas)==0x24),"bad off");
		static_assert((offsetof(CarControls,brake)==0x28),"bad off");
		static_assert((offsetof(CarControls,steer)==0x2C),"bad off");
		static_assert((offsetof(CarControls,clutch)==0x30),"bad off");
	};
};

//UDT: struct BrushOutput @len=8
	//_Func: public void BrushOutput(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: float, force
	//_Data: this+0x4, Member, Type: float, slip
//UDT;

struct BrushOutput {
public:
	float force;
	float slip;
	inline BrushOutput() { }
	inline BrushOutput(const BrushOutput& other) = default;
	inline BrushOutput& operator=(const BrushOutput& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(BrushOutput)==8),"bad size");
		static_assert((offsetof(BrushOutput,force)==0x0),"bad off");
		static_assert((offsetof(BrushOutput,slip)==0x4),"bad off");
	};
};

//UDT: struct ERSStatus @len=8
	//_Data: this+0x0, Member, Type: float, kineticRecovery
	//_Data: this+0x4, Member, Type: float, heatRecovery
	//_Func: public void ERSStatus(); @loc=optimized @len=0 @rva=0
//UDT;

struct ERSStatus {
public:
	float kineticRecovery;
	float heatRecovery;
	inline ERSStatus() { }
	inline ERSStatus(const ERSStatus& other) = default;
	inline ERSStatus& operator=(const ERSStatus& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(ERSStatus)==8),"bad size");
		static_assert((offsetof(ERSStatus,kineticRecovery)==0x0),"bad off");
		static_assert((offsetof(ERSStatus,heatRecovery)==0x4),"bad off");
	};
};

//UDT: class Damper @len=24
	//_Func: public void Damper(); @loc=static @len=45 @rva=2830928
	//_Func: public void ~Damper(); @loc=static @len=3 @rva=96368
	//_Data: this+0x0, Member, Type: float, reboundSlow
	//_Data: this+0x4, Member, Type: float, reboundFast
	//_Data: this+0x8, Member, Type: float, bumpSlow
	//_Data: this+0xC, Member, Type: float, bumpFast
	//_Data: this+0x10, Member, Type: float, fastThresholdBump
	//_Data: this+0x14, Member, Type: float, fastThresholdRebound
	//_Func: public float getForce(float v); @loc=static @len=119 @rva=2830976
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class Damper {
public:
	float reboundSlow;
	float reboundFast;
	float bumpSlow;
	float bumpFast;
	float fastThresholdBump;
	float fastThresholdRebound;
	inline Damper() { }
	inline Damper(const Damper& other) = default;
	inline Damper& operator=(const Damper& other) = default;
	inline void ctor() { typedef void (Damper::*_fpt)(); auto _f=xcast<_fpt>(_drva(2830928)); (this->*_f)(); }
	inline void dtor() { typedef void (Damper::*_fpt)(); auto _f=xcast<_fpt>(_drva(96368)); (this->*_f)(); }
	inline float getForce(float v) { typedef float (Damper::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2830976)); return (this->*_f)(v); }
	inline void _guard_obj() {
		static_assert((sizeof(Damper)==24),"bad size");
		static_assert((offsetof(Damper,reboundSlow)==0x0),"bad off");
		static_assert((offsetof(Damper,reboundFast)==0x4),"bad off");
		static_assert((offsetof(Damper,bumpSlow)==0x8),"bad off");
		static_assert((offsetof(Damper,bumpFast)==0xC),"bad off");
		static_assert((offsetof(Damper,fastThresholdBump)==0x10),"bad off");
		static_assert((offsetof(Damper,fastThresholdRebound)==0x14),"bad off");
	};
};

//UDT: struct WingOverrideDef @len=8
	//_Data: this+0x0, Member, Type: float, overrideAngle
	//_Data: this+0x4, Member, Type: bool, isActive
	//_Func: public void WingOverrideDef(); @loc=optimized @len=0 @rva=0
//UDT;

struct WingOverrideDef {
public:
	float overrideAngle;
	bool isActive;
	inline WingOverrideDef() { }
	inline WingOverrideDef(const WingOverrideDef& other) = default;
	inline WingOverrideDef& operator=(const WingOverrideDef& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(WingOverrideDef)==8),"bad size");
		static_assert((offsetof(WingOverrideDef,overrideAngle)==0x0),"bad off");
		static_assert((offsetof(WingOverrideDef,isActive)==0x4),"bad off");
	};
};

//UDT: struct NetCarStateProvider::LagDebug @len=24
	//_Data: this+0x0, Member, Type: double, rcvTime
	//_Data: this+0x8, Member, Type: double, physicsTime
	//_Data: this+0x10, Member, Type: bool, wasLagging
	//_Func: public void LagDebug(); @loc=optimized @len=0 @rva=0
//UDT;

struct NetCarStateProvider_LagDebug {
public:
	double rcvTime;
	double physicsTime;
	bool wasLagging;
	inline NetCarStateProvider_LagDebug() { }
	inline NetCarStateProvider_LagDebug(const NetCarStateProvider_LagDebug& other) = default;
	inline NetCarStateProvider_LagDebug& operator=(const NetCarStateProvider_LagDebug& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(NetCarStateProvider_LagDebug)==24),"bad size");
		static_assert((offsetof(NetCarStateProvider_LagDebug,rcvTime)==0x0),"bad off");
		static_assert((offsetof(NetCarStateProvider_LagDebug,physicsTime)==0x8),"bad off");
		static_assert((offsetof(NetCarStateProvider_LagDebug,wasLagging)==0x10),"bad off");
	};
};

//UDT: struct SunPosition::Location @len=32
	//_Data: this+0x0, Member, Type: double, longitude
	//_Data: this+0x8, Member, Type: double, latitude
	//_Data: this+0x10, Member, Type: int, gmt
	//_Data: this+0x18, Member, Type: double, nordOffset
//UDT;

struct SunPosition_Location {
public:
	double longitude;
	double latitude;
	int gmt;
	double nordOffset;
	inline SunPosition_Location() { }
	inline SunPosition_Location(const SunPosition_Location& other) = default;
	inline SunPosition_Location& operator=(const SunPosition_Location& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(SunPosition_Location)==32),"bad size");
		static_assert((offsetof(SunPosition_Location,longitude)==0x0),"bad off");
		static_assert((offsetof(SunPosition_Location,latitude)==0x8),"bad off");
		static_assert((offsetof(SunPosition_Location,gmt)==0x10),"bad off");
		static_assert((offsetof(SunPosition_Location,nordOffset)==0x18),"bad off");
	};
};

//UDT: struct WheelValues @len=16
	//_Data: this+0x0, Member, Type: float, lf
	//_Data: this+0x4, Member, Type: float, rf
	//_Data: this+0x8, Member, Type: float, lr
	//_Data: this+0xC, Member, Type: float, rr
	//_Func: public void WheelValues(); @loc=optimized @len=0 @rva=0
//UDT;

struct WheelValues {
public:
	float lf;
	float rf;
	float lr;
	float rr;
	inline WheelValues() { }
	inline WheelValues(const WheelValues& other) = default;
	inline WheelValues& operator=(const WheelValues& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(WheelValues)==16),"bad size");
		static_assert((offsetof(WheelValues,lf)==0x0),"bad off");
		static_assert((offsetof(WheelValues,rf)==0x4),"bad off");
		static_assert((offsetof(WheelValues,lr)==0x8),"bad off");
		static_assert((offsetof(WheelValues,rr)==0xC),"bad off");
	};
};

//UDT: struct BrushTyreModelData @len=28
	//_Func: public void BrushTyreModelData(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: float, CF
	//_Data: this+0x4, Member, Type: float, xu
	//_Data: this+0x8, Member, Type: float, CF1
	//_Data: this+0xC, Member, Type: float, Fz0
	//_Data: this+0x10, Member, Type: float, maxSlip0
	//_Data: this+0x14, Member, Type: float, maxSlip1
	//_Data: this+0x18, Member, Type: float, falloffSpeed
//UDT;

struct BrushTyreModelData {
public:
	float CF;
	float xu;
	float CF1;
	float Fz0;
	float maxSlip0;
	float maxSlip1;
	float falloffSpeed;
	inline BrushTyreModelData() { }
	inline BrushTyreModelData(const BrushTyreModelData& other) = default;
	inline BrushTyreModelData& operator=(const BrushTyreModelData& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(BrushTyreModelData)==28),"bad size");
		static_assert((offsetof(BrushTyreModelData,CF)==0x0),"bad off");
		static_assert((offsetof(BrushTyreModelData,xu)==0x4),"bad off");
		static_assert((offsetof(BrushTyreModelData,CF1)==0x8),"bad off");
		static_assert((offsetof(BrushTyreModelData,Fz0)==0xC),"bad off");
		static_assert((offsetof(BrushTyreModelData,maxSlip0)==0x10),"bad off");
		static_assert((offsetof(BrushTyreModelData,maxSlip1)==0x14),"bad off");
		static_assert((offsetof(BrushTyreModelData,falloffSpeed)==0x18),"bad off");
	};
};

//UDT: struct TyreSlipOutput @len=8
	//_Data: this+0x0, Member, Type: float, normalizedForce
	//_Data: this+0x4, Member, Type: float, slip
//UDT;

struct TyreSlipOutput {
public:
	float normalizedForce;
	float slip;
	inline TyreSlipOutput() { }
	inline TyreSlipOutput(const TyreSlipOutput& other) = default;
	inline TyreSlipOutput& operator=(const TyreSlipOutput& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(TyreSlipOutput)==8),"bad size");
		static_assert((offsetof(TyreSlipOutput,normalizedForce)==0x0),"bad off");
		static_assert((offsetof(TyreSlipOutput,slip)==0x4),"bad off");
	};
};

//UDT: struct ChaseCamData @len=12
	//_Data: this+0x0, Member, Type: float, distance
	//_Data: this+0x4, Member, Type: float, height
	//_Data: this+0x8, Member, Type: float, pitchRAD
	//_Func: public void ChaseCamData(); @loc=optimized @len=0 @rva=0
//UDT;

struct ChaseCamData {
public:
	float distance;
	float height;
	float pitchRAD;
	inline ChaseCamData() { }
	inline ChaseCamData(const ChaseCamData& other) = default;
	inline ChaseCamData& operator=(const ChaseCamData& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(ChaseCamData)==12),"bad size");
		static_assert((offsetof(ChaseCamData,distance)==0x0),"bad off");
		static_assert((offsetof(ChaseCamData,height)==0x4),"bad off");
		static_assert((offsetof(ChaseCamData,pitchRAD)==0x8),"bad off");
	};
};

//UDT: struct DRSWingSetting @len=8
	//_Data: this+0x0, Member, Type: int, index
	//_Data: this+0x4, Member, Type: float, angle
//UDT;

struct DRSWingSetting {
public:
	int index;
	float angle;
	inline DRSWingSetting() { }
	inline DRSWingSetting(const DRSWingSetting& other) = default;
	inline DRSWingSetting& operator=(const DRSWingSetting& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(DRSWingSetting)==8),"bad size");
		static_assert((offsetof(DRSWingSetting,index)==0x0),"bad off");
		static_assert((offsetof(DRSWingSetting,angle)==0x4),"bad off");
	};
};

//UDT: struct OnKeyEvent @len=4
	//_Func: public void OnKeyEvent(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: unsigned int, keyCode
//UDT;

struct OnKeyEvent {
public:
	unsigned int keyCode;
	inline OnKeyEvent() { }
	inline OnKeyEvent(const OnKeyEvent& other) = default;
	inline OnKeyEvent& operator=(const OnKeyEvent& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(OnKeyEvent)==4),"bad size");
		static_assert((offsetof(OnKeyEvent,keyCode)==0x0),"bad off");
	};
};

//UDT: struct MouseEvent @len=12
	//_Func: public void MouseEvent(int  _arg0, int  _arg1); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: int, x
	//_Data: this+0x4, Member, Type: int, y
	//_Data: this+0x8, Member, Type: enum MouseButton, button
//UDT;

struct MouseEvent {
public:
	int x;
	int y;
	MouseButton button;
	inline MouseEvent() { }
	inline MouseEvent(const MouseEvent& other) = default;
	inline MouseEvent& operator=(const MouseEvent& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(MouseEvent)==12),"bad size");
		static_assert((offsetof(MouseEvent,x)==0x0),"bad off");
		static_assert((offsetof(MouseEvent,y)==0x4),"bad off");
		static_assert((offsetof(MouseEvent,button)==0x8),"bad off");
	};
};

//UDT: class vec4f @len=16
	//_Data: this+0x0, Member, Type: float, x
	//_Data: this+0x4, Member, Type: float, y
	//_Data: this+0x8, Member, Type: float, z
	//_Data: this+0xC, Member, Type: float, w
	//_Func: public void vec4f(const vec3f & v3, float vw); @loc=static @len=25 @rva=962960
	//_Func: public void vec4f(float *  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void vec4f(float ix, float iy, float iz, float iw); @loc=static @len=29 @rva=3178496
	//_Func: public void vec4f(); @loc=static @len=13 @rva=508768
	//_Func: public vec3f toVec3fLinear(); @loc=optimized @len=0 @rva=0
	//_Func: public float length(); @loc=optimized @len=0 @rva=0
//UDT;

class vec4f {
public:
	float x;
	float y;
	float z;
	float w;
	inline vec4f() { }
	inline vec4f(const vec4f& other) = default;
	inline vec4f& operator=(const vec4f& other) = default;
	inline void ctor(const vec3f & v3, float vw) { typedef void (vec4f::*_fpt)(const vec3f &, float); auto _f=xcast<_fpt>(_drva(962960)); (this->*_f)(v3, vw); }
	inline void ctor(float ix, float iy, float iz, float iw) { typedef void (vec4f::*_fpt)(float, float, float, float); auto _f=xcast<_fpt>(_drva(3178496)); (this->*_f)(ix, iy, iz, iw); }
	inline void ctor() { typedef void (vec4f::*_fpt)(); auto _f=xcast<_fpt>(_drva(508768)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(vec4f)==16),"bad size");
		static_assert((offsetof(vec4f,x)==0x0),"bad off");
		static_assert((offsetof(vec4f,y)==0x4),"bad off");
		static_assert((offsetof(vec4f,z)==0x8),"bad off");
		static_assert((offsetof(vec4f,w)==0xC),"bad off");
	};
};

//UDT: struct LeaderboardEntry @len=32
	//_Func: public void LeaderboardEntry(CarAvatar *  _arg0, double  _arg1, double  _arg2, int  _arg3, bool  _arg4, bool  _arg5, bool  _arg6); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: class CarAvatar *, car
	//_Data: this+0x8, Member, Type: double, totalTime
	//_Data: this+0x10, Member, Type: double, bestLap
	//_Data: this+0x18, Member, Type: int, laps
	//_Data: this+0x1C, Member, Type: bool, isRaceMode
	//_Data: this+0x1D, Member, Type: bool, isBlackFlagged
	//_Data: this+0x1E, Member, Type: bool, hasCompletedLastLap
	//_Func: public bool operator<(const LeaderboardEntry & l); @loc=static @len=338 @rva=1327408
//UDT;

struct LeaderboardEntry {
public:
	CarAvatar * car;
	double totalTime;
	double bestLap;
	int laps;
	bool isRaceMode;
	bool isBlackFlagged;
	bool hasCompletedLastLap;
	inline LeaderboardEntry() { }
	inline LeaderboardEntry(const LeaderboardEntry& other) = default;
	inline LeaderboardEntry& operator=(const LeaderboardEntry& other) = default;
	inline bool operator<(const LeaderboardEntry & l) { typedef bool (LeaderboardEntry::*_fpt)(const LeaderboardEntry &); auto _f=xcast<_fpt>(_drva(1327408)); return (this->*_f)(l); }
	inline void _guard_obj() {
		static_assert((sizeof(LeaderboardEntry)==32),"bad size");
		static_assert((offsetof(LeaderboardEntry,car)==0x0),"bad off");
		static_assert((offsetof(LeaderboardEntry,totalTime)==0x8),"bad off");
		static_assert((offsetof(LeaderboardEntry,bestLap)==0x10),"bad off");
		static_assert((offsetof(LeaderboardEntry,laps)==0x18),"bad off");
		static_assert((offsetof(LeaderboardEntry,isRaceMode)==0x1C),"bad off");
		static_assert((offsetof(LeaderboardEntry,isBlackFlagged)==0x1D),"bad off");
		static_assert((offsetof(LeaderboardEntry,hasCompletedLastLap)==0x1E),"bad off");
	};
};

//UDT: struct RaceStatusCarDesc @len=24
	//_Func: public void RaceStatusCarDesc(CarAvatar *  _arg0); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: class CarAvatar *, car
	//_Data: this+0x8, Member, Type: float, resetTimer
	//_Data: this+0xC, Member, Type: bool, retired
	//_Data: this+0x10, Member, Type: float, invalidStateTimer
	//_Data: this+0x14, Member, Type: float, maxInvalidStateTimer
//UDT;

struct RaceStatusCarDesc {
public:
	CarAvatar * car;
	float resetTimer;
	bool retired;
	float invalidStateTimer;
	float maxInvalidStateTimer;
	inline RaceStatusCarDesc() { }
	inline RaceStatusCarDesc(const RaceStatusCarDesc& other) = default;
	inline RaceStatusCarDesc& operator=(const RaceStatusCarDesc& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(RaceStatusCarDesc)==24),"bad size");
		static_assert((offsetof(RaceStatusCarDesc,car)==0x0),"bad off");
		static_assert((offsetof(RaceStatusCarDesc,resetTimer)==0x8),"bad off");
		static_assert((offsetof(RaceStatusCarDesc,retired)==0xC),"bad off");
		static_assert((offsetof(RaceStatusCarDesc,invalidStateTimer)==0x10),"bad off");
		static_assert((offsetof(RaceStatusCarDesc,maxInvalidStateTimer)==0x14),"bad off");
	};
};

//UDT: struct OnChatMessageEvent @len=40
	//_Data: this+0x0, Member, Type: int, sessionID
	//_Data: this+0x8, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, message
	//_Func: public void OnChatMessageEvent(const OnChatMessageEvent &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void OnChatMessageEvent(); @loc=optimized @len=0 @rva=0
	//_Func: public void ~OnChatMessageEvent(); @loc=static @len=49 @rva=2180672
	//_Func: public OnChatMessageEvent & operator=(const OnChatMessageEvent &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct OnChatMessageEvent {
public:
	int sessionID;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > message;
	inline OnChatMessageEvent() { }
	inline OnChatMessageEvent(const OnChatMessageEvent& other) = default;
	inline OnChatMessageEvent& operator=(const OnChatMessageEvent& other) = default;
	inline void dtor() { typedef void (OnChatMessageEvent::*_fpt)(); auto _f=xcast<_fpt>(_drva(2180672)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(OnChatMessageEvent)==40),"bad size");
		static_assert((offsetof(OnChatMessageEvent,sessionID)==0x0),"bad off");
		static_assert((offsetof(OnChatMessageEvent,message)==0x8),"bad off");
	};
};

//UDT: struct RealTimeCarDesc @len=16
	//_Func: public void RealTimeCarDesc(CarAvatar *  _arg0); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: class CarAvatar *, car
	//_Data: this+0x8, Member, Type: bool, crossedForTheFirstTime
	//_Data: this+0xC, Member, Type: float, approxPos
//UDT;

struct RealTimeCarDesc {
public:
	CarAvatar * car;
	bool crossedForTheFirstTime;
	float approxPos;
	inline RealTimeCarDesc() { }
	inline RealTimeCarDesc(const RealTimeCarDesc& other) = default;
	inline RealTimeCarDesc& operator=(const RealTimeCarDesc& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(RealTimeCarDesc)==16),"bad size");
		static_assert((offsetof(RealTimeCarDesc,car)==0x0),"bad off");
		static_assert((offsetof(RealTimeCarDesc,crossedForTheFirstTime)==0x8),"bad off");
		static_assert((offsetof(RealTimeCarDesc,approxPos)==0xC),"bad off");
	};
};

//UDT: struct MultiplayerStatus @len=32
	//_Data: this+0x0, Member, Type: class std::vector<bool,std::allocator<bool> >, completedFlags
	//_Func: public void MultiplayerStatus(const MultiplayerStatus &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void MultiplayerStatus(); @loc=optimized @len=0 @rva=0
	//_Func: public void ~MultiplayerStatus(); @loc=static @len=60 @rva=1258160
	//_Func: public MultiplayerStatus & operator=(const MultiplayerStatus &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct MultiplayerStatus {
public:
	std::vector<bool,std::allocator<bool> > completedFlags;
	inline MultiplayerStatus() { }
	inline MultiplayerStatus(const MultiplayerStatus& other) = default;
	inline MultiplayerStatus& operator=(const MultiplayerStatus& other) = default;
	inline void dtor() { typedef void (MultiplayerStatus::*_fpt)(); auto _f=xcast<_fpt>(_drva(1258160)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(MultiplayerStatus)==32),"bad size");
		static_assert((offsetof(MultiplayerStatus,completedFlags)==0x0),"bad off");
	};
};

//UDT: struct CarCollisionBox @len=32
	//_Func: public void CarCollisionBox(const vec3f &  _arg0, const vec3f &  _arg1); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: class vec3f, centre
	//_Data: this+0xC, Member, Type: class vec3f, size
	//_Data: this+0x18, Member, Type: unsigned __int64, id
//UDT;

struct CarCollisionBox {
public:
	vec3f centre;
	vec3f size;
	unsigned __int64 id;
	inline CarCollisionBox() { }
	inline CarCollisionBox(const CarCollisionBox& other) = default;
	inline CarCollisionBox& operator=(const CarCollisionBox& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(CarCollisionBox)==32),"bad size");
		static_assert((offsetof(CarCollisionBox,centre)==0x0),"bad off");
		static_assert((offsetof(CarCollisionBox,size)==0xC),"bad off");
		static_assert((offsetof(CarCollisionBox,id)==0x18),"bad off");
	};
};

//UDT: struct UDPMessage @len=32
	//_Data: this+0x0, Member, Type: void *, data
	//_Data: this+0x8, Member, Type: int, size
	//_Data: this+0xC, Member, Type: struct sockaddr_in, srcAddress
	//_Func: public void UDPMessage(); @loc=optimized @len=0 @rva=0
//UDT;

struct UDPMessage {
public:
	void * data;
	int size;
	sockaddr_in srcAddress;
	inline UDPMessage() { }
	inline UDPMessage(const UDPMessage& other) = default;
	inline UDPMessage& operator=(const UDPMessage& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(UDPMessage)==32),"bad size");
		static_assert((offsetof(UDPMessage,data)==0x0),"bad off");
		static_assert((offsetof(UDPMessage,size)==0x8),"bad off");
		static_assert((offsetof(UDPMessage,srcAddress)==0xC),"bad off");
	};
};

//UDT: struct FadeModeDef @len=24
	//_Func: public void FadeModeDef(FadeMode aMode, void * aSender, float aTime); @loc=static @len=22 @rva=242368
	//_Func: public void FadeModeDef(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: enum FadeMode, mode
	//_Data: this+0x4, Member, Type: float, fadeTime
	//_Data: this+0x8, Member, Type: float, fadeTotalTime
	//_Data: this+0x10, Member, Type: void *, sender
//UDT;

struct FadeModeDef {
public:
	FadeMode mode;
	float fadeTime;
	float fadeTotalTime;
	void * sender;
	inline FadeModeDef() { }
	inline FadeModeDef(const FadeModeDef& other) = default;
	inline FadeModeDef& operator=(const FadeModeDef& other) = default;
	inline void ctor(FadeMode aMode, void * aSender, float aTime) { typedef void (FadeModeDef::*_fpt)(FadeMode, void *, float); auto _f=xcast<_fpt>(_drva(242368)); (this->*_f)(aMode, aSender, aTime); }
	inline void _guard_obj() {
		static_assert((sizeof(FadeModeDef)==24),"bad size");
		static_assert((offsetof(FadeModeDef,mode)==0x0),"bad off");
		static_assert((offsetof(FadeModeDef,fadeTime)==0x4),"bad off");
		static_assert((offsetof(FadeModeDef,fadeTotalTime)==0x8),"bad off");
		static_assert((offsetof(FadeModeDef,sender)==0x10),"bad off");
	};
};

//UDT: struct ClientRemoteCarDef @len=216
	//_Data: this+0x0, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, model
	//_Data: this+0x20, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, config
	//_Data: this+0x40, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, skin
	//_Data: this+0x60, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, driverName
	//_Data: this+0x80, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, team
	//_Data: this+0xA0, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, nationCode
	//_Data: this+0xC0, Member, Type: unsigned char, sessionID
	//_Data: this+0xC4, Member, Type: float[0x5], damageZoneLevel
	//_Func: public void ClientRemoteCarDef(const ClientRemoteCarDef & __that); @loc=static @len=314 @rva=241776
	//_Func: public void ClientRemoteCarDef(); @loc=optimized @len=0 @rva=0
	//_Func: public void ~ClientRemoteCarDef(); @loc=static @len=246 @rva=246128
	//_Func: public ClientRemoteCarDef & operator=(const ClientRemoteCarDef &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct ClientRemoteCarDef {
public:
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > model;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > config;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > skin;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > driverName;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > team;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > nationCode;
	unsigned char sessionID;
	float damageZoneLevel[5];
	inline ClientRemoteCarDef() { }
	inline ClientRemoteCarDef(const ClientRemoteCarDef& other) = default;
	inline ClientRemoteCarDef& operator=(const ClientRemoteCarDef& other) = default;
	inline void ctor(const ClientRemoteCarDef & __that) { typedef void (ClientRemoteCarDef::*_fpt)(const ClientRemoteCarDef &); auto _f=xcast<_fpt>(_drva(241776)); (this->*_f)(__that); }
	inline void dtor() { typedef void (ClientRemoteCarDef::*_fpt)(); auto _f=xcast<_fpt>(_drva(246128)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(ClientRemoteCarDef)==216),"bad size");
		static_assert((offsetof(ClientRemoteCarDef,model)==0x0),"bad off");
		static_assert((offsetof(ClientRemoteCarDef,config)==0x20),"bad off");
		static_assert((offsetof(ClientRemoteCarDef,skin)==0x40),"bad off");
		static_assert((offsetof(ClientRemoteCarDef,driverName)==0x60),"bad off");
		static_assert((offsetof(ClientRemoteCarDef,team)==0x80),"bad off");
		static_assert((offsetof(ClientRemoteCarDef,nationCode)==0xA0),"bad off");
		static_assert((offsetof(ClientRemoteCarDef,sessionID)==0xC0),"bad off");
		static_assert((offsetof(ClientRemoteCarDef,damageZoneLevel)==0xC4),"bad off");
	};
};

//UDT: struct CollisionEvent @len=44
	//_Data: this+0x0, Member, Type: int, carIndex
	//_Data: this+0x4, Member, Type: float, normalForce
	//_Data: this+0x8, Member, Type: class vec3f, pos
	//_Data: this+0x14, Member, Type: class vec3f, normal
	//_Data: this+0x20, Member, Type: float, impactAngle
	//_Data: this+0x24, Member, Type: float, relativeSpeed
	//_Data: this+0x28, Member, Type: unsigned long, colliderCategory
	//_Func: public void CollisionEvent(); @loc=optimized @len=0 @rva=0
//UDT;

struct CollisionEvent {
public:
	int carIndex;
	float normalForce;
	vec3f pos;
	vec3f normal;
	float impactAngle;
	float relativeSpeed;
	unsigned long colliderCategory;
	inline CollisionEvent() { }
	inline CollisionEvent(const CollisionEvent& other) = default;
	inline CollisionEvent& operator=(const CollisionEvent& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(CollisionEvent)==44),"bad size");
		static_assert((offsetof(CollisionEvent,carIndex)==0x0),"bad off");
		static_assert((offsetof(CollisionEvent,normalForce)==0x4),"bad off");
		static_assert((offsetof(CollisionEvent,pos)==0x8),"bad off");
		static_assert((offsetof(CollisionEvent,normal)==0x14),"bad off");
		static_assert((offsetof(CollisionEvent,impactAngle)==0x20),"bad off");
		static_assert((offsetof(CollisionEvent,relativeSpeed)==0x24),"bad off");
		static_assert((offsetof(CollisionEvent,colliderCategory)==0x28),"bad off");
	};
};

//UDT: struct ClientHandshakeResult @len=144
	//_Data: this+0x0, Member, Type: bool, success
	//_Data: this+0x8, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, model
	//_Data: this+0x28, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, skin
	//_Data: this+0x48, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, track
	//_Data: this+0x68, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, track_config
	//_Data: this+0x88, Member, Type: float, sunAngle
	//_Data: this+0x8C, Member, Type: unsigned char, sessionID
	//_Func: public void ClientHandshakeResult(const ClientHandshakeResult & __that); @loc=static @len=229 @rva=241536
	//_Func: public void ClientHandshakeResult(); @loc=optimized @len=0 @rva=0
	//_Func: public void ~ClientHandshakeResult(); @loc=static @len=160 @rva=245968
	//_Func: public ClientHandshakeResult & operator=(const ClientHandshakeResult &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct ClientHandshakeResult {
public:
	bool success;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > model;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > skin;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > track;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > track_config;
	float sunAngle;
	unsigned char sessionID;
	inline ClientHandshakeResult() { }
	inline ClientHandshakeResult(const ClientHandshakeResult& other) = default;
	inline ClientHandshakeResult& operator=(const ClientHandshakeResult& other) = default;
	inline void ctor(const ClientHandshakeResult & __that) { typedef void (ClientHandshakeResult::*_fpt)(const ClientHandshakeResult &); auto _f=xcast<_fpt>(_drva(241536)); (this->*_f)(__that); }
	inline void dtor() { typedef void (ClientHandshakeResult::*_fpt)(); auto _f=xcast<_fpt>(_drva(245968)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(ClientHandshakeResult)==144),"bad size");
		static_assert((offsetof(ClientHandshakeResult,success)==0x0),"bad off");
		static_assert((offsetof(ClientHandshakeResult,model)==0x8),"bad off");
		static_assert((offsetof(ClientHandshakeResult,skin)==0x28),"bad off");
		static_assert((offsetof(ClientHandshakeResult,track)==0x48),"bad off");
		static_assert((offsetof(ClientHandshakeResult,track_config)==0x68),"bad off");
		static_assert((offsetof(ClientHandshakeResult,sunAngle)==0x88),"bad off");
		static_assert((offsetof(ClientHandshakeResult,sessionID)==0x8C),"bad off");
	};
};

//UDT: class plane4f @len=16
	//_Data: this+0x0, Member, Type: class vec3f, normal
	//_Data: this+0xC, Member, Type: float, d
	//_Func: public void plane4f(const vec3f & point1, const vec3f & point2, const vec3f & point3); @loc=static @len=308 @rva=1146576
	//_Func: public void plane4f(const vec3f &  _arg0, const vec3f &  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public void plane4f(); @loc=optimized @len=0 @rva=0
	//_Func: public vec3f getRayIntersection(const vec3f &  _arg0, const vec3f &  _arg1); @loc=optimized @len=0 @rva=0
//UDT;

class plane4f {
public:
	vec3f normal;
	float d;
	inline plane4f() { }
	inline plane4f(const plane4f& other) = default;
	inline plane4f& operator=(const plane4f& other) = default;
	inline void ctor(const vec3f & point1, const vec3f & point2, const vec3f & point3) { typedef void (plane4f::*_fpt)(const vec3f &, const vec3f &, const vec3f &); auto _f=xcast<_fpt>(_drva(1146576)); (this->*_f)(point1, point2, point3); }
	inline void _guard_obj() {
		static_assert((sizeof(plane4f)==16),"bad size");
		static_assert((offsetof(plane4f,normal)==0x0),"bad off");
		static_assert((offsetof(plane4f,d)==0xC),"bad off");
	};
};

//UDT: struct OnESCMenuTriggered @len=16
	//_Func: public void OnESCMenuTriggered(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: class ESCMenu *, menu
	//_Data: this+0x8, Member, Type: bool, visible
	//_Data: this+0x9, Member, Type: bool, startReplay
//UDT;

struct OnESCMenuTriggered {
public:
	ESCMenu * menu;
	bool visible;
	bool startReplay;
	inline OnESCMenuTriggered() { }
	inline OnESCMenuTriggered(const OnESCMenuTriggered& other) = default;
	inline OnESCMenuTriggered& operator=(const OnESCMenuTriggered& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(OnESCMenuTriggered)==16),"bad size");
		static_assert((offsetof(OnESCMenuTriggered,menu)==0x0),"bad off");
		static_assert((offsetof(OnESCMenuTriggered,visible)==0x8),"bad off");
		static_assert((offsetof(OnESCMenuTriggered,startReplay)==0x9),"bad off");
	};
};

//UDT: struct StabilityControl @len=24
	//_Func: public void ~StabilityControl(); @loc=static @len=3 @rva=96368
	//_Data: this+0x0, Member, Type: float, gain
	//_Data: this+0x4, Member, Type: bool, useBeta
	//_Func: public void init(Car * car); @loc=static @len=22 @rva=2882096
	//_Func: public void step(float dt); @loc=static @len=511 @rva=2882128
	//_Data: this+0x8, Member, Type: class Car *, car
	//_Data: this+0x10, Member, Type: float, maxGain
	//_Func: public void StabilityControl(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct StabilityControl {
public:
	float gain;
	bool useBeta;
	Car * car;
	float maxGain;
	inline StabilityControl() { }
	inline StabilityControl(const StabilityControl& other) = default;
	inline StabilityControl& operator=(const StabilityControl& other) = default;
	inline void dtor() { typedef void (StabilityControl::*_fpt)(); auto _f=xcast<_fpt>(_drva(96368)); (this->*_f)(); }
	inline void init(Car * car) { typedef void (StabilityControl::*_fpt)(Car *); auto _f=xcast<_fpt>(_drva(2882096)); return (this->*_f)(car); }
	inline void step(float dt) { typedef void (StabilityControl::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2882128)); return (this->*_f)(dt); }
	inline void _guard_obj() {
		static_assert((sizeof(StabilityControl)==24),"bad size");
		static_assert((offsetof(StabilityControl,gain)==0x0),"bad off");
		static_assert((offsetof(StabilityControl,useBeta)==0x4),"bad off");
		static_assert((offsetof(StabilityControl,car)==0x8),"bad off");
		static_assert((offsetof(StabilityControl,maxGain)==0x10),"bad off");
	};
};

//UDT: struct OnNewCarLoadedEvent @len=8
	//_Data: this+0x0, Member, Type: class CarAvatar *, car
//UDT;

struct OnNewCarLoadedEvent {
public:
	CarAvatar * car;
	inline OnNewCarLoadedEvent() { }
	inline OnNewCarLoadedEvent(const OnNewCarLoadedEvent& other) = default;
	inline OnNewCarLoadedEvent& operator=(const OnNewCarLoadedEvent& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(OnNewCarLoadedEvent)==8),"bad size");
		static_assert((offsetof(OnNewCarLoadedEvent,car)==0x0),"bad off");
	};
};

//UDT: class IVarCallback @len=8 @vfcount=1
	//_VTable: 
	//_Func: public void onSetVar(SVar *  _arg0, float  _arg1); @intro @pure @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Func: public void IVarCallback(const IVarCallback &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void IVarCallback(); @loc=optimized @len=0 @rva=0
	//_Func: public IVarCallback & operator=(const IVarCallback &  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class IVarCallback {
public:
	inline IVarCallback() { }
	inline IVarCallback(const IVarCallback& other) = default;
	inline IVarCallback& operator=(const IVarCallback& other) = default;
	virtual void onSetVar_vf0(SVar *  _arg0, float  _arg1) = 0;
	inline void onSetVar(SVar *  _arg0, float  _arg1) { typedef void (IVarCallback::*_fpt)(SVar *, float); auto _f=xcast<_fpt>(get_vfp(this, 0)); return (this->*_f)( _arg0,  _arg1); }
	inline void _guard_obj() {
		static_assert((sizeof(IVarCallback)==8),"bad size");
	};
};

//UDT: struct SStrutSuspensionData @len=112
	//_Data: this+0x0, Member, Type: class vec3f, carStrut
	//_Data: this+0xC, Member, Type: class vec3f, tyreStrut
	//_Data: this+0x18, Member, Type: class vec3f, carBottomWB_F
	//_Data: this+0x24, Member, Type: class vec3f, carBottomWB_R
	//_Data: this+0x30, Member, Type: class vec3f, tyreBottomWB
	//_Data: this+0x3C, Member, Type: class vec3f, carSteer
	//_Data: this+0x48, Member, Type: class vec3f, tyreSteer
	//_Data: this+0x54, Member, Type: class vec3f, refPoint
	//_Data: this+0x60, Member, Type: float, hubMass
	//_Data: this+0x64, Member, Type: class vec3f, hubInertiaBox
	//_Func: public void SStrutSuspensionData(); @loc=optimized @len=0 @rva=0
//UDT;

struct SStrutSuspensionData {
public:
	vec3f carStrut;
	vec3f tyreStrut;
	vec3f carBottomWB_F;
	vec3f carBottomWB_R;
	vec3f tyreBottomWB;
	vec3f carSteer;
	vec3f tyreSteer;
	vec3f refPoint;
	float hubMass;
	vec3f hubInertiaBox;
	inline SStrutSuspensionData() { }
	inline SStrutSuspensionData(const SStrutSuspensionData& other) = default;
	inline SStrutSuspensionData& operator=(const SStrutSuspensionData& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(SStrutSuspensionData)==112),"bad size");
		static_assert((offsetof(SStrutSuspensionData,carStrut)==0x0),"bad off");
		static_assert((offsetof(SStrutSuspensionData,tyreStrut)==0xC),"bad off");
		static_assert((offsetof(SStrutSuspensionData,carBottomWB_F)==0x18),"bad off");
		static_assert((offsetof(SStrutSuspensionData,carBottomWB_R)==0x24),"bad off");
		static_assert((offsetof(SStrutSuspensionData,tyreBottomWB)==0x30),"bad off");
		static_assert((offsetof(SStrutSuspensionData,carSteer)==0x3C),"bad off");
		static_assert((offsetof(SStrutSuspensionData,tyreSteer)==0x48),"bad off");
		static_assert((offsetof(SStrutSuspensionData,refPoint)==0x54),"bad off");
		static_assert((offsetof(SStrutSuspensionData,hubMass)==0x60),"bad off");
		static_assert((offsetof(SStrutSuspensionData,hubInertiaBox)==0x64),"bad off");
	};
};

//UDT: struct ModelBoundariesCoordinates @len=24
	//_Data: this+0x0, Member, Type: float, front
	//_Data: this+0x4, Member, Type: float, rear
	//_Data: this+0x8, Member, Type: float, left
	//_Data: this+0xC, Member, Type: float, right
	//_Data: this+0x10, Member, Type: float, top
	//_Data: this+0x14, Member, Type: float, bottom
	//_Func: public void update(vec3f  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void ModelBoundariesCoordinates(); @loc=optimized @len=0 @rva=0
//UDT;

struct ModelBoundariesCoordinates {
public:
	float front;
	float rear;
	float left;
	float right;
	float top;
	float bottom;
	inline ModelBoundariesCoordinates() { }
	inline ModelBoundariesCoordinates(const ModelBoundariesCoordinates& other) = default;
	inline ModelBoundariesCoordinates& operator=(const ModelBoundariesCoordinates& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(ModelBoundariesCoordinates)==24),"bad size");
		static_assert((offsetof(ModelBoundariesCoordinates,front)==0x0),"bad off");
		static_assert((offsetof(ModelBoundariesCoordinates,rear)==0x4),"bad off");
		static_assert((offsetof(ModelBoundariesCoordinates,left)==0x8),"bad off");
		static_assert((offsetof(ModelBoundariesCoordinates,right)==0xC),"bad off");
		static_assert((offsetof(ModelBoundariesCoordinates,top)==0x10),"bad off");
		static_assert((offsetof(ModelBoundariesCoordinates,bottom)==0x14),"bad off");
	};
};

//UDT: struct TrackData @len=72
	//_Data: this+0x0, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, name
	//_Data: this+0x20, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, configuration
	//_Data: this+0x40, Member, Type: int, gridPlaces
	//_Func: public void TrackData(const TrackData &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void TrackData(); @loc=optimized @len=0 @rva=0
	//_Func: public void ~TrackData(); @loc=static @len=88 @rva=776352
	//_Func: public TrackData & operator=(const TrackData &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct TrackData {
public:
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > name;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > configuration;
	int gridPlaces;
	inline TrackData() { }
	inline TrackData(const TrackData& other) = default;
	inline TrackData& operator=(const TrackData& other) = default;
	inline void dtor() { typedef void (TrackData::*_fpt)(); auto _f=xcast<_fpt>(_drva(776352)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(TrackData)==72),"bad size");
		static_assert((offsetof(TrackData,name)==0x0),"bad off");
		static_assert((offsetof(TrackData,configuration)==0x20),"bad off");
		static_assert((offsetof(TrackData,gridPlaces)==0x40),"bad off");
	};
};

//UDT: struct WingState @len=68
	//_Data: this+0x0, Member, Type: float, aoa
	//_Data: this+0x4, Member, Type: float, cd
	//_Data: this+0x8, Member, Type: float, cl
	//_Data: this+0xC, Member, Type: float, angle
	//_Data: this+0x10, Member, Type: float, inputAngle
	//_Data: this+0x14, Member, Type: float, groundHeight
	//_Data: this+0x18, Member, Type: float, frontShare
	//_Data: this+0x1C, Member, Type: float, dragKG
	//_Data: this+0x20, Member, Type: float, liftKG
	//_Data: this+0x24, Member, Type: float, angleMult
	//_Data: this+0x28, Member, Type: float, groundEffectLift
	//_Data: this+0x2C, Member, Type: float, groundEffectDrag
	//_Data: this+0x30, Member, Type: float, yawAngle
	//_Data: this+0x34, Member, Type: bool, isVertical
	//_Data: this+0x38, Member, Type: class vec3f, liftVector
	//_Func: public void WingState(); @loc=optimized @len=0 @rva=0
//UDT;

struct WingState {
public:
	float aoa;
	float cd;
	float cl;
	float angle;
	float inputAngle;
	float groundHeight;
	float frontShare;
	float dragKG;
	float liftKG;
	float angleMult;
	float groundEffectLift;
	float groundEffectDrag;
	float yawAngle;
	bool isVertical;
	vec3f liftVector;
	inline WingState() { }
	inline WingState(const WingState& other) = default;
	inline WingState& operator=(const WingState& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(WingState)==68),"bad size");
		static_assert((offsetof(WingState,aoa)==0x0),"bad off");
		static_assert((offsetof(WingState,cd)==0x4),"bad off");
		static_assert((offsetof(WingState,cl)==0x8),"bad off");
		static_assert((offsetof(WingState,angle)==0xC),"bad off");
		static_assert((offsetof(WingState,inputAngle)==0x10),"bad off");
		static_assert((offsetof(WingState,groundHeight)==0x14),"bad off");
		static_assert((offsetof(WingState,frontShare)==0x18),"bad off");
		static_assert((offsetof(WingState,dragKG)==0x1C),"bad off");
		static_assert((offsetof(WingState,liftKG)==0x20),"bad off");
		static_assert((offsetof(WingState,angleMult)==0x24),"bad off");
		static_assert((offsetof(WingState,groundEffectLift)==0x28),"bad off");
		static_assert((offsetof(WingState,groundEffectDrag)==0x2C),"bad off");
		static_assert((offsetof(WingState,yawAngle)==0x30),"bad off");
		static_assert((offsetof(WingState,isVertical)==0x34),"bad off");
		static_assert((offsetof(WingState,liftVector)==0x38),"bad off");
	};
};

//UDT: struct DisconnectCountdown @len=40
	//_Data: this+0x0, Member, Type: bool, isSignaled
	//_Data: this+0x4, Member, Type: float, timeToDisconnection
	//_Data: this+0x8, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, message
	//_Func: public void DisconnectCountdown(const DisconnectCountdown &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void DisconnectCountdown(); @loc=optimized @len=0 @rva=0
	//_Func: public void ~DisconnectCountdown(); @loc=static @len=49 @rva=2180672
	//_Func: public DisconnectCountdown & operator=(const DisconnectCountdown &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct DisconnectCountdown {
public:
	bool isSignaled;
	float timeToDisconnection;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > message;
	inline DisconnectCountdown() { }
	inline DisconnectCountdown(const DisconnectCountdown& other) = default;
	inline DisconnectCountdown& operator=(const DisconnectCountdown& other) = default;
	inline void dtor() { typedef void (DisconnectCountdown::*_fpt)(); auto _f=xcast<_fpt>(_drva(2180672)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(DisconnectCountdown)==40),"bad size");
		static_assert((offsetof(DisconnectCountdown,isSignaled)==0x0),"bad off");
		static_assert((offsetof(DisconnectCountdown,timeToDisconnection)==0x4),"bad off");
		static_assert((offsetof(DisconnectCountdown,message)==0x8),"bad off");
	};
};

//UDT: class Task @len=40
	//_Func: public void Task(const Task &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void Task(); @loc=optimized @len=0 @rva=0
	//_Func: public void Task(std::function<void __cdecl(void)>  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void run(); @loc=optimized @len=0 @rva=0
	//_Func: public void spinWait(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: volatile bool, isDone
	//_Data: this+0x8, Member, Type: class std::function<void __cdecl(void)>, function
	//_Func: public void ~Task(); @loc=static @len=74 @rva=175552
	//_Func: public Task & operator=(const Task &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class Task {
public:
	bool isDone;
	std::function<void __cdecl(void)> function;
	inline Task() { }
	inline Task(const Task& other) = default;
	inline Task& operator=(const Task& other) = default;
	inline void dtor() { typedef void (Task::*_fpt)(); auto _f=xcast<_fpt>(_drva(175552)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(Task)==40),"bad size");
		static_assert((offsetof(Task,isDone)==0x0),"bad off");
		static_assert((offsetof(Task,function)==0x8),"bad off");
	};
};

//UDT: struct DriverActionsState @len=4
	//_Data: this+0x0, Member, Type: int, state
	//_Func: public void reset(); @loc=optimized @len=0 @rva=0
	//_Func: public void setState(DriverActions  _arg0, bool  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public bool getState(DriverActions  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void DriverActionsState(); @loc=optimized @len=0 @rva=0
//UDT;

struct DriverActionsState {
public:
	int state;
	inline DriverActionsState() { }
	inline DriverActionsState(const DriverActionsState& other) = default;
	inline DriverActionsState& operator=(const DriverActionsState& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(DriverActionsState)==4),"bad size");
		static_assert((offsetof(DriverActionsState,state)==0x0),"bad off");
	};
};

//UDT: struct ksgui::GraphReferenceAxis @len=20
	//_Func: public void GraphReferenceAxis(const vec3f & acolor, float arefValue, bool bisVertical); @loc=static @len=35 @rva=2987152
	//_Data: this+0x0, Member, Type: class vec3f, color
	//_Data: this+0xC, Member, Type: float, refValue
	//_Data: this+0x10, Member, Type: bool, isVertical
//UDT;

struct ksgui_GraphReferenceAxis {
public:
	vec3f color;
	float refValue;
	bool isVertical;
	inline ksgui_GraphReferenceAxis() { }
	inline ksgui_GraphReferenceAxis(const ksgui_GraphReferenceAxis& other) = default;
	inline ksgui_GraphReferenceAxis& operator=(const ksgui_GraphReferenceAxis& other) = default;
	inline void ctor(const vec3f & acolor, float arefValue, bool bisVertical) { typedef void (ksgui_GraphReferenceAxis::*_fpt)(const vec3f &, float, bool); auto _f=xcast<_fpt>(_drva(2987152)); (this->*_f)(acolor, arefValue, bisVertical); }
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_GraphReferenceAxis)==20),"bad size");
		static_assert((offsetof(ksgui_GraphReferenceAxis,color)==0x0),"bad off");
		static_assert((offsetof(ksgui_GraphReferenceAxis,refValue)==0xC),"bad off");
		static_assert((offsetof(ksgui_GraphReferenceAxis,isVertical)==0x10),"bad off");
	};
};

//UDT: struct SplinePoint @len=20
	//_Func: public void SplinePoint(const vec3f &  _arg0, float  _arg1, int  _arg2); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: class vec3f, point
	//_Data: this+0xC, Member, Type: float, pointLength
	//_Data: this+0x10, Member, Type: int, tag
//UDT;

struct SplinePoint {
public:
	vec3f point;
	float pointLength;
	int tag;
	inline SplinePoint() { }
	inline SplinePoint(const SplinePoint& other) = default;
	inline SplinePoint& operator=(const SplinePoint& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(SplinePoint)==20),"bad size");
		static_assert((offsetof(SplinePoint,point)==0x0),"bad off");
		static_assert((offsetof(SplinePoint,pointLength)==0xC),"bad off");
		static_assert((offsetof(SplinePoint,tag)==0x10),"bad off");
	};
};

//UDT: class TCPQueue @len=65540
	//_Func: public void TCPQueue(); @loc=optimized @len=0 @rva=0
	//_Func: public void push(unsigned char * data, unsigned int size); @loc=static @len=215 @rva=2482992
	//_Func: public std::vector<unsigned char,std::allocator<unsigned char> > getPacket(); @loc=static @len=238 @rva=2482752
	//_Data: this+0x0, Member, Type: unsigned char[0x10000], buffer
	//_Data: this+0x10000, Member, Type: unsigned int, cursor
//UDT;

class TCPQueue {
public:
	unsigned char buffer[65536];
	unsigned int cursor;
	inline TCPQueue() { }
	inline TCPQueue(const TCPQueue& other) = default;
	inline TCPQueue& operator=(const TCPQueue& other) = default;
	inline void push(unsigned char * data, unsigned int size) { typedef void (TCPQueue::*_fpt)(unsigned char *, unsigned int); auto _f=xcast<_fpt>(_drva(2482992)); return (this->*_f)(data, size); }
	inline std::vector<unsigned char,std::allocator<unsigned char> > getPacket() { typedef std::vector<unsigned char,std::allocator<unsigned char> > (TCPQueue::*_fpt)(); auto _f=xcast<_fpt>(_drva(2482752)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(TCPQueue)==65540),"bad size");
		static_assert((offsetof(TCPQueue,buffer)==0x0),"bad off");
		static_assert((offsetof(TCPQueue,cursor)==0x10000),"bad off");
	};
};

//UDT: struct PenaltyRules @len=8
	//_Data: this+0x0, Member, Type: enum JumpStartPenaltyMode, jumpStartPenaltyMode
	//_Data: this+0x4, Member, Type: short, basePitPenaltyLaps
	//_Func: public bool isFirstGearLocked(); @loc=optimized @len=0 @rva=0
	//_Func: public void PenaltyRules(); @loc=optimized @len=0 @rva=0
//UDT;

struct PenaltyRules {
public:
	JumpStartPenaltyMode jumpStartPenaltyMode;
	short basePitPenaltyLaps;
	inline PenaltyRules() { }
	inline PenaltyRules(const PenaltyRules& other) = default;
	inline PenaltyRules& operator=(const PenaltyRules& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(PenaltyRules)==8),"bad size");
		static_assert((offsetof(PenaltyRules,jumpStartPenaltyMode)==0x0),"bad off");
		static_assert((offsetof(PenaltyRules,basePitPenaltyLaps)==0x4),"bad off");
	};
};

//UDT: struct SessionInfo @len=32
	//_Func: public void SessionInfo(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: enum SessionType, type
	//_Data: this+0x8, Member, Type: double, startTimeMS
	//_Data: this+0x10, Member, Type: double, timeSecs
	//_Data: this+0x18, Member, Type: int, laps
	//_Data: this+0x1C, Member, Type: int, index
//UDT;

struct SessionInfo {
public:
	SessionType type;
	double startTimeMS;
	double timeSecs;
	int laps;
	int index;
	inline SessionInfo() { }
	inline SessionInfo(const SessionInfo& other) = default;
	inline SessionInfo& operator=(const SessionInfo& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(SessionInfo)==32),"bad size");
		static_assert((offsetof(SessionInfo,type)==0x0),"bad off");
		static_assert((offsetof(SessionInfo,startTimeMS)==0x8),"bad off");
		static_assert((offsetof(SessionInfo,timeSecs)==0x10),"bad off");
		static_assert((offsetof(SessionInfo,laps)==0x18),"bad off");
		static_assert((offsetof(SessionInfo,index)==0x1C),"bad off");
	};
};

//UDT: class ICollisionCallback @len=8 @vfcount=2
	//_VTable: 
	//_Func: public void ~ICollisionCallback(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=11 @rva=2501856
	//_Func: public void onCollisionCallBack(void *  _arg0, void *  _arg1, void *  _arg2, void *  _arg3, vec3f  _arg4, vec3f  _arg5, float  _arg6); @intro @pure @virtual vtpo=0 vfid=1 @loc=optimized @len=0 @rva=0
	//_Func: public void ICollisionCallback(const ICollisionCallback &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void ICollisionCallback(); @loc=optimized @len=0 @rva=0
	//_Func: public ICollisionCallback & operator=(const ICollisionCallback &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ICollisionCallback {
public:
	inline ICollisionCallback() { }
	inline ICollisionCallback(const ICollisionCallback& other) = default;
	inline ICollisionCallback& operator=(const ICollisionCallback& other) = default;
	virtual ~ICollisionCallback();
	inline void dtor() { typedef void (ICollisionCallback::*_fpt)(); auto _f=xcast<_fpt>(_drva(2501856)); (this->*_f)(); }
	virtual void onCollisionCallBack_vf1(void *  _arg0, void *  _arg1, void *  _arg2, void *  _arg3, vec3f  _arg4, vec3f  _arg5, float  _arg6) = 0;
	inline void onCollisionCallBack(void *  _arg0, void *  _arg1, void *  _arg2, void *  _arg3, vec3f  _arg4, vec3f  _arg5, float  _arg6) { typedef void (ICollisionCallback::*_fpt)(void *, void *, void *, void *, vec3f, vec3f, float); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)( _arg0,  _arg1,  _arg2,  _arg3,  _arg4,  _arg5,  _arg6); }
	inline void _guard_obj() {
		static_assert((sizeof(ICollisionCallback)==8),"bad size");
	};
};

//UDT: struct BodyCollisionMesh @len=24
	//_Func: public void ~BodyCollisionMesh(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: float *, vertices
	//_Data: this+0x8, Member, Type: unsigned short *, indices
	//_Data: this+0x10, Member, Type: struct dxGeom *, geomID
	//_Func: public void BodyCollisionMesh(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct BodyCollisionMesh {
public:
	float * vertices;
	unsigned short * indices;
	dxGeom * geomID;
	inline BodyCollisionMesh() { }
	inline BodyCollisionMesh(const BodyCollisionMesh& other) = default;
	inline BodyCollisionMesh& operator=(const BodyCollisionMesh& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(BodyCollisionMesh)==24),"bad size");
		static_assert((offsetof(BodyCollisionMesh,vertices)==0x0),"bad off");
		static_assert((offsetof(BodyCollisionMesh,indices)==0x8),"bad off");
		static_assert((offsetof(BodyCollisionMesh,geomID)==0x10),"bad off");
	};
};

//UDT: struct OnWindowClosedEvent @len=8
	//_Func: public void OnWindowClosedEvent(RenderWindow *  _arg0); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: class RenderWindow *, renderWindow
//UDT;

struct OnWindowClosedEvent {
public:
	RenderWindow * renderWindow;
	inline OnWindowClosedEvent() { }
	inline OnWindowClosedEvent(const OnWindowClosedEvent& other) = default;
	inline OnWindowClosedEvent& operator=(const OnWindowClosedEvent& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(OnWindowClosedEvent)==8),"bad size");
		static_assert((offsetof(OnWindowClosedEvent,renderWindow)==0x0),"bad off");
	};
};

//UDT: struct LapInvalidator @len=32
	//_Func: public void ~LapInvalidator(); @loc=static @len=3 @rva=96368
	//_Data: this+0x0, Member, Type: double, collisionSafeTime
	//_Func: public void init(Car * car); @loc=static @len=5 @rva=2865408
	//_Func: public int getCurrentTyresOut(); @loc=optimized @len=0 @rva=0
	//_Func: public void step(float dt); @loc=static @len=402 @rva=2884992
	//_Data: this+0x8, Member, Type: class Car *, car
	//_Data: this+0x10, Member, Type: int, currentTyresOut
	//_Data: this+0x14, Member, Type: bool, isInPenaltyZone
	//_Data: this+0x18, Member, Type: float, lastBlackFlagTime
	//_Func: private void onEnterPenaltyZone(int tyre_count, float black_flag_time); @loc=static @len=431 @rva=2884560
	//_Func: private void onInPenaltyZone(int  _arg0, float  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public void LapInvalidator(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct LapInvalidator {
public:
	double collisionSafeTime;
	Car * car;
	int currentTyresOut;
	bool isInPenaltyZone;
	float lastBlackFlagTime;
	inline LapInvalidator() { }
	inline LapInvalidator(const LapInvalidator& other) = default;
	inline LapInvalidator& operator=(const LapInvalidator& other) = default;
	inline void dtor() { typedef void (LapInvalidator::*_fpt)(); auto _f=xcast<_fpt>(_drva(96368)); (this->*_f)(); }
	inline void init(Car * car) { typedef void (LapInvalidator::*_fpt)(Car *); auto _f=xcast<_fpt>(_drva(2865408)); return (this->*_f)(car); }
	inline void step(float dt) { typedef void (LapInvalidator::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2884992)); return (this->*_f)(dt); }
	inline void onEnterPenaltyZone(int tyre_count, float black_flag_time) { typedef void (LapInvalidator::*_fpt)(int, float); auto _f=xcast<_fpt>(_drva(2884560)); return (this->*_f)(tyre_count, black_flag_time); }
	inline void _guard_obj() {
		static_assert((sizeof(LapInvalidator)==32),"bad size");
		static_assert((offsetof(LapInvalidator,collisionSafeTime)==0x0),"bad off");
		static_assert((offsetof(LapInvalidator,car)==0x8),"bad off");
		static_assert((offsetof(LapInvalidator,currentTyresOut)==0x10),"bad off");
		static_assert((offsetof(LapInvalidator,isInPenaltyZone)==0x14),"bad off");
		static_assert((offsetof(LapInvalidator,lastBlackFlagTime)==0x18),"bad off");
	};
};

//UDT: struct OnStepCompleteEvent @len=16
	//_Data: this+0x0, Member, Type: class Car *, car
	//_Data: this+0x8, Member, Type: double, physicsTime
//UDT;

struct OnStepCompleteEvent {
public:
	Car * car;
	double physicsTime;
	inline OnStepCompleteEvent() { }
	inline OnStepCompleteEvent(const OnStepCompleteEvent& other) = default;
	inline OnStepCompleteEvent& operator=(const OnStepCompleteEvent& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(OnStepCompleteEvent)==16),"bad size");
		static_assert((offsetof(OnStepCompleteEvent,car)==0x0),"bad off");
		static_assert((offsetof(OnStepCompleteEvent,physicsTime)==0x8),"bad off");
	};
};

//UDT: class Joypad @len=8 @vfcount=7
	//_VTable: 
	//_Func: public void acquire(); @intro @pure @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Func: public vec2f getLeftStick(); @intro @pure @virtual vtpo=0 vfid=1 @loc=optimized @len=0 @rva=0
	//_Func: public vec2f getRightStick(); @intro @pure @virtual vtpo=0 vfid=2 @loc=optimized @len=0 @rva=0
	//_Func: public float getLeftTrigger(); @intro @pure @virtual vtpo=0 vfid=3 @loc=optimized @len=0 @rva=0
	//_Func: public float getRightTrigger(); @intro @pure @virtual vtpo=0 vfid=4 @loc=optimized @len=0 @rva=0
	//_Func: public unsigned int getButtonMask(); @intro @pure @virtual vtpo=0 vfid=5 @loc=optimized @len=0 @rva=0
	//_Func: public void setVibrations(float  _arg0, float  _arg1); @intro @pure @virtual vtpo=0 vfid=6 @loc=optimized @len=0 @rva=0
	//_Func: public void Joypad(const Joypad &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void Joypad(); @loc=optimized @len=0 @rva=0
	//_Func: public Joypad & operator=(const Joypad &  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class Joypad {
public:
	inline Joypad() { }
	inline Joypad(const Joypad& other) = default;
	inline Joypad& operator=(const Joypad& other) = default;
	virtual void acquire_vf0() = 0;
	inline void acquire() { typedef void (Joypad::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 0)); return (this->*_f)(); }
	virtual vec2f getLeftStick_vf1() = 0;
	inline vec2f getLeftStick() { typedef vec2f (Joypad::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(); }
	virtual vec2f getRightStick_vf2() = 0;
	inline vec2f getRightStick() { typedef vec2f (Joypad::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)(); }
	virtual float getLeftTrigger_vf3() = 0;
	inline float getLeftTrigger() { typedef float (Joypad::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(); }
	virtual float getRightTrigger_vf4() = 0;
	inline float getRightTrigger() { typedef float (Joypad::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 4)); return (this->*_f)(); }
	virtual unsigned int getButtonMask_vf5() = 0;
	inline unsigned int getButtonMask() { typedef unsigned int (Joypad::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 5)); return (this->*_f)(); }
	virtual void setVibrations_vf6(float  _arg0, float  _arg1) = 0;
	inline void setVibrations(float  _arg0, float  _arg1) { typedef void (Joypad::*_fpt)(float, float); auto _f=xcast<_fpt>(get_vfp(this, 6)); return (this->*_f)( _arg0,  _arg1); }
	inline void _guard_obj() {
		static_assert((sizeof(Joypad)==8),"bad size");
	};
};

//UDT: struct GearChanger @len=24
	//_Func: public void ~GearChanger(); @loc=static @len=3 @rva=96368
	//_Data: this+0x0, Member, Type: bool, wasGearUpTriggered
	//_Data: this+0x1, Member, Type: bool, wasGearDnTriggered
	//_Func: public void init(Car * car); @loc=static @len=11 @rva=2861888
	//_Func: public void step(float dt); @loc=static @len=146 @rva=2861904
	//_Data: this+0x8, Member, Type: class Car *, car
	//_Data: this+0x10, Member, Type: bool, lastGearUp
	//_Data: this+0x11, Member, Type: bool, lastGearDn
	//_Func: public void GearChanger(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct GearChanger {
public:
	bool wasGearUpTriggered;
	bool wasGearDnTriggered;
	Car * car;
	bool lastGearUp;
	bool lastGearDn;
	inline GearChanger() { }
	inline GearChanger(const GearChanger& other) = default;
	inline GearChanger& operator=(const GearChanger& other) = default;
	inline void dtor() { typedef void (GearChanger::*_fpt)(); auto _f=xcast<_fpt>(_drva(96368)); (this->*_f)(); }
	inline void init(Car * car) { typedef void (GearChanger::*_fpt)(Car *); auto _f=xcast<_fpt>(_drva(2861888)); return (this->*_f)(car); }
	inline void step(float dt) { typedef void (GearChanger::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2861904)); return (this->*_f)(dt); }
	inline void _guard_obj() {
		static_assert((sizeof(GearChanger)==24),"bad size");
		static_assert((offsetof(GearChanger,wasGearUpTriggered)==0x0),"bad off");
		static_assert((offsetof(GearChanger,wasGearDnTriggered)==0x1),"bad off");
		static_assert((offsetof(GearChanger,car)==0x8),"bad off");
		static_assert((offsetof(GearChanger,lastGearUp)==0x10),"bad off");
		static_assert((offsetof(GearChanger,lastGearDn)==0x11),"bad off");
	};
};

//UDT: struct AutoShifter @len=40
	//_Func: public void ~AutoShifter(); @loc=static @len=3 @rva=96368
	//_Data: this+0x0, Member, Type: bool, isActive
	//_Data: this+0x4, Member, Type: int, changeUpRpm
	//_Data: this+0x8, Member, Type: int, changeDnRpm
	//_Data: this+0xC, Member, Type: float, slipThreshold
	//_Func: public void init(Car * car); @loc=static @len=44 @rva=2859040
	//_Func: public void step(float dt); @loc=static @len=843 @rva=2861040
	//_Data: this+0x10, Member, Type: class Car *, car
	//_Data: this+0x18, Member, Type: bool, butGearUp
	//_Data: this+0x19, Member, Type: bool, butGearDn
	//_Data: this+0x1C, Member, Type: float, gasCutoff
	//_Data: this+0x20, Member, Type: float, gasCutoffTime
	//_Func: private void loadINI(); @loc=static @len=1946 @rva=2859088
	//_Func: public void AutoShifter(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct AutoShifter {
public:
	bool isActive;
	int changeUpRpm;
	int changeDnRpm;
	float slipThreshold;
	Car * car;
	bool butGearUp;
	bool butGearDn;
	float gasCutoff;
	float gasCutoffTime;
	inline AutoShifter() { }
	inline AutoShifter(const AutoShifter& other) = default;
	inline AutoShifter& operator=(const AutoShifter& other) = default;
	inline void dtor() { typedef void (AutoShifter::*_fpt)(); auto _f=xcast<_fpt>(_drva(96368)); (this->*_f)(); }
	inline void init(Car * car) { typedef void (AutoShifter::*_fpt)(Car *); auto _f=xcast<_fpt>(_drva(2859040)); return (this->*_f)(car); }
	inline void step(float dt) { typedef void (AutoShifter::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2861040)); return (this->*_f)(dt); }
	inline void loadINI() { typedef void (AutoShifter::*_fpt)(); auto _f=xcast<_fpt>(_drva(2859088)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(AutoShifter)==40),"bad size");
		static_assert((offsetof(AutoShifter,isActive)==0x0),"bad off");
		static_assert((offsetof(AutoShifter,changeUpRpm)==0x4),"bad off");
		static_assert((offsetof(AutoShifter,changeDnRpm)==0x8),"bad off");
		static_assert((offsetof(AutoShifter,slipThreshold)==0xC),"bad off");
		static_assert((offsetof(AutoShifter,car)==0x10),"bad off");
		static_assert((offsetof(AutoShifter,butGearUp)==0x18),"bad off");
		static_assert((offsetof(AutoShifter,butGearDn)==0x19),"bad off");
		static_assert((offsetof(AutoShifter,gasCutoff)==0x1C),"bad off");
		static_assert((offsetof(AutoShifter,gasCutoffTime)==0x20),"bad off");
	};
};

//UDT: struct EDL @len=56
	//_Func: public void ~EDL(); @loc=static @len=3 @rva=96368
	//_Data: this+0x0, Member, Type: bool, isPresent
	//_Data: this+0x1, Member, Type: bool, isActive
	//_Data: this+0x4, Member, Type: float, wheelSpeedGainPower
	//_Data: this+0x8, Member, Type: float, wheelSpeedGainCoast
	//_Data: this+0xC, Member, Type: float, deadZonePower
	//_Data: this+0x10, Member, Type: float, deadZoneCoast
	//_Data: this+0x14, Member, Type: float, brakeTorquePower
	//_Data: this+0x18, Member, Type: float, brakeTorqueCoast
	//_Data: this+0x1C, Member, Type: float, outLevel
	//_Data: this+0x20, Member, Type: float, outBrakeTorque
	//_Data: this+0x24, Member, Type: float, speedDiff
	//_Func: public void step(float td); @loc=static @len=414 @rva=2864224
	//_Func: public void init(Car * a_car); @loc=static @len=2145 @rva=2862064
	//_Data: this+0x28, Member, Type: class Car *, car
	//_Data: this+0x30, Member, Type: int, leftTyreIndex
	//_Data: this+0x34, Member, Type: int, rightTyreIndex
	//_Func: public void EDL(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct EDL {
public:
	bool isPresent;
	bool isActive;
	float wheelSpeedGainPower;
	float wheelSpeedGainCoast;
	float deadZonePower;
	float deadZoneCoast;
	float brakeTorquePower;
	float brakeTorqueCoast;
	float outLevel;
	float outBrakeTorque;
	float speedDiff;
	Car * car;
	int leftTyreIndex;
	int rightTyreIndex;
	inline EDL() { }
	inline EDL(const EDL& other) = default;
	inline EDL& operator=(const EDL& other) = default;
	inline void dtor() { typedef void (EDL::*_fpt)(); auto _f=xcast<_fpt>(_drva(96368)); (this->*_f)(); }
	inline void step(float td) { typedef void (EDL::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2864224)); return (this->*_f)(td); }
	inline void init(Car * a_car) { typedef void (EDL::*_fpt)(Car *); auto _f=xcast<_fpt>(_drva(2862064)); return (this->*_f)(a_car); }
	inline void _guard_obj() {
		static_assert((sizeof(EDL)==56),"bad size");
		static_assert((offsetof(EDL,isPresent)==0x0),"bad off");
		static_assert((offsetof(EDL,isActive)==0x1),"bad off");
		static_assert((offsetof(EDL,wheelSpeedGainPower)==0x4),"bad off");
		static_assert((offsetof(EDL,wheelSpeedGainCoast)==0x8),"bad off");
		static_assert((offsetof(EDL,deadZonePower)==0xC),"bad off");
		static_assert((offsetof(EDL,deadZoneCoast)==0x10),"bad off");
		static_assert((offsetof(EDL,brakeTorquePower)==0x14),"bad off");
		static_assert((offsetof(EDL,brakeTorqueCoast)==0x18),"bad off");
		static_assert((offsetof(EDL,outLevel)==0x1C),"bad off");
		static_assert((offsetof(EDL,outBrakeTorque)==0x20),"bad off");
		static_assert((offsetof(EDL,speedDiff)==0x24),"bad off");
		static_assert((offsetof(EDL,car)==0x28),"bad off");
		static_assert((offsetof(EDL,leftTyreIndex)==0x30),"bad off");
		static_assert((offsetof(EDL,rightTyreIndex)==0x34),"bad off");
	};
};

//UDT: struct ksgui::OnScrollBarValueChanged @len=16
	//_Data: this+0x0, Member, Type: class ksgui::ScrollBar *, scrollBar
	//_Data: this+0x8, Member, Type: int, value
//UDT;

struct ksgui_OnScrollBarValueChanged {
public:
	ksgui_ScrollBar * scrollBar;
	int value;
	inline ksgui_OnScrollBarValueChanged() { }
	inline ksgui_OnScrollBarValueChanged(const ksgui_OnScrollBarValueChanged& other) = default;
	inline ksgui_OnScrollBarValueChanged& operator=(const ksgui_OnScrollBarValueChanged& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_OnScrollBarValueChanged)==16),"bad size");
		static_assert((offsetof(ksgui_OnScrollBarValueChanged,scrollBar)==0x0),"bad off");
		static_assert((offsetof(ksgui_OnScrollBarValueChanged,value)==0x8),"bad off");
	};
};

//UDT: struct ServerInfo @len=72
	//_Func: public void ServerInfo(const ServerInfo &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void ServerInfo(); @loc=static @len=127 @rva=243344
	//_Data: this+0x0, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, name
	//_Data: this+0x20, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, ip
	//_Data: this+0x40, Member, Type: unsigned short, httpPort
	//_Data: this+0x42, Member, Type: unsigned short, udpPort
	//_Data: this+0x44, Member, Type: unsigned short, tcpPort
	//_Func: public void ~ServerInfo(); @loc=static @len=88 @rva=776352
	//_Func: public ServerInfo & operator=(const ServerInfo &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct ServerInfo {
public:
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > name;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > ip;
	unsigned short httpPort;
	unsigned short udpPort;
	unsigned short tcpPort;
	inline ServerInfo() { }
	inline ServerInfo(const ServerInfo& other) = default;
	inline ServerInfo& operator=(const ServerInfo& other) = default;
	inline void ctor() { typedef void (ServerInfo::*_fpt)(); auto _f=xcast<_fpt>(_drva(243344)); (this->*_f)(); }
	inline void dtor() { typedef void (ServerInfo::*_fpt)(); auto _f=xcast<_fpt>(_drva(776352)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(ServerInfo)==72),"bad size");
		static_assert((offsetof(ServerInfo,name)==0x0),"bad off");
		static_assert((offsetof(ServerInfo,ip)==0x20),"bad off");
		static_assert((offsetof(ServerInfo,httpPort)==0x40),"bad off");
		static_assert((offsetof(ServerInfo,udpPort)==0x42),"bad off");
		static_assert((offsetof(ServerInfo,tcpPort)==0x44),"bad off");
	};
};

//UDT: struct ksgui::OnControlClicked @len=16
	//_Data: this+0x0, Member, Type: class ksgui::Control *, control
	//_Data: this+0x8, Member, Type: int, localx
	//_Data: this+0xC, Member, Type: int, localy
//UDT;

struct ksgui_OnControlClicked {
public:
	ksgui_Control * control;
	int localx;
	int localy;
	inline ksgui_OnControlClicked() { }
	inline ksgui_OnControlClicked(const ksgui_OnControlClicked& other) = default;
	inline ksgui_OnControlClicked& operator=(const ksgui_OnControlClicked& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_OnControlClicked)==16),"bad size");
		static_assert((offsetof(ksgui_OnControlClicked,control)==0x0),"bad off");
		static_assert((offsetof(ksgui_OnControlClicked,localx)==0x8),"bad off");
		static_assert((offsetof(ksgui_OnControlClicked,localy)==0xC),"bad off");
	};
};

//UDT: struct DriftModeComponent @len=80
	//_Func: public void ~DriftModeComponent(); @loc=static @len=3 @rva=96368
	//_Func: public double getPoints(); @loc=optimized @len=0 @rva=0
	//_Func: public double getInstantPoints(); @loc=optimized @len=0 @rva=0
	//_Func: public bool isExtremeDrifting(); @loc=optimized @len=0 @rva=0
	//_Func: public bool isValid(); @loc=optimized @len=0 @rva=0
	//_Func: public double getCurrentSpeedMult(); @loc=optimized @len=0 @rva=0
	//_Func: public double getCurrentDriftAngle(); @loc=optimized @len=0 @rva=0
	//_Func: public int getComboCounter(); @loc=optimized @len=0 @rva=0
	//_Func: public void init(Car * car); @loc=static @len=380 @rva=2882976
	//_Func: public void step(float dt); @loc=static @len=846 @rva=2883360
	//_Data: this+0x0, Member, Type: class Car *, car
	//_Data: this+0x8, Member, Type: float, driftStraightTimer
	//_Data: this+0x10, Member, Type: double, points
	//_Data: this+0x18, Member, Type: double, instantDrift
	//_Data: this+0x20, Member, Type: double, currentSpeedMultiplier
	//_Data: this+0x28, Member, Type: double, currentDriftAngle
	//_Data: this+0x30, Member, Type: int, comboCounter
	//_Data: this+0x34, Member, Type: int, lastDriftDirection
	//_Data: this+0x38, Member, Type: bool, extremeDrifting
	//_Data: this+0x39, Member, Type: bool, drifting
	//_Data: this+0x3A, Member, Type: bool, invalid
	//_Data: this+0x3C, Member, Type: float[0x5], oldDamageZones
	//_Func: private bool checkExtremeDrifting(); @loc=static @len=321 @rva=2882640
	//_Func: private bool hasCarBeenDamaged(); @loc=optimized @len=0 @rva=0
	//_Func: private void validateDrift(); @loc=static @len=347 @rva=2884208
	//_Func: public void DriftModeComponent(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct DriftModeComponent {
public:
	Car * car;
	float driftStraightTimer;
	double points;
	double instantDrift;
	double currentSpeedMultiplier;
	double currentDriftAngle;
	int comboCounter;
	int lastDriftDirection;
	bool extremeDrifting;
	bool drifting;
	bool invalid;
	float oldDamageZones[5];
	inline DriftModeComponent() { }
	inline DriftModeComponent(const DriftModeComponent& other) = default;
	inline DriftModeComponent& operator=(const DriftModeComponent& other) = default;
	inline void dtor() { typedef void (DriftModeComponent::*_fpt)(); auto _f=xcast<_fpt>(_drva(96368)); (this->*_f)(); }
	inline void init(Car * car) { typedef void (DriftModeComponent::*_fpt)(Car *); auto _f=xcast<_fpt>(_drva(2882976)); return (this->*_f)(car); }
	inline void step(float dt) { typedef void (DriftModeComponent::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2883360)); return (this->*_f)(dt); }
	inline bool checkExtremeDrifting() { typedef bool (DriftModeComponent::*_fpt)(); auto _f=xcast<_fpt>(_drva(2882640)); return (this->*_f)(); }
	inline void validateDrift() { typedef void (DriftModeComponent::*_fpt)(); auto _f=xcast<_fpt>(_drva(2884208)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(DriftModeComponent)==80),"bad size");
		static_assert((offsetof(DriftModeComponent,car)==0x0),"bad off");
		static_assert((offsetof(DriftModeComponent,driftStraightTimer)==0x8),"bad off");
		static_assert((offsetof(DriftModeComponent,points)==0x10),"bad off");
		static_assert((offsetof(DriftModeComponent,instantDrift)==0x18),"bad off");
		static_assert((offsetof(DriftModeComponent,currentSpeedMultiplier)==0x20),"bad off");
		static_assert((offsetof(DriftModeComponent,currentDriftAngle)==0x28),"bad off");
		static_assert((offsetof(DriftModeComponent,comboCounter)==0x30),"bad off");
		static_assert((offsetof(DriftModeComponent,lastDriftDirection)==0x34),"bad off");
		static_assert((offsetof(DriftModeComponent,extremeDrifting)==0x38),"bad off");
		static_assert((offsetof(DriftModeComponent,drifting)==0x39),"bad off");
		static_assert((offsetof(DriftModeComponent,invalid)==0x3A),"bad off");
		static_assert((offsetof(DriftModeComponent,oldDamageZones)==0x3C),"bad off");
	};
};

//UDT: struct SpeedLimiter @len=16
	//_Func: public void ~SpeedLimiter(); @loc=static @len=3 @rva=96368
	//_Func: public void init(Car * car); @loc=static @len=5 @rva=2865408
	//_Func: public void step(float dt); @loc=static @len=247 @rva=2865424
	//_Func: public bool isLimitingSpeed(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: bool, shoudLimit
	//_Data: this+0x1, Member, Type: bool, isLimiting
	//_Data: this+0x8, Member, Type: class Car *, car
	//_Func: public void SpeedLimiter(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct SpeedLimiter {
public:
	bool shoudLimit;
	bool isLimiting;
	Car * car;
	inline SpeedLimiter() { }
	inline SpeedLimiter(const SpeedLimiter& other) = default;
	inline SpeedLimiter& operator=(const SpeedLimiter& other) = default;
	inline void dtor() { typedef void (SpeedLimiter::*_fpt)(); auto _f=xcast<_fpt>(_drva(96368)); (this->*_f)(); }
	inline void init(Car * car) { typedef void (SpeedLimiter::*_fpt)(Car *); auto _f=xcast<_fpt>(_drva(2865408)); return (this->*_f)(car); }
	inline void step(float dt) { typedef void (SpeedLimiter::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2865424)); return (this->*_f)(dt); }
	inline void _guard_obj() {
		static_assert((sizeof(SpeedLimiter)==16),"bad size");
		static_assert((offsetof(SpeedLimiter,shoudLimit)==0x0),"bad off");
		static_assert((offsetof(SpeedLimiter,isLimiting)==0x1),"bad off");
		static_assert((offsetof(SpeedLimiter,car)==0x8),"bad off");
	};
};

//UDT: struct DifferentialSetting @len=16
	//_Data: this+0x0, Member, Type: float, power
	//_Data: this+0x4, Member, Type: float, coast
	//_Data: this+0x8, Member, Type: float, preload
	//_Data: this+0xC, Member, Type: enum DifferentialType, type
	//_Func: public void DifferentialSetting(); @loc=optimized @len=0 @rva=0
//UDT;

struct DifferentialSetting {
public:
	float power;
	float coast;
	float preload;
	DifferentialType type;
	inline DifferentialSetting() { }
	inline DifferentialSetting(const DifferentialSetting& other) = default;
	inline DifferentialSetting& operator=(const DifferentialSetting& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(DifferentialSetting)==16),"bad size");
		static_assert((offsetof(DifferentialSetting,power)==0x0),"bad off");
		static_assert((offsetof(DifferentialSetting,coast)==0x4),"bad off");
		static_assert((offsetof(DifferentialSetting,preload)==0x8),"bad off");
		static_assert((offsetof(DifferentialSetting,type)==0xC),"bad off");
	};
};

//UDT: struct GearRequestStatus @len=32
	//_Func: public void GearRequestStatus(); @loc=optimized @len=0 @rva=0
	//_Func: public bool setRequest(GearChangeRequest  _arg0, double  _arg1, int  _arg2); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: enum GearChangeRequest, request
	//_Data: this+0x8, Member, Type: double, timeAccumulator
	//_Data: this+0x10, Member, Type: double, timeout
	//_Data: this+0x18, Member, Type: int, requestedGear
//UDT;

struct GearRequestStatus {
public:
	GearChangeRequest request;
	double timeAccumulator;
	double timeout;
	int requestedGear;
	inline GearRequestStatus() { }
	inline GearRequestStatus(const GearRequestStatus& other) = default;
	inline GearRequestStatus& operator=(const GearRequestStatus& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(GearRequestStatus)==32),"bad size");
		static_assert((offsetof(GearRequestStatus,request)==0x0),"bad off");
		static_assert((offsetof(GearRequestStatus,timeAccumulator)==0x8),"bad off");
		static_assert((offsetof(GearRequestStatus,timeout)==0x10),"bad off");
		static_assert((offsetof(GearRequestStatus,requestedGear)==0x18),"bad off");
	};
};

//UDT: struct ksgui::OnCutExtremesChanged @len=16
	//_Data: this+0x0, Member, Type: class ksgui::Slider *, slider
	//_Data: this+0x8, Member, Type: float, cutIn
	//_Data: this+0xC, Member, Type: float, cutOut
//UDT;

struct ksgui_OnCutExtremesChanged {
public:
	ksgui_Slider * slider;
	float cutIn;
	float cutOut;
	inline ksgui_OnCutExtremesChanged() { }
	inline ksgui_OnCutExtremesChanged(const ksgui_OnCutExtremesChanged& other) = default;
	inline ksgui_OnCutExtremesChanged& operator=(const ksgui_OnCutExtremesChanged& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_OnCutExtremesChanged)==16),"bad size");
		static_assert((offsetof(ksgui_OnCutExtremesChanged,slider)==0x0),"bad off");
		static_assert((offsetof(ksgui_OnCutExtremesChanged,cutIn)==0x8),"bad off");
		static_assert((offsetof(ksgui_OnCutExtremesChanged,cutOut)==0xC),"bad off");
	};
};

//UDT: struct SGearRatio @len=40
	//_Func: public void SGearRatio(const SGearRatio &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void SGearRatio(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * iname, double iratio); @loc=static @len=173 @rva=2514800
	//_Data: this+0x0, Member, Type: double, ratio
	//_Data: this+0x8, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, name
	//_Func: public void ~SGearRatio(); @loc=static @len=49 @rva=2180672
	//_Func: public SGearRatio & operator=(const SGearRatio &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct SGearRatio {
public:
	double ratio;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > name;
	inline SGearRatio() { }
	inline SGearRatio(const SGearRatio& other) = default;
	inline SGearRatio& operator=(const SGearRatio& other) = default;
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * iname, double iratio) { typedef void (SGearRatio::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, double); auto _f=xcast<_fpt>(_drva(2514800)); (this->*_f)(iname, iratio); }
	inline void dtor() { typedef void (SGearRatio::*_fpt)(); auto _f=xcast<_fpt>(_drva(2180672)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(SGearRatio)==40),"bad size");
		static_assert((offsetof(SGearRatio,ratio)==0x0),"bad off");
		static_assert((offsetof(SGearRatio,name)==0x8),"bad off");
	};
};

//UDT: struct OnReplayStatusChanged @len=12
	//_Func: public void OnReplayStatusChanged(eReplayStatus  _arg0, float  _arg1, float  _arg2); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: enum eReplayStatus, status
	//_Data: this+0x4, Member, Type: float, timeMult
	//_Data: this+0x8, Member, Type: float, slowMotionLevel
//UDT;

struct OnReplayStatusChanged {
public:
	eReplayStatus status;
	float timeMult;
	float slowMotionLevel;
	inline OnReplayStatusChanged() { }
	inline OnReplayStatusChanged(const OnReplayStatusChanged& other) = default;
	inline OnReplayStatusChanged& operator=(const OnReplayStatusChanged& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(OnReplayStatusChanged)==12),"bad size");
		static_assert((offsetof(OnReplayStatusChanged,status)==0x0),"bad off");
		static_assert((offsetof(OnReplayStatusChanged,timeMult)==0x4),"bad off");
		static_assert((offsetof(OnReplayStatusChanged,slowMotionLevel)==0x8),"bad off");
	};
};

//UDT: struct DriverInfo @len=128
	//_Data: this+0x0, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, name
	//_Data: this+0x20, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, team
	//_Data: this+0x40, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, nationality
	//_Data: this+0x60, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, nationCode
	//_Func: public void DriverInfo(const DriverInfo & __that); @loc=static @len=192 @rva=242096
	//_Func: public void DriverInfo(); @loc=static @len=69 @rva=242288
	//_Func: public void ~DriverInfo(); @loc=static @len=152 @rva=246464
	//_Func: public DriverInfo & operator=(const DriverInfo & __that); @loc=static @len=122 @rva=848192
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct DriverInfo {
public:
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > name;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > team;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > nationality;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > nationCode;
	inline DriverInfo() { }
	inline DriverInfo(const DriverInfo& other) = default;
	inline DriverInfo& operator=(const DriverInfo& other) = default;
	inline void ctor(const DriverInfo & __that) { typedef void (DriverInfo::*_fpt)(const DriverInfo &); auto _f=xcast<_fpt>(_drva(242096)); (this->*_f)(__that); }
	inline void ctor() { typedef void (DriverInfo::*_fpt)(); auto _f=xcast<_fpt>(_drva(242288)); (this->*_f)(); }
	inline void dtor() { typedef void (DriverInfo::*_fpt)(); auto _f=xcast<_fpt>(_drva(246464)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(DriverInfo)==128),"bad size");
		static_assert((offsetof(DriverInfo,name)==0x0),"bad off");
		static_assert((offsetof(DriverInfo,team)==0x20),"bad off");
		static_assert((offsetof(DriverInfo,nationality)==0x40),"bad off");
		static_assert((offsetof(DriverInfo,nationCode)==0x60),"bad off");
	};
};

//UDT: struct ReceivedVoteDef @len=28
	//_Data: this+0x0, Member, Type: enum VoteType, voteType
	//_Data: this+0x4, Member, Type: int, quorum
	//_Data: this+0x8, Member, Type: int, votes
	//_Data: this+0xC, Member, Type: int, timeLeftMS
	//_Data: this+0x10, Member, Type: int, lastVoterSessionID
	//_Data: this+0x14, Member, Type: int, lastVoterVote
	//_Data: this+0x18, Member, Type: unsigned char, targetSessionID
	//_Data: this+0x19, Member, Type: bool, isMe
	//_Func: public void ReceivedVoteDef(); @loc=static @len=25 @rva=242528
//UDT;

struct ReceivedVoteDef {
public:
	VoteType voteType;
	int quorum;
	int votes;
	int timeLeftMS;
	int lastVoterSessionID;
	int lastVoterVote;
	unsigned char targetSessionID;
	bool isMe;
	inline ReceivedVoteDef() { }
	inline ReceivedVoteDef(const ReceivedVoteDef& other) = default;
	inline ReceivedVoteDef& operator=(const ReceivedVoteDef& other) = default;
	inline void ctor() { typedef void (ReceivedVoteDef::*_fpt)(); auto _f=xcast<_fpt>(_drva(242528)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(ReceivedVoteDef)==28),"bad size");
		static_assert((offsetof(ReceivedVoteDef,voteType)==0x0),"bad off");
		static_assert((offsetof(ReceivedVoteDef,quorum)==0x4),"bad off");
		static_assert((offsetof(ReceivedVoteDef,votes)==0x8),"bad off");
		static_assert((offsetof(ReceivedVoteDef,timeLeftMS)==0xC),"bad off");
		static_assert((offsetof(ReceivedVoteDef,lastVoterSessionID)==0x10),"bad off");
		static_assert((offsetof(ReceivedVoteDef,lastVoterVote)==0x14),"bad off");
		static_assert((offsetof(ReceivedVoteDef,targetSessionID)==0x18),"bad off");
		static_assert((offsetof(ReceivedVoteDef,isMe)==0x19),"bad off");
	};
};

//UDT: struct DrivableCameraDef @len=56
	//_Func: public void DrivableCameraDef(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: class vec3f, bumperCameraPos
	//_Data: this+0xC, Member, Type: float, bumperCameraPitch
	//_Data: this+0x10, Member, Type: class vec3f, bonnetCameraPos
	//_Data: this+0x1C, Member, Type: float, bonnetCameraPitch
	//_Data: this+0x20, Member, Type: float, chaseCameraPitch
	//_Data: this+0x24, Member, Type: class vec3f, dashCameraPos
	//_Data: this+0x30, Member, Type: float, rotationOffset
	//_Data: this+0x34, Member, Type: bool, bumperExternalSound
	//_Data: this+0x35, Member, Type: bool, bonnetExternalSound
//UDT;

struct DrivableCameraDef {
public:
	vec3f bumperCameraPos;
	float bumperCameraPitch;
	vec3f bonnetCameraPos;
	float bonnetCameraPitch;
	float chaseCameraPitch;
	vec3f dashCameraPos;
	float rotationOffset;
	bool bumperExternalSound;
	bool bonnetExternalSound;
	inline DrivableCameraDef() { }
	inline DrivableCameraDef(const DrivableCameraDef& other) = default;
	inline DrivableCameraDef& operator=(const DrivableCameraDef& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(DrivableCameraDef)==56),"bad size");
		static_assert((offsetof(DrivableCameraDef,bumperCameraPos)==0x0),"bad off");
		static_assert((offsetof(DrivableCameraDef,bumperCameraPitch)==0xC),"bad off");
		static_assert((offsetof(DrivableCameraDef,bonnetCameraPos)==0x10),"bad off");
		static_assert((offsetof(DrivableCameraDef,bonnetCameraPitch)==0x1C),"bad off");
		static_assert((offsetof(DrivableCameraDef,chaseCameraPitch)==0x20),"bad off");
		static_assert((offsetof(DrivableCameraDef,dashCameraPos)==0x24),"bad off");
		static_assert((offsetof(DrivableCameraDef,rotationOffset)==0x30),"bad off");
		static_assert((offsetof(DrivableCameraDef,bumperExternalSound)==0x34),"bad off");
		static_assert((offsetof(DrivableCameraDef,bonnetExternalSound)==0x35),"bad off");
	};
};

//UDT: struct TyreThermalPatch @len=40
	//_Func: public void TyreThermalPatch(const TyreThermalPatch &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void TyreThermalPatch(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: class std::vector<TyreThermalPatch *,std::allocator<TyreThermalPatch *> >, connections
	//_Data: this+0x18, Member, Type: float, T
	//_Data: this+0x1C, Member, Type: float, inputT
	//_Data: this+0x20, Member, Type: int, elementIndex
	//_Data: this+0x24, Member, Type: int, stripeIndex
	//_Func: public void ~TyreThermalPatch(); @loc=optimized @len=0 @rva=0
	//_Func: public TyreThermalPatch & operator=(const TyreThermalPatch &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct TyreThermalPatch {
public:
	std::vector<TyreThermalPatch *,std::allocator<TyreThermalPatch *> > connections;
	float T;
	float inputT;
	int elementIndex;
	int stripeIndex;
	inline TyreThermalPatch() { }
	inline TyreThermalPatch(const TyreThermalPatch& other) = default;
	inline TyreThermalPatch& operator=(const TyreThermalPatch& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(TyreThermalPatch)==40),"bad size");
		static_assert((offsetof(TyreThermalPatch,connections)==0x0),"bad off");
		static_assert((offsetof(TyreThermalPatch,T)==0x18),"bad off");
		static_assert((offsetof(TyreThermalPatch,inputT)==0x1C),"bad off");
		static_assert((offsetof(TyreThermalPatch,elementIndex)==0x20),"bad off");
		static_assert((offsetof(TyreThermalPatch,stripeIndex)==0x24),"bad off");
	};
};

//UDT: struct OnLapCompletedEvent @len=56
	//_Func: public void OnLapCompletedEvent(const OnLapCompletedEvent &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void OnLapCompletedEvent(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: unsigned int, carIndex
	//_Data: this+0x4, Member, Type: unsigned int, lapTime
	//_Data: this+0x8, Member, Type: unsigned int, lapCount
	//_Data: this+0x10, Member, Type: class std::vector<unsigned int,std::allocator<unsigned int> >, splits
	//_Data: this+0x28, Member, Type: double, eventTime
	//_Data: this+0x30, Member, Type: bool, isValid
	//_Data: this+0x34, Member, Type: int, cuts
	//_Func: public void ~OnLapCompletedEvent(); @loc=static @len=53 @rva=246720
	//_Func: public OnLapCompletedEvent & operator=(const OnLapCompletedEvent &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct OnLapCompletedEvent {
public:
	unsigned int carIndex;
	unsigned int lapTime;
	unsigned int lapCount;
	std::vector<unsigned int,std::allocator<unsigned int> > splits;
	double eventTime;
	bool isValid;
	int cuts;
	inline OnLapCompletedEvent() { }
	inline OnLapCompletedEvent(const OnLapCompletedEvent& other) = default;
	inline OnLapCompletedEvent& operator=(const OnLapCompletedEvent& other) = default;
	inline void dtor() { typedef void (OnLapCompletedEvent::*_fpt)(); auto _f=xcast<_fpt>(_drva(246720)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(OnLapCompletedEvent)==56),"bad size");
		static_assert((offsetof(OnLapCompletedEvent,carIndex)==0x0),"bad off");
		static_assert((offsetof(OnLapCompletedEvent,lapTime)==0x4),"bad off");
		static_assert((offsetof(OnLapCompletedEvent,lapCount)==0x8),"bad off");
		static_assert((offsetof(OnLapCompletedEvent,splits)==0x10),"bad off");
		static_assert((offsetof(OnLapCompletedEvent,eventTime)==0x28),"bad off");
		static_assert((offsetof(OnLapCompletedEvent,isValid)==0x30),"bad off");
		static_assert((offsetof(OnLapCompletedEvent,cuts)==0x34),"bad off");
	};
};

//UDT: struct ksgui::OnSpinnerValueChanged @len=16
	//_Data: this+0x0, Member, Type: class ksgui::Spinner *, spinner
	//_Data: this+0x8, Member, Type: int, value
//UDT;

struct ksgui_OnSpinnerValueChanged {
public:
	ksgui_Spinner * spinner;
	int value;
	inline ksgui_OnSpinnerValueChanged() { }
	inline ksgui_OnSpinnerValueChanged(const ksgui_OnSpinnerValueChanged& other) = default;
	inline ksgui_OnSpinnerValueChanged& operator=(const ksgui_OnSpinnerValueChanged& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_OnSpinnerValueChanged)==16),"bad size");
		static_assert((offsetof(ksgui_OnSpinnerValueChanged,spinner)==0x0),"bad off");
		static_assert((offsetof(ksgui_OnSpinnerValueChanged,value)==0x8),"bad off");
	};
};

//UDT: class FileChangeObserver @len=48
	//_Func: public void FileChangeObserver(const FileChangeObserver &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void FileChangeObserver(); @loc=optimized @len=0 @rva=0
	//_Func: public void FileChangeObserver(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & a_filename); @loc=static @len=55 @rva=2339840
	//_Func: public void ~FileChangeObserver(); @loc=static @len=49 @rva=2180672
	//_Func: public bool hasChanged(); @loc=static @len=47 @rva=2339904
	//_Func: public void reset(); @loc=static @len=162 @rva=2340144
	//_Func: public void observe(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & a_filename); @loc=static @len=191 @rva=2339952
	//_Data: this+0x0, Member, Type: struct _FILETIME, lastFileTime
	//_Data: this+0x8, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, filename
	//_Data: this+0x28, Member, Type: unsigned long, lastChanged
	//_Func: private bool getFileTime(_FILETIME &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public FileChangeObserver & operator=(const FileChangeObserver &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class FileChangeObserver {
public:
	_FILETIME lastFileTime;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > filename;
	unsigned long lastChanged;
	inline FileChangeObserver() { }
	inline FileChangeObserver(const FileChangeObserver& other) = default;
	inline FileChangeObserver& operator=(const FileChangeObserver& other) = default;
	inline void ctor(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & a_filename) { typedef void (FileChangeObserver::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2339840)); (this->*_f)(a_filename); }
	inline void dtor() { typedef void (FileChangeObserver::*_fpt)(); auto _f=xcast<_fpt>(_drva(2180672)); (this->*_f)(); }
	inline bool hasChanged() { typedef bool (FileChangeObserver::*_fpt)(); auto _f=xcast<_fpt>(_drva(2339904)); return (this->*_f)(); }
	inline void reset() { typedef void (FileChangeObserver::*_fpt)(); auto _f=xcast<_fpt>(_drva(2340144)); return (this->*_f)(); }
	inline void observe(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & a_filename) { typedef void (FileChangeObserver::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2339952)); return (this->*_f)(a_filename); }
	inline void _guard_obj() {
		static_assert((sizeof(FileChangeObserver)==48),"bad size");
		static_assert((offsetof(FileChangeObserver,lastFileTime)==0x0),"bad off");
		static_assert((offsetof(FileChangeObserver,filename)==0x8),"bad off");
		static_assert((offsetof(FileChangeObserver,lastChanged)==0x28),"bad off");
	};
};

//UDT: struct TimeLineStatus @len=12
	//_Func: public void TimeLineStatus(); @loc=optimized @len=0 @rva=0
	//_Func: public void reset(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: bool, isValid
	//_Data: this+0x4, Member, Type: enum eTimeLineCheckResponse, lastResponse
	//_Data: this+0x8, Member, Type: unsigned int, lastTime
//UDT;

struct TimeLineStatus {
public:
	bool isValid;
	eTimeLineCheckResponse lastResponse;
	unsigned int lastTime;
	inline TimeLineStatus() { }
	inline TimeLineStatus(const TimeLineStatus& other) = default;
	inline TimeLineStatus& operator=(const TimeLineStatus& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(TimeLineStatus)==12),"bad size");
		static_assert((offsetof(TimeLineStatus,isValid)==0x0),"bad off");
		static_assert((offsetof(TimeLineStatus,lastResponse)==0x4),"bad off");
		static_assert((offsetof(TimeLineStatus,lastTime)==0x8),"bad off");
	};
};

//UDT: struct OnWindowResizeEvent @len=16
	//_Func: public void OnWindowResizeEvent(int  _arg0, int  _arg1, RenderWindow *  _arg2); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: int, width
	//_Data: this+0x4, Member, Type: int, height
	//_Data: this+0x8, Member, Type: class RenderWindow *, renderWindow
//UDT;

struct OnWindowResizeEvent {
public:
	int width;
	int height;
	RenderWindow * renderWindow;
	inline OnWindowResizeEvent() { }
	inline OnWindowResizeEvent(const OnWindowResizeEvent& other) = default;
	inline OnWindowResizeEvent& operator=(const OnWindowResizeEvent& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(OnWindowResizeEvent)==16),"bad size");
		static_assert((offsetof(OnWindowResizeEvent,width)==0x0),"bad off");
		static_assert((offsetof(OnWindowResizeEvent,height)==0x4),"bad off");
		static_assert((offsetof(OnWindowResizeEvent,renderWindow)==0x8),"bad off");
	};
};

//UDT: struct KGLShaderCBuffer @len=40
	//_Data: this+0x0, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, cBufferName
	//_Data: this+0x20, Member, Type: unsigned int, size
	//_Data: this+0x24, Member, Type: unsigned int, slot
	//_Func: public void KGLShaderCBuffer(const KGLShaderCBuffer &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void KGLShaderCBuffer(); @loc=optimized @len=0 @rva=0
	//_Func: public void ~KGLShaderCBuffer(); @loc=static @len=48 @rva=113184
	//_Func: public KGLShaderCBuffer & operator=(const KGLShaderCBuffer &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct KGLShaderCBuffer {
public:
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > cBufferName;
	unsigned int size;
	unsigned int slot;
	inline KGLShaderCBuffer() { }
	inline KGLShaderCBuffer(const KGLShaderCBuffer& other) = default;
	inline KGLShaderCBuffer& operator=(const KGLShaderCBuffer& other) = default;
	inline void dtor() { typedef void (KGLShaderCBuffer::*_fpt)(); auto _f=xcast<_fpt>(_drva(113184)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(KGLShaderCBuffer)==40),"bad size");
		static_assert((offsetof(KGLShaderCBuffer,cBufferName)==0x0),"bad off");
		static_assert((offsetof(KGLShaderCBuffer,size)==0x20),"bad off");
		static_assert((offsetof(KGLShaderCBuffer,slot)==0x24),"bad off");
	};
};

//UDT: struct PenaltyRecord @len=12
	//_Func: public void PenaltyRecord(unsigned int  _arg0, unsigned int  _arg1, PenaltyDescription  _arg2); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: unsigned int, lap
	//_Data: this+0x4, Member, Type: unsigned int, seconds
	//_Data: this+0x8, Member, Type: enum PenaltyDescription, descr
//UDT;

struct PenaltyRecord {
public:
	unsigned int lap;
	unsigned int seconds;
	PenaltyDescription descr;
	inline PenaltyRecord() { }
	inline PenaltyRecord(const PenaltyRecord& other) = default;
	inline PenaltyRecord& operator=(const PenaltyRecord& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(PenaltyRecord)==12),"bad size");
		static_assert((offsetof(PenaltyRecord,lap)==0x0),"bad off");
		static_assert((offsetof(PenaltyRecord,seconds)==0x4),"bad off");
		static_assert((offsetof(PenaltyRecord,descr)==0x8),"bad off");
	};
};

//UDT: struct AISplinePayload @len=84
	//_Func: public void AISplinePayload(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: float, speedMS
	//_Data: this+0x4, Member, Type: float, radius
	//_Data: this+0x8, Member, Type: float[0x2], sides
	//_Data: this+0x10, Member, Type: float, camber
	//_Data: this+0x14, Member, Type: float, direction
	//_Data: this+0x18, Member, Type: class vec3f, normal
	//_Data: this+0x24, Member, Type: class vec3f, forwardVector
	//_Data: this+0x30, Member, Type: float, length
	//_Data: this+0x34, Member, Type: float, gas
	//_Data: this+0x38, Member, Type: float, brake
	//_Data: this+0x3C, Member, Type: float, grade
	//_Data: this+0x40, Member, Type: float, grip
	//_Data: this+0x44, Member, Type: float, distFromCorner
	//_Data: this+0x48, Member, Type: float, distFromNextCorner
	//_Data: this+0x4C, Member, Type: bool, isPitlane
	//_Data: this+0x50, Member, Type: float, compression
//UDT;

struct AISplinePayload {
public:
	float speedMS;
	float radius;
	float sides[2];
	float camber;
	float direction;
	vec3f normal;
	vec3f forwardVector;
	float length;
	float gas;
	float brake;
	float grade;
	float grip;
	float distFromCorner;
	float distFromNextCorner;
	bool isPitlane;
	float compression;
	inline AISplinePayload() { }
	inline AISplinePayload(const AISplinePayload& other) = default;
	inline AISplinePayload& operator=(const AISplinePayload& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(AISplinePayload)==84),"bad size");
		static_assert((offsetof(AISplinePayload,speedMS)==0x0),"bad off");
		static_assert((offsetof(AISplinePayload,radius)==0x4),"bad off");
		static_assert((offsetof(AISplinePayload,sides)==0x8),"bad off");
		static_assert((offsetof(AISplinePayload,camber)==0x10),"bad off");
		static_assert((offsetof(AISplinePayload,direction)==0x14),"bad off");
		static_assert((offsetof(AISplinePayload,normal)==0x18),"bad off");
		static_assert((offsetof(AISplinePayload,forwardVector)==0x24),"bad off");
		static_assert((offsetof(AISplinePayload,length)==0x30),"bad off");
		static_assert((offsetof(AISplinePayload,gas)==0x34),"bad off");
		static_assert((offsetof(AISplinePayload,brake)==0x38),"bad off");
		static_assert((offsetof(AISplinePayload,grade)==0x3C),"bad off");
		static_assert((offsetof(AISplinePayload,grip)==0x40),"bad off");
		static_assert((offsetof(AISplinePayload,distFromCorner)==0x44),"bad off");
		static_assert((offsetof(AISplinePayload,distFromNextCorner)==0x48),"bad off");
		static_assert((offsetof(AISplinePayload,isPitlane)==0x4C),"bad off");
		static_assert((offsetof(AISplinePayload,compression)==0x50),"bad off");
	};
};

//UDT: struct GridElement @len=24
	//_Func: public void GridElement(const GridElement &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void GridElement(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: class std::vector<unsigned int,std::allocator<unsigned int> >, closestIndices
	//_Func: public void ~GridElement(); @loc=static @len=41 @rva=2731104
	//_Func: public GridElement & operator=(const GridElement &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct GridElement {
public:
	std::vector<unsigned int,std::allocator<unsigned int> > closestIndices;
	inline GridElement() { }
	inline GridElement(const GridElement& other) = default;
	inline GridElement& operator=(const GridElement& other) = default;
	inline void dtor() { typedef void (GridElement::*_fpt)(); auto _f=xcast<_fpt>(_drva(2731104)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(GridElement)==24),"bad size");
		static_assert((offsetof(GridElement,closestIndices)==0x0),"bad off");
	};
};

//UDT: struct CarCollisionBounds @len=40
	//_Data: this+0x0, Member, Type: class vec3f, min
	//_Data: this+0xC, Member, Type: class vec3f, max
	//_Data: this+0x18, Member, Type: float, length
	//_Data: this+0x1C, Member, Type: float, width
	//_Data: this+0x20, Member, Type: float, lengthFront
	//_Data: this+0x24, Member, Type: float, lengthRear
	//_Func: public void CarCollisionBounds(); @loc=optimized @len=0 @rva=0
//UDT;

struct CarCollisionBounds {
public:
	vec3f min;
	vec3f max;
	float length;
	float width;
	float lengthFront;
	float lengthRear;
	inline CarCollisionBounds() { }
	inline CarCollisionBounds(const CarCollisionBounds& other) = default;
	inline CarCollisionBounds& operator=(const CarCollisionBounds& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(CarCollisionBounds)==40),"bad size");
		static_assert((offsetof(CarCollisionBounds,min)==0x0),"bad off");
		static_assert((offsetof(CarCollisionBounds,max)==0xC),"bad off");
		static_assert((offsetof(CarCollisionBounds,length)==0x18),"bad off");
		static_assert((offsetof(CarCollisionBounds,width)==0x1C),"bad off");
		static_assert((offsetof(CarCollisionBounds,lengthFront)==0x20),"bad off");
		static_assert((offsetof(CarCollisionBounds,lengthRear)==0x24),"bad off");
	};
};

//UDT: struct FuelLapEvaluator @len=72
	//_Func: public void ~FuelLapEvaluator(); @loc=static @len=3 @rva=96368
	//_Func: public float getFuelLaps(); @loc=static @len=43 @rva=2675296
	//_Func: public void setIgnoreLap(bool value); @loc=static @len=4 @rva=2675536
	//_Func: public void init(Car * icar); @loc=static @len=145 @rva=2675376
	//_Func: public float getFuelPerLap(); @loc=static @len=26 @rva=2675344
	//_Func: public float getKmPerLiter(); @loc=optimized @len=0 @rva=0
	//_Func: public float getTotalKM(); @loc=optimized @len=0 @rva=0
	//_Func: public void step(float dt); @loc=static @len=152 @rva=2675552
	//_Data: this+0x0, Member, Type: class Car *, car
	//_Data: this+0x8, Member, Type: int, lapCount
	//_Data: this+0x10, Member, Type: double, lapStartFuel
	//_Data: this+0x18, Member, Type: double, fuelPerLap
	//_Data: this+0x20, Member, Type: double, totalM
	//_Data: this+0x28, Member, Type: double, totalLiters
	//_Data: this+0x30, Member, Type: double, startFuel
	//_Data: this+0x38, Member, Type: double, oldFuelPerLap
	//_Data: this+0x40, Member, Type: bool, ignoreLap
	//_Func: public void FuelLapEvaluator(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct FuelLapEvaluator {
public:
	Car * car;
	int lapCount;
	double lapStartFuel;
	double fuelPerLap;
	double totalM;
	double totalLiters;
	double startFuel;
	double oldFuelPerLap;
	bool ignoreLap;
	inline FuelLapEvaluator() { }
	inline FuelLapEvaluator(const FuelLapEvaluator& other) = default;
	inline FuelLapEvaluator& operator=(const FuelLapEvaluator& other) = default;
	inline void dtor() { typedef void (FuelLapEvaluator::*_fpt)(); auto _f=xcast<_fpt>(_drva(96368)); (this->*_f)(); }
	inline float getFuelLaps() { typedef float (FuelLapEvaluator::*_fpt)(); auto _f=xcast<_fpt>(_drva(2675296)); return (this->*_f)(); }
	inline void setIgnoreLap(bool value) { typedef void (FuelLapEvaluator::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(2675536)); return (this->*_f)(value); }
	inline void init(Car * icar) { typedef void (FuelLapEvaluator::*_fpt)(Car *); auto _f=xcast<_fpt>(_drva(2675376)); return (this->*_f)(icar); }
	inline float getFuelPerLap() { typedef float (FuelLapEvaluator::*_fpt)(); auto _f=xcast<_fpt>(_drva(2675344)); return (this->*_f)(); }
	inline void step(float dt) { typedef void (FuelLapEvaluator::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2675552)); return (this->*_f)(dt); }
	inline void _guard_obj() {
		static_assert((sizeof(FuelLapEvaluator)==72),"bad size");
		static_assert((offsetof(FuelLapEvaluator,car)==0x0),"bad off");
		static_assert((offsetof(FuelLapEvaluator,lapCount)==0x8),"bad off");
		static_assert((offsetof(FuelLapEvaluator,lapStartFuel)==0x10),"bad off");
		static_assert((offsetof(FuelLapEvaluator,fuelPerLap)==0x18),"bad off");
		static_assert((offsetof(FuelLapEvaluator,totalM)==0x20),"bad off");
		static_assert((offsetof(FuelLapEvaluator,totalLiters)==0x28),"bad off");
		static_assert((offsetof(FuelLapEvaluator,startFuel)==0x30),"bad off");
		static_assert((offsetof(FuelLapEvaluator,oldFuelPerLap)==0x38),"bad off");
		static_assert((offsetof(FuelLapEvaluator,ignoreLap)==0x40),"bad off");
	};
};

//UDT: struct TrackAvatar::SectorDescription @len=40
	//_Data: this+0x0, Member, Type: float, in
	//_Data: this+0x4, Member, Type: float, out
	//_Data: this+0x8, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, text
	//_Func: public void SectorDescription(const TrackAvatar_SectorDescription &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void SectorDescription(); @loc=optimized @len=0 @rva=0
	//_Func: public void ~SectorDescription(); @loc=static @len=49 @rva=2180672
	//_Func: public TrackAvatar_SectorDescription & operator=(const TrackAvatar_SectorDescription &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct TrackAvatar_SectorDescription {
public:
	float in;
	float out;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > text;
	inline TrackAvatar_SectorDescription() { }
	inline TrackAvatar_SectorDescription(const TrackAvatar_SectorDescription& other) = default;
	inline TrackAvatar_SectorDescription& operator=(const TrackAvatar_SectorDescription& other) = default;
	inline void dtor() { typedef void (TrackAvatar_SectorDescription::*_fpt)(); auto _f=xcast<_fpt>(_drva(2180672)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(TrackAvatar_SectorDescription)==40),"bad size");
		static_assert((offsetof(TrackAvatar_SectorDescription,in)==0x0),"bad off");
		static_assert((offsetof(TrackAvatar_SectorDescription,out)==0x4),"bad off");
		static_assert((offsetof(TrackAvatar_SectorDescription,text)==0x8),"bad off");
	};
};

//UDT: struct AIState @len=60
	//_Func: public void AIState(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: float, currentSteerSignal
	//_Data: this+0x4, Member, Type: class vec3f, steerTarget
	//_Data: this+0x10, Member, Type: float, gasBrakeTarget
	//_Data: this+0x14, Member, Type: bool, isActive
	//_Data: this+0x18, Member, Type: float, targetSpeed
	//_Data: this+0x1C, Member, Type: float, targetLateralOffset
	//_Data: this+0x20, Member, Type: float, brakeTargetSpeed
	//_Data: this+0x24, Member, Type: float, brakeTargetDist
	//_Data: this+0x28, Member, Type: float, currentNormalizedSplinePosition
	//_Data: this+0x2C, Member, Type: float, outsideOffset
	//_Data: this+0x30, Member, Type: float, projDNRPM
	//_Data: this+0x34, Member, Type: float, understeerFactor
	//_Data: this+0x38, Member, Type: float, currentPush
//UDT;

struct AIState {
public:
	float currentSteerSignal;
	vec3f steerTarget;
	float gasBrakeTarget;
	bool isActive;
	float targetSpeed;
	float targetLateralOffset;
	float brakeTargetSpeed;
	float brakeTargetDist;
	float currentNormalizedSplinePosition;
	float outsideOffset;
	float projDNRPM;
	float understeerFactor;
	float currentPush;
	inline AIState() { }
	inline AIState(const AIState& other) = default;
	inline AIState& operator=(const AIState& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(AIState)==60),"bad size");
		static_assert((offsetof(AIState,currentSteerSignal)==0x0),"bad off");
		static_assert((offsetof(AIState,steerTarget)==0x4),"bad off");
		static_assert((offsetof(AIState,gasBrakeTarget)==0x10),"bad off");
		static_assert((offsetof(AIState,isActive)==0x14),"bad off");
		static_assert((offsetof(AIState,targetSpeed)==0x18),"bad off");
		static_assert((offsetof(AIState,targetLateralOffset)==0x1C),"bad off");
		static_assert((offsetof(AIState,brakeTargetSpeed)==0x20),"bad off");
		static_assert((offsetof(AIState,brakeTargetDist)==0x24),"bad off");
		static_assert((offsetof(AIState,currentNormalizedSplinePosition)==0x28),"bad off");
		static_assert((offsetof(AIState,outsideOffset)==0x2C),"bad off");
		static_assert((offsetof(AIState,projDNRPM)==0x30),"bad off");
		static_assert((offsetof(AIState,understeerFactor)==0x34),"bad off");
		static_assert((offsetof(AIState,currentPush)==0x38),"bad off");
	};
};

//UDT: struct OnTyreCompoundChanged @len=72
	//_Data: this+0x0, Member, Type: int, tyreIndex
	//_Data: this+0x4, Member, Type: int, compoundIndex
	//_Data: this+0x8, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, compoundName
	//_Data: this+0x28, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, shortName
	//_Func: public void OnTyreCompoundChanged(const OnTyreCompoundChanged &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void OnTyreCompoundChanged(); @loc=optimized @len=0 @rva=0
	//_Func: public void ~OnTyreCompoundChanged(); @loc=static @len=90 @rva=847584
	//_Func: public OnTyreCompoundChanged & operator=(const OnTyreCompoundChanged &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct OnTyreCompoundChanged {
public:
	int tyreIndex;
	int compoundIndex;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > compoundName;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > shortName;
	inline OnTyreCompoundChanged() { }
	inline OnTyreCompoundChanged(const OnTyreCompoundChanged& other) = default;
	inline OnTyreCompoundChanged& operator=(const OnTyreCompoundChanged& other) = default;
	inline void dtor() { typedef void (OnTyreCompoundChanged::*_fpt)(); auto _f=xcast<_fpt>(_drva(847584)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(OnTyreCompoundChanged)==72),"bad size");
		static_assert((offsetof(OnTyreCompoundChanged,tyreIndex)==0x0),"bad off");
		static_assert((offsetof(OnTyreCompoundChanged,compoundIndex)==0x4),"bad off");
		static_assert((offsetof(OnTyreCompoundChanged,compoundName)==0x8),"bad off");
		static_assert((offsetof(OnTyreCompoundChanged,shortName)==0x28),"bad off");
	};
};

//UDT: class ShaderResource @len=48 @vfcount=1
	//_VTable: 
	//_Func: public void ShaderResource(const ShaderResource &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void ShaderResource(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * iname, int islot); @loc=static @len=166 @rva=2282272
	//_Func: public void ~ShaderResource(); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Data: this+0x8, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, name
	//_Data: this+0x28, Member, Type: int, slot
	//_Func: public ShaderResource & operator=(const ShaderResource &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ShaderResource {
public:
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > name;
	int slot;
	inline ShaderResource() { }
	inline ShaderResource(const ShaderResource& other) = default;
	inline ShaderResource& operator=(const ShaderResource& other) = default;
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * iname, int islot) { typedef void (ShaderResource::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, int); auto _f=xcast<_fpt>(_drva(2282272)); (this->*_f)(iname, islot); }
	virtual ~ShaderResource();
	inline void _guard_obj() {
		static_assert((sizeof(ShaderResource)==48),"bad size");
		static_assert((offsetof(ShaderResource,name)==0x8),"bad off");
		static_assert((offsetof(ShaderResource,slot)==0x28),"bad off");
	};
};

//UDT: struct SDWSuspensionData @len=124
	//_Data: this+0x0, Member, Type: class vec3f, carTopWB_F
	//_Data: this+0xC, Member, Type: class vec3f, carTopWB_R
	//_Data: this+0x18, Member, Type: class vec3f, carBottomWB_F
	//_Data: this+0x24, Member, Type: class vec3f, carBottomWB_R
	//_Data: this+0x30, Member, Type: class vec3f, tyreTopWB
	//_Data: this+0x3C, Member, Type: class vec3f, tyreBottomWB
	//_Data: this+0x48, Member, Type: class vec3f, carSteer
	//_Data: this+0x54, Member, Type: class vec3f, tyreSteer
	//_Data: this+0x60, Member, Type: class vec3f, refPoint
	//_Data: this+0x6C, Member, Type: float, hubMass
	//_Data: this+0x70, Member, Type: class vec3f, hubInertiaBox
	//_Func: public void SDWSuspensionData(); @loc=optimized @len=0 @rva=0
//UDT;

struct SDWSuspensionData {
public:
	vec3f carTopWB_F;
	vec3f carTopWB_R;
	vec3f carBottomWB_F;
	vec3f carBottomWB_R;
	vec3f tyreTopWB;
	vec3f tyreBottomWB;
	vec3f carSteer;
	vec3f tyreSteer;
	vec3f refPoint;
	float hubMass;
	vec3f hubInertiaBox;
	inline SDWSuspensionData() { }
	inline SDWSuspensionData(const SDWSuspensionData& other) = default;
	inline SDWSuspensionData& operator=(const SDWSuspensionData& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(SDWSuspensionData)==124),"bad size");
		static_assert((offsetof(SDWSuspensionData,carTopWB_F)==0x0),"bad off");
		static_assert((offsetof(SDWSuspensionData,carTopWB_R)==0xC),"bad off");
		static_assert((offsetof(SDWSuspensionData,carBottomWB_F)==0x18),"bad off");
		static_assert((offsetof(SDWSuspensionData,carBottomWB_R)==0x24),"bad off");
		static_assert((offsetof(SDWSuspensionData,tyreTopWB)==0x30),"bad off");
		static_assert((offsetof(SDWSuspensionData,tyreBottomWB)==0x3C),"bad off");
		static_assert((offsetof(SDWSuspensionData,carSteer)==0x48),"bad off");
		static_assert((offsetof(SDWSuspensionData,tyreSteer)==0x54),"bad off");
		static_assert((offsetof(SDWSuspensionData,refPoint)==0x60),"bad off");
		static_assert((offsetof(SDWSuspensionData,hubMass)==0x6C),"bad off");
		static_assert((offsetof(SDWSuspensionData,hubInertiaBox)==0x70),"bad off");
	};
};

//UDT: struct MLBall @len=24
	//_Data: this+0x0, Member, Type: class vec3f, relToTyre
	//_Data: this+0xC, Member, Type: class vec3f, relToCar
	//_Func: public void MLBall(); @loc=optimized @len=0 @rva=0
//UDT;

struct MLBall {
public:
	vec3f relToTyre;
	vec3f relToCar;
	inline MLBall() { }
	inline MLBall(const MLBall& other) = default;
	inline MLBall& operator=(const MLBall& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(MLBall)==24),"bad size");
		static_assert((offsetof(MLBall,relToTyre)==0x0),"bad off");
		static_assert((offsetof(MLBall,relToCar)==0xC),"bad off");
	};
};

//UDT: struct NetCarState @len=136
	//_Func: public void NetCarState(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: class vec3f, pos
	//_Data: this+0xC, Member, Type: class vec3f, rotation
	//_Data: this+0x18, Member, Type: class vec3f, velocity
	//_Data: this+0x24, Member, Type: class vec3f, acceleration
	//_Data: this+0x30, Member, Type: double, timeStamp
	//_Data: this+0x38, Member, Type: double, rcvTime
	//_Data: this+0x40, Member, Type: unsigned char, pakSequenceId
	//_Data: this+0x44, Member, Type: float, targetHeight
	//_Data: this+0x48, Member, Type: float[0x4], tyreAngularSpeed
	//_Data: this+0x58, Member, Type: unsigned short, engineRPM
	//_Data: this+0x5C, Member, Type: float, steerAngle
	//_Data: this+0x60, Member, Type: float, wheelAngle
	//_Data: this+0x64, Member, Type: int, gearIndex
	//_Data: this+0x68, Member, Type: unsigned int, statusBytes
	//_Data: this+0x6C, Member, Type: float, aoa
	//_Data: this+0x70, Member, Type: class vec3f, aoaAxis
	//_Data: this+0x7C, Member, Type: int, ping
	//_Data: this+0x80, Member, Type: float, performanceDelta
	//_Data: this+0x84, Member, Type: float, gas
//UDT;

struct NetCarState {
public:
	vec3f pos;
	vec3f rotation;
	vec3f velocity;
	vec3f acceleration;
	double timeStamp;
	double rcvTime;
	unsigned char pakSequenceId;
	float targetHeight;
	float tyreAngularSpeed[4];
	unsigned short engineRPM;
	float steerAngle;
	float wheelAngle;
	int gearIndex;
	unsigned int statusBytes;
	float aoa;
	vec3f aoaAxis;
	int ping;
	float performanceDelta;
	float gas;
	inline NetCarState() { }
	inline NetCarState(const NetCarState& other) = default;
	inline NetCarState& operator=(const NetCarState& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(NetCarState)==136),"bad size");
		static_assert((offsetof(NetCarState,pos)==0x0),"bad off");
		static_assert((offsetof(NetCarState,rotation)==0xC),"bad off");
		static_assert((offsetof(NetCarState,velocity)==0x18),"bad off");
		static_assert((offsetof(NetCarState,acceleration)==0x24),"bad off");
		static_assert((offsetof(NetCarState,timeStamp)==0x30),"bad off");
		static_assert((offsetof(NetCarState,rcvTime)==0x38),"bad off");
		static_assert((offsetof(NetCarState,pakSequenceId)==0x40),"bad off");
		static_assert((offsetof(NetCarState,targetHeight)==0x44),"bad off");
		static_assert((offsetof(NetCarState,tyreAngularSpeed)==0x48),"bad off");
		static_assert((offsetof(NetCarState,engineRPM)==0x58),"bad off");
		static_assert((offsetof(NetCarState,steerAngle)==0x5C),"bad off");
		static_assert((offsetof(NetCarState,wheelAngle)==0x60),"bad off");
		static_assert((offsetof(NetCarState,gearIndex)==0x64),"bad off");
		static_assert((offsetof(NetCarState,statusBytes)==0x68),"bad off");
		static_assert((offsetof(NetCarState,aoa)==0x6C),"bad off");
		static_assert((offsetof(NetCarState,aoaAxis)==0x70),"bad off");
		static_assert((offsetof(NetCarState,ping)==0x7C),"bad off");
		static_assert((offsetof(NetCarState,performanceDelta)==0x80),"bad off");
		static_assert((offsetof(NetCarState,gas)==0x84),"bad off");
	};
};

//UDT: struct LightingSettings @len=180
	//_Func: public void LightingSettings(); @loc=static @len=323 @rva=2104736
	//_Data: this+0x0, Member, Type: class vec3f, lightDirection
	//_Data: this+0xC, Member, Type: class vec3f, lightColor
	//_Data: this+0x18, Member, Type: class vec3f, horizonLow
	//_Data: this+0x24, Member, Type: class vec3f, horizonHigh
	//_Data: this+0x30, Member, Type: class vec3f, skyLow
	//_Data: this+0x3C, Member, Type: class vec3f, skyHigh
	//_Data: this+0x48, Member, Type: class vec3f, sunLow
	//_Data: this+0x54, Member, Type: class vec3f, sunHigh
	//_Data: this+0x60, Member, Type: float, angle
	//_Data: this+0x64, Member, Type: float, headingAngle
	//_Data: this+0x68, Member, Type: float, pitchAngle
	//_Data: this+0x6C, Member, Type: class vec3f, ambientLow
	//_Data: this+0x78, Member, Type: class vec3f, ambientHigh
	//_Data: this+0x84, Member, Type: class vec3f, fogColor
	//_Data: this+0x90, Member, Type: float, fogLinear
	//_Data: this+0x94, Member, Type: float, fogBlend
	//_Data: this+0x98, Member, Type: float, cloudCover
	//_Data: this+0x9C, Member, Type: float, cloudCutoff
	//_Data: this+0xA0, Member, Type: float, cloudColor
	//_Data: this+0xA4, Member, Type: float, cloudOffset
	//_Data: this+0xA8, Member, Type: float, saturation
	//_Data: this+0xAC, Member, Type: float, gameTime
	//_Data: this+0xB0, Member, Type: float, sunAngleGamma
//UDT;

struct LightingSettings {
public:
	vec3f lightDirection;
	vec3f lightColor;
	vec3f horizonLow;
	vec3f horizonHigh;
	vec3f skyLow;
	vec3f skyHigh;
	vec3f sunLow;
	vec3f sunHigh;
	float angle;
	float headingAngle;
	float pitchAngle;
	vec3f ambientLow;
	vec3f ambientHigh;
	vec3f fogColor;
	float fogLinear;
	float fogBlend;
	float cloudCover;
	float cloudCutoff;
	float cloudColor;
	float cloudOffset;
	float saturation;
	float gameTime;
	float sunAngleGamma;
	inline LightingSettings() { }
	inline LightingSettings(const LightingSettings& other) = default;
	inline LightingSettings& operator=(const LightingSettings& other) = default;
	inline void ctor() { typedef void (LightingSettings::*_fpt)(); auto _f=xcast<_fpt>(_drva(2104736)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(LightingSettings)==180),"bad size");
		static_assert((offsetof(LightingSettings,lightDirection)==0x0),"bad off");
		static_assert((offsetof(LightingSettings,lightColor)==0xC),"bad off");
		static_assert((offsetof(LightingSettings,horizonLow)==0x18),"bad off");
		static_assert((offsetof(LightingSettings,horizonHigh)==0x24),"bad off");
		static_assert((offsetof(LightingSettings,skyLow)==0x30),"bad off");
		static_assert((offsetof(LightingSettings,skyHigh)==0x3C),"bad off");
		static_assert((offsetof(LightingSettings,sunLow)==0x48),"bad off");
		static_assert((offsetof(LightingSettings,sunHigh)==0x54),"bad off");
		static_assert((offsetof(LightingSettings,angle)==0x60),"bad off");
		static_assert((offsetof(LightingSettings,headingAngle)==0x64),"bad off");
		static_assert((offsetof(LightingSettings,pitchAngle)==0x68),"bad off");
		static_assert((offsetof(LightingSettings,ambientLow)==0x6C),"bad off");
		static_assert((offsetof(LightingSettings,ambientHigh)==0x78),"bad off");
		static_assert((offsetof(LightingSettings,fogColor)==0x84),"bad off");
		static_assert((offsetof(LightingSettings,fogLinear)==0x90),"bad off");
		static_assert((offsetof(LightingSettings,fogBlend)==0x94),"bad off");
		static_assert((offsetof(LightingSettings,cloudCover)==0x98),"bad off");
		static_assert((offsetof(LightingSettings,cloudCutoff)==0x9C),"bad off");
		static_assert((offsetof(LightingSettings,cloudColor)==0xA0),"bad off");
		static_assert((offsetof(LightingSettings,cloudOffset)==0xA4),"bad off");
		static_assert((offsetof(LightingSettings,saturation)==0xA8),"bad off");
		static_assert((offsetof(LightingSettings,gameTime)==0xAC),"bad off");
		static_assert((offsetof(LightingSettings,sunAngleGamma)==0xB0),"bad off");
	};
};

//UDT: struct OnGearRequestEvent @len=8
	//_Func: public void OnGearRequestEvent(GearChangeRequest  _arg0, int  _arg1); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: enum GearChangeRequest, request
	//_Data: this+0x4, Member, Type: int, nextGear
//UDT;

struct OnGearRequestEvent {
public:
	GearChangeRequest request;
	int nextGear;
	inline OnGearRequestEvent() { }
	inline OnGearRequestEvent(const OnGearRequestEvent& other) = default;
	inline OnGearRequestEvent& operator=(const OnGearRequestEvent& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(OnGearRequestEvent)==8),"bad size");
		static_assert((offsetof(OnGearRequestEvent,request)==0x0),"bad off");
		static_assert((offsetof(OnGearRequestEvent,nextGear)==0x4),"bad off");
	};
};

//UDT: class IndexBuffer @len=16 @vfcount=1
	//_VTable: 
	//_Func: public void IndexBuffer(const IndexBuffer &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void IndexBuffer(std::vector<unsigned short,std::allocator<unsigned short> > & indices); @loc=static @len=64 @rva=2258768
	//_Func: public void ~IndexBuffer(); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Data: this+0x8, Member, Type: void *, kid
	//_Func: public IndexBuffer & operator=(const IndexBuffer &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class IndexBuffer {
public:
	void * kid;
	inline IndexBuffer() { }
	inline IndexBuffer(const IndexBuffer& other) = default;
	inline IndexBuffer& operator=(const IndexBuffer& other) = default;
	inline void ctor(std::vector<unsigned short,std::allocator<unsigned short> > & indices) { typedef void (IndexBuffer::*_fpt)(std::vector<unsigned short,std::allocator<unsigned short> > &); auto _f=xcast<_fpt>(_drva(2258768)); (this->*_f)(indices); }
	virtual ~IndexBuffer();
	inline void _guard_obj() {
		static_assert((sizeof(IndexBuffer)==16),"bad size");
		static_assert((offsetof(IndexBuffer,kid)==0x8),"bad off");
	};
};

//UDT: struct KGLShaderVar @len=80
	//_Data: this+0x0, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, name
	//_Data: this+0x20, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, cBufferName
	//_Data: this+0x40, Member, Type: unsigned int, cBufferSlot
	//_Data: this+0x44, Member, Type: unsigned int, size
	//_Data: this+0x48, Member, Type: unsigned int, offset
	//_Func: public void KGLShaderVar(const KGLShaderVar &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void KGLShaderVar(); @loc=optimized @len=0 @rva=0
	//_Func: public void ~KGLShaderVar(); @loc=static @len=90 @rva=130576
	//_Func: public KGLShaderVar & operator=(const KGLShaderVar &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct KGLShaderVar {
public:
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > name;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > cBufferName;
	unsigned int cBufferSlot;
	unsigned int size;
	unsigned int offset;
	inline KGLShaderVar() { }
	inline KGLShaderVar(const KGLShaderVar& other) = default;
	inline KGLShaderVar& operator=(const KGLShaderVar& other) = default;
	inline void dtor() { typedef void (KGLShaderVar::*_fpt)(); auto _f=xcast<_fpt>(_drva(130576)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(KGLShaderVar)==80),"bad size");
		static_assert((offsetof(KGLShaderVar,name)==0x0),"bad off");
		static_assert((offsetof(KGLShaderVar,cBufferName)==0x20),"bad off");
		static_assert((offsetof(KGLShaderVar,cBufferSlot)==0x40),"bad off");
		static_assert((offsetof(KGLShaderVar,size)==0x44),"bad off");
		static_assert((offsetof(KGLShaderVar,offset)==0x48),"bad off");
	};
};

//UDT: struct KGLShaderTexture @len=40
	//_Data: this+0x0, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, name
	//_Data: this+0x20, Member, Type: int, slot
	//_Func: public void KGLShaderTexture(const KGLShaderTexture &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void KGLShaderTexture(); @loc=optimized @len=0 @rva=0
	//_Func: public void ~KGLShaderTexture(); @loc=static @len=48 @rva=113184
	//_Func: public KGLShaderTexture & operator=(const KGLShaderTexture &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct KGLShaderTexture {
public:
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > name;
	int slot;
	inline KGLShaderTexture() { }
	inline KGLShaderTexture(const KGLShaderTexture& other) = default;
	inline KGLShaderTexture& operator=(const KGLShaderTexture& other) = default;
	inline void dtor() { typedef void (KGLShaderTexture::*_fpt)(); auto _f=xcast<_fpt>(_drva(113184)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(KGLShaderTexture)==40),"bad size");
		static_assert((offsetof(KGLShaderTexture,name)==0x0),"bad off");
		static_assert((offsetof(KGLShaderTexture,slot)==0x20),"bad off");
	};
};

//UDT: struct ksgui::OnCheckBoxChanged @len=16
	//_Data: this+0x0, Member, Type: class ksgui::CheckBox *, checkBox
	//_Data: this+0x8, Member, Type: bool, value
//UDT;

struct ksgui_OnCheckBoxChanged {
public:
	ksgui_CheckBox * checkBox;
	bool value;
	inline ksgui_OnCheckBoxChanged() { }
	inline ksgui_OnCheckBoxChanged(const ksgui_OnCheckBoxChanged& other) = default;
	inline ksgui_OnCheckBoxChanged& operator=(const ksgui_OnCheckBoxChanged& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_OnCheckBoxChanged)==16),"bad size");
		static_assert((offsetof(ksgui_OnCheckBoxChanged,checkBox)==0x0),"bad off");
		static_assert((offsetof(ksgui_OnCheckBoxChanged,value)==0x8),"bad off");
	};
};

//UDT: struct ksgui::OnSliderInteraction @len=16
	//_Data: this+0x0, Member, Type: class ksgui::Slider *, slider
	//_Data: this+0x8, Member, Type: float, value
//UDT;

struct ksgui_OnSliderInteraction {
public:
	ksgui_Slider * slider;
	float value;
	inline ksgui_OnSliderInteraction() { }
	inline ksgui_OnSliderInteraction(const ksgui_OnSliderInteraction& other) = default;
	inline ksgui_OnSliderInteraction& operator=(const ksgui_OnSliderInteraction& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_OnSliderInteraction)==16),"bad size");
		static_assert((offsetof(ksgui_OnSliderInteraction,slider)==0x0),"bad off");
		static_assert((offsetof(ksgui_OnSliderInteraction,value)==0x8),"bad off");
	};
};

//UDT: class SetupItem @len=136 @vfcount=1
	//_VTable: 
	//_Func: public void SetupItem(const SetupItem & __that); @loc=static @len=224 @rva=2657424
	//_Func: public void SetupItem(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * aname, float & aconnectedFloat, std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * units, bool isAttached, float multiplier, float labelMult); @loc=static @len=303 @rva=2929008
	//_Func: public void ~SetupItem(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=164 @rva=2929312
	//_Data: this+0x8, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, name
	//_Data: this+0x28, Member, Type: float &, connectedFloat
	//_Data: this+0x30, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, units
	//_Data: this+0x50, Member, Type: float, multiplier
	//_Data: this+0x54, Member, Type: float, newValue
	//_Data: this+0x58, Member, Type: bool, attached
	//_Data: this+0x60, Member, Type: class std::function<void __cdecl(SetupItem *)>, onValueChanged
	//_Data: this+0x80, Member, Type: float, labelMultiplier
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class SetupItem {
public:
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > name;
	float & connectedFloat;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > units;
	float multiplier;
	float newValue;
	bool attached;
	std::function<void __cdecl(SetupItem *)> onValueChanged;
	float labelMultiplier;
	inline SetupItem() : connectedFloat(*((float*)NULL)) { }
	inline SetupItem(const SetupItem& other) = default;
	inline SetupItem& operator=(const SetupItem& other) = default;
	inline void ctor(const SetupItem & __that) { typedef void (SetupItem::*_fpt)(const SetupItem &); auto _f=xcast<_fpt>(_drva(2657424)); (this->*_f)(__that); }
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * aname, float & aconnectedFloat, std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * units, bool isAttached, float multiplier, float labelMult) { typedef void (SetupItem::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, float &, std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, bool, float, float); auto _f=xcast<_fpt>(_drva(2929008)); (this->*_f)(aname, aconnectedFloat, units, isAttached, multiplier, labelMult); }
	virtual ~SetupItem();
	inline void dtor() { typedef void (SetupItem::*_fpt)(); auto _f=xcast<_fpt>(_drva(2929312)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(SetupItem)==136),"bad size");
		static_assert((offsetof(SetupItem,name)==0x8),"bad off");
		static_assert((offsetof(SetupItem,units)==0x30),"bad off");
		static_assert((offsetof(SetupItem,multiplier)==0x50),"bad off");
		static_assert((offsetof(SetupItem,newValue)==0x54),"bad off");
		static_assert((offsetof(SetupItem,attached)==0x58),"bad off");
		static_assert((offsetof(SetupItem,onValueChanged)==0x60),"bad off");
		static_assert((offsetof(SetupItem,labelMultiplier)==0x80),"bad off");
	};
};

//UDT: class IACPPluginHost @len=8 @vfcount=9
	//_VTable: 
	//_Func: public HWND__ * getHwnd(); @intro @pure @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Func: public HINSTANCE__ * getHInstance(); @intro @pure @virtual vtpo=0 vfid=1 @loc=optimized @len=0 @rva=0
	//_Func: public void setABS(float  _arg0); @intro @pure @virtual vtpo=0 vfid=2 @loc=optimized @len=0 @rva=0
	//_Func: public void setTC(float  _arg0); @intro @pure @virtual vtpo=0 vfid=3 @loc=optimized @len=0 @rva=0
	//_Func: public void setStabilityControl(float  _arg0); @intro @pure @virtual vtpo=0 vfid=4 @loc=optimized @len=0 @rva=0
	//_Func: public void setIdealLine(bool  _arg0, bool  _arg1); @intro @pure @virtual vtpo=0 vfid=5 @loc=optimized @len=0 @rva=0
	//_Func: public void setAutoShift(bool  _arg0); @intro @pure @virtual vtpo=0 vfid=6 @loc=optimized @len=0 @rva=0
	//_Func: public void setBrakeBias(float  _arg0); @intro @pure @virtual vtpo=0 vfid=7 @loc=optimized @len=0 @rva=0
	//_Func: public void setSystemMessage(const wchar_t *  _arg0, const wchar_t *  _arg1, bool  _arg2); @intro @pure @virtual vtpo=0 vfid=8 @loc=optimized @len=0 @rva=0
	//_Func: public void IACPPluginHost(const IACPPluginHost &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void IACPPluginHost(); @loc=optimized @len=0 @rva=0
	//_Func: public IACPPluginHost & operator=(const IACPPluginHost &  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class IACPPluginHost {
public:
	inline IACPPluginHost() { }
	inline IACPPluginHost(const IACPPluginHost& other) = default;
	inline IACPPluginHost& operator=(const IACPPluginHost& other) = default;
	virtual HWND__ * getHwnd_vf0() = 0;
	inline HWND__ * getHwnd() { typedef HWND__ * (IACPPluginHost::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 0)); return (this->*_f)(); }
	virtual HINSTANCE__ * getHInstance_vf1() = 0;
	inline HINSTANCE__ * getHInstance() { typedef HINSTANCE__ * (IACPPluginHost::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(); }
	virtual void setABS_vf2(float  _arg0) = 0;
	inline void setABS(float  _arg0) { typedef void (IACPPluginHost::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)( _arg0); }
	virtual void setTC_vf3(float  _arg0) = 0;
	inline void setTC(float  _arg0) { typedef void (IACPPluginHost::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)( _arg0); }
	virtual void setStabilityControl_vf4(float  _arg0) = 0;
	inline void setStabilityControl(float  _arg0) { typedef void (IACPPluginHost::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 4)); return (this->*_f)( _arg0); }
	virtual void setIdealLine_vf5(bool  _arg0, bool  _arg1) = 0;
	inline void setIdealLine(bool  _arg0, bool  _arg1) { typedef void (IACPPluginHost::*_fpt)(bool, bool); auto _f=xcast<_fpt>(get_vfp(this, 5)); return (this->*_f)( _arg0,  _arg1); }
	virtual void setAutoShift_vf6(bool  _arg0) = 0;
	inline void setAutoShift(bool  _arg0) { typedef void (IACPPluginHost::*_fpt)(bool); auto _f=xcast<_fpt>(get_vfp(this, 6)); return (this->*_f)( _arg0); }
	virtual void setBrakeBias_vf7(float  _arg0) = 0;
	inline void setBrakeBias(float  _arg0) { typedef void (IACPPluginHost::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 7)); return (this->*_f)( _arg0); }
	virtual void setSystemMessage_vf8(const wchar_t *  _arg0, const wchar_t *  _arg1, bool  _arg2) = 0;
	inline void setSystemMessage(const wchar_t *  _arg0, const wchar_t *  _arg1, bool  _arg2) { typedef void (IACPPluginHost::*_fpt)(const wchar_t *, const wchar_t *, bool); auto _f=xcast<_fpt>(get_vfp(this, 8)); return (this->*_f)( _arg0,  _arg1,  _arg2); }
	inline void _guard_obj() {
		static_assert((sizeof(IACPPluginHost)==8),"bad size");
	};
};

//UDT: struct AxleBall @len=32
	//_Data: this+0x0, Member, Type: class vec3f, relToAxle
	//_Data: this+0xC, Member, Type: class vec3f, relToCar
	//_Data: this+0x18, Member, Type: class IJoint *, joint
	//_Func: public void AxleBall(); @loc=optimized @len=0 @rva=0
//UDT;

struct AxleBall {
public:
	vec3f relToAxle;
	vec3f relToCar;
	IJoint * joint;
	inline AxleBall() { }
	inline AxleBall(const AxleBall& other) = default;
	inline AxleBall& operator=(const AxleBall& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(AxleBall)==32),"bad size");
		static_assert((offsetof(AxleBall,relToAxle)==0x0),"bad off");
		static_assert((offsetof(AxleBall,relToCar)==0xC),"bad off");
		static_assert((offsetof(AxleBall,joint)==0x18),"bad off");
	};
};

//UDT: struct RayCastHit @len=40
	//_Func: public void RayCastHit(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: class vec3f, pos
	//_Data: this+0xC, Member, Type: class vec3f, normal
	//_Data: this+0x18, Member, Type: class ICollisionObject *, collisionObject
	//_Data: this+0x20, Member, Type: bool, hasContact
//UDT;

struct RayCastHit {
public:
	vec3f pos;
	vec3f normal;
	ICollisionObject * collisionObject;
	bool hasContact;
	inline RayCastHit() { }
	inline RayCastHit(const RayCastHit& other) = default;
	inline RayCastHit& operator=(const RayCastHit& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(RayCastHit)==40),"bad size");
		static_assert((offsetof(RayCastHit,pos)==0x0),"bad off");
		static_assert((offsetof(RayCastHit,normal)==0xC),"bad off");
		static_assert((offsetof(RayCastHit,collisionObject)==0x18),"bad off");
		static_assert((offsetof(RayCastHit,hasContact)==0x20),"bad off");
	};
};

//UDT: struct OnCollisionEvent @len=40
	//_Data: this+0x0, Member, Type: class IRigidBody *, body
	//_Data: this+0x8, Member, Type: float, relativeSpeed
	//_Data: this+0xC, Member, Type: class vec3f, worldPos
	//_Data: this+0x18, Member, Type: class vec3f, relPos
	//_Data: this+0x24, Member, Type: unsigned long, colliderGroup
	//_Func: public void OnCollisionEvent(); @loc=optimized @len=0 @rva=0
//UDT;

struct OnCollisionEvent {
public:
	IRigidBody * body;
	float relativeSpeed;
	vec3f worldPos;
	vec3f relPos;
	unsigned long colliderGroup;
	inline OnCollisionEvent() { }
	inline OnCollisionEvent(const OnCollisionEvent& other) = default;
	inline OnCollisionEvent& operator=(const OnCollisionEvent& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(OnCollisionEvent)==40),"bad size");
		static_assert((offsetof(OnCollisionEvent,body)==0x0),"bad off");
		static_assert((offsetof(OnCollisionEvent,relativeSpeed)==0x8),"bad off");
		static_assert((offsetof(OnCollisionEvent,worldPos)==0xC),"bad off");
		static_assert((offsetof(OnCollisionEvent,relPos)==0x18),"bad off");
		static_assert((offsetof(OnCollisionEvent,colliderGroup)==0x24),"bad off");
	};
};

//UDT: struct MeshVertex @len=44
	//_Func: public void MeshVertex(const MeshVertex &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void MeshVertex(const vec3f &  _arg0, const vec3f &  _arg1, const vec2f &  _arg2); @loc=optimized @len=0 @rva=0
	//_Func: public void MeshVertex(const vec3f &  _arg0, const vec3f &  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public void MeshVertex(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: class vec3f, pos
	//_Data: this+0xC, Member, Type: class vec3f, normal
	//_Data: this+0x18, Member, Type: class vec2f, texCoord
	//_Data: this+0x20, Member, Type: class vec3f, tangent
//UDT;

struct MeshVertex {
public:
	vec3f pos;
	vec3f normal;
	vec2f texCoord;
	vec3f tangent;
	inline MeshVertex() { }
	inline MeshVertex(const MeshVertex& other) = default;
	inline MeshVertex& operator=(const MeshVertex& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(MeshVertex)==44),"bad size");
		static_assert((offsetof(MeshVertex,pos)==0x0),"bad off");
		static_assert((offsetof(MeshVertex,normal)==0xC),"bad off");
		static_assert((offsetof(MeshVertex,texCoord)==0x18),"bad off");
		static_assert((offsetof(MeshVertex,tangent)==0x20),"bad off");
	};
};

//UDT: class CameraMouseControlBase @len=64 @vfcount=1
	//_VTable: 
	//_Func: public void CameraMouseControlBase(const CameraMouseControlBase &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void CameraMouseControlBase(Camera * camera); @loc=static @len=80 @rva=2161696
	//_Func: public void ~CameraMouseControlBase(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=11 @rva=2161776
	//_Data: this+0x8, Member, Type: const float, MOVE_SPEED
	//_Data: this+0xC, Member, Type: const float, MOVE_SPEED_SHIFT
	//_Data: this+0x10, Member, Type: const float, MOVE_SPEED_CTRL
	//_Data: this+0x14, Member, Type: float, mouseRotationSpeed
	//_Data: this+0x18, Member, Type: float, moveSpeed
	//_Data: this+0x1C, Member, Type: bool, isVertialStrafeActive
	//_Data: this+0x1D, Member, Type: bool, useRightButtonForMouseLook
	//_Data: this+0x20, Member, Type: float, moveSpeedShift
	//_Data: this+0x24, Member, Type: float, moveSpeedCtrl
	//_Func: public void update(float deltaT); @loc=static @len=51 @rva=2162480
	//_Func: public void resetMouseButtonState(); @loc=optimized @len=0 @rva=0
	//_Func: public void setSpeedSteps(float  _arg0, float  _arg1, float  _arg2); @loc=optimized @len=0 @rva=0
	//_Func: public Camera * getCamera(); @loc=static @len=5 @rva=2161840
	//_Data: this+0x28, Member, Type: class Camera *, target
	//_Data: this+0x30, Member, Type: struct std::pair<long,long>, lastMousePoint
	//_Data: this+0x38, Member, Type: bool, lastMouseDown
	//_Func: protected void stepKeyboard(float dt, float msp); @loc=static @len=302 @rva=2162176
	//_Func: protected void mouseLook(float dt, float speed); @loc=static @len=317 @rva=2161856
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class CameraMouseControlBase {
public:
	float MOVE_SPEED;
	float MOVE_SPEED_SHIFT;
	float MOVE_SPEED_CTRL;
	float mouseRotationSpeed;
	float moveSpeed;
	bool isVertialStrafeActive;
	bool useRightButtonForMouseLook;
	float moveSpeedShift;
	float moveSpeedCtrl;
	Camera * target;
	std::pair<long,long> lastMousePoint;
	bool lastMouseDown;
	inline CameraMouseControlBase() { }
	inline CameraMouseControlBase(const CameraMouseControlBase& other) = default;
	inline CameraMouseControlBase& operator=(const CameraMouseControlBase& other) = default;
	inline void ctor(Camera * camera) { typedef void (CameraMouseControlBase::*_fpt)(Camera *); auto _f=xcast<_fpt>(_drva(2161696)); (this->*_f)(camera); }
	virtual ~CameraMouseControlBase();
	inline void dtor() { typedef void (CameraMouseControlBase::*_fpt)(); auto _f=xcast<_fpt>(_drva(2161776)); (this->*_f)(); }
	inline void update(float deltaT) { typedef void (CameraMouseControlBase::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2162480)); return (this->*_f)(deltaT); }
	inline Camera * getCamera() { typedef Camera * (CameraMouseControlBase::*_fpt)(); auto _f=xcast<_fpt>(_drva(2161840)); return (this->*_f)(); }
	inline void stepKeyboard(float dt, float msp) { typedef void (CameraMouseControlBase::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2162176)); return (this->*_f)(dt, msp); }
	inline void mouseLook(float dt, float speed) { typedef void (CameraMouseControlBase::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2161856)); return (this->*_f)(dt, speed); }
	inline void _guard_obj() {
		static_assert((sizeof(CameraMouseControlBase)==64),"bad size");
		static_assert((offsetof(CameraMouseControlBase,MOVE_SPEED)==0x8),"bad off");
		static_assert((offsetof(CameraMouseControlBase,MOVE_SPEED_SHIFT)==0xC),"bad off");
		static_assert((offsetof(CameraMouseControlBase,MOVE_SPEED_CTRL)==0x10),"bad off");
		static_assert((offsetof(CameraMouseControlBase,mouseRotationSpeed)==0x14),"bad off");
		static_assert((offsetof(CameraMouseControlBase,moveSpeed)==0x18),"bad off");
		static_assert((offsetof(CameraMouseControlBase,isVertialStrafeActive)==0x1C),"bad off");
		static_assert((offsetof(CameraMouseControlBase,useRightButtonForMouseLook)==0x1D),"bad off");
		static_assert((offsetof(CameraMouseControlBase,moveSpeedShift)==0x20),"bad off");
		static_assert((offsetof(CameraMouseControlBase,moveSpeedCtrl)==0x24),"bad off");
		static_assert((offsetof(CameraMouseControlBase,target)==0x28),"bad off");
		static_assert((offsetof(CameraMouseControlBase,lastMousePoint)==0x30),"bad off");
		static_assert((offsetof(CameraMouseControlBase,lastMouseDown)==0x38),"bad off");
	};
};

//UDT: struct DynamicTrackObject @len=56
	//_Data: this+0x0, Member, Type: class Node *, node
	//_Data: this+0x8, Member, Type: class vec3f, pos
	//_Data: this+0x14, Member, Type: class vec3f, pos_range
	//_Data: this+0x20, Member, Type: class vec3f, vel
	//_Data: this+0x2C, Member, Type: class vec3f, org_pos
	//_Func: public void DynamicTrackObject(); @loc=optimized @len=0 @rva=0
//UDT;

struct DynamicTrackObject {
public:
	Node * node;
	vec3f pos;
	vec3f pos_range;
	vec3f vel;
	vec3f org_pos;
	inline DynamicTrackObject() { }
	inline DynamicTrackObject(const DynamicTrackObject& other) = default;
	inline DynamicTrackObject& operator=(const DynamicTrackObject& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(DynamicTrackObject)==56),"bad size");
		static_assert((offsetof(DynamicTrackObject,node)==0x0),"bad off");
		static_assert((offsetof(DynamicTrackObject,pos)==0x8),"bad off");
		static_assert((offsetof(DynamicTrackObject,pos_range)==0x14),"bad off");
		static_assert((offsetof(DynamicTrackObject,vel)==0x20),"bad off");
		static_assert((offsetof(DynamicTrackObject,org_pos)==0x2C),"bad off");
	};
};

//UDT: struct TrackPhysicsStats @len=24
	//_Data: this+0x0, Member, Type: unsigned int, objects
	//_Data: this+0x4, Member, Type: unsigned int, tris
	//_Data: this+0x8, Member, Type: class std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >, groups
	//_Func: public void TrackPhysicsStats(const TrackPhysicsStats &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void TrackPhysicsStats(); @loc=optimized @len=0 @rva=0
	//_Func: public void ~TrackPhysicsStats(); @loc=static @len=46 @rva=1862144
	//_Func: public TrackPhysicsStats & operator=(const TrackPhysicsStats &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct TrackPhysicsStats {
public:
	unsigned int objects;
	unsigned int tris;
	std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > groups;
	inline TrackPhysicsStats() { }
	inline TrackPhysicsStats(const TrackPhysicsStats& other) = default;
	inline TrackPhysicsStats& operator=(const TrackPhysicsStats& other) = default;
	inline void dtor() { typedef void (TrackPhysicsStats::*_fpt)(); auto _f=xcast<_fpt>(_drva(1862144)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(TrackPhysicsStats)==24),"bad size");
		static_assert((offsetof(TrackPhysicsStats,objects)==0x0),"bad off");
		static_assert((offsetof(TrackPhysicsStats,tris)==0x4),"bad off");
		static_assert((offsetof(TrackPhysicsStats,groups)==0x8),"bad off");
	};
};

//UDT: struct MaterialOption @len=48
	//_Func: public void MaterialOption(const MaterialOption &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void MaterialOption(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >  _arg0, IMaterialOptionChangeListener *  _arg1); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, name
	//_Func: public void setValue(bool  _arg0, bool  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public bool getValue(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x20, Member, Type: class IMaterialOptionChangeListener *, material
	//_Data: this+0x28, Member, Type: bool, value
	//_Func: public void ~MaterialOption(); @loc=optimized @len=0 @rva=0
	//_Func: public MaterialOption & operator=(const MaterialOption &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct MaterialOption {
public:
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > name;
	IMaterialOptionChangeListener * material;
	bool value;
	inline MaterialOption() { }
	inline MaterialOption(const MaterialOption& other) = default;
	inline MaterialOption& operator=(const MaterialOption& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(MaterialOption)==48),"bad size");
		static_assert((offsetof(MaterialOption,name)==0x0),"bad off");
		static_assert((offsetof(MaterialOption,material)==0x20),"bad off");
		static_assert((offsetof(MaterialOption,value)==0x28),"bad off");
	};
};

//UDT: struct ACPhysicsEvent @len=72
	//_Data: this+0x0, Member, Type: enum eACEventType, type
	//_Data: this+0x4, Member, Type: float, param1
	//_Data: this+0x8, Member, Type: float, param2
	//_Data: this+0xC, Member, Type: float, param3
	//_Data: this+0x10, Member, Type: float, param4
	//_Data: this+0x14, Member, Type: class vec3f, vParam1
	//_Data: this+0x20, Member, Type: class vec3f, vParam2
	//_Data: this+0x30, Member, Type: void *, voidParam0
	//_Data: this+0x38, Member, Type: void *, voidParam1
	//_Data: this+0x40, Member, Type: unsigned long, ulParam0
	//_Func: public void ACPhysicsEvent(); @loc=optimized @len=0 @rva=0
//UDT;

struct ACPhysicsEvent {
public:
	eACEventType type;
	float param1;
	float param2;
	float param3;
	float param4;
	vec3f vParam1;
	vec3f vParam2;
	void * voidParam0;
	void * voidParam1;
	unsigned long ulParam0;
	inline ACPhysicsEvent() { }
	inline ACPhysicsEvent(const ACPhysicsEvent& other) = default;
	inline ACPhysicsEvent& operator=(const ACPhysicsEvent& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(ACPhysicsEvent)==72),"bad size");
		static_assert((offsetof(ACPhysicsEvent,type)==0x0),"bad off");
		static_assert((offsetof(ACPhysicsEvent,param1)==0x4),"bad off");
		static_assert((offsetof(ACPhysicsEvent,param2)==0x8),"bad off");
		static_assert((offsetof(ACPhysicsEvent,param3)==0xC),"bad off");
		static_assert((offsetof(ACPhysicsEvent,param4)==0x10),"bad off");
		static_assert((offsetof(ACPhysicsEvent,vParam1)==0x14),"bad off");
		static_assert((offsetof(ACPhysicsEvent,vParam2)==0x20),"bad off");
		static_assert((offsetof(ACPhysicsEvent,voidParam0)==0x30),"bad off");
		static_assert((offsetof(ACPhysicsEvent,voidParam1)==0x38),"bad off");
		static_assert((offsetof(ACPhysicsEvent,ulParam0)==0x40),"bad off");
	};
};

//UDT: struct Lap @len=72
	//_Func: public void Lap(const Lap & __that); @loc=static @len=113 @rva=242400
	//_Func: public void Lap(int  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void Lap(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: unsigned int, time
	//_Data: this+0x8, Member, Type: class std::vector<unsigned int,std::allocator<unsigned int> >, splits
	//_Data: this+0x20, Member, Type: unsigned int, cuts
	//_Data: this+0x24, Member, Type: bool, isValid
	//_Data: this+0x28, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, compound
	//_Func: public void ~Lap(); @loc=static @len=95 @rva=246624
	//_Func: public Lap & operator=(const Lap &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct Lap {
public:
	unsigned int time;
	std::vector<unsigned int,std::allocator<unsigned int> > splits;
	unsigned int cuts;
	bool isValid;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > compound;
	inline Lap() { }
	inline Lap(const Lap& other) = default;
	inline Lap& operator=(const Lap& other) = default;
	inline void ctor(const Lap & __that) { typedef void (Lap::*_fpt)(const Lap &); auto _f=xcast<_fpt>(_drva(242400)); (this->*_f)(__that); }
	inline void dtor() { typedef void (Lap::*_fpt)(); auto _f=xcast<_fpt>(_drva(246624)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(Lap)==72),"bad size");
		static_assert((offsetof(Lap,time)==0x0),"bad off");
		static_assert((offsetof(Lap,splits)==0x8),"bad off");
		static_assert((offsetof(Lap,cuts)==0x20),"bad off");
		static_assert((offsetof(Lap,isValid)==0x24),"bad off");
		static_assert((offsetof(Lap,compound)==0x28),"bad off");
	};
};

//UDT: struct ksgui::OnListBoxItemClickedEvent @len=24
	//_Data: this+0x0, Member, Type: class ksgui::ListBox *, listBox
	//_Data: this+0x8, Member, Type: struct ksgui::ListBoxRowData *, row
	//_Data: this+0x10, Member, Type: unsigned int, itemIndex
//UDT;

struct ksgui_OnListBoxItemClickedEvent {
public:
	ksgui_ListBox * listBox;
	ksgui_ListBoxRowData * row;
	unsigned int itemIndex;
	inline ksgui_OnListBoxItemClickedEvent() { }
	inline ksgui_OnListBoxItemClickedEvent(const ksgui_OnListBoxItemClickedEvent& other) = default;
	inline ksgui_OnListBoxItemClickedEvent& operator=(const ksgui_OnListBoxItemClickedEvent& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_OnListBoxItemClickedEvent)==24),"bad size");
		static_assert((offsetof(ksgui_OnListBoxItemClickedEvent,listBox)==0x0),"bad off");
		static_assert((offsetof(ksgui_OnListBoxItemClickedEvent,row)==0x8),"bad off");
		static_assert((offsetof(ksgui_OnListBoxItemClickedEvent,itemIndex)==0x10),"bad off");
	};
};

//UDT: struct INISection @len=16
	//_Data: this+0x0, Member, Type: class std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >, keys
	//_Func: public bool hasKey(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & k); @loc=static @len=105 @rva=2322496
	//_Func: public void INISection(const INISection &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void INISection(); @loc=optimized @len=0 @rva=0
	//_Func: public void ~INISection(); @loc=static @len=41 @rva=4512704
	//_Func: public INISection & operator=(const INISection &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct INISection {
public:
	std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > keys;
	inline INISection() { }
	inline INISection(const INISection& other) = default;
	inline INISection& operator=(const INISection& other) = default;
	inline bool hasKey(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & k) { typedef bool (INISection::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2322496)); return (this->*_f)(k); }
	inline void dtor() { typedef void (INISection::*_fpt)(); auto _f=xcast<_fpt>(_drva(4512704)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(INISection)==16),"bad size");
		static_assert((offsetof(INISection,keys)==0x0),"bad off");
	};
};

//UDT: struct PersistanceCameraModeDef @len=8
	//_Func: public void PersistanceCameraModeDef(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: enum CameraMode, lastCameraMode
	//_Data: this+0x4, Member, Type: enum DrivableCamera, lastDrivableCameraMode
//UDT;

struct PersistanceCameraModeDef {
public:
	CameraMode lastCameraMode;
	DrivableCamera lastDrivableCameraMode;
	inline PersistanceCameraModeDef() { }
	inline PersistanceCameraModeDef(const PersistanceCameraModeDef& other) = default;
	inline PersistanceCameraModeDef& operator=(const PersistanceCameraModeDef& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(PersistanceCameraModeDef)==8),"bad size");
		static_assert((offsetof(PersistanceCameraModeDef,lastCameraMode)==0x0),"bad off");
		static_assert((offsetof(PersistanceCameraModeDef,lastDrivableCameraMode)==0x4),"bad off");
	};
};

//UDT: class IPAddress @len=16
	//_Func: public void IPAddress(); @loc=static @len=13 @rva=508768
	//_Func: public void IPAddress(const IPAddress &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void IPAddress(const sockaddr_in & addr); @loc=static @len=10 @rva=2479584
	//_Func: public void IPAddress(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & addr, unsigned short port); @loc=static @len=143 @rva=2479600
	//_Func: public void ~IPAddress(); @loc=static @len=3 @rva=96368
	//_Data: this+0x0, Member, Type: struct sockaddr_in, sokaddr
	//_Func: public unsigned short getPort(); @loc=optimized @len=0 @rva=0
	//_Func: public std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getAddress(); @loc=optimized @len=0 @rva=0
	//_Func: public std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getAddressPort(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class IPAddress {
public:
	sockaddr_in sokaddr;
	inline IPAddress() { }
	inline IPAddress(const IPAddress& other) = default;
	inline IPAddress& operator=(const IPAddress& other) = default;
	inline void ctor() { typedef void (IPAddress::*_fpt)(); auto _f=xcast<_fpt>(_drva(508768)); (this->*_f)(); }
	inline void ctor(const sockaddr_in & addr) { typedef void (IPAddress::*_fpt)(const sockaddr_in &); auto _f=xcast<_fpt>(_drva(2479584)); (this->*_f)(addr); }
	inline void ctor(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & addr, unsigned short port) { typedef void (IPAddress::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, unsigned short); auto _f=xcast<_fpt>(_drva(2479600)); (this->*_f)(addr, port); }
	inline void dtor() { typedef void (IPAddress::*_fpt)(); auto _f=xcast<_fpt>(_drva(96368)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(IPAddress)==16),"bad size");
		static_assert((offsetof(IPAddress,sokaddr)==0x0),"bad off");
	};
};

//UDT: struct OnControlsProviderChanged @len=16
	//_Data: this+0x0, Member, Type: class Car *, car
	//_Data: this+0x8, Member, Type: class ICarControlsProvider *, newControlsProvider
//UDT;

struct OnControlsProviderChanged {
public:
	Car * car;
	ICarControlsProvider * newControlsProvider;
	inline OnControlsProviderChanged() { }
	inline OnControlsProviderChanged(const OnControlsProviderChanged& other) = default;
	inline OnControlsProviderChanged& operator=(const OnControlsProviderChanged& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(OnControlsProviderChanged)==16),"bad size");
		static_assert((offsetof(OnControlsProviderChanged,car)==0x0),"bad off");
		static_assert((offsetof(OnControlsProviderChanged,newControlsProvider)==0x8),"bad off");
	};
};

//UDT: class TrackIR @len=8
	//_Func: public void TrackIR(HWND__ * hwnd); @loc=static @len=704 @rva=1892320
	//_Func: public void ~TrackIR(); @loc=static @len=41 @rva=1893024
	//_Data: this+0x0, Member, Type: bool, isValid
	//_Data: this+0x4, Member, Type: float, divisionValue
	//_Func: public void getOffsets(vec3f & rot, vec3f & pos); @loc=static @len=300 @rva=1893680
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class TrackIR {
public:
	bool isValid;
	float divisionValue;
	inline TrackIR() { }
	inline TrackIR(const TrackIR& other) = default;
	inline TrackIR& operator=(const TrackIR& other) = default;
	inline void ctor(HWND__ * hwnd) { typedef void (TrackIR::*_fpt)(HWND__ *); auto _f=xcast<_fpt>(_drva(1892320)); (this->*_f)(hwnd); }
	inline void dtor() { typedef void (TrackIR::*_fpt)(); auto _f=xcast<_fpt>(_drva(1893024)); (this->*_f)(); }
	inline void getOffsets(vec3f & rot, vec3f & pos) { typedef void (TrackIR::*_fpt)(vec3f &, vec3f &); auto _f=xcast<_fpt>(_drva(1893680)); return (this->*_f)(rot, pos); }
	inline void _guard_obj() {
		static_assert((sizeof(TrackIR)==8),"bad size");
		static_assert((offsetof(TrackIR,isValid)==0x0),"bad off");
		static_assert((offsetof(TrackIR,divisionValue)==0x4),"bad off");
	};
};

//UDT: struct RemoteSessionResult @len=112
	//_Func: public void RemoteSessionResult(const RemoteSessionResult & __that); @loc=static @len=125 @rva=242752
	//_Func: public void RemoteSessionResult(int carsCount); @loc=static @len=211 @rva=242880
	//_Func: public void RemoteSessionResult(); @loc=static @len=127 @rva=243104
	//_Data: this+0x0, Member, Type: class std::vector<int,std::allocator<int> >, positions
	//_Data: this+0x18, Member, Type: class std::vector<int,std::allocator<int> >, times
	//_Data: this+0x30, Member, Type: class std::vector<int,std::allocator<int> >, lapCounter
	//_Data: this+0x48, Member, Type: class std::vector<bool,std::allocator<bool> >, hasFinished
	//_Data: this+0x68, Member, Type: unsigned int, leaderLapCount
	//_Func: public void ~RemoteSessionResult(); @loc=static @len=184 @rva=246784
	//_Func: public RemoteSessionResult & operator=(const RemoteSessionResult &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct RemoteSessionResult {
public:
	std::vector<int,std::allocator<int> > positions;
	std::vector<int,std::allocator<int> > times;
	std::vector<int,std::allocator<int> > lapCounter;
	std::vector<bool,std::allocator<bool> > hasFinished;
	unsigned int leaderLapCount;
	inline RemoteSessionResult() { }
	inline RemoteSessionResult(const RemoteSessionResult& other) = default;
	inline RemoteSessionResult& operator=(const RemoteSessionResult& other) = default;
	inline void ctor(const RemoteSessionResult & __that) { typedef void (RemoteSessionResult::*_fpt)(const RemoteSessionResult &); auto _f=xcast<_fpt>(_drva(242752)); (this->*_f)(__that); }
	inline void ctor(int carsCount) { typedef void (RemoteSessionResult::*_fpt)(int); auto _f=xcast<_fpt>(_drva(242880)); (this->*_f)(carsCount); }
	inline void ctor() { typedef void (RemoteSessionResult::*_fpt)(); auto _f=xcast<_fpt>(_drva(243104)); (this->*_f)(); }
	inline void dtor() { typedef void (RemoteSessionResult::*_fpt)(); auto _f=xcast<_fpt>(_drva(246784)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(RemoteSessionResult)==112),"bad size");
		static_assert((offsetof(RemoteSessionResult,positions)==0x0),"bad off");
		static_assert((offsetof(RemoteSessionResult,times)==0x18),"bad off");
		static_assert((offsetof(RemoteSessionResult,lapCounter)==0x30),"bad off");
		static_assert((offsetof(RemoteSessionResult,hasFinished)==0x48),"bad off");
		static_assert((offsetof(RemoteSessionResult,leaderLapCount)==0x68),"bad off");
	};
};

//UDT: class Session @len=112
	//_Func: public void Session(const Session & __that); @loc=static @len=190 @rva=704528
	//_Func: public void Session(); @loc=static @len=145 @rva=610160
	//_Data: this+0x0, Member, Type: enum SessionType, sessionType
	//_Data: this+0x4, Member, Type: bool, isTimedRace
	//_Data: this+0x5, Member, Type: bool, hasAdditionalLap
	//_Data: this+0x8, Member, Type: int, laps
	//_Data: this+0xC, Member, Type: float, durationMinutes
	//_Data: this+0x10, Member, Type: float, overtime_ms
	//_Data: this+0x18, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, spawSet
	//_Data: this+0x38, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, name
	//_Data: this+0x58, Member, Type: double, startTime
	//_Data: this+0x60, Member, Type: int, forcedPosition
	//_Data: this+0x64, Member, Type: bool, isOver
	//_Data: this+0x68, Member, Type: unsigned int, leaderCompletedLaps
	//_Func: public void ~Session(); @loc=static @len=90 @rva=584992
	//_Func: public Session & operator=(const Session & __that); @loc=static @len=143 @rva=612480
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class Session {
public:
	SessionType sessionType;
	bool isTimedRace;
	bool hasAdditionalLap;
	int laps;
	float durationMinutes;
	float overtime_ms;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > spawSet;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > name;
	double startTime;
	int forcedPosition;
	bool isOver;
	unsigned int leaderCompletedLaps;
	inline Session() { }
	inline Session(const Session& other) = default;
	inline Session& operator=(const Session& other) = default;
	inline void ctor(const Session & __that) { typedef void (Session::*_fpt)(const Session &); auto _f=xcast<_fpt>(_drva(704528)); (this->*_f)(__that); }
	inline void ctor() { typedef void (Session::*_fpt)(); auto _f=xcast<_fpt>(_drva(610160)); (this->*_f)(); }
	inline void dtor() { typedef void (Session::*_fpt)(); auto _f=xcast<_fpt>(_drva(584992)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(Session)==112),"bad size");
		static_assert((offsetof(Session,sessionType)==0x0),"bad off");
		static_assert((offsetof(Session,isTimedRace)==0x4),"bad off");
		static_assert((offsetof(Session,hasAdditionalLap)==0x5),"bad off");
		static_assert((offsetof(Session,laps)==0x8),"bad off");
		static_assert((offsetof(Session,durationMinutes)==0xC),"bad off");
		static_assert((offsetof(Session,overtime_ms)==0x10),"bad off");
		static_assert((offsetof(Session,spawSet)==0x18),"bad off");
		static_assert((offsetof(Session,name)==0x38),"bad off");
		static_assert((offsetof(Session,startTime)==0x58),"bad off");
		static_assert((offsetof(Session,forcedPosition)==0x60),"bad off");
		static_assert((offsetof(Session,isOver)==0x64),"bad off");
		static_assert((offsetof(Session,leaderCompletedLaps)==0x68),"bad off");
	};
};

//UDT: struct ClientCollisionEvent @len=40
	//_Data: this+0x0, Member, Type: class NetCarStateProvider *, netCar
	//_Data: this+0x8, Member, Type: float, speed
	//_Data: this+0xC, Member, Type: class vec3f, worldPos
	//_Data: this+0x18, Member, Type: class vec3f, relPos
	//_Func: public void ClientCollisionEvent(); @loc=optimized @len=0 @rva=0
//UDT;

struct ClientCollisionEvent {
public:
	NetCarStateProvider * netCar;
	float speed;
	vec3f worldPos;
	vec3f relPos;
	inline ClientCollisionEvent() { }
	inline ClientCollisionEvent(const ClientCollisionEvent& other) = default;
	inline ClientCollisionEvent& operator=(const ClientCollisionEvent& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(ClientCollisionEvent)==40),"bad size");
		static_assert((offsetof(ClientCollisionEvent,netCar)==0x0),"bad off");
		static_assert((offsetof(ClientCollisionEvent,speed)==0x8),"bad off");
		static_assert((offsetof(ClientCollisionEvent,worldPos)==0xC),"bad off");
		static_assert((offsetof(ClientCollisionEvent,relPos)==0x18),"bad off");
	};
};

//UDT: struct RemoteSession @len=64
	//_Data: this+0x0, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, name
	//_Data: this+0x20, Member, Type: enum SessionType, type
	//_Data: this+0x24, Member, Type: int, index
	//_Data: this+0x28, Member, Type: int, time
	//_Data: this+0x2C, Member, Type: int, laps
	//_Data: this+0x30, Member, Type: double, startTime
	//_Data: this+0x38, Member, Type: bool, isSpectator
	//_Data: this+0x39, Member, Type: bool, isTimedRace
	//_Data: this+0x3A, Member, Type: bool, hasExtraLap
	//_Func: public void RemoteSession(const RemoteSession & __that); @loc=static @len=112 @rva=242560
	//_Func: public void RemoteSession(); @loc=static @len=79 @rva=242672
	//_Func: public void ~RemoteSession(); @loc=static @len=47 @rva=2334528
	//_Func: public RemoteSession & operator=(const RemoteSession &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct RemoteSession {
public:
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > name;
	SessionType type;
	int index;
	int time;
	int laps;
	double startTime;
	bool isSpectator;
	bool isTimedRace;
	bool hasExtraLap;
	inline RemoteSession() { }
	inline RemoteSession(const RemoteSession& other) = default;
	inline RemoteSession& operator=(const RemoteSession& other) = default;
	inline void ctor(const RemoteSession & __that) { typedef void (RemoteSession::*_fpt)(const RemoteSession &); auto _f=xcast<_fpt>(_drva(242560)); (this->*_f)(__that); }
	inline void ctor() { typedef void (RemoteSession::*_fpt)(); auto _f=xcast<_fpt>(_drva(242672)); (this->*_f)(); }
	inline void dtor() { typedef void (RemoteSession::*_fpt)(); auto _f=xcast<_fpt>(_drva(2334528)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(RemoteSession)==64),"bad size");
		static_assert((offsetof(RemoteSession,name)==0x0),"bad off");
		static_assert((offsetof(RemoteSession,type)==0x20),"bad off");
		static_assert((offsetof(RemoteSession,index)==0x24),"bad off");
		static_assert((offsetof(RemoteSession,time)==0x28),"bad off");
		static_assert((offsetof(RemoteSession,laps)==0x2C),"bad off");
		static_assert((offsetof(RemoteSession,startTime)==0x30),"bad off");
		static_assert((offsetof(RemoteSession,isSpectator)==0x38),"bad off");
		static_assert((offsetof(RemoteSession,isTimedRace)==0x39),"bad off");
		static_assert((offsetof(RemoteSession,hasExtraLap)==0x3A),"bad off");
	};
};

//UDT: struct DRSWingConnection @len=24
	//_Func: public void DRSWingConnection(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: class Wing *, wing
	//_Data: this+0x8, Member, Type: float, effect
	//_Data: this+0xC, Member, Type: float, angle
	//_Data: this+0x10, Member, Type: enum DRWWingConnectionMode, mode
//UDT;

struct DRSWingConnection {
public:
	Wing * wing;
	float effect;
	float angle;
	DRWWingConnectionMode mode;
	inline DRSWingConnection() { }
	inline DRSWingConnection(const DRSWingConnection& other) = default;
	inline DRSWingConnection& operator=(const DRSWingConnection& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(DRSWingConnection)==24),"bad size");
		static_assert((offsetof(DRSWingConnection,wing)==0x0),"bad off");
		static_assert((offsetof(DRSWingConnection,effect)==0x8),"bad off");
		static_assert((offsetof(DRSWingConnection,angle)==0xC),"bad off");
		static_assert((offsetof(DRSWingConnection,mode)==0x10),"bad off");
	};
};

//UDT: class KGLTexture @len=64
	//_Func: public void KGLTexture(const KGLTexture &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void KGLTexture(ID3D11ShaderResourceView *  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void KGLTexture(const void * buffer, int size, ID3D11Device * device); @loc=static @len=296 @rva=145776
	//_Func: public void KGLTexture(const void * buffer, DXGI_FORMAT format, unsigned int width, unsigned int height, ID3D11Device * device); @loc=static @len=359 @rva=146080
	//_Func: public void KGLTexture(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & filename, ID3D11Device * device); @loc=static @len=328 @rva=145440
	//_Func: public void ~KGLTexture(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: struct ID3D11ShaderResourceView *, shaderResourceView
	//_Tag 12
	//_Data: this+0x8, Member, Type: enum KGLTexture::ImageFileFormat, fileFormat
	//_Data: this+0xC, Member, Type: enum DXGI_FORMAT, textureFormat
	//_Data: this+0x10, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, fileName
	//_Data: this+0x30, Member, Type: unsigned int, width
	//_Data: this+0x34, Member, Type: unsigned int, height
	//_Func: private void initSize(); @loc=static @len=147 @rva=146448
	//_Data: this+0x38, Member, Type: bool, ownsShaderResourceView
	//_Func: public KGLTexture & operator=(const KGLTexture &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class KGLTexture {
public:
	ID3D11ShaderResourceView * shaderResourceView;
	KGLTexture_ImageFileFormat fileFormat;
	DXGI_FORMAT textureFormat;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > fileName;
	unsigned int width;
	unsigned int height;
	bool ownsShaderResourceView;
	inline KGLTexture() { }
	inline KGLTexture(const KGLTexture& other) = default;
	inline KGLTexture& operator=(const KGLTexture& other) = default;
	inline void ctor(const void * buffer, int size, ID3D11Device * device) { typedef void (KGLTexture::*_fpt)(const void *, int, ID3D11Device *); auto _f=xcast<_fpt>(_drva(145776)); (this->*_f)(buffer, size, device); }
	inline void ctor(const void * buffer, DXGI_FORMAT format, unsigned int width, unsigned int height, ID3D11Device * device) { typedef void (KGLTexture::*_fpt)(const void *, DXGI_FORMAT, unsigned int, unsigned int, ID3D11Device *); auto _f=xcast<_fpt>(_drva(146080)); (this->*_f)(buffer, format, width, height, device); }
	inline void ctor(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & filename, ID3D11Device * device) { typedef void (KGLTexture::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, ID3D11Device *); auto _f=xcast<_fpt>(_drva(145440)); (this->*_f)(filename, device); }
	inline void initSize() { typedef void (KGLTexture::*_fpt)(); auto _f=xcast<_fpt>(_drva(146448)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(KGLTexture)==64),"bad size");
		static_assert((offsetof(KGLTexture,shaderResourceView)==0x0),"bad off");
		static_assert((offsetof(KGLTexture,fileFormat)==0x8),"bad off");
		static_assert((offsetof(KGLTexture,textureFormat)==0xC),"bad off");
		static_assert((offsetof(KGLTexture,fileName)==0x10),"bad off");
		static_assert((offsetof(KGLTexture,width)==0x30),"bad off");
		static_assert((offsetof(KGLTexture,height)==0x34),"bad off");
		static_assert((offsetof(KGLTexture,ownsShaderResourceView)==0x38),"bad off");
	};
};

//UDT: struct TelemetryChannelData @len=32
	//_Func: public void TelemetryChannelData(const TelemetryChannelData &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void TelemetryChannelData(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: class std::vector<float,std::allocator<float> >, values
	//_Data: this+0x18, Member, Type: enum TelemetryUnits, units
	//_Data: this+0x1C, Member, Type: int, frequency
	//_Func: public void ~TelemetryChannelData(); @loc=static @len=48 @rva=811392
	//_Func: public TelemetryChannelData & operator=(const TelemetryChannelData &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct TelemetryChannelData {
public:
	std::vector<float,std::allocator<float> > values;
	TelemetryUnits units;
	int frequency;
	inline TelemetryChannelData() { }
	inline TelemetryChannelData(const TelemetryChannelData& other) = default;
	inline TelemetryChannelData& operator=(const TelemetryChannelData& other) = default;
	inline void dtor() { typedef void (TelemetryChannelData::*_fpt)(); auto _f=xcast<_fpt>(_drva(811392)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(TelemetryChannelData)==32),"bad size");
		static_assert((offsetof(TelemetryChannelData,values)==0x0),"bad off");
		static_assert((offsetof(TelemetryChannelData,units)==0x18),"bad off");
		static_assert((offsetof(TelemetryChannelData,frequency)==0x1C),"bad off");
	};
};

//UDT: struct OnPenaltyEvent @len=16
	//_Func: public void OnPenaltyEvent(Car *  _arg0, PenaltyType  _arg1); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: class Car *, car
	//_Data: this+0x8, Member, Type: enum PenaltyType, ptype
//UDT;

struct OnPenaltyEvent {
public:
	Car * car;
	PenaltyType ptype;
	inline OnPenaltyEvent() { }
	inline OnPenaltyEvent(const OnPenaltyEvent& other) = default;
	inline OnPenaltyEvent& operator=(const OnPenaltyEvent& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(OnPenaltyEvent)==16),"bad size");
		static_assert((offsetof(OnPenaltyEvent,car)==0x0),"bad off");
		static_assert((offsetof(OnPenaltyEvent,ptype)==0x8),"bad off");
	};
};

//UDT: class RenderTarget @len=40 @vfcount=1
	//_VTable: 
	//_Func: public void RenderTarget(const RenderTarget &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void RenderTarget(GraphicsManager * graphics, eRenderTargetFormat fmt, unsigned int iwidth, unsigned int iheight, bool hasColor, bool hasDepth, int mips); @loc=static @len=276 @rva=2211888
	//_Func: public void ~RenderTarget(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=58 @rva=2212176
	//_Data: this+0x8, Member, Type: enum eRenderTargetFormat, format
	//_Data: this+0xC, Member, Type: int, width
	//_Data: this+0x10, Member, Type: int, height
	//_Data: this+0x14, Member, Type: bool, hasNullDepth
	//_Data: this+0x18, Member, Type: void *, kidColor
	//_Data: this+0x20, Member, Type: void *, kidDepth
	//_Func: public void clear(); @loc=static @len=109 @rva=2212336
	//_Func: public RenderTarget & operator=(const RenderTarget &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class RenderTarget {
public:
	eRenderTargetFormat format;
	int width;
	int height;
	bool hasNullDepth;
	void * kidColor;
	void * kidDepth;
	inline RenderTarget() { }
	inline RenderTarget(const RenderTarget& other) = default;
	inline RenderTarget& operator=(const RenderTarget& other) = default;
	inline void ctor(GraphicsManager * graphics, eRenderTargetFormat fmt, unsigned int iwidth, unsigned int iheight, bool hasColor, bool hasDepth, int mips) { typedef void (RenderTarget::*_fpt)(GraphicsManager *, eRenderTargetFormat, unsigned int, unsigned int, bool, bool, int); auto _f=xcast<_fpt>(_drva(2211888)); (this->*_f)(graphics, fmt, iwidth, iheight, hasColor, hasDepth, mips); }
	virtual ~RenderTarget();
	inline void dtor() { typedef void (RenderTarget::*_fpt)(); auto _f=xcast<_fpt>(_drva(2212176)); (this->*_f)(); }
	inline void clear() { typedef void (RenderTarget::*_fpt)(); auto _f=xcast<_fpt>(_drva(2212336)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(RenderTarget)==40),"bad size");
		static_assert((offsetof(RenderTarget,format)==0x8),"bad off");
		static_assert((offsetof(RenderTarget,width)==0xC),"bad off");
		static_assert((offsetof(RenderTarget,height)==0x10),"bad off");
		static_assert((offsetof(RenderTarget,hasNullDepth)==0x14),"bad off");
		static_assert((offsetof(RenderTarget,kidColor)==0x18),"bad off");
		static_assert((offsetof(RenderTarget,kidDepth)==0x20),"bad off");
	};
};

//UDT: struct RayCastResult @len=48
	//_Func: public void RayCastResult(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: struct SurfaceDef *, surfaceDef
	//_Data: this+0x8, Member, Type: class vec3f, pos
	//_Data: this+0x14, Member, Type: class vec3f, normal
	//_Data: this+0x20, Member, Type: bool, hasHit
	//_Data: this+0x28, Member, Type: void *, collisionObject
//UDT;

struct RayCastResult {
public:
	SurfaceDef * surfaceDef;
	vec3f pos;
	vec3f normal;
	bool hasHit;
	void * collisionObject;
	inline RayCastResult() { }
	inline RayCastResult(const RayCastResult& other) = default;
	inline RayCastResult& operator=(const RayCastResult& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(RayCastResult)==48),"bad size");
		static_assert((offsetof(RayCastResult,surfaceDef)==0x0),"bad off");
		static_assert((offsetof(RayCastResult,pos)==0x8),"bad off");
		static_assert((offsetof(RayCastResult,normal)==0x14),"bad off");
		static_assert((offsetof(RayCastResult,hasHit)==0x20),"bad off");
		static_assert((offsetof(RayCastResult,collisionObject)==0x28),"bad off");
	};
};

//UDT: class DirectInput @len=64 @vfcount=1
	//_VTable: 
	//_Func: public DirectInput * singleton(); @pure @loc=static @len=88 @rva=2355856
	//_Func: public void cleanup(); @pure @loc=static @len=42 @rva=2355040
	//_Data: this+0x8, Member, Type: class std::vector<std::pair<_GUID,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<_GUID,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >, guids
	//_Data: this+0x20, Member, Type: struct IDirectInput8W *, lpDI
	//_Data: static, [0155A5E8][0003:000475E8], Static Member, Type: struct HWND__ *, hWnd
	//_Data: static, [0155A5F0][0003:000475F0], Static Member, Type: struct HINSTANCE__ *, hInstance
	//_Func: public InputDevice * getDevice(int index); @loc=static @len=36 @rva=2355200
	//_Func: public void initJoys(); @loc=static @len=298 @rva=2355248
	//_Func: public void poll(); @loc=static @len=85 @rva=2355552
	//_Func: public void forceFF(float v); @loc=static @len=111 @rva=2355088
	//_Func: public void setNormalizedMode(bool  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void resetFF(); @loc=optimized @len=0 @rva=0
	//_Func: public void DirectInput(const DirectInput &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: private void DirectInput(); @loc=static @len=147 @rva=2353328
	//_Func: private void ~DirectInput(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=207 @rva=2353568
	//_Data: static, [0155A5F8][0003:000475F8], Static Member, Type: class DirectInput *, m_singleton
	//_Data: this+0x28, Member, Type: class std::vector<InputDevice *,std::allocator<InputDevice *> >, devices
	//_Func: public DirectInput & operator=(const DirectInput &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: private void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class DirectInput {
public:
	std::vector<std::pair<_GUID,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<_GUID,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > guids;
	IDirectInput8W * lpDI;
	std::vector<InputDevice *,std::allocator<InputDevice *> > devices;
	inline DirectInput() { }
	inline DirectInput(const DirectInput& other) = default;
	inline DirectInput& operator=(const DirectInput& other) = default;
	inline static DirectInput * singleton() { typedef DirectInput * (*_fpt)(); auto _f=(_fpt)_drva(2355856); return _f(); }
	inline static void cleanup() { typedef void (*_fpt)(); auto _f=(_fpt)_drva(2355040); return _f(); }
	inline InputDevice * getDevice(int index) { typedef InputDevice * (DirectInput::*_fpt)(int); auto _f=xcast<_fpt>(_drva(2355200)); return (this->*_f)(index); }
	inline void initJoys() { typedef void (DirectInput::*_fpt)(); auto _f=xcast<_fpt>(_drva(2355248)); return (this->*_f)(); }
	inline void poll() { typedef void (DirectInput::*_fpt)(); auto _f=xcast<_fpt>(_drva(2355552)); return (this->*_f)(); }
	inline void forceFF(float v) { typedef void (DirectInput::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2355088)); return (this->*_f)(v); }
	inline void ctor() { typedef void (DirectInput::*_fpt)(); auto _f=xcast<_fpt>(_drva(2353328)); (this->*_f)(); }
	virtual ~DirectInput();
	inline void dtor() { typedef void (DirectInput::*_fpt)(); auto _f=xcast<_fpt>(_drva(2353568)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(DirectInput)==64),"bad size");
		static_assert((offsetof(DirectInput,guids)==0x8),"bad off");
		static_assert((offsetof(DirectInput,lpDI)==0x20),"bad off");
		static_assert((offsetof(DirectInput,devices)==0x28),"bad off");
	};
};

//UDT: class IRayTrackCollisionProvider @len=8 @vfcount=4
	//_VTable: 
	//_Func: public void ~IRayTrackCollisionProvider(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=11 @rva=2585840
	//_Func: public bool rayCast(const vec3f &  _arg0, const vec3f &  _arg1, RayCastResult *  _arg2, float  _arg3); @intro @pure @virtual vtpo=0 vfid=1 @loc=optimized @len=0 @rva=0
	//_Func: public bool rayCastWithRayCaster(const vec3f &  _arg0, const vec3f &  _arg1, RayCastResult *  _arg2, float  _arg3, IRayCaster *  _arg4); @intro @pure @virtual vtpo=0 vfid=2 @loc=optimized @len=0 @rva=0
	//_Func: public IRayCaster * createRayCaster(float  _arg0); @intro @pure @virtual vtpo=0 vfid=3 @loc=optimized @len=0 @rva=0
	//_Func: public void IRayTrackCollisionProvider(const IRayTrackCollisionProvider &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void IRayTrackCollisionProvider(); @loc=optimized @len=0 @rva=0
	//_Func: public IRayTrackCollisionProvider & operator=(const IRayTrackCollisionProvider &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class IRayTrackCollisionProvider {
public:
	inline IRayTrackCollisionProvider() { }
	inline IRayTrackCollisionProvider(const IRayTrackCollisionProvider& other) = default;
	inline IRayTrackCollisionProvider& operator=(const IRayTrackCollisionProvider& other) = default;
	virtual ~IRayTrackCollisionProvider();
	inline void dtor() { typedef void (IRayTrackCollisionProvider::*_fpt)(); auto _f=xcast<_fpt>(_drva(2585840)); (this->*_f)(); }
	virtual bool rayCast_vf1(const vec3f &  _arg0, const vec3f &  _arg1, RayCastResult *  _arg2, float  _arg3) = 0;
	inline bool rayCast(const vec3f &  _arg0, const vec3f &  _arg1, RayCastResult *  _arg2, float  _arg3) { typedef bool (IRayTrackCollisionProvider::*_fpt)(const vec3f &, const vec3f &, RayCastResult *, float); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)( _arg0,  _arg1,  _arg2,  _arg3); }
	virtual bool rayCastWithRayCaster_vf2(const vec3f &  _arg0, const vec3f &  _arg1, RayCastResult *  _arg2, float  _arg3, IRayCaster *  _arg4) = 0;
	inline bool rayCastWithRayCaster(const vec3f &  _arg0, const vec3f &  _arg1, RayCastResult *  _arg2, float  _arg3, IRayCaster *  _arg4) { typedef bool (IRayTrackCollisionProvider::*_fpt)(const vec3f &, const vec3f &, RayCastResult *, float, IRayCaster *); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)( _arg0,  _arg1,  _arg2,  _arg3,  _arg4); }
	virtual IRayCaster * createRayCaster_vf3(float  _arg0) = 0;
	inline IRayCaster * createRayCaster(float  _arg0) { typedef IRayCaster * (IRayTrackCollisionProvider::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)( _arg0); }
	inline void _guard_obj() {
		static_assert((sizeof(IRayTrackCollisionProvider)==8),"bad size");
	};
};

//UDT: class ShaderManager @len=40 @vfcount=1
	//_VTable: 
	//_Func: public void ShaderManager(const ShaderManager &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void ShaderManager(GraphicsManager * graphics); @loc=static @len=32 @rva=2259120
	//_Func: public void ~ShaderManager(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=62 @rva=2259152
	//_Func: public Shader * getShader(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name); @loc=static @len=391 @rva=2259776
	//_Func: public void cleanup(); @loc=static @len=95 @rva=2259680
	//_Func: public std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > getShaders(); @loc=optimized @len=0 @rva=0
	//_Func: public std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getPermutationSignature(std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > &  _arg0); @pure @loc=optimized @len=0 @rva=0
	//_Data: this+0x8, Member, Type: class GraphicsManager *, graphics
	//_Data: this+0x10, Member, Type: class std::vector<Shader *,std::allocator<Shader *> >, shaders
	//_Func: public ShaderManager & operator=(const ShaderManager &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ShaderManager {
public:
	GraphicsManager * graphics;
	std::vector<Shader *,std::allocator<Shader *> > shaders;
	inline ShaderManager() { }
	inline ShaderManager(const ShaderManager& other) = default;
	inline ShaderManager& operator=(const ShaderManager& other) = default;
	inline void ctor(GraphicsManager * graphics) { typedef void (ShaderManager::*_fpt)(GraphicsManager *); auto _f=xcast<_fpt>(_drva(2259120)); (this->*_f)(graphics); }
	virtual ~ShaderManager();
	inline void dtor() { typedef void (ShaderManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2259152)); (this->*_f)(); }
	inline Shader * getShader(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name) { typedef Shader * (ShaderManager::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2259776)); return (this->*_f)(name); }
	inline void cleanup() { typedef void (ShaderManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2259680)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(ShaderManager)==40),"bad size");
		static_assert((offsetof(ShaderManager,graphics)==0x8),"bad off");
		static_assert((offsetof(ShaderManager,shaders)==0x10),"bad off");
	};
};

//UDT: class GameObject @len=88 @vfcount=6
	//_VTable: 
	//_Func: public void GameObject(const GameObject &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void GameObject(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * iname, Game * igame); @loc=static @len=161 @rva=2358320
	//_Func: public void ~GameObject(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=167 @rva=2358496
	//_Data: this+0x8, Member, Type: class Game *, game
	//_Data: this+0x10, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, name
	//_Data: this+0x30, Member, Type: bool, isActive
	//_Func: public void removeGameObject(GameObject *  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public GameObject * getParent(); @loc=static @len=5 @rva=2358672
	//_Func: public void update(float deltaT); @intro @virtual vtpo=0 vfid=1 @loc=static @len=3 @rva=96368
	//_Func: public void render(float deltaT); @intro @virtual vtpo=0 vfid=2 @loc=static @len=3 @rva=96368
	//_Func: public void renderHUD(float deltaT); @intro @virtual vtpo=0 vfid=3 @loc=static @len=3 @rva=96368
	//_Func: public void renderAudio(float deltaT); @intro @virtual vtpo=0 vfid=4 @loc=static @len=3 @rva=96368
	//_Func: public void shutdown(); @intro @virtual vtpo=0 vfid=5 @loc=static @len=3 @rva=96368
	//_Func: public GameObject * findGameObject(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &  _arg0, GameObject *  _arg1); @pure @loc=optimized @len=0 @rva=0
	//_Func: public GameObject * getGameObject(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name); @loc=static @len=242 @rva=1177456
	//_Data: this+0x38, Member, Type: class GameObject *, parent
	//_Data: this+0x40, Member, Type: class std::vector<GameObject *,std::allocator<GameObject *> >, gameObjects
	//_Func: public GameObject & operator=(const GameObject &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class GameObject {
public:
	Game * game;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > name;
	bool isActive;
	GameObject * parent;
	std::vector<GameObject *,std::allocator<GameObject *> > gameObjects;
	inline GameObject() { }
	inline GameObject(const GameObject& other) = default;
	inline GameObject& operator=(const GameObject& other) = default;
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * iname, Game * igame) { typedef void (GameObject::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, Game *); auto _f=xcast<_fpt>(_drva(2358320)); (this->*_f)(iname, igame); }
	virtual ~GameObject();
	inline void dtor() { typedef void (GameObject::*_fpt)(); auto _f=xcast<_fpt>(_drva(2358496)); (this->*_f)(); }
	inline GameObject * getParent() { typedef GameObject * (GameObject::*_fpt)(); auto _f=xcast<_fpt>(_drva(2358672)); return (this->*_f)(); }
	virtual void update_vf1(float deltaT);
	inline void update_impl(float deltaT) { typedef void (GameObject::*_fpt)(float); auto _f=xcast<_fpt>(_drva(96368)); return (this->*_f)(deltaT); }
	inline void update(float deltaT) { typedef void (GameObject::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(deltaT); }
	virtual void render_vf2(float deltaT);
	inline void render_impl(float deltaT) { typedef void (GameObject::*_fpt)(float); auto _f=xcast<_fpt>(_drva(96368)); return (this->*_f)(deltaT); }
	inline void render(float deltaT) { typedef void (GameObject::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)(deltaT); }
	virtual void renderHUD_vf3(float deltaT);
	inline void renderHUD_impl(float deltaT) { typedef void (GameObject::*_fpt)(float); auto _f=xcast<_fpt>(_drva(96368)); return (this->*_f)(deltaT); }
	inline void renderHUD(float deltaT) { typedef void (GameObject::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(deltaT); }
	virtual void renderAudio_vf4(float deltaT);
	inline void renderAudio_impl(float deltaT) { typedef void (GameObject::*_fpt)(float); auto _f=xcast<_fpt>(_drva(96368)); return (this->*_f)(deltaT); }
	inline void renderAudio(float deltaT) { typedef void (GameObject::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 4)); return (this->*_f)(deltaT); }
	virtual void shutdown_vf5();
	inline void shutdown_impl() { typedef void (GameObject::*_fpt)(); auto _f=xcast<_fpt>(_drva(96368)); return (this->*_f)(); }
	inline void shutdown() { typedef void (GameObject::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 5)); return (this->*_f)(); }
	inline GameObject * getGameObject(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name) { typedef GameObject * (GameObject::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *); auto _f=xcast<_fpt>(_drva(1177456)); return (this->*_f)(name); }
	inline void _guard_obj() {
		static_assert((sizeof(GameObject)==88),"bad size");
		static_assert((offsetof(GameObject,game)==0x8),"bad off");
		static_assert((offsetof(GameObject,name)==0x10),"bad off");
		static_assert((offsetof(GameObject,isActive)==0x30),"bad off");
		static_assert((offsetof(GameObject,parent)==0x38),"bad off");
		static_assert((offsetof(GameObject,gameObjects)==0x40),"bad off");
	};
};

//UDT: struct OnFlagEvent @len=16
	//_Data: this+0x0, Member, Type: class Car *, car
	//_Data: this+0x8, Member, Type: enum FlagEventType, type
	//_Data: this+0xC, Member, Type: enum PenaltyDescription, description
//UDT;

struct OnFlagEvent {
public:
	Car * car;
	FlagEventType type;
	PenaltyDescription description;
	inline OnFlagEvent() { }
	inline OnFlagEvent(const OnFlagEvent& other) = default;
	inline OnFlagEvent& operator=(const OnFlagEvent& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(OnFlagEvent)==16),"bad size");
		static_assert((offsetof(OnFlagEvent,car)==0x0),"bad off");
		static_assert((offsetof(OnFlagEvent,type)==0x8),"bad off");
		static_assert((offsetof(OnFlagEvent,description)==0xC),"bad off");
	};
};

//UDT: class ShaderVariable @len=64 @vfcount=1
	//_VTable: 
	//_Func: public void ShaderVariable(const ShaderVariable &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void ShaderVariable(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * iname, CBuffer * cbuffer, int ioffset, int isize); @loc=static @len=318 @rva=2135136
	//_Func: public void ~ShaderVariable(); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Data: this+0x8, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, name
	//_Data: this+0x28, Member, Type: enum eVariableType, type
	//_Data: this+0x2C, Member, Type: int, size
	//_Data: this+0x30, Member, Type: int, offset
	//_Data: this+0x38, Member, Type: class CBuffer *, buffer
	//_Func: public void set(int * value); @loc=static @len=17 @rva=2135552
	//_Func: public void set(float * value); @loc=static @len=17 @rva=2135552
	//_Func: public ShaderVariable & operator=(const ShaderVariable &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ShaderVariable {
public:
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > name;
	eVariableType type;
	int size;
	int offset;
	CBuffer * buffer;
	inline ShaderVariable() { }
	inline ShaderVariable(const ShaderVariable& other) = default;
	inline ShaderVariable& operator=(const ShaderVariable& other) = default;
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * iname, CBuffer * cbuffer, int ioffset, int isize) { typedef void (ShaderVariable::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, CBuffer *, int, int); auto _f=xcast<_fpt>(_drva(2135136)); (this->*_f)(iname, cbuffer, ioffset, isize); }
	virtual ~ShaderVariable();
	inline void set(int * value) { typedef void (ShaderVariable::*_fpt)(int *); auto _f=xcast<_fpt>(_drva(2135552)); return (this->*_f)(value); }
	inline void set(float * value) { typedef void (ShaderVariable::*_fpt)(float *); auto _f=xcast<_fpt>(_drva(2135552)); return (this->*_f)(value); }
	inline void _guard_obj() {
		static_assert((sizeof(ShaderVariable)==64),"bad size");
		static_assert((offsetof(ShaderVariable,name)==0x8),"bad off");
		static_assert((offsetof(ShaderVariable,type)==0x28),"bad off");
		static_assert((offsetof(ShaderVariable,size)==0x2C),"bad off");
		static_assert((offsetof(ShaderVariable,offset)==0x30),"bad off");
		static_assert((offsetof(ShaderVariable,buffer)==0x38),"bad off");
	};
};

//UDT: class OptionsManager @len=24 @vfcount=1
	//_VTable: 
	//_Func: public void OptionsManager(const OptionsManager &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void OptionsManager(); @loc=static @len=1210 @rva=1627248
	//_Func: public void ~OptionsManager(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=55 @rva=1628464
	//_Data: this+0x8, Member, Type: class std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,float,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,float> > >, options
	//_Func: protected void loadOptions(); @loc=static @len=446 @rva=1628704
	//_Func: public OptionsManager & operator=(const OptionsManager &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class OptionsManager {
public:
	std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,float,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,float> > > options;
	inline OptionsManager() { }
	inline OptionsManager(const OptionsManager& other) = default;
	inline OptionsManager& operator=(const OptionsManager& other) = default;
	inline void ctor() { typedef void (OptionsManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1627248)); (this->*_f)(); }
	virtual ~OptionsManager();
	inline void dtor() { typedef void (OptionsManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1628464)); (this->*_f)(); }
	inline void loadOptions() { typedef void (OptionsManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1628704)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(OptionsManager)==24),"bad size");
		static_assert((offsetof(OptionsManager,options)==0x8),"bad off");
	};
};

//UDT: class TimeLine @len=56 @vfcount=1
	//_VTable: 
	//_Func: public void TimeLine(const TimeLine &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void TimeLine(const vec3f & p1, const vec3f & p2, int iid, TimeLineType type); @loc=static @len=303 @rva=2928048
	//_Func: public void ~TimeLine(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=11 @rva=2928352
	//_Data: this+0x8, Member, Type: enum TimeLineType, type
	//_Func: public eTimeLineCheckResponse check(const vec3f & p); @loc=static @len=239 @rva=2928368
	//_Func: public int getID(); @loc=optimized @len=0 @rva=0
	//_Func: public vec3f getPoint(int  _arg0); @loc=optimized @len=0 @rva=0
	//_Data: this+0xC, Member, Type: class vec3f[0x2], points
	//_Data: this+0x24, Member, Type: int, id
	//_Data: this+0x28, Member, Type: float, length
	//_Data: this+0x2C, Member, Type: class vec3f, planeNormal
	//_Func: public TimeLine & operator=(const TimeLine &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class TimeLine {
public:
	TimeLineType type;
	vec3f points[2];
	int id;
	float length;
	vec3f planeNormal;
	inline TimeLine() { }
	inline TimeLine(const TimeLine& other) = default;
	inline TimeLine& operator=(const TimeLine& other) = default;
	inline void ctor(const vec3f & p1, const vec3f & p2, int iid, TimeLineType type) { typedef void (TimeLine::*_fpt)(const vec3f &, const vec3f &, int, TimeLineType); auto _f=xcast<_fpt>(_drva(2928048)); (this->*_f)(p1, p2, iid, type); }
	virtual ~TimeLine();
	inline void dtor() { typedef void (TimeLine::*_fpt)(); auto _f=xcast<_fpt>(_drva(2928352)); (this->*_f)(); }
	inline eTimeLineCheckResponse check(const vec3f & p) { typedef eTimeLineCheckResponse (TimeLine::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2928368)); return (this->*_f)(p); }
	inline void _guard_obj() {
		static_assert((sizeof(TimeLine)==56),"bad size");
		static_assert((offsetof(TimeLine,type)==0x8),"bad off");
		static_assert((offsetof(TimeLine,points)==0xC),"bad off");
		static_assert((offsetof(TimeLine,id)==0x24),"bad off");
		static_assert((offsetof(TimeLine,length)==0x28),"bad off");
		static_assert((offsetof(TimeLine,planeNormal)==0x2C),"bad off");
	};
};

//UDT: class CarRaceInfo @len=40 @vfcount=1
	//_VTable: 
	//_Func: public void CarRaceInfo(const CarRaceInfo &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void CarRaceInfo(); @loc=static @len=78 @rva=948448
	//_Func: public void ~CarRaceInfo(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=55 @rva=948528
	//_Func: public void setSpawnPositionIndex(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & setName, int gp); @loc=static @len=26 @rva=951456
	//_Func: public int getSpawnPositionIndex(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & setName); @loc=static @len=20 @rva=950352
	//_Func: public void init(CarAvatar * acar); @loc=static @len=760 @rva=950384
	//_Data: this+0x8, Member, Type: class CarAvatar *, car
	//_Data: this+0x10, Member, Type: class std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,int,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,int> > >, spawnPositionIndex
	//_Data: this+0x20, Member, Type: class RaceManager *, raceManager
	//_Func: public CarRaceInfo & operator=(const CarRaceInfo &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class CarRaceInfo {
public:
	CarAvatar * car;
	std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,int,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,int> > > spawnPositionIndex;
	RaceManager * raceManager;
	inline CarRaceInfo() { }
	inline CarRaceInfo(const CarRaceInfo& other) = default;
	inline CarRaceInfo& operator=(const CarRaceInfo& other) = default;
	inline void ctor() { typedef void (CarRaceInfo::*_fpt)(); auto _f=xcast<_fpt>(_drva(948448)); (this->*_f)(); }
	virtual ~CarRaceInfo();
	inline void dtor() { typedef void (CarRaceInfo::*_fpt)(); auto _f=xcast<_fpt>(_drva(948528)); (this->*_f)(); }
	inline void setSpawnPositionIndex(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & setName, int gp) { typedef void (CarRaceInfo::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, int); auto _f=xcast<_fpt>(_drva(951456)); return (this->*_f)(setName, gp); }
	inline int getSpawnPositionIndex(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & setName) { typedef int (CarRaceInfo::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(950352)); return (this->*_f)(setName); }
	inline void init(CarAvatar * acar) { typedef void (CarRaceInfo::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(950384)); return (this->*_f)(acar); }
	inline void _guard_obj() {
		static_assert((sizeof(CarRaceInfo)==40),"bad size");
		static_assert((offsetof(CarRaceInfo,car)==0x8),"bad off");
		static_assert((offsetof(CarRaceInfo,spawnPositionIndex)==0x10),"bad off");
		static_assert((offsetof(CarRaceInfo,raceManager)==0x20),"bad off");
	};
};

//UDT: class Shader @len=200 @vfcount=1
	//_VTable: 
	//_Func: public void Shader(const Shader &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void Shader(GraphicsManager * graphics, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ifilename); @loc=static @len=262 @rva=2203104
	//_Func: public void ~Shader(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=596 @rva=2203376
	//_Data: this+0x8, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, name
	//_Data: this+0x28, Member, Type: class std::vector<ShaderVariable *,std::allocator<ShaderVariable *> >, vars
	//_Data: this+0x40, Member, Type: class std::vector<ShaderResource *,std::allocator<ShaderResource *> >, resources
	//_Data: this+0x58, Member, Type: class std::vector<CBuffer *,std::allocator<CBuffer *> >, cBuffers
	//_Data: this+0x70, Member, Type: class std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, options
	//_Data: this+0x88, Member, Type: bool, isAlphaTested
	//_Data: this+0x8C, Member, Type: enum ILType, ilType
	//_Data: this+0x90, Member, Type: int, guid
	//_Data: this+0x94, Member, Type: bool, useNullPS
	//_Func: public void apply(); @loc=static @len=12 @rva=2204592
	//_Func: public ShaderVariable * getVar(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name); @loc=static @len=206 @rva=2204608
	//_Func: public void applyConstantBuffers(); @loc=optimized @len=0 @rva=0
	//_Data: static, [0155A350][0003:00047350], Static Member, Type: int, guidCount
	//_Data: this+0x98, Member, Type: class GraphicsManager *, graphics
	//_Data: this+0xA0, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, filename
	//_Data: this+0xC0, Member, Type: void *, kid
	//_Func: protected bool initShaderBinary(); @loc=static @len=182 @rva=2204816
	//_Func: protected void loadVertexShader(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: protected void loadPixelShader(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: protected void reflectVars(); @loc=static @len=1681 @rva=2205008
	//_Func: protected CBuffer * getCBuffer(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public Shader & operator=(const Shader &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class Shader {
public:
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > name;
	std::vector<ShaderVariable *,std::allocator<ShaderVariable *> > vars;
	std::vector<ShaderResource *,std::allocator<ShaderResource *> > resources;
	std::vector<CBuffer *,std::allocator<CBuffer *> > cBuffers;
	std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > options;
	bool isAlphaTested;
	ILType ilType;
	int guid;
	bool useNullPS;
	GraphicsManager * graphics;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > filename;
	void * kid;
	inline Shader() { }
	inline Shader(const Shader& other) = default;
	inline Shader& operator=(const Shader& other) = default;
	inline void ctor(GraphicsManager * graphics, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ifilename) { typedef void (Shader::*_fpt)(GraphicsManager *, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2203104)); (this->*_f)(graphics, ifilename); }
	virtual ~Shader();
	inline void dtor() { typedef void (Shader::*_fpt)(); auto _f=xcast<_fpt>(_drva(2203376)); (this->*_f)(); }
	inline void apply() { typedef void (Shader::*_fpt)(); auto _f=xcast<_fpt>(_drva(2204592)); return (this->*_f)(); }
	inline ShaderVariable * getVar(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name) { typedef ShaderVariable * (Shader::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2204608)); return (this->*_f)(name); }
	inline bool initShaderBinary() { typedef bool (Shader::*_fpt)(); auto _f=xcast<_fpt>(_drva(2204816)); return (this->*_f)(); }
	inline void reflectVars() { typedef void (Shader::*_fpt)(); auto _f=xcast<_fpt>(_drva(2205008)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(Shader)==200),"bad size");
		static_assert((offsetof(Shader,name)==0x8),"bad off");
		static_assert((offsetof(Shader,vars)==0x28),"bad off");
		static_assert((offsetof(Shader,resources)==0x40),"bad off");
		static_assert((offsetof(Shader,cBuffers)==0x58),"bad off");
		static_assert((offsetof(Shader,options)==0x70),"bad off");
		static_assert((offsetof(Shader,isAlphaTested)==0x88),"bad off");
		static_assert((offsetof(Shader,ilType)==0x8C),"bad off");
		static_assert((offsetof(Shader,guid)==0x90),"bad off");
		static_assert((offsetof(Shader,useNullPS)==0x94),"bad off");
		static_assert((offsetof(Shader,graphics)==0x98),"bad off");
		static_assert((offsetof(Shader,filename)==0xA0),"bad off");
		static_assert((offsetof(Shader,kid)==0xC0),"bad off");
	};
};

//UDT: struct OnNewSessionEvent @len=120
	//_Data: this+0x0, Member, Type: class Session, newSession
	//_Data: this+0x70, Member, Type: short, index
	//_Func: public void OnNewSessionEvent(const OnNewSessionEvent &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void OnNewSessionEvent(); @loc=optimized @len=0 @rva=0
	//_Func: public void ~OnNewSessionEvent(); @loc=static @len=90 @rva=584992
	//_Func: public OnNewSessionEvent & operator=(const OnNewSessionEvent &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct OnNewSessionEvent {
public:
	Session newSession;
	short index;
	inline OnNewSessionEvent() { }
	inline OnNewSessionEvent(const OnNewSessionEvent& other) = default;
	inline OnNewSessionEvent& operator=(const OnNewSessionEvent& other) = default;
	inline void dtor() { typedef void (OnNewSessionEvent::*_fpt)(); auto _f=xcast<_fpt>(_drva(584992)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(OnNewSessionEvent)==120),"bad size");
		static_assert((offsetof(OnNewSessionEvent,newSession)==0x0),"bad off");
		static_assert((offsetof(OnNewSessionEvent,index)==0x70),"bad off");
	};
};

//UDT: struct DRSDetection @len=32
	//_Data: this+0x0, Member, Type: float, lastSplinePos
	//_Data: this+0x8, Member, Type: class std::vector<DRSDetectionStatus,std::allocator<DRSDetectionStatus> >, statuses
	//_Func: public void DRSDetection(const DRSDetection &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void DRSDetection(); @loc=optimized @len=0 @rva=0
	//_Func: public void ~DRSDetection(); @loc=optimized @len=0 @rva=0
	//_Func: public DRSDetection & operator=(const DRSDetection &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct DRSDetection {
public:
	float lastSplinePos;
	std::vector<DRSDetectionStatus,std::allocator<DRSDetectionStatus> > statuses;
	inline DRSDetection() { }
	inline DRSDetection(const DRSDetection& other) = default;
	inline DRSDetection& operator=(const DRSDetection& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(DRSDetection)==32),"bad size");
		static_assert((offsetof(DRSDetection,lastSplinePos)==0x0),"bad off");
		static_assert((offsetof(DRSDetection,statuses)==0x8),"bad off");
	};
};

//UDT: class IKeyEventListener @len=8 @vfcount=2
	//_VTable: 
	//_Func: public void onKeyDown(const OnKeyEvent &  _arg0); @intro @pure @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Func: public void onKeyChar(unsigned int  _arg0); @intro @pure @virtual vtpo=0 vfid=1 @loc=optimized @len=0 @rva=0
	//_Func: public void IKeyEventListener(const IKeyEventListener &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void IKeyEventListener(); @loc=optimized @len=0 @rva=0
	//_Func: public IKeyEventListener & operator=(const IKeyEventListener &  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class IKeyEventListener {
public:
	inline IKeyEventListener() { }
	inline IKeyEventListener(const IKeyEventListener& other) = default;
	inline IKeyEventListener& operator=(const IKeyEventListener& other) = default;
	virtual void onKeyDown_vf0(const OnKeyEvent &  _arg0) = 0;
	inline void onKeyDown(const OnKeyEvent &  _arg0) { typedef void (IKeyEventListener::*_fpt)(const OnKeyEvent &); auto _f=xcast<_fpt>(get_vfp(this, 0)); return (this->*_f)( _arg0); }
	virtual void onKeyChar_vf1(unsigned int  _arg0) = 0;
	inline void onKeyChar(unsigned int  _arg0) { typedef void (IKeyEventListener::*_fpt)(unsigned int); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)( _arg0); }
	inline void _guard_obj() {
		static_assert((sizeof(IKeyEventListener)==8),"bad size");
	};
};

//UDT: struct PhysicsCPUTimes @len=40
	//_Data: this+0x0, Member, Type: double, carStep
	//_Data: this+0x8, Member, Type: struct CoreCPUTimes, coreCPUTimes
	//_Data: this+0x20, Member, Type: int, currentCPU
	//_Func: public void PhysicsCPUTimes(); @loc=optimized @len=0 @rva=0
//UDT;

struct PhysicsCPUTimes {
public:
	double carStep;
	CoreCPUTimes coreCPUTimes;
	int currentCPU;
	inline PhysicsCPUTimes() { }
	inline PhysicsCPUTimes(const PhysicsCPUTimes& other) = default;
	inline PhysicsCPUTimes& operator=(const PhysicsCPUTimes& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(PhysicsCPUTimes)==40),"bad size");
		static_assert((offsetof(PhysicsCPUTimes,carStep)==0x0),"bad off");
		static_assert((offsetof(PhysicsCPUTimes,coreCPUTimes)==0x8),"bad off");
		static_assert((offsetof(PhysicsCPUTimes,currentCPU)==0x20),"bad off");
	};
};

//UDT: struct AxleJoint @len=64
	//_Data: this+0x0, Member, Type: struct AxleBall, ballCar
	//_Data: this+0x20, Member, Type: struct AxleBall, ballAxle
	//_Func: public void AxleJoint(); @loc=optimized @len=0 @rva=0
//UDT;

struct AxleJoint {
public:
	AxleBall ballCar;
	AxleBall ballAxle;
	inline AxleJoint() { }
	inline AxleJoint(const AxleJoint& other) = default;
	inline AxleJoint& operator=(const AxleJoint& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(AxleJoint)==64),"bad size");
		static_assert((offsetof(AxleJoint,ballCar)==0x0),"bad off");
		static_assert((offsetof(AxleJoint,ballAxle)==0x20),"bad off");
	};
};

//UDT: class Turbo @len=36
	//_Func: public void Turbo(TurboDef & data); @loc=static @len=67 @rva=2811696
	//_Func: public void ~Turbo(); @loc=static @len=3 @rva=96368
	//_Func: public void step(float gas, float rpms, float dt); @loc=static @len=236 @rva=2811840
	//_Func: public float getBoost(); @loc=static @len=11 @rva=2811776
	//_Func: public void reset(); @loc=static @len=8 @rva=2811792
	//_Func: public void setTurboBoostLevel(float value); @loc=static @len=18 @rva=2811808
	//_Func: public float getTurboBoostLevel(); @loc=optimized @len=0 @rva=0
	//_Func: public void setWastegate(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public float getWastegate(); @loc=static @len=6 @rva=2645504
	//_Func: public float getMaxBoost(bool  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void setMaxBoost(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: float, userSetting
	//_Data: this+0x4, Member, Type: float, rotation
	//_Data: this+0x8, Member, Type: struct TurboDef, data
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class Turbo {
public:
	float userSetting;
	float rotation;
	TurboDef data;
	inline Turbo() { }
	inline Turbo(const Turbo& other) = default;
	inline Turbo& operator=(const Turbo& other) = default;
	inline void ctor(TurboDef & data) { typedef void (Turbo::*_fpt)(TurboDef &); auto _f=xcast<_fpt>(_drva(2811696)); (this->*_f)(data); }
	inline void dtor() { typedef void (Turbo::*_fpt)(); auto _f=xcast<_fpt>(_drva(96368)); (this->*_f)(); }
	inline void step(float gas, float rpms, float dt) { typedef void (Turbo::*_fpt)(float, float, float); auto _f=xcast<_fpt>(_drva(2811840)); return (this->*_f)(gas, rpms, dt); }
	inline float getBoost() { typedef float (Turbo::*_fpt)(); auto _f=xcast<_fpt>(_drva(2811776)); return (this->*_f)(); }
	inline void reset() { typedef void (Turbo::*_fpt)(); auto _f=xcast<_fpt>(_drva(2811792)); return (this->*_f)(); }
	inline void setTurboBoostLevel(float value) { typedef void (Turbo::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2811808)); return (this->*_f)(value); }
	inline float getWastegate() { typedef float (Turbo::*_fpt)(); auto _f=xcast<_fpt>(_drva(2645504)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(Turbo)==36),"bad size");
		static_assert((offsetof(Turbo,userSetting)==0x0),"bad off");
		static_assert((offsetof(Turbo,rotation)==0x4),"bad off");
		static_assert((offsetof(Turbo,data)==0x8),"bad off");
	};
};

//UDT: class SinSignalGenerator @len=16 @vfcount=3
	//_Base: class SignalGenerator @off=0 @len=16
	//_Func: public void SinSignalGenerator(const SinSignalGenerator &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void SinSignalGenerator(); @loc=static @len=33 @rva=2197680
	//_Func: public void ~SinSignalGenerator(); @virtual vtpo=0 vfid=0 @loc=static @len=15 @rva=2197728
	//_Func: public float getValue(); @virtual vtpo=0 vfid=2 @loc=static @len=81 @rva=2197808
	//_Func: public SinSignalGenerator & operator=(const SinSignalGenerator &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class SinSignalGenerator : public SignalGenerator {
public:
	inline SinSignalGenerator() { }
	inline SinSignalGenerator(const SinSignalGenerator& other) = default;
	inline SinSignalGenerator& operator=(const SinSignalGenerator& other) = default;
	inline void ctor() { typedef void (SinSignalGenerator::*_fpt)(); auto _f=xcast<_fpt>(_drva(2197680)); (this->*_f)(); }
	virtual ~SinSignalGenerator();
	inline void dtor() { typedef void (SinSignalGenerator::*_fpt)(); auto _f=xcast<_fpt>(_drva(2197728)); (this->*_f)(); }
	virtual float getValue_vf2();
	inline float getValue_impl() { typedef float (SinSignalGenerator::*_fpt)(); auto _f=xcast<_fpt>(_drva(2197808)); return (this->*_f)(); }
	inline float getValue() { typedef float (SinSignalGenerator::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(SinSignalGenerator)==16),"bad size");
	};
};

//UDT: struct SystemCBuffers @len=160
	//_Data: this+0x0, Member, Type: class CBuffer, cbCamera
	//_Data: this+0x28, Member, Type: class CBuffer, cbPerObject
	//_Data: this+0x50, Member, Type: class CBuffer, cbLighting
	//_Data: this+0x78, Member, Type: class CBuffer, cbShadowMap
	//_Func: public void SystemCBuffers(); @loc=optimized @len=0 @rva=0
	//_Func: public void ~SystemCBuffers(); @loc=static @len=65 @rva=2106176
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct SystemCBuffers {
public:
	CBuffer cbCamera;
	CBuffer cbPerObject;
	CBuffer cbLighting;
	CBuffer cbShadowMap;
	inline SystemCBuffers() { }
	inline SystemCBuffers(const SystemCBuffers& other) = default;
	inline SystemCBuffers& operator=(const SystemCBuffers& other) = default;
	inline void dtor() { typedef void (SystemCBuffers::*_fpt)(); auto _f=xcast<_fpt>(_drva(2106176)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(SystemCBuffers)==160),"bad size");
		static_assert((offsetof(SystemCBuffers,cbCamera)==0x0),"bad off");
		static_assert((offsetof(SystemCBuffers,cbPerObject)==0x28),"bad off");
		static_assert((offsetof(SystemCBuffers,cbLighting)==0x50),"bad off");
		static_assert((offsetof(SystemCBuffers,cbShadowMap)==0x78),"bad off");
	};
};

//UDT: class ThermalObject @len=32 @vfcount=1
	//_VTable: 
	//_Func: public void ThermalObject(const ThermalObject &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void ThermalObject(); @loc=static @len=42 @rva=2829952
	//_Func: public void ~ThermalObject(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=11 @rva=2830000
	//_Data: this+0x8, Member, Type: float, tmass
	//_Data: this+0xC, Member, Type: float, coolSpeedK
	//_Data: this+0x10, Member, Type: float, coolFactor
	//_Data: this+0x14, Member, Type: float, heatFactor
	//_Data: this+0x18, Member, Type: float, t
	//_Func: public void step(float dt, float ambientTemp, const Speed & speed); @loc=static @len=128 @rva=2830080
	//_Func: public void addHeadSource(float heat); @loc=static @len=11 @rva=2830064
	//_Data: this+0x1C, Member, Type: float, heatAccumulator
	//_Func: public ThermalObject & operator=(const ThermalObject &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ThermalObject {
public:
	float tmass;
	float coolSpeedK;
	float coolFactor;
	float heatFactor;
	float t;
	float heatAccumulator;
	inline ThermalObject() { }
	inline ThermalObject(const ThermalObject& other) = default;
	inline ThermalObject& operator=(const ThermalObject& other) = default;
	inline void ctor() { typedef void (ThermalObject::*_fpt)(); auto _f=xcast<_fpt>(_drva(2829952)); (this->*_f)(); }
	virtual ~ThermalObject();
	inline void dtor() { typedef void (ThermalObject::*_fpt)(); auto _f=xcast<_fpt>(_drva(2830000)); (this->*_f)(); }
	inline void step(float dt, float ambientTemp, const Speed & speed) { typedef void (ThermalObject::*_fpt)(float, float, const Speed &); auto _f=xcast<_fpt>(_drva(2830080)); return (this->*_f)(dt, ambientTemp, speed); }
	inline void addHeadSource(float heat) { typedef void (ThermalObject::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2830064)); return (this->*_f)(heat); }
	inline void _guard_obj() {
		static_assert((sizeof(ThermalObject)==32),"bad size");
		static_assert((offsetof(ThermalObject,tmass)==0x8),"bad off");
		static_assert((offsetof(ThermalObject,coolSpeedK)==0xC),"bad off");
		static_assert((offsetof(ThermalObject,coolFactor)==0x10),"bad off");
		static_assert((offsetof(ThermalObject,heatFactor)==0x14),"bad off");
		static_assert((offsetof(ThermalObject,t)==0x18),"bad off");
		static_assert((offsetof(ThermalObject,heatAccumulator)==0x1C),"bad off");
	};
};

//UDT: struct PhysicsValueCache @len=4
	//_Data: this+0x0, Member, Type: class Speed, speed
	//_Func: public void PhysicsValueCache(); @loc=optimized @len=0 @rva=0
	//_Func: public void ~PhysicsValueCache(); @loc=static @len=5 @rva=1183184
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct PhysicsValueCache {
public:
	Speed speed;
	inline PhysicsValueCache() { }
	inline PhysicsValueCache(const PhysicsValueCache& other) = default;
	inline PhysicsValueCache& operator=(const PhysicsValueCache& other) = default;
	inline void dtor() { typedef void (PhysicsValueCache::*_fpt)(); auto _f=xcast<_fpt>(_drva(1183184)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(PhysicsValueCache)==4),"bad size");
		static_assert((offsetof(PhysicsValueCache,speed)==0x0),"bad off");
	};
};

//UDT: struct OnMouseMoveEvent @len=12
	//_Base: struct MouseEvent @off=0 @len=12
	//_Func: public void OnMouseMoveEvent(int  _arg0, int  _arg1); @loc=optimized @len=0 @rva=0
//UDT;

struct OnMouseMoveEvent : public MouseEvent {
public:
	inline OnMouseMoveEvent() { }
	inline OnMouseMoveEvent(const OnMouseMoveEvent& other) = default;
	inline OnMouseMoveEvent& operator=(const OnMouseMoveEvent& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(OnMouseMoveEvent)==12),"bad size");
	};
};

//UDT: class ActiveActuator @len=24
	//_Data: this+0x0, Member, Type: float, targetTravel
	//_Data: this+0x4, Member, Type: class PIDController, pid
	//_Func: public void ActiveActuator(); @loc=static @len=33 @rva=2930128
	//_Func: public void ~ActiveActuator(); @loc=static @len=9 @rva=2930176
	//_Func: public float eval(float dt, float currentTravel); @loc=static @len=19 @rva=2930192
	//_Func: public void setPID(float  _arg0, float  _arg1, float  _arg2); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class ActiveActuator {
public:
	float targetTravel;
	PIDController pid;
	inline ActiveActuator() { }
	inline ActiveActuator(const ActiveActuator& other) = default;
	inline ActiveActuator& operator=(const ActiveActuator& other) = default;
	inline void ctor() { typedef void (ActiveActuator::*_fpt)(); auto _f=xcast<_fpt>(_drva(2930128)); (this->*_f)(); }
	inline void dtor() { typedef void (ActiveActuator::*_fpt)(); auto _f=xcast<_fpt>(_drva(2930176)); (this->*_f)(); }
	inline float eval(float dt, float currentTravel) { typedef float (ActiveActuator::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2930192)); return (this->*_f)(dt, currentTravel); }
	inline void _guard_obj() {
		static_assert((sizeof(ActiveActuator)==24),"bad size");
		static_assert((offsetof(ActiveActuator,targetTravel)==0x0),"bad off");
		static_assert((offsetof(ActiveActuator,pid)==0x4),"bad off");
	};
};

//UDT: struct OnMouseWheelMovedEvent @len=16
	//_Base: struct MouseEvent @off=0 @len=12
	//_Func: public void OnMouseWheelMovedEvent(int  _arg0, int  _arg1, float  _arg2); @loc=optimized @len=0 @rva=0
	//_Data: this+0xC, Member, Type: float, delta
//UDT;

struct OnMouseWheelMovedEvent : public MouseEvent {
public:
	float delta;
	inline OnMouseWheelMovedEvent() { }
	inline OnMouseWheelMovedEvent(const OnMouseWheelMovedEvent& other) = default;
	inline OnMouseWheelMovedEvent& operator=(const OnMouseWheelMovedEvent& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(OnMouseWheelMovedEvent)==16),"bad size");
		static_assert((offsetof(OnMouseWheelMovedEvent,delta)==0xC),"bad off");
	};
};

//UDT: struct CarControlsInput @len=8
	//_Data: this+0x0, Member, Type: float, steerLock
	//_Data: this+0x4, Member, Type: class Speed, speed
	//_Func: public void CarControlsInput(); @loc=optimized @len=0 @rva=0
	//_Func: public void ~CarControlsInput(); @loc=static @len=9 @rva=2930176
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct CarControlsInput {
public:
	float steerLock;
	Speed speed;
	inline CarControlsInput() { }
	inline CarControlsInput(const CarControlsInput& other) = default;
	inline CarControlsInput& operator=(const CarControlsInput& other) = default;
	inline void dtor() { typedef void (CarControlsInput::*_fpt)(); auto _f=xcast<_fpt>(_drva(2930176)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(CarControlsInput)==8),"bad size");
		static_assert((offsetof(CarControlsInput,steerLock)==0x0),"bad off");
		static_assert((offsetof(CarControlsInput,speed)==0x4),"bad off");
	};
};

//UDT: struct MLJoint @len=56
	//_Data: this+0x0, Member, Type: struct MLBall, ballCar
	//_Data: this+0x18, Member, Type: struct MLBall, ballTyre
	//_Data: this+0x30, Member, Type: class IJoint *, joint
	//_Func: public void MLJoint(); @loc=optimized @len=0 @rva=0
//UDT;

struct MLJoint {
public:
	MLBall ballCar;
	MLBall ballTyre;
	IJoint * joint;
	inline MLJoint() { }
	inline MLJoint(const MLJoint& other) = default;
	inline MLJoint& operator=(const MLJoint& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(MLJoint)==56),"bad size");
		static_assert((offsetof(MLJoint,ballCar)==0x0),"bad off");
		static_assert((offsetof(MLJoint,ballTyre)==0x18),"bad off");
		static_assert((offsetof(MLJoint,joint)==0x30),"bad off");
	};
};

//UDT: struct Wind @len=20
	//_Data: this+0x0, Member, Type: class vec3f, vector
	//_Data: this+0xC, Member, Type: class Speed, speed
	//_Data: this+0x10, Member, Type: float, directionDeg
	//_Func: public void Wind(); @loc=optimized @len=0 @rva=0
	//_Func: public void ~Wind(); @loc=static @len=9 @rva=2502208
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct Wind {
public:
	vec3f vector;
	Speed speed;
	float directionDeg;
	inline Wind() { }
	inline Wind(const Wind& other) = default;
	inline Wind& operator=(const Wind& other) = default;
	inline void dtor() { typedef void (Wind::*_fpt)(); auto _f=xcast<_fpt>(_drva(2502208)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(Wind)==20),"bad size");
		static_assert((offsetof(Wind,vector)==0x0),"bad off");
		static_assert((offsetof(Wind,speed)==0xC),"bad off");
		static_assert((offsetof(Wind,directionDeg)==0x10),"bad off");
	};
};

//UDT: class BrushTyreModel @len=28
	//_Func: public void BrushTyreModel(); @loc=static @len=46 @rva=2929488
	//_Func: public void ~BrushTyreModel(); @loc=static @len=3 @rva=96368
	//_Data: this+0x0, Member, Type: struct BrushTyreModelData, data
	//_Func: public BrushOutput solve(float slip, float friction, float load, float cf1_mix, float asy); @loc=static @len=286 @rva=2929600
	//_Func: public BrushOutput solveV5(float slip, float load, float asy); @loc=static @len=236 @rva=2929888
	//_Func: public float getCFFromSlipAngle(float angle); @loc=static @len=56 @rva=2929536
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class BrushTyreModel {
public:
	BrushTyreModelData data;
	inline BrushTyreModel() { }
	inline BrushTyreModel(const BrushTyreModel& other) = default;
	inline BrushTyreModel& operator=(const BrushTyreModel& other) = default;
	inline void ctor() { typedef void (BrushTyreModel::*_fpt)(); auto _f=xcast<_fpt>(_drva(2929488)); (this->*_f)(); }
	inline void dtor() { typedef void (BrushTyreModel::*_fpt)(); auto _f=xcast<_fpt>(_drva(96368)); (this->*_f)(); }
	inline BrushOutput solve(float slip, float friction, float load, float cf1_mix, float asy) { typedef BrushOutput (BrushTyreModel::*_fpt)(float, float, float, float, float); auto _f=xcast<_fpt>(_drva(2929600)); return (this->*_f)(slip, friction, load, cf1_mix, asy); }
	inline BrushOutput solveV5(float slip, float load, float asy) { typedef BrushOutput (BrushTyreModel::*_fpt)(float, float, float); auto _f=xcast<_fpt>(_drva(2929888)); return (this->*_f)(slip, load, asy); }
	inline float getCFFromSlipAngle(float angle) { typedef float (BrushTyreModel::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2929536)); return (this->*_f)(angle); }
	inline void _guard_obj() {
		static_assert((sizeof(BrushTyreModel)==28),"bad size");
		static_assert((offsetof(BrushTyreModel,data)==0x0),"bad off");
	};
};

//UDT: struct OnMouseUpEvent @len=12
	//_Base: struct MouseEvent @off=0 @len=12
	//_Func: public void OnMouseUpEvent(int  _arg0, int  _arg1, MouseButton  _arg2); @loc=optimized @len=0 @rva=0
//UDT;

struct OnMouseUpEvent : public MouseEvent {
public:
	inline OnMouseUpEvent() { }
	inline OnMouseUpEvent(const OnMouseUpEvent& other) = default;
	inline OnMouseUpEvent& operator=(const OnMouseUpEvent& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(OnMouseUpEvent)==12),"bad size");
	};
};

//UDT: struct ksgui::ListBoxRowData @len=104
	//_Data: this+0x0, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, name
	//_Data: this+0x20, Member, Type: unsigned int, category
	//_Data: this+0x24, Member, Type: class vec4f, backColor
	//_Func: public void ListBoxRowData(const ksgui_ListBoxRowData & __that); @loc=static @len=116 @rva=2395072
	//_Func: public void ListBoxRowData(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >  _arg0, std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > &  _arg1, unsigned int  _arg2); @loc=optimized @len=0 @rva=0
	//_Func: public void ListBoxRowData(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * text); @loc=static @len=365 @rva=454352
	//_Func: public void addData(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >  _arg0, vec4f  _arg1, vec4f  _arg2); @loc=optimized @len=0 @rva=0
	//_Func: public void setColumn(unsigned int  _arg0, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getColumn(unsigned int columnIndex); @loc=static @len=65 @rva=2398208
	//_Func: public unsigned int columnCount(); @loc=optimized @len=0 @rva=0
	//_Func: public void setColumnForeColor(unsigned int  _arg0, vec4f  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public vec4f getForeColor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
	//_Data: this+0x38, Member, Type: class std::vector<vec4f,std::allocator<vec4f> >, forecolors
	//_Data: this+0x50, Member, Type: class std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, columns
	//_Func: public void ~ListBoxRowData(); @loc=static @len=112 @rva=454992
	//_Func: public ksgui_ListBoxRowData & operator=(const ksgui_ListBoxRowData &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct ksgui_ListBoxRowData {
public:
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > name;
	unsigned int category;
	vec4f backColor;
	std::vector<vec4f,std::allocator<vec4f> > forecolors;
	std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > columns;
	inline ksgui_ListBoxRowData() { }
	inline ksgui_ListBoxRowData(const ksgui_ListBoxRowData& other) = default;
	inline ksgui_ListBoxRowData& operator=(const ksgui_ListBoxRowData& other) = default;
	inline void ctor(const ksgui_ListBoxRowData & __that) { typedef void (ksgui_ListBoxRowData::*_fpt)(const ksgui_ListBoxRowData &); auto _f=xcast<_fpt>(_drva(2395072)); (this->*_f)(__that); }
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * text) { typedef void (ksgui_ListBoxRowData::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *); auto _f=xcast<_fpt>(_drva(454352)); (this->*_f)(text); }
	inline std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getColumn(unsigned int columnIndex) { typedef std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > (ksgui_ListBoxRowData::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(2398208)); return (this->*_f)(columnIndex); }
	inline void dtor() { typedef void (ksgui_ListBoxRowData::*_fpt)(); auto _f=xcast<_fpt>(_drva(454992)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_ListBoxRowData)==104),"bad size");
		static_assert((offsetof(ksgui_ListBoxRowData,name)==0x0),"bad off");
		static_assert((offsetof(ksgui_ListBoxRowData,category)==0x20),"bad off");
		static_assert((offsetof(ksgui_ListBoxRowData,backColor)==0x24),"bad off");
		static_assert((offsetof(ksgui_ListBoxRowData,forecolors)==0x38),"bad off");
		static_assert((offsetof(ksgui_ListBoxRowData,columns)==0x50),"bad off");
	};
};

//UDT: class IRayCaster @len=8 @vfcount=3
	//_VTable: 
	//_Func: public void ~IRayCaster(); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Func: public RayCastHit rayCast(const vec3f &  _arg0, const vec3f &  _arg1); @intro @pure @virtual vtpo=0 vfid=1 @loc=optimized @len=0 @rva=0
	//_Func: public void release(); @intro @pure @virtual vtpo=0 vfid=2 @loc=optimized @len=0 @rva=0
	//_Func: public void IRayCaster(const IRayCaster &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void IRayCaster(); @loc=optimized @len=0 @rva=0
	//_Func: public IRayCaster & operator=(const IRayCaster &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class IRayCaster {
public:
	inline IRayCaster() { }
	inline IRayCaster(const IRayCaster& other) = default;
	inline IRayCaster& operator=(const IRayCaster& other) = default;
	virtual ~IRayCaster();
	virtual RayCastHit rayCast_vf1(const vec3f &  _arg0, const vec3f &  _arg1) = 0;
	inline RayCastHit rayCast(const vec3f &  _arg0, const vec3f &  _arg1) { typedef RayCastHit (IRayCaster::*_fpt)(const vec3f &, const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)( _arg0,  _arg1); }
	virtual void release_vf2() = 0;
	inline void release() { typedef void (IRayCaster::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(IRayCaster)==8),"bad size");
	};
};

//UDT: class ITyreModel @len=8 @vfcount=2
	//_VTable: 
	//_Func: public void ~ITyreModel(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=11 @rva=4503904
	//_Func: public TyreModelOutput solve(const TyreModelInput &  _arg0); @intro @pure @virtual vtpo=0 vfid=1 @loc=optimized @len=0 @rva=0
	//_Func: public void ITyreModel(const ITyreModel &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void ITyreModel(); @loc=optimized @len=0 @rva=0
	//_Func: public ITyreModel & operator=(const ITyreModel &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ITyreModel {
public:
	inline ITyreModel() { }
	inline ITyreModel(const ITyreModel& other) = default;
	inline ITyreModel& operator=(const ITyreModel& other) = default;
	virtual ~ITyreModel();
	inline void dtor() { typedef void (ITyreModel::*_fpt)(); auto _f=xcast<_fpt>(_drva(4503904)); (this->*_f)(); }
	virtual TyreModelOutput solve_vf1(const TyreModelInput &  _arg0) = 0;
	inline TyreModelOutput solve(const TyreModelInput &  _arg0) { typedef TyreModelOutput (ITyreModel::*_fpt)(const TyreModelInput &); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)( _arg0); }
	inline void _guard_obj() {
		static_assert((sizeof(ITyreModel)==8),"bad size");
	};
};

//UDT: class JoypadManager @len=8
	//_Func: public void JoypadManager(const JoypadManager &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void JoypadManager(); @loc=static @len=80 @rva=2375584
	//_Func: public Joypad * getJoypad(); @loc=static @len=4 @rva=100192
	//_Data: this+0x0, Member, Type: class std::unique_ptr<Joypad,std::default_delete<Joypad> >, joypad
	//_Func: public void ~JoypadManager(); @loc=static @len=13 @rva=2367136
	//_Func: public JoypadManager & operator=(const JoypadManager &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class JoypadManager {
public:
	std::unique_ptr<Joypad,std::default_delete<Joypad> > joypad;
	inline JoypadManager() { }
	inline JoypadManager(const JoypadManager& other) = default;
	inline JoypadManager& operator=(const JoypadManager& other) = default;
	inline void ctor() { typedef void (JoypadManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2375584)); (this->*_f)(); }
	inline Joypad * getJoypad() { typedef Joypad * (JoypadManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(100192)); return (this->*_f)(); }
	inline void dtor() { typedef void (JoypadManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2367136)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(JoypadManager)==8),"bad size");
		static_assert((offsetof(JoypadManager,joypad)==0x0),"bad off");
	};
};

//UDT: class Triangle @len=64 @vfcount=1
	//_VTable: 
	//_Func: public void Triangle(const Triangle &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void Triangle(const vec3f & p1, const vec3f & p2, const vec3f & p3); @loc=static @len=564 @rva=2144864
	//_Func: public void Triangle(); @loc=optimized @len=0 @rva=0
	//_Func: public void ~Triangle(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=11 @rva=2145440
	//_Data: this+0x8, Member, Type: class vec3f[0x3], points
	//_Data: this+0x2C, Member, Type: class plane4f, plane
	//_Func: public bool getRayIntersection(const vec3f &  _arg0, const vec3f &  _arg1, vec3f &  _arg2); @loc=optimized @len=0 @rva=0
	//_Func: public float computeArea(); @loc=static @len=175 @rva=2145456
	//_Func: public Triangle & operator=(const Triangle &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class Triangle {
public:
	vec3f points[3];
	plane4f plane;
	inline Triangle() { }
	inline Triangle(const Triangle& other) = default;
	inline Triangle& operator=(const Triangle& other) = default;
	inline void ctor(const vec3f & p1, const vec3f & p2, const vec3f & p3) { typedef void (Triangle::*_fpt)(const vec3f &, const vec3f &, const vec3f &); auto _f=xcast<_fpt>(_drva(2144864)); (this->*_f)(p1, p2, p3); }
	virtual ~Triangle();
	inline void dtor() { typedef void (Triangle::*_fpt)(); auto _f=xcast<_fpt>(_drva(2145440)); (this->*_f)(); }
	inline float computeArea() { typedef float (Triangle::*_fpt)(); auto _f=xcast<_fpt>(_drva(2145456)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(Triangle)==64),"bad size");
		static_assert((offsetof(Triangle,points)==0x8),"bad off");
		static_assert((offsetof(Triangle,plane)==0x2C),"bad off");
	};
};

//UDT: class mat44f @len=64
	//_Data: this+0x0, Member, Type: float, M11
	//_Data: this+0x4, Member, Type: float, M12
	//_Data: this+0x8, Member, Type: float, M13
	//_Data: this+0xC, Member, Type: float, M14
	//_Data: this+0x10, Member, Type: float, M21
	//_Data: this+0x14, Member, Type: float, M22
	//_Data: this+0x18, Member, Type: float, M23
	//_Data: this+0x1C, Member, Type: float, M24
	//_Data: this+0x20, Member, Type: float, M31
	//_Data: this+0x24, Member, Type: float, M32
	//_Data: this+0x28, Member, Type: float, M33
	//_Data: this+0x2C, Member, Type: float, M34
	//_Data: this+0x30, Member, Type: float, M41
	//_Data: this+0x34, Member, Type: float, M42
	//_Data: this+0x38, Member, Type: float, M43
	//_Data: this+0x3C, Member, Type: float, M44
	//_Func: public void mat44f(float  _arg0, float  _arg1, float  _arg2, float  _arg3, float  _arg4, float  _arg5, float  _arg6, float  _arg7, float  _arg8, float  _arg9, float  _arg10, float  _arg11, float  _arg12, float  _arg13, float  _arg14, float  _arg15); @loc=optimized @len=0 @rva=0
	//_Func: public void mat44f(float *  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void mat44f(const mat44f &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void mat44f(); @loc=optimized @len=0 @rva=0
	//_Func: public bool isFinite(); @loc=static @len=485 @rva=2072368
	//_Func: public mat44f createIdentity(); @pure @loc=optimized @len=0 @rva=0
	//_Func: public void loadIdentity(); @loc=optimized @len=0 @rva=0
	//_Func: public mat44f createBillboard(const vec3f & objectPosition, const vec3f & cameraPosition, const vec3f & cameraUpVector, const vec3f & cameraForwardVector); @pure @loc=static @len=646 @rva=511792
	//_Func: public mat44f createBillboard(const vec3f &  _arg0, const mat44f &  _arg1); @pure @loc=optimized @len=0 @rva=0
	//_Func: public mat44f createScale(const vec3f &  _arg0); @pure @loc=optimized @len=0 @rva=0
	//_Func: public mat44f createTarget(const vec3f & cameraPosition, const vec3f & cameraTarget); @pure @loc=static @len=682 @rva=393040
	//_Func: public vec3f toRollPitchYaw(); @loc=optimized @len=0 @rva=0
	//_Func: public mat44f createFromRollPitchYaw(const vec3f &  _arg0); @pure @loc=optimized @len=0 @rva=0
	//_Func: public mat44f createLookAt(const vec3f & cameraPosition, const vec3f & cameraTarget, const vec3f & cameraUpVector); @pure @loc=static @len=811 @rva=147600
	//_Func: public mat44f createPerspectiveOffCenter(float  _arg0, float  _arg1, float  _arg2, float  _arg3, float  _arg4, float  _arg5); @pure @loc=optimized @len=0 @rva=0
	//_Func: public mat44f createPerspective(float  _arg0, float  _arg1, float  _arg2, float  _arg3); @pure @loc=optimized @len=0 @rva=0
	//_Func: public mat44f createOrtho(float  _arg0, float  _arg1, float  _arg2, float  _arg3, float  _arg4, float  _arg5); @pure @loc=optimized @len=0 @rva=0
	//_Func: public void transpose(mat44f &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public vec3f getScale(); @loc=static @len=204 @rva=2071424
	//_Func: public void normalizeRotation(); @loc=optimized @len=0 @rva=0
	//_Func: public void setScale(const vec3f & s); @loc=static @len=591 @rva=2134544
	//_Func: public void setStandardScale(); @loc=optimized @len=0 @rva=0
	//_Func: public mat44f createFromQuaternion(const vec4f &  _arg0); @pure @loc=optimized @len=0 @rva=0
	//_Func: public mat44f createFromAxisAngle(const vec3f & axis, float angle); @pure @loc=static @len=310 @rva=356768
	//_Func: public void setTranslation(const vec3f & value); @loc=static @len=18 @rva=394240
	//_Func: public vec3f getTranslation(); @loc=static @len=21 @rva=296464
	//_Func: public void setUp(const vec3f &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public vec3f getUp(); @loc=optimized @len=0 @rva=0
	//_Func: public vec3f getForward(); @loc=optimized @len=0 @rva=0
	//_Func: public void setForward(const vec3f &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public vec3f getBackward(); @loc=optimized @len=0 @rva=0
	//_Func: public void setRight(const vec3f &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public vec3f getRight(); @loc=optimized @len=0 @rva=0
	//_Func: public bool isIdentity(); @loc=static @len=112 @rva=1817520
	//_Func: public void setFromHeadingUp(const vec3f & h, const vec3f & u); @loc=static @len=264 @rva=393968
	//_Func: public vec4f toQuaternion(); @loc=optimized @len=0 @rva=0
	//_Func: public vec3f toEuler(); @loc=static @len=166 @rva=340800
	//_Func: public mat44f createFromEuler(const vec3f & angles, const vec3f & translation); @pure @loc=static @len=597 @rva=1150704
	//_Func: public mat44f createFromEulerSafe(vec3f euler, vec3f translation); @pure @loc=static @len=337 @rva=1399856
	//_Func: public mat44f invert(); @loc=optimized @len=0 @rva=0
	//_Func: public void print(); @loc=static @len=278 @rva=938816
//UDT;

class mat44f {
public:
	float M11;
	float M12;
	float M13;
	float M14;
	float M21;
	float M22;
	float M23;
	float M24;
	float M31;
	float M32;
	float M33;
	float M34;
	float M41;
	float M42;
	float M43;
	float M44;
	inline mat44f() { }
	inline mat44f(const mat44f& other) = default;
	inline mat44f& operator=(const mat44f& other) = default;
	inline bool isFinite() { typedef bool (mat44f::*_fpt)(); auto _f=xcast<_fpt>(_drva(2072368)); return (this->*_f)(); }
	inline static mat44f createBillboard(const vec3f & objectPosition, const vec3f & cameraPosition, const vec3f & cameraUpVector, const vec3f & cameraForwardVector) { typedef mat44f (*_fpt)(const vec3f &, const vec3f &, const vec3f &, const vec3f &); auto _f=(_fpt)_drva(511792); return _f(objectPosition, cameraPosition, cameraUpVector, cameraForwardVector); }
	inline static mat44f createTarget(const vec3f & cameraPosition, const vec3f & cameraTarget) { typedef mat44f (*_fpt)(const vec3f &, const vec3f &); auto _f=(_fpt)_drva(393040); return _f(cameraPosition, cameraTarget); }
	inline static mat44f createLookAt(const vec3f & cameraPosition, const vec3f & cameraTarget, const vec3f & cameraUpVector) { typedef mat44f (*_fpt)(const vec3f &, const vec3f &, const vec3f &); auto _f=(_fpt)_drva(147600); return _f(cameraPosition, cameraTarget, cameraUpVector); }
	inline vec3f getScale() { typedef vec3f (mat44f::*_fpt)(); auto _f=xcast<_fpt>(_drva(2071424)); return (this->*_f)(); }
	inline void setScale(const vec3f & s) { typedef void (mat44f::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2134544)); return (this->*_f)(s); }
	inline static mat44f createFromAxisAngle(const vec3f & axis, float angle) { typedef mat44f (*_fpt)(const vec3f &, float); auto _f=(_fpt)_drva(356768); return _f(axis, angle); }
	inline void setTranslation(const vec3f & value) { typedef void (mat44f::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(394240)); return (this->*_f)(value); }
	inline vec3f getTranslation() { typedef vec3f (mat44f::*_fpt)(); auto _f=xcast<_fpt>(_drva(296464)); return (this->*_f)(); }
	inline bool isIdentity() { typedef bool (mat44f::*_fpt)(); auto _f=xcast<_fpt>(_drva(1817520)); return (this->*_f)(); }
	inline void setFromHeadingUp(const vec3f & h, const vec3f & u) { typedef void (mat44f::*_fpt)(const vec3f &, const vec3f &); auto _f=xcast<_fpt>(_drva(393968)); return (this->*_f)(h, u); }
	inline vec3f toEuler() { typedef vec3f (mat44f::*_fpt)(); auto _f=xcast<_fpt>(_drva(340800)); return (this->*_f)(); }
	inline static mat44f createFromEuler(const vec3f & angles, const vec3f & translation) { typedef mat44f (*_fpt)(const vec3f &, const vec3f &); auto _f=(_fpt)_drva(1150704); return _f(angles, translation); }
	inline static mat44f createFromEulerSafe(vec3f euler, vec3f translation) { typedef mat44f (*_fpt)(vec3f, vec3f); auto _f=(_fpt)_drva(1399856); return _f(euler, translation); }
	inline void print() { typedef void (mat44f::*_fpt)(); auto _f=xcast<_fpt>(_drva(938816)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(mat44f)==64),"bad size");
		static_assert((offsetof(mat44f,M11)==0x0),"bad off");
		static_assert((offsetof(mat44f,M12)==0x4),"bad off");
		static_assert((offsetof(mat44f,M13)==0x8),"bad off");
		static_assert((offsetof(mat44f,M14)==0xC),"bad off");
		static_assert((offsetof(mat44f,M21)==0x10),"bad off");
		static_assert((offsetof(mat44f,M22)==0x14),"bad off");
		static_assert((offsetof(mat44f,M23)==0x18),"bad off");
		static_assert((offsetof(mat44f,M24)==0x1C),"bad off");
		static_assert((offsetof(mat44f,M31)==0x20),"bad off");
		static_assert((offsetof(mat44f,M32)==0x24),"bad off");
		static_assert((offsetof(mat44f,M33)==0x28),"bad off");
		static_assert((offsetof(mat44f,M34)==0x2C),"bad off");
		static_assert((offsetof(mat44f,M41)==0x30),"bad off");
		static_assert((offsetof(mat44f,M42)==0x34),"bad off");
		static_assert((offsetof(mat44f,M43)==0x38),"bad off");
		static_assert((offsetof(mat44f,M44)==0x3C),"bad off");
	};
};

//UDT: struct DRS @len=48
	//_Func: public void ~DRS(); @loc=static @len=53 @rva=650384
	//_Data: this+0x0, Member, Type: bool, isPresent
	//_Data: this+0x1, Member, Type: bool, isActive
	//_Data: this+0x2, Member, Type: bool, isAvailable
	//_Data: this+0x3, Member, Type: bool, ignoreZones
	//_Data: this+0x8, Member, Type: class std::vector<DRSWingConnection,std::allocator<DRSWingConnection> >, wings
	//_Func: public void init(Car * car); @loc=static @len=2665 @rva=2835248
	//_Func: public void step(float dt); @loc=static @len=312 @rva=2838112
	//_Data: this+0x20, Member, Type: class Car *, car
	//_Data: this+0x28, Member, Type: bool, lastState
	//_Data: this+0x2C, Member, Type: float, limitG
	//_Func: public void DRS(const DRS &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void DRS(); @loc=optimized @len=0 @rva=0
	//_Func: public DRS & operator=(const DRS &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct DRS {
public:
	bool isPresent;
	bool isActive;
	bool isAvailable;
	bool ignoreZones;
	std::vector<DRSWingConnection,std::allocator<DRSWingConnection> > wings;
	Car * car;
	bool lastState;
	float limitG;
	inline DRS() { }
	inline DRS(const DRS& other) = default;
	inline DRS& operator=(const DRS& other) = default;
	inline void dtor() { typedef void (DRS::*_fpt)(); auto _f=xcast<_fpt>(_drva(650384)); (this->*_f)(); }
	inline void init(Car * car) { typedef void (DRS::*_fpt)(Car *); auto _f=xcast<_fpt>(_drva(2835248)); return (this->*_f)(car); }
	inline void step(float dt) { typedef void (DRS::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2838112)); return (this->*_f)(dt); }
	inline void _guard_obj() {
		static_assert((sizeof(DRS)==48),"bad size");
		static_assert((offsetof(DRS,isPresent)==0x0),"bad off");
		static_assert((offsetof(DRS,isActive)==0x1),"bad off");
		static_assert((offsetof(DRS,isAvailable)==0x2),"bad off");
		static_assert((offsetof(DRS,ignoreZones)==0x3),"bad off");
		static_assert((offsetof(DRS,wings)==0x8),"bad off");
		static_assert((offsetof(DRS,car)==0x20),"bad off");
		static_assert((offsetof(DRS,lastState)==0x28),"bad off");
		static_assert((offsetof(DRS,limitG)==0x2C),"bad off");
	};
};

//UDT: struct RemoteSessionResume @len=176
	//_Data: this+0x0, Member, Type: struct RemoteSession, session
	//_Data: this+0x40, Member, Type: struct RemoteSessionResult, results
	//_Func: public void RemoteSessionResume(const RemoteSessionResume &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void RemoteSessionResume(); @loc=static @len=103 @rva=243232
	//_Func: public void ~RemoteSessionResume(); @loc=optimized @len=0 @rva=0
	//_Func: public RemoteSessionResume & operator=(const RemoteSessionResume &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct RemoteSessionResume {
public:
	RemoteSession session;
	RemoteSessionResult results;
	inline RemoteSessionResume() { }
	inline RemoteSessionResume(const RemoteSessionResume& other) = default;
	inline RemoteSessionResume& operator=(const RemoteSessionResume& other) = default;
	inline void ctor() { typedef void (RemoteSessionResume::*_fpt)(); auto _f=xcast<_fpt>(_drva(243232)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(RemoteSessionResume)==176),"bad size");
		static_assert((offsetof(RemoteSessionResume,session)==0x0),"bad off");
		static_assert((offsetof(RemoteSessionResume,results)==0x40),"bad off");
	};
};

//UDT: struct DebugLine @len=44
	//_Func: public void DebugLine(const vec3f &  _arg0, const vec3f &  _arg1, const vec4f &  _arg2, float  _arg3); @loc=optimized @len=0 @rva=0
	//_Func: public void DebugLine(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: class vec3f, p0
	//_Data: this+0xC, Member, Type: class vec3f, p1
	//_Data: this+0x18, Member, Type: class vec4f, color
	//_Data: this+0x28, Member, Type: float, seconds
//UDT;

struct DebugLine {
public:
	vec3f p0;
	vec3f p1;
	vec4f color;
	float seconds;
	inline DebugLine() { }
	inline DebugLine(const DebugLine& other) = default;
	inline DebugLine& operator=(const DebugLine& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(DebugLine)==44),"bad size");
		static_assert((offsetof(DebugLine,p0)==0x0),"bad off");
		static_assert((offsetof(DebugLine,p1)==0xC),"bad off");
		static_assert((offsetof(DebugLine,color)==0x18),"bad off");
		static_assert((offsetof(DebugLine,seconds)==0x28),"bad off");
	};
};

//UDT: struct OnMouseDownEvent @len=12
	//_Base: struct MouseEvent @off=0 @len=12
	//_Func: public void OnMouseDownEvent(int  _arg0, int  _arg1, MouseButton  _arg2); @loc=optimized @len=0 @rva=0
//UDT;

struct OnMouseDownEvent : public MouseEvent {
public:
	inline OnMouseDownEvent() { }
	inline OnMouseDownEvent(const OnMouseDownEvent& other) = default;
	inline OnMouseDownEvent& operator=(const OnMouseDownEvent& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(OnMouseDownEvent)==12),"bad size");
	};
};

//UDT: struct SessionResult @len=120
	//_Func: public void SessionResult(const SessionResult &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void SessionResult(int  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void SessionResult(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: class std::vector<std::vector<Lap,std::allocator<Lap> >,std::allocator<std::vector<Lap,std::allocator<Lap> > > >, laps
	//_Data: this+0x18, Member, Type: class std::vector<Lap,std::allocator<Lap> >, bestLaps
	//_Data: this+0x30, Member, Type: class std::vector<int,std::allocator<int> >, positions
	//_Data: this+0x48, Member, Type: class std::vector<int,std::allocator<int> >, lapCount
	//_Data: this+0x60, Member, Type: class std::vector<float,std::allocator<float> >, total
	//_Func: public void ~SessionResult(); @loc=static @len=249 @rva=611008
	//_Func: public SessionResult & operator=(const SessionResult &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct SessionResult {
public:
	std::vector<std::vector<Lap,std::allocator<Lap> >,std::allocator<std::vector<Lap,std::allocator<Lap> > > > laps;
	std::vector<Lap,std::allocator<Lap> > bestLaps;
	std::vector<int,std::allocator<int> > positions;
	std::vector<int,std::allocator<int> > lapCount;
	std::vector<float,std::allocator<float> > total;
	inline SessionResult() { }
	inline SessionResult(const SessionResult& other) = default;
	inline SessionResult& operator=(const SessionResult& other) = default;
	inline void dtor() { typedef void (SessionResult::*_fpt)(); auto _f=xcast<_fpt>(_drva(611008)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(SessionResult)==120),"bad size");
		static_assert((offsetof(SessionResult,laps)==0x0),"bad off");
		static_assert((offsetof(SessionResult,bestLaps)==0x18),"bad off");
		static_assert((offsetof(SessionResult,positions)==0x30),"bad off");
		static_assert((offsetof(SessionResult,lapCount)==0x48),"bad off");
		static_assert((offsetof(SessionResult,total)==0x60),"bad off");
	};
};

//UDT: class LapDB @len=176
	//_Func: public void LapDB(const LapDB &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void LapDB(CarAvatar * icar); @loc=static @len=165 @rva=1326000
	//_Func: public void reset(); @loc=static @len=369 @rva=1334192
	//_Data: this+0x0, Member, Type: double, totalTime
	//_Data: this+0x8, Member, Type: class std::vector<Lap,std::allocator<Lap> >, laps
	//_Data: this+0x20, Member, Type: struct Lap, bestLap
	//_Data: this+0x68, Member, Type: class CarAvatar *, car
	//_Data: this+0x70, Member, Type: unsigned int, lastLapStartTime
	//_Data: this+0x78, Member, Type: class std::vector<unsigned int,std::allocator<unsigned int> >, currentSplits
	//_Data: this+0x90, Member, Type: class std::vector<unsigned int,std::allocator<unsigned int> >, personalBestSplits
	//_Data: this+0xA8, Member, Type: int, bestLapSplit
	//_Data: this+0xAC, Member, Type: bool, hasCompletedLastLap
	//_Func: public void ~LapDB(); @loc=static @len=242 @rva=1326656
	//_Func: public LapDB & operator=(const LapDB &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class LapDB {
public:
	double totalTime;
	std::vector<Lap,std::allocator<Lap> > laps;
	Lap bestLap;
	CarAvatar * car;
	unsigned int lastLapStartTime;
	std::vector<unsigned int,std::allocator<unsigned int> > currentSplits;
	std::vector<unsigned int,std::allocator<unsigned int> > personalBestSplits;
	int bestLapSplit;
	bool hasCompletedLastLap;
	inline LapDB() { }
	inline LapDB(const LapDB& other) = default;
	inline LapDB& operator=(const LapDB& other) = default;
	inline void ctor(CarAvatar * icar) { typedef void (LapDB::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(1326000)); (this->*_f)(icar); }
	inline void reset() { typedef void (LapDB::*_fpt)(); auto _f=xcast<_fpt>(_drva(1334192)); return (this->*_f)(); }
	inline void dtor() { typedef void (LapDB::*_fpt)(); auto _f=xcast<_fpt>(_drva(1326656)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(LapDB)==176),"bad size");
		static_assert((offsetof(LapDB,totalTime)==0x0),"bad off");
		static_assert((offsetof(LapDB,laps)==0x8),"bad off");
		static_assert((offsetof(LapDB,bestLap)==0x20),"bad off");
		static_assert((offsetof(LapDB,car)==0x68),"bad off");
		static_assert((offsetof(LapDB,lastLapStartTime)==0x70),"bad off");
		static_assert((offsetof(LapDB,currentSplits)==0x78),"bad off");
		static_assert((offsetof(LapDB,personalBestSplits)==0x90),"bad off");
		static_assert((offsetof(LapDB,bestLapSplit)==0xA8),"bad off");
		static_assert((offsetof(LapDB,hasCompletedLastLap)==0xAC),"bad off");
	};
};

//UDT: class ThreadPool @len=104 @vfcount=1
	//_VTable: 
	//_Func: public void ThreadPool(const ThreadPool &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void ThreadPool(int inumThreads, std::function<void __cdecl(int)> * initFun); @loc=static @len=740 @rva=2950304
	//_Func: public void ~ThreadPool(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=323 @rva=2951328
	//_Func: public void join(); @loc=optimized @len=0 @rva=0
	//_Func: public void addTask(Task & task); @loc=static @len=131 @rva=2953008
	//_Func: public unsigned int workersCount(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x8, Member, Type: int, numThreads
	//_Data: this+0x10, Member, Type: class std::vector<std::thread,std::allocator<std::thread> >, workers
	//_Data: this+0x28, Member, Type: bool, stop
	//_Data: this+0x30, Member, Type: class std::deque<Task *,std::allocator<Task *> >, tasks
	//_Data: this+0x58, Member, Type: class std::mutex, queue_mutex
	//_Data: this+0x60, Member, Type: class std::condition_variable, condition
	//_Func: public ThreadPool & operator=(const ThreadPool &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ThreadPool {
public:
	int numThreads;
	std::vector<std::thread,std::allocator<std::thread> > workers;
	bool stop;
	std::deque<Task *,std::allocator<Task *> > tasks;
	std::mutex queue_mutex;
	std::condition_variable condition;
	inline ThreadPool() { }
	inline ThreadPool(const ThreadPool& other) = default;
	inline ThreadPool& operator=(const ThreadPool& other) = default;
	inline void ctor(int inumThreads, std::function<void __cdecl(int)> * initFun) { typedef void (ThreadPool::*_fpt)(int, std::function<void __cdecl(int)> *); auto _f=xcast<_fpt>(_drva(2950304)); (this->*_f)(inumThreads, initFun); }
	virtual ~ThreadPool();
	inline void dtor() { typedef void (ThreadPool::*_fpt)(); auto _f=xcast<_fpt>(_drva(2951328)); (this->*_f)(); }
	inline void addTask(Task & task) { typedef void (ThreadPool::*_fpt)(Task &); auto _f=xcast<_fpt>(_drva(2953008)); return (this->*_f)(task); }
	inline void _guard_obj() {
		static_assert((sizeof(ThreadPool)==104),"bad size");
		static_assert((offsetof(ThreadPool,numThreads)==0x8),"bad off");
		static_assert((offsetof(ThreadPool,workers)==0x10),"bad off");
		static_assert((offsetof(ThreadPool,stop)==0x28),"bad off");
		static_assert((offsetof(ThreadPool,tasks)==0x30),"bad off");
		static_assert((offsetof(ThreadPool,queue_mutex)==0x58),"bad off");
		static_assert((offsetof(ThreadPool,condition)==0x60),"bad off");
	};
};

//UDT: class Curve @len=128 @vfcount=1
	//_VTable: 
	//_Func: public void Curve(const Curve & __that); @loc=static @len=158 @rva=844960
	//_Func: public void Curve(); @loc=static @len=85 @rva=2119856
	//_Func: public void ~Curve(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=216 @rva=2119952
	//_Data: static, [0155A278][0003:00047278], Static Member, Type: class std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, openedFiles
	//_Func: public void load(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ifilename); @loc=static @len=1276 @rva=2124368
	//_Func: public void loadEncrypted(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ifilename, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & dataFile); @loc=static @len=1013 @rva=2125648
	//_Func: public void save(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void scale(float v); @loc=static @len=39 @rva=2126816
	//_Func: public void scaleReferences(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public float getValue(float ref); @loc=static @len=186 @rva=2124176
	//_Func: public float getValueUncapped(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public float getValueCatmullRom(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public float getCubicSplineValue(float ref); @loc=static @len=61 @rva=2124016
	//_Func: public void addValue(float ref, float val); @loc=static @len=312 @rva=2120416
	//_Func: public void resample(float  _arg0, float  _arg1, float  _arg2); @loc=optimized @len=0 @rva=0
	//_Func: public void getMaxValue(float &  _arg0, float &  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public float getMaxReference(); @loc=static @len=10 @rva=2124080
	//_Func: public int getCount(); @loc=static @len=13 @rva=2124000
	//_Func: public float getValueFast(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public std::pair<float,float> getPairAtIndex(int index); @loc=static @len=79 @rva=2124096
	//_Func: public void clear(); @loc=optimized @len=0 @rva=0
	//_Func: public void print(); @loc=static @len=137 @rva=2126672
	//_Data: this+0x8, Member, Type: class std::vector<float,std::allocator<float> >, references
	//_Data: this+0x20, Member, Type: class std::vector<float,std::allocator<float> >, values
	//_Data: this+0x38, Member, Type: float, fastStep
	//_Data: this+0x3C, Member, Type: bool, cubicSplineReady
	//_Data: this+0x40, Member, Type: class CubicSpline<float,float>, cSpline
	//_Data: this+0x60, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, filename
	//_Func: public Curve & operator=(const Curve & __that); @loc=static @len=107 @rva=355408
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class Curve {
public:
	std::vector<float,std::allocator<float> > references;
	std::vector<float,std::allocator<float> > values;
	float fastStep;
	bool cubicSplineReady;
	CubicSpline<float,float> cSpline;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > filename;
	inline Curve() { }
	inline Curve(const Curve& other) = default;
	inline Curve& operator=(const Curve& other) = default;
	inline void ctor(const Curve & __that) { typedef void (Curve::*_fpt)(const Curve &); auto _f=xcast<_fpt>(_drva(844960)); (this->*_f)(__that); }
	inline void ctor() { typedef void (Curve::*_fpt)(); auto _f=xcast<_fpt>(_drva(2119856)); (this->*_f)(); }
	virtual ~Curve();
	inline void dtor() { typedef void (Curve::*_fpt)(); auto _f=xcast<_fpt>(_drva(2119952)); (this->*_f)(); }
	inline void load(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ifilename) { typedef void (Curve::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2124368)); return (this->*_f)(ifilename); }
	inline void loadEncrypted(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ifilename, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & dataFile) { typedef void (Curve::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2125648)); return (this->*_f)(ifilename, dataFile); }
	inline void scale(float v) { typedef void (Curve::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2126816)); return (this->*_f)(v); }
	inline float getValue(float ref) { typedef float (Curve::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2124176)); return (this->*_f)(ref); }
	inline float getCubicSplineValue(float ref) { typedef float (Curve::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2124016)); return (this->*_f)(ref); }
	inline void addValue(float ref, float val) { typedef void (Curve::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2120416)); return (this->*_f)(ref, val); }
	inline float getMaxReference() { typedef float (Curve::*_fpt)(); auto _f=xcast<_fpt>(_drva(2124080)); return (this->*_f)(); }
	inline int getCount() { typedef int (Curve::*_fpt)(); auto _f=xcast<_fpt>(_drva(2124000)); return (this->*_f)(); }
	inline std::pair<float,float> getPairAtIndex(int index) { typedef std::pair<float,float> (Curve::*_fpt)(int); auto _f=xcast<_fpt>(_drva(2124096)); return (this->*_f)(index); }
	inline void print() { typedef void (Curve::*_fpt)(); auto _f=xcast<_fpt>(_drva(2126672)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(Curve)==128),"bad size");
		static_assert((offsetof(Curve,references)==0x8),"bad off");
		static_assert((offsetof(Curve,values)==0x20),"bad off");
		static_assert((offsetof(Curve,fastStep)==0x38),"bad off");
		static_assert((offsetof(Curve,cubicSplineReady)==0x3C),"bad off");
		static_assert((offsetof(Curve,cSpline)==0x40),"bad off");
		static_assert((offsetof(Curve,filename)==0x60),"bad off");
	};
};

//UDT: class UDPSocket @len=56
	//_Func: public void UDPSocket(const UDPSocket &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void UDPSocket(unsigned short  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void UDPSocket(); @loc=static @len=64 @rva=2477984
	//_Func: public void ~UDPSocket(); @loc=static @len=50 @rva=2478064
	//_Func: public void bindToPort(unsigned short  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void setBlockingMode(bool imode); @loc=static @len=13 @rva=2479568
	//_Func: public bool getBlockingMode(); @loc=optimized @len=0 @rva=0
	//_Func: public void addListener(std::function<void __cdecl(UDPMessage const &)> * listener); @loc=static @len=125 @rva=2478736
	//_Func: public int receive(std::function<void __cdecl(UDPMessage const &)>  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public int receive(int maxPackets); @loc=static @len=382 @rva=2479104
	//_Func: public void send(void * data, int length, sockaddr_in target); @loc=static @len=76 @rva=2479488
	//_Func: public unsigned short getPing(); @loc=optimized @len=0 @rva=0
	//_Func: public double getLastPingTime(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: unsigned __int64, soc
	//_Data: this+0x8, Member, Type: bool, isBlocking
	//_Data: this+0x10, Member, Type: class std::vector<std::function<void __cdecl(UDPMessage const &)>,std::allocator<std::function<void __cdecl(UDPMessage const &)> > >, listeners
	//_Data: this+0x28, Member, Type: unsigned short, ping
	//_Data: this+0x2A, Member, Type: bool, shutdownFlag
	//_Data: this+0x30, Member, Type: double, lastPingTime
	//_Func: private void broadcastMessage(const UDPMessage &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public UDPSocket & operator=(const UDPSocket &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class UDPSocket {
public:
	unsigned __int64 soc;
	bool isBlocking;
	std::vector<std::function<void __cdecl(UDPMessage const &)>,std::allocator<std::function<void __cdecl(UDPMessage const &)> > > listeners;
	unsigned short ping;
	bool shutdownFlag;
	double lastPingTime;
	inline UDPSocket() { }
	inline UDPSocket(const UDPSocket& other) = default;
	inline UDPSocket& operator=(const UDPSocket& other) = default;
	inline void ctor() { typedef void (UDPSocket::*_fpt)(); auto _f=xcast<_fpt>(_drva(2477984)); (this->*_f)(); }
	inline void dtor() { typedef void (UDPSocket::*_fpt)(); auto _f=xcast<_fpt>(_drva(2478064)); (this->*_f)(); }
	inline void setBlockingMode(bool imode) { typedef void (UDPSocket::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(2479568)); return (this->*_f)(imode); }
	inline void addListener(std::function<void __cdecl(UDPMessage const &)> * listener) { typedef void (UDPSocket::*_fpt)(std::function<void __cdecl(UDPMessage const &)> *); auto _f=xcast<_fpt>(_drva(2478736)); return (this->*_f)(listener); }
	inline int receive(int maxPackets) { typedef int (UDPSocket::*_fpt)(int); auto _f=xcast<_fpt>(_drva(2479104)); return (this->*_f)(maxPackets); }
	inline void send(void * data, int length, sockaddr_in target) { typedef void (UDPSocket::*_fpt)(void *, int, sockaddr_in); auto _f=xcast<_fpt>(_drva(2479488)); return (this->*_f)(data, length, target); }
	inline void _guard_obj() {
		static_assert((sizeof(UDPSocket)==56),"bad size");
		static_assert((offsetof(UDPSocket,soc)==0x0),"bad off");
		static_assert((offsetof(UDPSocket,isBlocking)==0x8),"bad off");
		static_assert((offsetof(UDPSocket,listeners)==0x10),"bad off");
		static_assert((offsetof(UDPSocket,ping)==0x28),"bad off");
		static_assert((offsetof(UDPSocket,shutdownFlag)==0x2A),"bad off");
		static_assert((offsetof(UDPSocket,lastPingTime)==0x30),"bad off");
	};
};

//UDT: class TelemetryChannel @len=88
	//_Func: public void TelemetryChannel(const TelemetryChannel & __that); @loc=static @len=148 @rva=2866288
	//_Func: public void TelemetryChannel(const std::basic_string<char,std::char_traits<char>,std::allocator<char> > & name, float * adataSource, TelemetryUnits units, int frequency, float scale); @loc=static @len=156 @rva=2866448
	//_Data: this+0x0, Member, Type: class std::basic_string<char,std::char_traits<char>,std::allocator<char> >, name
	//_Data: this+0x20, Member, Type: struct TelemetryChannelData, data
	//_Data: this+0x40, Member, Type: float *, dataSource
	//_Data: this+0x48, Member, Type: double, lastTickTime
	//_Data: this+0x50, Member, Type: float, scale
	//_Func: public void ~TelemetryChannel(); @loc=static @len=103 @rva=2549872
	//_Func: public TelemetryChannel & operator=(const TelemetryChannel &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class TelemetryChannel {
public:
	std::basic_string<char,std::char_traits<char>,std::allocator<char> > name;
	TelemetryChannelData data;
	float * dataSource;
	double lastTickTime;
	float scale;
	inline TelemetryChannel() { }
	inline TelemetryChannel(const TelemetryChannel& other) = default;
	inline TelemetryChannel& operator=(const TelemetryChannel& other) = default;
	inline void ctor(const TelemetryChannel & __that) { typedef void (TelemetryChannel::*_fpt)(const TelemetryChannel &); auto _f=xcast<_fpt>(_drva(2866288)); (this->*_f)(__that); }
	inline void ctor(const std::basic_string<char,std::char_traits<char>,std::allocator<char> > & name, float * adataSource, TelemetryUnits units, int frequency, float scale) { typedef void (TelemetryChannel::*_fpt)(const std::basic_string<char,std::char_traits<char>,std::allocator<char> > &, float *, TelemetryUnits, int, float); auto _f=xcast<_fpt>(_drva(2866448)); (this->*_f)(name, adataSource, units, frequency, scale); }
	inline void dtor() { typedef void (TelemetryChannel::*_fpt)(); auto _f=xcast<_fpt>(_drva(2549872)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(TelemetryChannel)==88),"bad size");
		static_assert((offsetof(TelemetryChannel,name)==0x0),"bad off");
		static_assert((offsetof(TelemetryChannel,data)==0x20),"bad off");
		static_assert((offsetof(TelemetryChannel,dataSource)==0x40),"bad off");
		static_assert((offsetof(TelemetryChannel,lastTickTime)==0x48),"bad off");
		static_assert((offsetof(TelemetryChannel,scale)==0x50),"bad off");
	};
};

//UDT: struct PerformanceMeter @len=112
	//_Func: public void ~PerformanceMeter(); @loc=static @len=110 @rva=2536400
	//_Data: this+0x0, Member, Type: bool, isEnabled
	//_Func: public void init(Car * car); @loc=static @len=35 @rva=2537408
	//_Func: public void step(float dt); @loc=static @len=497 @rva=2537696
	//_Func: public PerformanceSplit getCurrentSplit(); @loc=static @len=157 @rva=2537216
	//_Func: public bool hasData(); @loc=static @len=19 @rva=2537376
	//_Func: public void reset(); @loc=static @len=87 @rva=2537600
	//_Data: this+0x8, Member, Type: class Car *, car
	//_Data: this+0x10, Member, Type: class std::vector<PerformancePair,std::allocator<PerformancePair> >, currentLap
	//_Data: this+0x28, Member, Type: class std::vector<PerformancePair,std::allocator<PerformancePair> >, bestLap
	//_Data: this+0x40, Member, Type: double, bestLapTime
	//_Data: this+0x48, Member, Type: int, lastLapIndex
	//_Data: this+0x50, Member, Type: double, currentDistance
	//_Data: this+0x58, Member, Type: double, lastRecordedDistance
	//_Data: this+0x60, Member, Type: double, currentDiff
	//_Data: this+0x68, Member, Type: float, currentSpeedDiffMS
	//_Func: public void PerformanceMeter(const PerformanceMeter &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void PerformanceMeter(); @loc=optimized @len=0 @rva=0
	//_Func: public PerformanceMeter & operator=(const PerformanceMeter &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct PerformanceMeter {
public:
	bool isEnabled;
	Car * car;
	std::vector<PerformancePair,std::allocator<PerformancePair> > currentLap;
	std::vector<PerformancePair,std::allocator<PerformancePair> > bestLap;
	double bestLapTime;
	int lastLapIndex;
	double currentDistance;
	double lastRecordedDistance;
	double currentDiff;
	float currentSpeedDiffMS;
	inline PerformanceMeter() { }
	inline PerformanceMeter(const PerformanceMeter& other) = default;
	inline PerformanceMeter& operator=(const PerformanceMeter& other) = default;
	inline void dtor() { typedef void (PerformanceMeter::*_fpt)(); auto _f=xcast<_fpt>(_drva(2536400)); (this->*_f)(); }
	inline void init(Car * car) { typedef void (PerformanceMeter::*_fpt)(Car *); auto _f=xcast<_fpt>(_drva(2537408)); return (this->*_f)(car); }
	inline void step(float dt) { typedef void (PerformanceMeter::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2537696)); return (this->*_f)(dt); }
	inline PerformanceSplit getCurrentSplit() { typedef PerformanceSplit (PerformanceMeter::*_fpt)(); auto _f=xcast<_fpt>(_drva(2537216)); return (this->*_f)(); }
	inline bool hasData() { typedef bool (PerformanceMeter::*_fpt)(); auto _f=xcast<_fpt>(_drva(2537376)); return (this->*_f)(); }
	inline void reset() { typedef void (PerformanceMeter::*_fpt)(); auto _f=xcast<_fpt>(_drva(2537600)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(PerformanceMeter)==112),"bad size");
		static_assert((offsetof(PerformanceMeter,isEnabled)==0x0),"bad off");
		static_assert((offsetof(PerformanceMeter,car)==0x8),"bad off");
		static_assert((offsetof(PerformanceMeter,currentLap)==0x10),"bad off");
		static_assert((offsetof(PerformanceMeter,bestLap)==0x28),"bad off");
		static_assert((offsetof(PerformanceMeter,bestLapTime)==0x40),"bad off");
		static_assert((offsetof(PerformanceMeter,lastLapIndex)==0x48),"bad off");
		static_assert((offsetof(PerformanceMeter,currentDistance)==0x50),"bad off");
		static_assert((offsetof(PerformanceMeter,lastRecordedDistance)==0x58),"bad off");
		static_assert((offsetof(PerformanceMeter,currentDiff)==0x60),"bad off");
		static_assert((offsetof(PerformanceMeter,currentSpeedDiffMS)==0x68),"bad off");
	};
};

//UDT: class CommandManager @len=16
	//_Func: public void CommandManager(const CommandManager &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void CommandManager(); @loc=static @len=8361 @rva=953200
	//_Func: public void ~CommandManager(); @loc=static @len=41 @rva=2105504
	//_Func: public int getCommand(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & commandName); @loc=static @len=16 @rva=962064
	//_Func: public bool isTriggered(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &  _arg0); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: class std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,CommandItem,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,CommandItem> > >, commands
	//_Func: public CommandManager & operator=(const CommandManager &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class CommandManager {
public:
	std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,CommandItem,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,CommandItem> > > commands;
	inline CommandManager() { }
	inline CommandManager(const CommandManager& other) = default;
	inline CommandManager& operator=(const CommandManager& other) = default;
	inline void ctor() { typedef void (CommandManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(953200)); (this->*_f)(); }
	inline void dtor() { typedef void (CommandManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2105504)); (this->*_f)(); }
	inline int getCommand(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & commandName) { typedef int (CommandManager::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(962064)); return (this->*_f)(commandName); }
	inline void _guard_obj() {
		static_assert((sizeof(CommandManager)==16),"bad size");
		static_assert((offsetof(CommandManager,commands)==0x0),"bad off");
	};
};

//UDT: class CameraCarManager @len=112 @vfcount=6
	//_Base: class GameObject @off=0 @len=88
	//_Func: public void CameraCarManager(const CameraCarManager &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void CameraCarManager(Sim * a_sim, CameraForward * a_camera); @loc=static @len=129 @rva=803952
	//_Func: public void ~CameraCarManager(); @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Func: public int getCurrentCameraIndex(); @loc=optimized @len=0 @rva=0
	//_Func: public void setCurrentCamera(unsigned int cameraIndex); @loc=static @len=94 @rva=804720
	//_Func: public int getCameraCount(); @loc=static @len=75 @rva=804544
	//_Func: public void update(float dt); @virtual vtpo=0 vfid=1 @loc=static @len=427 @rva=804816
	//_Func: public void nextCamera(); @loc=static @len=93 @rva=804624
	//_Data: this+0x58, Member, Type: class Sim *, sim
	//_Data: this+0x60, Member, Type: class CameraForward *, camera
	//_Data: this+0x68, Member, Type: unsigned int, currentCameraIndex
	//_Func: public CameraCarManager & operator=(const CameraCarManager &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class CameraCarManager : public GameObject {
public:
	Sim * sim;
	CameraForward * camera;
	unsigned int currentCameraIndex;
	inline CameraCarManager() { }
	inline CameraCarManager(const CameraCarManager& other) = default;
	inline CameraCarManager& operator=(const CameraCarManager& other) = default;
	inline void ctor(Sim * a_sim, CameraForward * a_camera) { typedef void (CameraCarManager::*_fpt)(Sim *, CameraForward *); auto _f=xcast<_fpt>(_drva(803952)); (this->*_f)(a_sim, a_camera); }
	virtual ~CameraCarManager();
	inline void setCurrentCamera(unsigned int cameraIndex) { typedef void (CameraCarManager::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(804720)); return (this->*_f)(cameraIndex); }
	inline int getCameraCount() { typedef int (CameraCarManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(804544)); return (this->*_f)(); }
	virtual void update_vf1(float dt);
	inline void update_impl(float dt) { typedef void (CameraCarManager::*_fpt)(float); auto _f=xcast<_fpt>(_drva(804816)); return (this->*_f)(dt); }
	inline void update(float dt) { typedef void (CameraCarManager::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(dt); }
	inline void nextCamera() { typedef void (CameraCarManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(804624)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(CameraCarManager)==112),"bad size");
		static_assert((offsetof(CameraCarManager,sim)==0x58),"bad off");
		static_assert((offsetof(CameraCarManager,camera)==0x60),"bad off");
		static_assert((offsetof(CameraCarManager,currentCameraIndex)==0x68),"bad off");
	};
};

//UDT: class Texture @len=40
	//_Func: public void Texture(const Texture &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void Texture(const RenderTarget & rt); @loc=static @len=51 @rva=2088512
	//_Func: public void Texture(unsigned char * buffer, unsigned int size); @loc=static @len=56 @rva=2088576
	//_Func: public void Texture(unsigned char * buffer, unsigned int width, unsigned int height, PixelFormat aFormat); @loc=static @len=79 @rva=2088640
	//_Func: public void Texture(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & filename); @loc=static @len=125 @rva=2088384
	//_Func: public void Texture(); @loc=static @len=25 @rva=205552
	//_Func: public void ~Texture(); @loc=static @len=49 @rva=2180672
	//_Data: this+0x0, Member, Type: void *, kid
	//_Data: this+0x8, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, fileName
	//_Func: public void reload(); @loc=optimized @len=0 @rva=0
	//_Func: public void save(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public PixelFormat getTexturePixelFormat(); @loc=optimized @len=0 @rva=0
	//_Func: public void release(); @loc=static @len=35 @rva=2088720
	//_Func: public bool isNull(); @loc=optimized @len=0 @rva=0
	//_Func: public bool isValid(); @loc=optimized @len=0 @rva=0
	//_Func: public void getSize(unsigned int &  _arg0, unsigned int &  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public unsigned int height(); @loc=optimized @len=0 @rva=0
	//_Func: public unsigned int width(); @loc=optimized @len=0 @rva=0
	//_Func: public Texture & operator=(const Texture & __that); @loc=static @len=49 @rva=206640
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class Texture {
public:
	void * kid;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > fileName;
	inline Texture() { }
	inline Texture(const Texture& other) = default;
	inline Texture& operator=(const Texture& other) = default;
	inline void ctor(const RenderTarget & rt) { typedef void (Texture::*_fpt)(const RenderTarget &); auto _f=xcast<_fpt>(_drva(2088512)); (this->*_f)(rt); }
	inline void ctor(unsigned char * buffer, unsigned int size) { typedef void (Texture::*_fpt)(unsigned char *, unsigned int); auto _f=xcast<_fpt>(_drva(2088576)); (this->*_f)(buffer, size); }
	inline void ctor(unsigned char * buffer, unsigned int width, unsigned int height, PixelFormat aFormat) { typedef void (Texture::*_fpt)(unsigned char *, unsigned int, unsigned int, PixelFormat); auto _f=xcast<_fpt>(_drva(2088640)); (this->*_f)(buffer, width, height, aFormat); }
	inline void ctor(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & filename) { typedef void (Texture::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2088384)); (this->*_f)(filename); }
	inline void ctor() { typedef void (Texture::*_fpt)(); auto _f=xcast<_fpt>(_drva(205552)); (this->*_f)(); }
	inline void dtor() { typedef void (Texture::*_fpt)(); auto _f=xcast<_fpt>(_drva(2180672)); (this->*_f)(); }
	inline void release() { typedef void (Texture::*_fpt)(); auto _f=xcast<_fpt>(_drva(2088720)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(Texture)==40),"bad size");
		static_assert((offsetof(Texture,kid)==0x0),"bad off");
		static_assert((offsetof(Texture,fileName)==0x8),"bad off");
	};
};

//UDT: struct DebugString @len=80
	//_Func: public void DebugString(const DebugString & __that); @loc=static @len=108 @rva=508160
	//_Func: public void DebugString(const vec3f &  _arg0, const vec4f &  _arg1, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &  _arg2, int  _arg3, float  _arg4, float  _arg5); @loc=optimized @len=0 @rva=0
	//_Func: public void DebugString(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: class vec3f, p
	//_Data: this+0x10, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, text
	//_Data: this+0x30, Member, Type: class vec4f, color
	//_Data: this+0x40, Member, Type: float, seconds
	//_Data: this+0x44, Member, Type: float, scale
	//_Data: this+0x48, Member, Type: int, stringId
	//_Func: public void ~DebugString(); @loc=static @len=49 @rva=2353488
	//_Func: public DebugString & operator=(const DebugString &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct DebugString {
public:
	vec3f p;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > text;
	vec4f color;
	float seconds;
	float scale;
	int stringId;
	inline DebugString() { }
	inline DebugString(const DebugString& other) = default;
	inline DebugString& operator=(const DebugString& other) = default;
	inline void ctor(const DebugString & __that) { typedef void (DebugString::*_fpt)(const DebugString &); auto _f=xcast<_fpt>(_drva(508160)); (this->*_f)(__that); }
	inline void dtor() { typedef void (DebugString::*_fpt)(); auto _f=xcast<_fpt>(_drva(2353488)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(DebugString)==80),"bad size");
		static_assert((offsetof(DebugString,p)==0x0),"bad off");
		static_assert((offsetof(DebugString,text)==0x10),"bad off");
		static_assert((offsetof(DebugString,color)==0x30),"bad off");
		static_assert((offsetof(DebugString,seconds)==0x40),"bad off");
		static_assert((offsetof(DebugString,scale)==0x44),"bad off");
		static_assert((offsetof(DebugString,stringId)==0x48),"bad off");
	};
};

//UDT: struct TimeTransponder @len=152
	//_Func: public void ~TimeTransponder(); @loc=static @len=184 @rva=2688112
	//_Data: this+0x0, Member, Type: unsigned int, t
	//_Data: this+0x4, Member, Type: unsigned int, lastLap
	//_Data: this+0x8, Member, Type: unsigned int, bestLap
	//_Data: this+0xC, Member, Type: unsigned int, lapCount
	//_Data: this+0x10, Member, Type: bool, finishLinePassed
	//_Data: this+0x11, Member, Type: bool, wasLastLapValid
	//_Func: public void init(Car * car); @loc=static @len=298 @rva=2688960
	//_Func: public bool isValid(); @loc=static @len=195 @rva=2689408
	//_Func: public void onTimeLinePassed(int index, bool isFinishLine); @loc=static @len=569 @rva=2690080
	//_Func: public TimeLineStatus & getStatus(int index); @loc=static @len=217 @rva=2688736
	//_Func: public std::vector<unsigned int,std::allocator<unsigned int> > getLastLapSplits(); @loc=static @len=38 @rva=2688688
	//_Func: public unsigned int getCurrentSplit(int  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void invalidate(); @loc=static @len=112 @rva=2689264
	//_Func: public void reset(); @loc=static @len=219 @rva=2690656
	//_Func: public void step(float dt); @loc=static @len=476 @rva=2691568
	//_Func: public void armFirstLap(); @loc=static @len=8 @rva=2688656
	//_Func: public void addCut(); @loc=static @len=7 @rva=2688640
	//_Func: public int getCuts(); @loc=static @len=7 @rva=2688672
	//_Func: public bool isInOpenTrackTransition(); @loc=static @len=24 @rva=2689376
	//_Data: this+0x18, Member, Type: class std::vector<TimeLineStatus,std::allocator<TimeLineStatus> >, status
	//_Data: this+0x30, Member, Type: class std::vector<unsigned int,std::allocator<unsigned int> >, lastLapSplits
	//_Data: this+0x48, Member, Type: class std::vector<unsigned int,std::allocator<unsigned int> >, bestLapSplits
	//_Data: this+0x60, Member, Type: class std::vector<unsigned int,std::allocator<unsigned int> >, currentSplits
	//_Data: this+0x78, Member, Type: class Car *, car
	//_Data: this+0x80, Member, Type: bool, isFirstLapArmed
	//_Data: this+0x84, Member, Type: int, cuts
	//_Data: this+0x88, Member, Type: bool, extInvalid
	//_Data: this+0x8C, Member, Type: enum OpenTrackTimeState, openTrackState
	//_Data: this+0x90, Member, Type: bool, isOpenTrack
	//_Func: protected void lap(bool valid); @loc=static @len=462 @rva=2689616
	//_Func: protected void split(int sectorIndex); @loc=static @len=155 @rva=2691408
	//_Func: public void TimeTransponder(const TimeTransponder &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void TimeTransponder(); @loc=optimized @len=0 @rva=0
	//_Func: public TimeTransponder & operator=(const TimeTransponder &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct TimeTransponder {
public:
	unsigned int t;
	unsigned int lastLap;
	unsigned int bestLap;
	unsigned int lapCount;
	bool finishLinePassed;
	bool wasLastLapValid;
	std::vector<TimeLineStatus,std::allocator<TimeLineStatus> > status;
	std::vector<unsigned int,std::allocator<unsigned int> > lastLapSplits;
	std::vector<unsigned int,std::allocator<unsigned int> > bestLapSplits;
	std::vector<unsigned int,std::allocator<unsigned int> > currentSplits;
	Car * car;
	bool isFirstLapArmed;
	int cuts;
	bool extInvalid;
	OpenTrackTimeState openTrackState;
	bool isOpenTrack;
	inline TimeTransponder() { }
	inline TimeTransponder(const TimeTransponder& other) = default;
	inline TimeTransponder& operator=(const TimeTransponder& other) = default;
	inline void dtor() { typedef void (TimeTransponder::*_fpt)(); auto _f=xcast<_fpt>(_drva(2688112)); (this->*_f)(); }
	inline void init(Car * car) { typedef void (TimeTransponder::*_fpt)(Car *); auto _f=xcast<_fpt>(_drva(2688960)); return (this->*_f)(car); }
	inline bool isValid() { typedef bool (TimeTransponder::*_fpt)(); auto _f=xcast<_fpt>(_drva(2689408)); return (this->*_f)(); }
	inline void onTimeLinePassed(int index, bool isFinishLine) { typedef void (TimeTransponder::*_fpt)(int, bool); auto _f=xcast<_fpt>(_drva(2690080)); return (this->*_f)(index, isFinishLine); }
	inline TimeLineStatus & getStatus(int index) { typedef TimeLineStatus & (TimeTransponder::*_fpt)(int); auto _f=xcast<_fpt>(_drva(2688736)); return (this->*_f)(index); }
	inline std::vector<unsigned int,std::allocator<unsigned int> > getLastLapSplits() { typedef std::vector<unsigned int,std::allocator<unsigned int> > (TimeTransponder::*_fpt)(); auto _f=xcast<_fpt>(_drva(2688688)); return (this->*_f)(); }
	inline void invalidate() { typedef void (TimeTransponder::*_fpt)(); auto _f=xcast<_fpt>(_drva(2689264)); return (this->*_f)(); }
	inline void reset() { typedef void (TimeTransponder::*_fpt)(); auto _f=xcast<_fpt>(_drva(2690656)); return (this->*_f)(); }
	inline void step(float dt) { typedef void (TimeTransponder::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2691568)); return (this->*_f)(dt); }
	inline void armFirstLap() { typedef void (TimeTransponder::*_fpt)(); auto _f=xcast<_fpt>(_drva(2688656)); return (this->*_f)(); }
	inline void addCut() { typedef void (TimeTransponder::*_fpt)(); auto _f=xcast<_fpt>(_drva(2688640)); return (this->*_f)(); }
	inline int getCuts() { typedef int (TimeTransponder::*_fpt)(); auto _f=xcast<_fpt>(_drva(2688672)); return (this->*_f)(); }
	inline bool isInOpenTrackTransition() { typedef bool (TimeTransponder::*_fpt)(); auto _f=xcast<_fpt>(_drva(2689376)); return (this->*_f)(); }
	inline void lap(bool valid) { typedef void (TimeTransponder::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(2689616)); return (this->*_f)(valid); }
	inline void split(int sectorIndex) { typedef void (TimeTransponder::*_fpt)(int); auto _f=xcast<_fpt>(_drva(2691408)); return (this->*_f)(sectorIndex); }
	inline void _guard_obj() {
		static_assert((sizeof(TimeTransponder)==152),"bad size");
		static_assert((offsetof(TimeTransponder,t)==0x0),"bad off");
		static_assert((offsetof(TimeTransponder,lastLap)==0x4),"bad off");
		static_assert((offsetof(TimeTransponder,bestLap)==0x8),"bad off");
		static_assert((offsetof(TimeTransponder,lapCount)==0xC),"bad off");
		static_assert((offsetof(TimeTransponder,finishLinePassed)==0x10),"bad off");
		static_assert((offsetof(TimeTransponder,wasLastLapValid)==0x11),"bad off");
		static_assert((offsetof(TimeTransponder,status)==0x18),"bad off");
		static_assert((offsetof(TimeTransponder,lastLapSplits)==0x30),"bad off");
		static_assert((offsetof(TimeTransponder,bestLapSplits)==0x48),"bad off");
		static_assert((offsetof(TimeTransponder,currentSplits)==0x60),"bad off");
		static_assert((offsetof(TimeTransponder,car)==0x78),"bad off");
		static_assert((offsetof(TimeTransponder,isFirstLapArmed)==0x80),"bad off");
		static_assert((offsetof(TimeTransponder,cuts)==0x84),"bad off");
		static_assert((offsetof(TimeTransponder,extInvalid)==0x88),"bad off");
		static_assert((offsetof(TimeTransponder,openTrackState)==0x8C),"bad off");
		static_assert((offsetof(TimeTransponder,isOpenTrack)==0x90),"bad off");
	};
};

//UDT: struct HeaveSpring @len=88
	//_Func: public void ~HeaveSpring(); @loc=static @len=9 @rva=2831104
	//_Data: this+0x0, Member, Type: bool, isPresent
	//_Data: this+0x4, Member, Type: float, rodLength
	//_Data: this+0x8, Member, Type: struct HeaveSpringStatus, status
	//_Data: this+0xC, Member, Type: float, k
	//_Data: this+0x10, Member, Type: float, progressiveK
	//_Data: this+0x14, Member, Type: float, packerRange
	//_Data: this+0x18, Member, Type: float, bumpStopRate
	//_Data: this+0x1C, Member, Type: float, bumpStopUp
	//_Data: this+0x20, Member, Type: float, bumpStopDn
	//_Data: this+0x24, Member, Type: class Damper, damper
	//_Data: this+0x3C, Member, Type: bool, isFront
	//_Func: public void init(Car * car, Suspension * s0, Suspension * s1, bool isFront); @loc=static @len=34 @rva=2831120
	//_Func: public void step(float dt); @loc=static @len=2039 @rva=2832736
	//_Data: this+0x40, Member, Type: class Suspension *[0x2], suspensions
	//_Data: this+0x50, Member, Type: class Car *, car
	//_Func: private void initData(); @loc=static @len=1565 @rva=2831168
	//_Func: public void HeaveSpring(); @loc=static @len=52 @rva=2546416
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct HeaveSpring {
public:
	bool isPresent;
	float rodLength;
	HeaveSpringStatus status;
	float k;
	float progressiveK;
	float packerRange;
	float bumpStopRate;
	float bumpStopUp;
	float bumpStopDn;
	Damper damper;
	bool isFront;
	Suspension * suspensions[2];
	Car * car;
	inline HeaveSpring() { }
	inline HeaveSpring(const HeaveSpring& other) = default;
	inline HeaveSpring& operator=(const HeaveSpring& other) = default;
	inline void dtor() { typedef void (HeaveSpring::*_fpt)(); auto _f=xcast<_fpt>(_drva(2831104)); (this->*_f)(); }
	inline void init(Car * car, Suspension * s0, Suspension * s1, bool isFront) { typedef void (HeaveSpring::*_fpt)(Car *, Suspension *, Suspension *, bool); auto _f=xcast<_fpt>(_drva(2831120)); return (this->*_f)(car, s0, s1, isFront); }
	inline void step(float dt) { typedef void (HeaveSpring::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2832736)); return (this->*_f)(dt); }
	inline void initData() { typedef void (HeaveSpring::*_fpt)(); auto _f=xcast<_fpt>(_drva(2831168)); return (this->*_f)(); }
	inline void ctor() { typedef void (HeaveSpring::*_fpt)(); auto _f=xcast<_fpt>(_drva(2546416)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(HeaveSpring)==88),"bad size");
		static_assert((offsetof(HeaveSpring,isPresent)==0x0),"bad off");
		static_assert((offsetof(HeaveSpring,rodLength)==0x4),"bad off");
		static_assert((offsetof(HeaveSpring,status)==0x8),"bad off");
		static_assert((offsetof(HeaveSpring,k)==0xC),"bad off");
		static_assert((offsetof(HeaveSpring,progressiveK)==0x10),"bad off");
		static_assert((offsetof(HeaveSpring,packerRange)==0x14),"bad off");
		static_assert((offsetof(HeaveSpring,bumpStopRate)==0x18),"bad off");
		static_assert((offsetof(HeaveSpring,bumpStopUp)==0x1C),"bad off");
		static_assert((offsetof(HeaveSpring,bumpStopDn)==0x20),"bad off");
		static_assert((offsetof(HeaveSpring,damper)==0x24),"bad off");
		static_assert((offsetof(HeaveSpring,isFront)==0x3C),"bad off");
		static_assert((offsetof(HeaveSpring,suspensions)==0x40),"bad off");
		static_assert((offsetof(HeaveSpring,car)==0x50),"bad off");
	};
};

//UDT: class ICarControlsProvider @len=24 @vfcount=12
	//_VTable: 
	//_Func: public void ICarControlsProvider(const ICarControlsProvider &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void ICarControlsProvider(); @loc=optimized @len=0 @rva=0
	//_Func: public void ~ICarControlsProvider(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=11 @rva=523776
	//_Func: public void acquireControls(CarControls *  _arg0, float  _arg1, CarControlsInput *  _arg2); @intro @pure @virtual vtpo=0 vfid=1 @loc=optimized @len=0 @rva=0
	//_Func: public bool getAction(DriverActions  _arg0); @intro @pure @virtual vtpo=0 vfid=2 @loc=optimized @len=0 @rva=0
	//_Func: public void sendFF(float  _arg0, float  _arg1, float  _arg2); @intro @pure @virtual vtpo=0 vfid=3 @loc=optimized @len=0 @rva=0
	//_Func: public const char * getName(); @intro @pure @virtual vtpo=0 vfid=4 @loc=optimized @len=0 @rva=0
	//_Func: public float getFFGlobalGain(); @intro @pure @virtual vtpo=0 vfid=5 @loc=optimized @len=0 @rva=0
	//_Func: public bool isDeviceConnected(); @intro @pure @virtual vtpo=0 vfid=6 @loc=optimized @len=0 @rva=0
	//_Func: public void onAutoShifterChanged(bool newmode); @intro @virtual vtpo=0 vfid=7 @loc=static @len=3 @rva=96368
	//_Func: public void setKeyboardEnabled(bool  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public bool isKeyboardEnabled(); @loc=optimized @len=0 @rva=0
	//_Func: public bool IsKeyboardControl(); @intro @virtual vtpo=0 vfid=8 @loc=static @len=3 @rva=140928
	//_Func: public void setVibrations(const VibrationDef & vibrations); @intro @virtual vtpo=0 vfid=9 @loc=static @len=3 @rva=96368
	//_Func: public void setEngineRPM(float rpm, float minRpm, float maxRpm); @intro @virtual vtpo=0 vfid=10 @loc=static @len=3 @rva=96368
	//_Func: public bool shouldDelete(); @intro @virtual vtpo=0 vfid=11 @loc=static @len=3 @rva=706688
	//_Data: this+0x8, Member, Type: bool, ffEnabled
	//_Data: this+0xC, Member, Type: float, ffFilter
	//_Data: this+0x10, Member, Type: bool, suppressPenalties
	//_Data: this+0x11, Member, Type: bool, isAutoclutchNeeded
	//_Data: this+0x12, Member, Type: bool, useFakeUndersteerFF
	//_Data: this+0x13, Member, Type: bool, keyboardEnabled
	//_Func: public ICarControlsProvider & operator=(const ICarControlsProvider &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ICarControlsProvider {
public:
	bool ffEnabled;
	float ffFilter;
	bool suppressPenalties;
	bool isAutoclutchNeeded;
	bool useFakeUndersteerFF;
	bool keyboardEnabled;
	inline ICarControlsProvider() { }
	inline ICarControlsProvider(const ICarControlsProvider& other) = default;
	inline ICarControlsProvider& operator=(const ICarControlsProvider& other) = default;
	virtual ~ICarControlsProvider();
	inline void dtor() { typedef void (ICarControlsProvider::*_fpt)(); auto _f=xcast<_fpt>(_drva(523776)); (this->*_f)(); }
	virtual void acquireControls_vf1(CarControls *  _arg0, float  _arg1, CarControlsInput *  _arg2) = 0;
	inline void acquireControls(CarControls *  _arg0, float  _arg1, CarControlsInput *  _arg2) { typedef void (ICarControlsProvider::*_fpt)(CarControls *, float, CarControlsInput *); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)( _arg0,  _arg1,  _arg2); }
	virtual bool getAction_vf2(DriverActions  _arg0) = 0;
	inline bool getAction(DriverActions  _arg0) { typedef bool (ICarControlsProvider::*_fpt)(DriverActions); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)( _arg0); }
	virtual void sendFF_vf3(float  _arg0, float  _arg1, float  _arg2) = 0;
	inline void sendFF(float  _arg0, float  _arg1, float  _arg2) { typedef void (ICarControlsProvider::*_fpt)(float, float, float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)( _arg0,  _arg1,  _arg2); }
	virtual const char * getName_vf4() = 0;
	inline const char * getName() { typedef const char * (ICarControlsProvider::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 4)); return (this->*_f)(); }
	virtual float getFFGlobalGain_vf5() = 0;
	inline float getFFGlobalGain() { typedef float (ICarControlsProvider::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 5)); return (this->*_f)(); }
	virtual bool isDeviceConnected_vf6() = 0;
	inline bool isDeviceConnected() { typedef bool (ICarControlsProvider::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 6)); return (this->*_f)(); }
	virtual void onAutoShifterChanged_vf7(bool newmode);
	inline void onAutoShifterChanged_impl(bool newmode) { typedef void (ICarControlsProvider::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(96368)); return (this->*_f)(newmode); }
	inline void onAutoShifterChanged(bool newmode) { typedef void (ICarControlsProvider::*_fpt)(bool); auto _f=xcast<_fpt>(get_vfp(this, 7)); return (this->*_f)(newmode); }
	virtual bool IsKeyboardControl_vf8();
	inline bool IsKeyboardControl_impl() { typedef bool (ICarControlsProvider::*_fpt)(); auto _f=xcast<_fpt>(_drva(140928)); return (this->*_f)(); }
	inline bool IsKeyboardControl() { typedef bool (ICarControlsProvider::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 8)); return (this->*_f)(); }
	virtual void setVibrations_vf9(const VibrationDef & vibrations);
	inline void setVibrations_impl(const VibrationDef & vibrations) { typedef void (ICarControlsProvider::*_fpt)(const VibrationDef &); auto _f=xcast<_fpt>(_drva(96368)); return (this->*_f)(vibrations); }
	inline void setVibrations(const VibrationDef & vibrations) { typedef void (ICarControlsProvider::*_fpt)(const VibrationDef &); auto _f=xcast<_fpt>(get_vfp(this, 9)); return (this->*_f)(vibrations); }
	virtual void setEngineRPM_vf10(float rpm, float minRpm, float maxRpm);
	inline void setEngineRPM_impl(float rpm, float minRpm, float maxRpm) { typedef void (ICarControlsProvider::*_fpt)(float, float, float); auto _f=xcast<_fpt>(_drva(96368)); return (this->*_f)(rpm, minRpm, maxRpm); }
	inline void setEngineRPM(float rpm, float minRpm, float maxRpm) { typedef void (ICarControlsProvider::*_fpt)(float, float, float); auto _f=xcast<_fpt>(get_vfp(this, 10)); return (this->*_f)(rpm, minRpm, maxRpm); }
	virtual bool shouldDelete_vf11();
	inline bool shouldDelete_impl() { typedef bool (ICarControlsProvider::*_fpt)(); auto _f=xcast<_fpt>(_drva(706688)); return (this->*_f)(); }
	inline bool shouldDelete() { typedef bool (ICarControlsProvider::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 11)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(ICarControlsProvider)==24),"bad size");
		static_assert((offsetof(ICarControlsProvider,ffEnabled)==0x8),"bad off");
		static_assert((offsetof(ICarControlsProvider,ffFilter)==0xC),"bad off");
		static_assert((offsetof(ICarControlsProvider,suppressPenalties)==0x10),"bad off");
		static_assert((offsetof(ICarControlsProvider,isAutoclutchNeeded)==0x11),"bad off");
		static_assert((offsetof(ICarControlsProvider,useFakeUndersteerFF)==0x12),"bad off");
		static_assert((offsetof(ICarControlsProvider,keyboardEnabled)==0x13),"bad off");
	};
};

//UDT: class Font @len=32
	//_Func: public void Font(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & fontFamily, eFontType fontType, float size, bool italic, bool bold); @loc=static @len=323 @rva=2099808
	//_Func: public void Font(eFontType fontType, float size, bool italic, bool bold); @loc=static @len=240 @rva=2100144
	//_Func: public void ~Font(); @loc=static @len=3 @rva=96368
	//_Func: public void cleanup(); @pure @loc=static @len=157 @rva=2101040
	//_Data: this+0x0, Member, Type: float, scale
	//_Data: this+0x4, Member, Type: bool, shadowed
	//_Data: this+0x8, Member, Type: float, shadowPixelDistance
	//_Func: public void blitString(float x, float y, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & s, float ascale, eFontAlign align); @loc=static @len=261 @rva=2100768
	//_Func: public void setColor(const vec4f & cc); @loc=static @len=113 @rva=2102576
	//_Func: public void setColor(float r, float g, float b, float a); @loc=static @len=101 @rva=2102704
	//_Data: this+0x10, Member, Type: void *, kid
	//_Data: this+0x18, Member, Type: unsigned int, color
	//_Data: this+0x1C, Member, Type: float, currentAlpha
	//_Data: static, [0155A260][0003:00047260], Static Member, Type: class std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,void *,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,void *> > >, fontWrappers
	//_Func: private void * getFontWrapper(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, bool italic, bool bold); @pure @loc=static @len=1119 @rva=2101456
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class Font {
public:
	float scale;
	bool shadowed;
	float shadowPixelDistance;
	void * kid;
	unsigned int color;
	float currentAlpha;
	inline Font() { }
	inline Font(const Font& other) = default;
	inline Font& operator=(const Font& other) = default;
	inline void ctor(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & fontFamily, eFontType fontType, float size, bool italic, bool bold) { typedef void (Font::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, eFontType, float, bool, bool); auto _f=xcast<_fpt>(_drva(2099808)); (this->*_f)(fontFamily, fontType, size, italic, bold); }
	inline void ctor(eFontType fontType, float size, bool italic, bool bold) { typedef void (Font::*_fpt)(eFontType, float, bool, bool); auto _f=xcast<_fpt>(_drva(2100144)); (this->*_f)(fontType, size, italic, bold); }
	inline void dtor() { typedef void (Font::*_fpt)(); auto _f=xcast<_fpt>(_drva(96368)); (this->*_f)(); }
	inline static void cleanup() { typedef void (*_fpt)(); auto _f=(_fpt)_drva(2101040); return _f(); }
	inline void blitString(float x, float y, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & s, float ascale, eFontAlign align) { typedef void (Font::*_fpt)(float, float, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, float, eFontAlign); auto _f=xcast<_fpt>(_drva(2100768)); return (this->*_f)(x, y, s, ascale, align); }
	inline void setColor(const vec4f & cc) { typedef void (Font::*_fpt)(const vec4f &); auto _f=xcast<_fpt>(_drva(2102576)); return (this->*_f)(cc); }
	inline void setColor(float r, float g, float b, float a) { typedef void (Font::*_fpt)(float, float, float, float); auto _f=xcast<_fpt>(_drva(2102704)); return (this->*_f)(r, g, b, a); }
	inline static void * getFontWrapper(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, bool italic, bool bold) { typedef void * (*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, bool, bool); auto _f=(_fpt)_drva(2101456); return _f(name, italic, bold); }
	inline void _guard_obj() {
		static_assert((sizeof(Font)==32),"bad size");
		static_assert((offsetof(Font,scale)==0x0),"bad off");
		static_assert((offsetof(Font,shadowed)==0x4),"bad off");
		static_assert((offsetof(Font,shadowPixelDistance)==0x8),"bad off");
		static_assert((offsetof(Font,kid)==0x10),"bad off");
		static_assert((offsetof(Font,color)==0x18),"bad off");
		static_assert((offsetof(Font,currentAlpha)==0x1C),"bad off");
	};
};

//UDT: struct SplineLocator @len=48
	//_Func: public void ~SplineLocator(); @loc=static @len=3 @rva=96368
	//_Data: this+0x0, Member, Type: class AISpline *, currentSpline
	//_Func: public void init(Car * car); @loc=static @len=73 @rva=2798240
	//_Func: public void step(float dt); @loc=static @len=370 @rva=2799040
	//_Func: public float getNormalizedPosition(); @loc=optimized @len=0 @rva=0
	//_Func: public int getCurrentIndex(); @loc=optimized @len=0 @rva=0
	//_Func: public float locateOnSpline(AISpline * spline, const vec3f & pos, int & index); @pure @loc=static @len=258 @rva=2798320
	//_Func: public float locateOnSplineWithBounds(AISpline * spline, const vec3f & pos, const std::vector<SplineIndexBound,std::allocator<SplineIndexBound> > & bounds, int & index); @pure @loc=static @len=273 @rva=2798592
	//_Func: public void getSides(float * sides, float nsplinepos); @loc=static @len=355 @rva=2797872
	//_Func: public float getOffset(); @loc=optimized @len=0 @rva=0
	//_Func: public float getRoadLateralPosition(); @loc=optimized @len=0 @rva=0
	//_Func: public void reset(); @loc=static @len=15 @rva=2798880
	//_Func: public void resetToClosestPoint(); @loc=static @len=143 @rva=2798896
	//_Func: public bool isOutside(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x8, Member, Type: class Car *, car
	//_Data: this+0x10, Member, Type: int, currentIndex
	//_Data: this+0x18, Member, Type: class Track *, track
	//_Data: this+0x20, Member, Type: float, normalizedPos
	//_Data: this+0x24, Member, Type: float, offset
	//_Data: this+0x28, Member, Type: bool, isOutsideLimits
	//_Func: public void SplineLocator(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct SplineLocator {
public:
	AISpline * currentSpline;
	Car * car;
	int currentIndex;
	Track * track;
	float normalizedPos;
	float offset;
	bool isOutsideLimits;
	inline SplineLocator() { }
	inline SplineLocator(const SplineLocator& other) = default;
	inline SplineLocator& operator=(const SplineLocator& other) = default;
	inline void dtor() { typedef void (SplineLocator::*_fpt)(); auto _f=xcast<_fpt>(_drva(96368)); (this->*_f)(); }
	inline void init(Car * car) { typedef void (SplineLocator::*_fpt)(Car *); auto _f=xcast<_fpt>(_drva(2798240)); return (this->*_f)(car); }
	inline void step(float dt) { typedef void (SplineLocator::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2799040)); return (this->*_f)(dt); }
	inline static float locateOnSpline(AISpline * spline, const vec3f & pos, int & index) { typedef float (*_fpt)(AISpline *, const vec3f &, int &); auto _f=(_fpt)_drva(2798320); return _f(spline, pos, index); }
	inline static float locateOnSplineWithBounds(AISpline * spline, const vec3f & pos, const std::vector<SplineIndexBound,std::allocator<SplineIndexBound> > & bounds, int & index) { typedef float (*_fpt)(AISpline *, const vec3f &, const std::vector<SplineIndexBound,std::allocator<SplineIndexBound> > &, int &); auto _f=(_fpt)_drva(2798592); return _f(spline, pos, bounds, index); }
	inline void getSides(float * sides, float nsplinepos) { typedef void (SplineLocator::*_fpt)(float *, float); auto _f=xcast<_fpt>(_drva(2797872)); return (this->*_f)(sides, nsplinepos); }
	inline void reset() { typedef void (SplineLocator::*_fpt)(); auto _f=xcast<_fpt>(_drva(2798880)); return (this->*_f)(); }
	inline void resetToClosestPoint() { typedef void (SplineLocator::*_fpt)(); auto _f=xcast<_fpt>(_drva(2798896)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(SplineLocator)==48),"bad size");
		static_assert((offsetof(SplineLocator,currentSpline)==0x0),"bad off");
		static_assert((offsetof(SplineLocator,car)==0x8),"bad off");
		static_assert((offsetof(SplineLocator,currentIndex)==0x10),"bad off");
		static_assert((offsetof(SplineLocator,track)==0x18),"bad off");
		static_assert((offsetof(SplineLocator,normalizedPos)==0x20),"bad off");
		static_assert((offsetof(SplineLocator,offset)==0x24),"bad off");
		static_assert((offsetof(SplineLocator,isOutsideLimits)==0x28),"bad off");
	};
};

//UDT: class CollisionMeshODE @len=48 @vfcount=6
	//_Base: class ICollisionObject @off=0 @len=8
	//_Func: public void CollisionMeshODE(const CollisionMeshODE &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void CollisionMeshODE(PhysicsCore * core, float * vertices, int numVertices, unsigned short * indices, int indexCount, unsigned long group, unsigned long mask, unsigned int space_id); @loc=static @len=366 @rva=2943920
	//_Func: public void ~CollisionMeshODE(); @virtual vtpo=0 vfid=5 @loc=optimized @len=0 @rva=0
	//_Func: public void release(); @virtual vtpo=0 vfid=0 @loc=static @len=18 @rva=2944400
	//_Func: public void setUserPointer(void * p); @virtual vtpo=0 vfid=1 @loc=static @len=5 @rva=2944432
	//_Func: public void * getUserPointer(); @virtual vtpo=0 vfid=2 @loc=static @len=5 @rva=2161840
	//_Func: public vec3f getTriangleNormal(int  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public unsigned long getGroup(); @virtual vtpo=0 vfid=3 @loc=static @len=9 @rva=2944368
	//_Func: public unsigned long getMask(); @virtual vtpo=0 vfid=4 @loc=static @len=9 @rva=2944384
	//_Data: this+0x8, Member, Type: struct dxTriMeshData *, trimeshData
	//_Data: this+0x10, Member, Type: struct dxGeom *, trimesh
	//_Data: this+0x18, Member, Type: float *, lvertices
	//_Data: this+0x20, Member, Type: unsigned short *, lindices
	//_Data: this+0x28, Member, Type: void *, userPointer
	//_Func: public CollisionMeshODE & operator=(const CollisionMeshODE &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=5 @loc=optimized @len=0 @rva=0
//UDT;

class CollisionMeshODE : public ICollisionObject {
public:
	dxTriMeshData * trimeshData;
	dxGeom * trimesh;
	float * lvertices;
	unsigned short * lindices;
	void * userPointer;
	inline CollisionMeshODE() { }
	inline CollisionMeshODE(const CollisionMeshODE& other) = default;
	inline CollisionMeshODE& operator=(const CollisionMeshODE& other) = default;
	inline void ctor(PhysicsCore * core, float * vertices, int numVertices, unsigned short * indices, int indexCount, unsigned long group, unsigned long mask, unsigned int space_id) { typedef void (CollisionMeshODE::*_fpt)(PhysicsCore *, float *, int, unsigned short *, int, unsigned long, unsigned long, unsigned int); auto _f=xcast<_fpt>(_drva(2943920)); (this->*_f)(core, vertices, numVertices, indices, indexCount, group, mask, space_id); }
	virtual ~CollisionMeshODE();
	virtual void release_vf0();
	inline void release_impl() { typedef void (CollisionMeshODE::*_fpt)(); auto _f=xcast<_fpt>(_drva(2944400)); return (this->*_f)(); }
	inline void release() { typedef void (CollisionMeshODE::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 0)); return (this->*_f)(); }
	virtual void setUserPointer_vf1(void * p);
	inline void setUserPointer_impl(void * p) { typedef void (CollisionMeshODE::*_fpt)(void *); auto _f=xcast<_fpt>(_drva(2944432)); return (this->*_f)(p); }
	inline void setUserPointer(void * p) { typedef void (CollisionMeshODE::*_fpt)(void *); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(p); }
	virtual void * getUserPointer_vf2();
	inline void * getUserPointer_impl() { typedef void * (CollisionMeshODE::*_fpt)(); auto _f=xcast<_fpt>(_drva(2161840)); return (this->*_f)(); }
	inline void * getUserPointer() { typedef void * (CollisionMeshODE::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)(); }
	virtual unsigned long getGroup_vf3();
	inline unsigned long getGroup_impl() { typedef unsigned long (CollisionMeshODE::*_fpt)(); auto _f=xcast<_fpt>(_drva(2944368)); return (this->*_f)(); }
	inline unsigned long getGroup() { typedef unsigned long (CollisionMeshODE::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(); }
	virtual unsigned long getMask_vf4();
	inline unsigned long getMask_impl() { typedef unsigned long (CollisionMeshODE::*_fpt)(); auto _f=xcast<_fpt>(_drva(2944384)); return (this->*_f)(); }
	inline unsigned long getMask() { typedef unsigned long (CollisionMeshODE::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 4)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(CollisionMeshODE)==48),"bad size");
		static_assert((offsetof(CollisionMeshODE,trimeshData)==0x8),"bad off");
		static_assert((offsetof(CollisionMeshODE,trimesh)==0x10),"bad off");
		static_assert((offsetof(CollisionMeshODE,lvertices)==0x18),"bad off");
		static_assert((offsetof(CollisionMeshODE,lindices)==0x20),"bad off");
		static_assert((offsetof(CollisionMeshODE,userPointer)==0x28),"bad off");
	};
};

//UDT: struct CarColliderManager @len=128
	//_Func: public void CarColliderManager(const CarColliderManager &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void CarColliderManager(); @loc=static @len=184 @rva=2545584
	//_Func: public void ~CarColliderManager(); @loc=static @len=119 @rva=2766048
	//_Data: this+0x0, Member, Type: bool, isLive
	//_Func: public void init(Car * acar); @loc=static @len=68 @rva=2766672
	//_Func: public void addBox(CarCollisionBox &  _arg0, bool  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public int getBoxesCount(); @loc=optimized @len=0 @rva=0
	//_Func: public CarCollisionBox getBox(int index); @loc=static @len=142 @rva=2766528
	//_Func: public void adjustBox(int  _arg0, const CarCollisionBox &  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public void step(float dt); @loc=static @len=61 @rva=2768208
	//_Data: this+0x8, Member, Type: class std::vector<CarCollisionBox,std::allocator<CarCollisionBox> >, boxes
	//_Data: this+0x20, Member, Type: class FileChangeObserver, observer
	//_Data: this+0x50, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, carModel
	//_Data: this+0x70, Member, Type: class IRigidBody *, carBody
	//_Data: this+0x78, Member, Type: class Car *, car
	//_Func: private void loadINI(); @loc=static @len=1449 @rva=2766752
	//_Func: public CarColliderManager & operator=(const CarColliderManager &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct CarColliderManager {
public:
	bool isLive;
	std::vector<CarCollisionBox,std::allocator<CarCollisionBox> > boxes;
	FileChangeObserver observer;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > carModel;
	IRigidBody * carBody;
	Car * car;
	inline CarColliderManager() { }
	inline CarColliderManager(const CarColliderManager& other) = default;
	inline CarColliderManager& operator=(const CarColliderManager& other) = default;
	inline void ctor() { typedef void (CarColliderManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2545584)); (this->*_f)(); }
	inline void dtor() { typedef void (CarColliderManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2766048)); (this->*_f)(); }
	inline void init(Car * acar) { typedef void (CarColliderManager::*_fpt)(Car *); auto _f=xcast<_fpt>(_drva(2766672)); return (this->*_f)(acar); }
	inline CarCollisionBox getBox(int index) { typedef CarCollisionBox (CarColliderManager::*_fpt)(int); auto _f=xcast<_fpt>(_drva(2766528)); return (this->*_f)(index); }
	inline void step(float dt) { typedef void (CarColliderManager::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2768208)); return (this->*_f)(dt); }
	inline void loadINI() { typedef void (CarColliderManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2766752)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(CarColliderManager)==128),"bad size");
		static_assert((offsetof(CarColliderManager,isLive)==0x0),"bad off");
		static_assert((offsetof(CarColliderManager,boxes)==0x8),"bad off");
		static_assert((offsetof(CarColliderManager,observer)==0x20),"bad off");
		static_assert((offsetof(CarColliderManager,carModel)==0x50),"bad off");
		static_assert((offsetof(CarColliderManager,carBody)==0x70),"bad off");
		static_assert((offsetof(CarColliderManager,car)==0x78),"bad off");
	};
};

//UDT: struct SetupManager @len=80
	//_Func: public void ~SetupManager(); @loc=static @len=71 @rva=2657648
	//_Data: this+0x0, Member, Type: class std::vector<SetupItem,std::allocator<SetupItem> >, items
	//_Func: public void init(Car * acar); @loc=static @len=723 @rva=2658960
	//_Func: public void step(float dt); @loc=static @len=108 @rva=2674832
	//_Func: public SetupItem * getSetupItem(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name); @loc=static @len=215 @rva=2658736
	//_Func: public bool isItemAttached(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public CarSetupState getSetupState(); @loc=optimized @len=0 @rva=0
	//_Func: public float getMinHeightM(); @loc=optimized @len=0 @rva=0
	//_Func: public void forceCheckRules(); @loc=optimized @len=0 @rva=0
	//_Func: public void load(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & filename); @loc=static @len=806 @rva=2673808
	//_Data: this+0x18, Member, Type: bool, checkRules
	//_Data: this+0x20, Member, Type: class Car *, car
	//_Data: this+0x28, Member, Type: class std::vector<float,std::allocator<float> >, gearSettings
	//_Data: this+0x40, Member, Type: float, minimumHeight_m
	//_Data: this+0x44, Member, Type: const float, maxWaitTime
	//_Data: this+0x48, Member, Type: float, waitTime
	//_Data: this+0x4C, Member, Type: enum CarSetupState, setupState
	//_Func: protected void initItems(bool attached); @loc=static @len=13969 @rva=2659696
	//_Func: protected void writeTemplateForLocalization(); @loc=optimized @len=0 @rva=0
	//_Func: protected bool isSetupRespectingRules(); @loc=static @len=128 @rva=2673680
	//_Func: public void SetupManager(const SetupManager &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void SetupManager(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct SetupManager {
public:
	std::vector<SetupItem,std::allocator<SetupItem> > items;
	bool checkRules;
	Car * car;
	std::vector<float,std::allocator<float> > gearSettings;
	float minimumHeight_m;
	float maxWaitTime;
	float waitTime;
	CarSetupState setupState;
	inline SetupManager() { }
	inline SetupManager(const SetupManager& other) = default;
	inline SetupManager& operator=(const SetupManager& other) = default;
	inline void dtor() { typedef void (SetupManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2657648)); (this->*_f)(); }
	inline void init(Car * acar) { typedef void (SetupManager::*_fpt)(Car *); auto _f=xcast<_fpt>(_drva(2658960)); return (this->*_f)(acar); }
	inline void step(float dt) { typedef void (SetupManager::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2674832)); return (this->*_f)(dt); }
	inline SetupItem * getSetupItem(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name) { typedef SetupItem * (SetupManager::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2658736)); return (this->*_f)(name); }
	inline void load(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & filename) { typedef void (SetupManager::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2673808)); return (this->*_f)(filename); }
	inline void initItems(bool attached) { typedef void (SetupManager::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(2659696)); return (this->*_f)(attached); }
	inline bool isSetupRespectingRules() { typedef bool (SetupManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2673680)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(SetupManager)==80),"bad size");
		static_assert((offsetof(SetupManager,items)==0x0),"bad off");
		static_assert((offsetof(SetupManager,checkRules)==0x18),"bad off");
		static_assert((offsetof(SetupManager,car)==0x20),"bad off");
		static_assert((offsetof(SetupManager,gearSettings)==0x28),"bad off");
		static_assert((offsetof(SetupManager,minimumHeight_m)==0x40),"bad off");
		static_assert((offsetof(SetupManager,maxWaitTime)==0x44),"bad off");
		static_assert((offsetof(SetupManager,waitTime)==0x48),"bad off");
		static_assert((offsetof(SetupManager,setupState)==0x4C),"bad off");
	};
};

//UDT: class KGLShader @len=144
	//_Func: public void KGLShader(const KGLShader &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void KGLShader(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &  _arg0, ID3D11Device *  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public void ~KGLShader(); @loc=static @len=117 @rva=126672
	//_Func: public void clearInputLayouts(); @pure @loc=static @len=142 @rva=131232
	//_Data: this+0x0, Member, Type: struct ID3D11VertexShader *, vs
	//_Data: this+0x8, Member, Type: struct ID3D11PixelShader *, ps
	//_Data: this+0x10, Member, Type: struct ID3D11InputLayout *, inputLayout
	//_Data: this+0x18, Member, Type: bool, isAlphaTested
	//_Data: this+0x1C, Member, Type: int, ilType
	//_Data: this+0x20, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, fileName
	//_Data: this+0x40, Member, Type: class std::vector<KGLShaderVar,std::allocator<KGLShaderVar> >, vars
	//_Data: this+0x58, Member, Type: class std::vector<KGLShaderTexture,std::allocator<KGLShaderTexture> >, textures
	//_Data: this+0x70, Member, Type: class std::vector<KGLShaderCBuffer,std::allocator<KGLShaderCBuffer> >, cBuffers
	//_Func: public KGLShaderVar * getVarByName(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name); @loc=static @len=199 @rva=131024
	//_Func: public KGLShaderTexture * getTextureByName(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &  _arg0); @loc=optimized @len=0 @rva=0
	//_Data: this+0x88, Member, Type: struct ID3D11Device *, device
	//_Func: private void loadShaderBinary(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & filename); @loc=static @len=968 @rva=127168
	//_Func: private void createVertexShader(ID3D10Blob * blob); @loc=static @len=190 @rva=128144
	//_Func: private void createPixelShader(ID3D10Blob * blob); @loc=static @len=154 @rva=128336
	//_Func: private void reflectVars(ID3D10Blob * blob, bool isPS); @loc=static @len=2067 @rva=128496
	//_Func: private void addCBuffer(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name, unsigned int size, unsigned int slot); @loc=static @len=347 @rva=130672
	//_Func: public KGLShader & operator=(const KGLShader &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class KGLShader {
public:
	ID3D11VertexShader * vs;
	ID3D11PixelShader * ps;
	ID3D11InputLayout * inputLayout;
	bool isAlphaTested;
	int ilType;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > fileName;
	std::vector<KGLShaderVar,std::allocator<KGLShaderVar> > vars;
	std::vector<KGLShaderTexture,std::allocator<KGLShaderTexture> > textures;
	std::vector<KGLShaderCBuffer,std::allocator<KGLShaderCBuffer> > cBuffers;
	ID3D11Device * device;
	inline KGLShader() { }
	inline KGLShader(const KGLShader& other) = default;
	inline KGLShader& operator=(const KGLShader& other) = default;
	inline void dtor() { typedef void (KGLShader::*_fpt)(); auto _f=xcast<_fpt>(_drva(126672)); (this->*_f)(); }
	inline static void clearInputLayouts() { typedef void (*_fpt)(); auto _f=(_fpt)_drva(131232); return _f(); }
	inline KGLShaderVar * getVarByName(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name) { typedef KGLShaderVar * (KGLShader::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(131024)); return (this->*_f)(name); }
	inline void loadShaderBinary(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & filename) { typedef void (KGLShader::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(127168)); return (this->*_f)(filename); }
	inline void createVertexShader(ID3D10Blob * blob) { typedef void (KGLShader::*_fpt)(ID3D10Blob *); auto _f=xcast<_fpt>(_drva(128144)); return (this->*_f)(blob); }
	inline void createPixelShader(ID3D10Blob * blob) { typedef void (KGLShader::*_fpt)(ID3D10Blob *); auto _f=xcast<_fpt>(_drva(128336)); return (this->*_f)(blob); }
	inline void reflectVars(ID3D10Blob * blob, bool isPS) { typedef void (KGLShader::*_fpt)(ID3D10Blob *, bool); auto _f=xcast<_fpt>(_drva(128496)); return (this->*_f)(blob, isPS); }
	inline void addCBuffer(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name, unsigned int size, unsigned int slot) { typedef void (KGLShader::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, unsigned int, unsigned int); auto _f=xcast<_fpt>(_drva(130672)); return (this->*_f)(name, size, slot); }
	inline void _guard_obj() {
		static_assert((sizeof(KGLShader)==144),"bad size");
		static_assert((offsetof(KGLShader,vs)==0x0),"bad off");
		static_assert((offsetof(KGLShader,ps)==0x8),"bad off");
		static_assert((offsetof(KGLShader,inputLayout)==0x10),"bad off");
		static_assert((offsetof(KGLShader,isAlphaTested)==0x18),"bad off");
		static_assert((offsetof(KGLShader,ilType)==0x1C),"bad off");
		static_assert((offsetof(KGLShader,fileName)==0x20),"bad off");
		static_assert((offsetof(KGLShader,vars)==0x40),"bad off");
		static_assert((offsetof(KGLShader,textures)==0x58),"bad off");
		static_assert((offsetof(KGLShader,cBuffers)==0x70),"bad off");
		static_assert((offsetof(KGLShader,device)==0x88),"bad off");
	};
};

//UDT: class CameraMouseControl @len=176 @vfcount=6
	//_Base: class GameObject @off=0 @len=88
	//_Func: public void CameraMouseControl(const CameraMouseControl &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void CameraMouseControl(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, Camera * camera, Game * igame); @loc=static @len=533 @rva=2358688
	//_Func: public void ~CameraMouseControl(); @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Func: public void update(float deltaT); @virtual vtpo=0 vfid=1 @loc=static @len=331 @rva=2359360
	//_Func: public Camera * getCamera(); @loc=optimized @len=0 @rva=0
	//_Func: public void setAudioDistanceScale(); @loc=static @len=27 @rva=2359328
	//_Func: public void setSpeedSteps(float  _arg0, float  _arg1, float  _arg2); @loc=optimized @len=0 @rva=0
	//_Func: public void setMouseSpeed(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Data: this+0x58, Member, Type: class CameraMouseControlBase, base
	//_Data: this+0x98, Member, Type: bool, initialized
	//_Data: this+0x9C, Member, Type: class vec3f, prevPosition
	//_Data: this+0xA8, Member, Type: float, distanceScale
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class CameraMouseControl : public GameObject {
public:
	CameraMouseControlBase base;
	bool initialized;
	vec3f prevPosition;
	float distanceScale;
	inline CameraMouseControl() { }
	inline CameraMouseControl(const CameraMouseControl& other) = default;
	inline CameraMouseControl& operator=(const CameraMouseControl& other) = default;
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, Camera * camera, Game * igame) { typedef void (CameraMouseControl::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, Camera *, Game *); auto _f=xcast<_fpt>(_drva(2358688)); (this->*_f)(name, camera, igame); }
	virtual ~CameraMouseControl();
	virtual void update_vf1(float deltaT);
	inline void update_impl(float deltaT) { typedef void (CameraMouseControl::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2359360)); return (this->*_f)(deltaT); }
	inline void update(float deltaT) { typedef void (CameraMouseControl::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(deltaT); }
	inline void setAudioDistanceScale() { typedef void (CameraMouseControl::*_fpt)(); auto _f=xcast<_fpt>(_drva(2359328)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(CameraMouseControl)==176),"bad size");
		static_assert((offsetof(CameraMouseControl,base)==0x58),"bad off");
		static_assert((offsetof(CameraMouseControl,initialized)==0x98),"bad off");
		static_assert((offsetof(CameraMouseControl,prevPosition)==0x9C),"bad off");
		static_assert((offsetof(CameraMouseControl,distanceScale)==0xA8),"bad off");
	};
};

//UDT: class TCPSocket @len=65656
	//_Func: public void TCPSocket(const TCPSocket &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void TCPSocket(); @loc=static @len=98 @rva=2481840
	//_Func: public void ~TCPSocket(); @loc=static @len=142 @rva=2482080
	//_Data: this+0x0, Member, Type: class BufferedChannel<unsigned __int64>, chNewConnections
	//_Func: public void setSocket(unsigned __int64  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public bool connect(const IPAddress & target); @loc=static @len=147 @rva=2482592
	//_Func: public void setBlockingMode(bool imode); @loc=static @len=14 @rva=2484144
	//_Func: public bool getBlockingMode(); @loc=optimized @len=0 @rva=0
	//_Func: public void addListener(std::function<void __cdecl(UDPMessage const &)> * listener); @loc=static @len=125 @rva=2482464
	//_Func: public int receive(std::function<void __cdecl(UDPMessage const &)>  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public int receive(int maxPackets); @loc=static @len=285 @rva=2483216
	//_Func: public void send(void * data, int length, sockaddr_in target); @loc=static @len=14 @rva=2484128
	//_Func: public void sendReliable(void *  _arg0, int  _arg1, sockaddr_in  _arg2); @loc=optimized @len=0 @rva=0
	//_Func: public std::vector<unsigned char,std::allocator<unsigned char> > receivePacket(); @loc=static @len=416 @rva=2483504
	//_Func: public void listen(unsigned short  _arg0); @loc=optimized @len=0 @rva=0
	//_Data: this+0x28, Member, Type: class std::vector<std::function<void __cdecl(UDPMessage const &)>,std::allocator<std::function<void __cdecl(UDPMessage const &)> > >, listeners
	//_Data: this+0x40, Member, Type: class std::thread, listenerThread
	//_Data: this+0x50, Member, Type: bool, isExiting
	//_Data: this+0x58, Member, Type: unsigned char *, recvBuffer
	//_Data: this+0x60, Member, Type: unsigned __int64, soc
	//_Data: this+0x68, Member, Type: unsigned __int64, listenSock
	//_Data: this+0x70, Member, Type: bool, isBlocking
	//_Data: this+0x71, Member, Type: bool, isServer
	//_Data: this+0x74, Member, Type: class TCPQueue, buffer
	//_Func: private void broadcastMessage(const UDPMessage &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public TCPSocket & operator=(const TCPSocket &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class TCPSocket {
public:
	BufferedChannel<unsigned __int64> chNewConnections;
	std::vector<std::function<void __cdecl(UDPMessage const &)>,std::allocator<std::function<void __cdecl(UDPMessage const &)> > > listeners;
	std::thread listenerThread;
	bool isExiting;
	unsigned char * recvBuffer;
	unsigned __int64 soc;
	unsigned __int64 listenSock;
	bool isBlocking;
	bool isServer;
	TCPQueue buffer;
	inline TCPSocket() { }
	inline TCPSocket(const TCPSocket& other) = default;
	inline TCPSocket& operator=(const TCPSocket& other) = default;
	inline void ctor() { typedef void (TCPSocket::*_fpt)(); auto _f=xcast<_fpt>(_drva(2481840)); (this->*_f)(); }
	inline void dtor() { typedef void (TCPSocket::*_fpt)(); auto _f=xcast<_fpt>(_drva(2482080)); (this->*_f)(); }
	inline bool connect(const IPAddress & target) { typedef bool (TCPSocket::*_fpt)(const IPAddress &); auto _f=xcast<_fpt>(_drva(2482592)); return (this->*_f)(target); }
	inline void setBlockingMode(bool imode) { typedef void (TCPSocket::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(2484144)); return (this->*_f)(imode); }
	inline void addListener(std::function<void __cdecl(UDPMessage const &)> * listener) { typedef void (TCPSocket::*_fpt)(std::function<void __cdecl(UDPMessage const &)> *); auto _f=xcast<_fpt>(_drva(2482464)); return (this->*_f)(listener); }
	inline int receive(int maxPackets) { typedef int (TCPSocket::*_fpt)(int); auto _f=xcast<_fpt>(_drva(2483216)); return (this->*_f)(maxPackets); }
	inline void send(void * data, int length, sockaddr_in target) { typedef void (TCPSocket::*_fpt)(void *, int, sockaddr_in); auto _f=xcast<_fpt>(_drva(2484128)); return (this->*_f)(data, length, target); }
	inline std::vector<unsigned char,std::allocator<unsigned char> > receivePacket() { typedef std::vector<unsigned char,std::allocator<unsigned char> > (TCPSocket::*_fpt)(); auto _f=xcast<_fpt>(_drva(2483504)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(TCPSocket)==65656),"bad size");
		static_assert((offsetof(TCPSocket,chNewConnections)==0x0),"bad off");
		static_assert((offsetof(TCPSocket,listeners)==0x28),"bad off");
		static_assert((offsetof(TCPSocket,listenerThread)==0x40),"bad off");
		static_assert((offsetof(TCPSocket,isExiting)==0x50),"bad off");
		static_assert((offsetof(TCPSocket,recvBuffer)==0x58),"bad off");
		static_assert((offsetof(TCPSocket,soc)==0x60),"bad off");
		static_assert((offsetof(TCPSocket,listenSock)==0x68),"bad off");
		static_assert((offsetof(TCPSocket,isBlocking)==0x70),"bad off");
		static_assert((offsetof(TCPSocket,isServer)==0x71),"bad off");
		static_assert((offsetof(TCPSocket,buffer)==0x74),"bad off");
	};
};

//UDT: class ACPlugin @len=120 @vfcount=10
	//_Base: class IACPPluginHost @off=0 @len=8
	//_Func: public void ACPlugin(const ACPlugin &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void ACPlugin(Sim * aSim, HINSTANCE__ * module); @loc=static @len=683 @rva=784032
	//_Func: public void ~ACPlugin(); @intro @virtual vtpo=0 vfid=9 @loc=static @len=134 @rva=784720
	//_Data: this+0x8, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, name
	//_Func: public void update(ACCarState * state, float dt); @loc=static @len=19 @rva=785920
	//_Func: public void onGui(ACPluginContext * cc); @loc=static @len=16 @rva=785184
	//_Func: public HWND__ * getHwnd(); @virtual vtpo=0 vfid=0 @loc=static @len=8 @rva=785168
	//_Func: public HINSTANCE__ * getHInstance(); @virtual vtpo=0 vfid=1 @loc=static @len=8 @rva=785152
	//_Func: public void setABS(float value); @virtual vtpo=0 vfid=2 @loc=static @len=62 @rva=785200
	//_Func: public void setTC(float value); @virtual vtpo=0 vfid=3 @loc=static @len=62 @rva=785856
	//_Func: public void setStabilityControl(float value); @virtual vtpo=0 vfid=4 @loc=static @len=13 @rva=785440
	//_Func: public void setIdealLine(bool value, bool isFromPhysicsThread); @virtual vtpo=0 vfid=5 @loc=static @len=137 @rva=785296
	//_Func: public void setAutoShift(bool value); @virtual vtpo=0 vfid=6 @loc=static @len=11 @rva=785264
	//_Func: public void setBrakeBias(float value); @virtual vtpo=0 vfid=7 @loc=static @len=13 @rva=785280
	//_Func: public void setSystemMessage(const wchar_t * message, const wchar_t * description, bool isFromPhysicsThread); @virtual vtpo=0 vfid=8 @loc=static @len=388 @rva=785456
	//_Data: this+0x28, Member, Type: struct HINSTANCE__ *, hModule
	//_Data: this+0x30, Member, Type: function  *, getName
	//_Data: this+0x38, Member, Type: function  *, init
	//_Data: this+0x40, Member, Type: function  *, shutdown
	//_Data: this+0x48, Member, Type: function  *, p_update
	//_Data: this+0x50, Member, Type: function  *, p_onGui
	//_Data: this+0x58, Member, Type: function  *, getControls
	//_Data: this+0x60, Member, Type: class CarAvatar *, carAvatar
	//_Data: this+0x68, Member, Type: class Car *, car
	//_Data: this+0x70, Member, Type: class Sim *, sim
	//_Func: public ACPlugin & operator=(const ACPlugin &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=9 @loc=optimized @len=0 @rva=0
//UDT;

class ACPlugin : public IACPPluginHost {
public:
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > name;
	HINSTANCE__ * hModule;
	void * getName;
	void * init;
	void * shutdown;
	void * p_update;
	void * p_onGui;
	void * getControls;
	CarAvatar * carAvatar;
	Car * car;
	Sim * sim;
	inline ACPlugin() { }
	inline ACPlugin(const ACPlugin& other) = default;
	inline ACPlugin& operator=(const ACPlugin& other) = default;
	inline void ctor(Sim * aSim, HINSTANCE__ * module) { typedef void (ACPlugin::*_fpt)(Sim *, HINSTANCE__ *); auto _f=xcast<_fpt>(_drva(784032)); (this->*_f)(aSim, module); }
	virtual ~ACPlugin();
	inline void dtor() { typedef void (ACPlugin::*_fpt)(); auto _f=xcast<_fpt>(_drva(784720)); (this->*_f)(); }
	inline void update(ACCarState * state, float dt) { typedef void (ACPlugin::*_fpt)(ACCarState *, float); auto _f=xcast<_fpt>(_drva(785920)); return (this->*_f)(state, dt); }
	inline void onGui(ACPluginContext * cc) { typedef void (ACPlugin::*_fpt)(ACPluginContext *); auto _f=xcast<_fpt>(_drva(785184)); return (this->*_f)(cc); }
	virtual HWND__ * getHwnd_vf0();
	inline HWND__ * getHwnd_impl() { typedef HWND__ * (ACPlugin::*_fpt)(); auto _f=xcast<_fpt>(_drva(785168)); return (this->*_f)(); }
	inline HWND__ * getHwnd() { typedef HWND__ * (ACPlugin::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 0)); return (this->*_f)(); }
	virtual HINSTANCE__ * getHInstance_vf1();
	inline HINSTANCE__ * getHInstance_impl() { typedef HINSTANCE__ * (ACPlugin::*_fpt)(); auto _f=xcast<_fpt>(_drva(785152)); return (this->*_f)(); }
	inline HINSTANCE__ * getHInstance() { typedef HINSTANCE__ * (ACPlugin::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(); }
	virtual void setABS_vf2(float value);
	inline void setABS_impl(float value) { typedef void (ACPlugin::*_fpt)(float); auto _f=xcast<_fpt>(_drva(785200)); return (this->*_f)(value); }
	inline void setABS(float value) { typedef void (ACPlugin::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)(value); }
	virtual void setTC_vf3(float value);
	inline void setTC_impl(float value) { typedef void (ACPlugin::*_fpt)(float); auto _f=xcast<_fpt>(_drva(785856)); return (this->*_f)(value); }
	inline void setTC(float value) { typedef void (ACPlugin::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(value); }
	virtual void setStabilityControl_vf4(float value);
	inline void setStabilityControl_impl(float value) { typedef void (ACPlugin::*_fpt)(float); auto _f=xcast<_fpt>(_drva(785440)); return (this->*_f)(value); }
	inline void setStabilityControl(float value) { typedef void (ACPlugin::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 4)); return (this->*_f)(value); }
	virtual void setIdealLine_vf5(bool value, bool isFromPhysicsThread);
	inline void setIdealLine_impl(bool value, bool isFromPhysicsThread) { typedef void (ACPlugin::*_fpt)(bool, bool); auto _f=xcast<_fpt>(_drva(785296)); return (this->*_f)(value, isFromPhysicsThread); }
	inline void setIdealLine(bool value, bool isFromPhysicsThread) { typedef void (ACPlugin::*_fpt)(bool, bool); auto _f=xcast<_fpt>(get_vfp(this, 5)); return (this->*_f)(value, isFromPhysicsThread); }
	virtual void setAutoShift_vf6(bool value);
	inline void setAutoShift_impl(bool value) { typedef void (ACPlugin::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(785264)); return (this->*_f)(value); }
	inline void setAutoShift(bool value) { typedef void (ACPlugin::*_fpt)(bool); auto _f=xcast<_fpt>(get_vfp(this, 6)); return (this->*_f)(value); }
	virtual void setBrakeBias_vf7(float value);
	inline void setBrakeBias_impl(float value) { typedef void (ACPlugin::*_fpt)(float); auto _f=xcast<_fpt>(_drva(785280)); return (this->*_f)(value); }
	inline void setBrakeBias(float value) { typedef void (ACPlugin::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 7)); return (this->*_f)(value); }
	virtual void setSystemMessage_vf8(const wchar_t * message, const wchar_t * description, bool isFromPhysicsThread);
	inline void setSystemMessage_impl(const wchar_t * message, const wchar_t * description, bool isFromPhysicsThread) { typedef void (ACPlugin::*_fpt)(const wchar_t *, const wchar_t *, bool); auto _f=xcast<_fpt>(_drva(785456)); return (this->*_f)(message, description, isFromPhysicsThread); }
	inline void setSystemMessage(const wchar_t * message, const wchar_t * description, bool isFromPhysicsThread) { typedef void (ACPlugin::*_fpt)(const wchar_t *, const wchar_t *, bool); auto _f=xcast<_fpt>(get_vfp(this, 8)); return (this->*_f)(message, description, isFromPhysicsThread); }
	inline void _guard_obj() {
		static_assert((sizeof(ACPlugin)==120),"bad size");
		static_assert((offsetof(ACPlugin,name)==0x8),"bad off");
		static_assert((offsetof(ACPlugin,hModule)==0x28),"bad off");
		static_assert((offsetof(ACPlugin,getName)==0x30),"bad off");
		static_assert((offsetof(ACPlugin,init)==0x38),"bad off");
		static_assert((offsetof(ACPlugin,shutdown)==0x40),"bad off");
		static_assert((offsetof(ACPlugin,p_update)==0x48),"bad off");
		static_assert((offsetof(ACPlugin,p_onGui)==0x50),"bad off");
		static_assert((offsetof(ACPlugin,getControls)==0x58),"bad off");
		static_assert((offsetof(ACPlugin,carAvatar)==0x60),"bad off");
		static_assert((offsetof(ACPlugin,car)==0x68),"bad off");
		static_assert((offsetof(ACPlugin,sim)==0x70),"bad off");
	};
};

//UDT: struct TyreModelData @len=656
	//_Func: public void TyreModelData(const TyreModelData & __that); @loc=static @len=398 @rva=2609552
	//_Func: public void TyreModelData(); @loc=static @len=289 @rva=2547280
	//_Data: this+0x0, Member, Type: int, version
	//_Data: this+0x4, Member, Type: float, Dy0
	//_Data: this+0x8, Member, Type: float, Dy1
	//_Data: this+0xC, Member, Type: float, Dx0
	//_Data: this+0x10, Member, Type: float, Dx1
	//_Data: this+0x14, Member, Type: float, Fz0
	//_Data: this+0x18, Member, Type: float, flexK
	//_Data: this+0x1C, Member, Type: float, speedSensitivity
	//_Data: this+0x20, Member, Type: float, relaxationLength
	//_Data: this+0x24, Member, Type: float, rr0
	//_Data: this+0x28, Member, Type: float, rr1
	//_Data: this+0x2C, Member, Type: float, rr_sa
	//_Data: this+0x30, Member, Type: float, rr_sr
	//_Data: this+0x34, Member, Type: float, rr_slip
	//_Data: this+0x38, Member, Type: float, camberGain
	//_Data: this+0x3C, Member, Type: float, pressureSpringGain
	//_Data: this+0x40, Member, Type: float, pressureFlexGain
	//_Data: this+0x44, Member, Type: float, pressureRRGain
	//_Data: this+0x48, Member, Type: float, pressureGainD
	//_Data: this+0x4C, Member, Type: float, idealPressure
	//_Data: this+0x50, Member, Type: float, pressureRef
	//_Data: this+0x58, Member, Type: class Curve, wearCurve
	//_Data: this+0xD8, Member, Type: float, dcamber0
	//_Data: this+0xDC, Member, Type: float, dcamber1
	//_Data: this+0xE0, Member, Type: class Curve, dyLoadCurve
	//_Data: this+0x160, Member, Type: class Curve, dxLoadCurve
	//_Data: this+0x1E0, Member, Type: float, lsMultY
	//_Data: this+0x1E4, Member, Type: float, lsExpY
	//_Data: this+0x1E8, Member, Type: float, lsMultX
	//_Data: this+0x1EC, Member, Type: float, lsExpX
	//_Data: this+0x1F0, Member, Type: float, maxWearKM
	//_Data: this+0x1F4, Member, Type: float, maxWearMult
	//_Data: this+0x1F8, Member, Type: float, asy
	//_Data: this+0x1FC, Member, Type: float, cfXmult
	//_Data: this+0x200, Member, Type: float, brakeDXMod
	//_Data: this+0x208, Member, Type: class Curve, dCamberCurve
	//_Data: this+0x288, Member, Type: bool, useSmoothDCamberCurve
	//_Data: this+0x28C, Member, Type: float, combinedFactor
	//_Func: public void ~TyreModelData(); @loc=static @len=75 @rva=2550176
	//_Func: public TyreModelData & operator=(const TyreModelData & __that); @loc=static @len=751 @rva=2610288
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct TyreModelData {
public:
	int version;
	float Dy0;
	float Dy1;
	float Dx0;
	float Dx1;
	float Fz0;
	float flexK;
	float speedSensitivity;
	float relaxationLength;
	float rr0;
	float rr1;
	float rr_sa;
	float rr_sr;
	float rr_slip;
	float camberGain;
	float pressureSpringGain;
	float pressureFlexGain;
	float pressureRRGain;
	float pressureGainD;
	float idealPressure;
	float pressureRef;
	Curve wearCurve;
	float dcamber0;
	float dcamber1;
	Curve dyLoadCurve;
	Curve dxLoadCurve;
	float lsMultY;
	float lsExpY;
	float lsMultX;
	float lsExpX;
	float maxWearKM;
	float maxWearMult;
	float asy;
	float cfXmult;
	float brakeDXMod;
	Curve dCamberCurve;
	bool useSmoothDCamberCurve;
	float combinedFactor;
	inline TyreModelData() { }
	inline TyreModelData(const TyreModelData& other) = default;
	inline TyreModelData& operator=(const TyreModelData& other) = default;
	inline void ctor(const TyreModelData & __that) { typedef void (TyreModelData::*_fpt)(const TyreModelData &); auto _f=xcast<_fpt>(_drva(2609552)); (this->*_f)(__that); }
	inline void ctor() { typedef void (TyreModelData::*_fpt)(); auto _f=xcast<_fpt>(_drva(2547280)); (this->*_f)(); }
	inline void dtor() { typedef void (TyreModelData::*_fpt)(); auto _f=xcast<_fpt>(_drva(2550176)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(TyreModelData)==656),"bad size");
		static_assert((offsetof(TyreModelData,version)==0x0),"bad off");
		static_assert((offsetof(TyreModelData,Dy0)==0x4),"bad off");
		static_assert((offsetof(TyreModelData,Dy1)==0x8),"bad off");
		static_assert((offsetof(TyreModelData,Dx0)==0xC),"bad off");
		static_assert((offsetof(TyreModelData,Dx1)==0x10),"bad off");
		static_assert((offsetof(TyreModelData,Fz0)==0x14),"bad off");
		static_assert((offsetof(TyreModelData,flexK)==0x18),"bad off");
		static_assert((offsetof(TyreModelData,speedSensitivity)==0x1C),"bad off");
		static_assert((offsetof(TyreModelData,relaxationLength)==0x20),"bad off");
		static_assert((offsetof(TyreModelData,rr0)==0x24),"bad off");
		static_assert((offsetof(TyreModelData,rr1)==0x28),"bad off");
		static_assert((offsetof(TyreModelData,rr_sa)==0x2C),"bad off");
		static_assert((offsetof(TyreModelData,rr_sr)==0x30),"bad off");
		static_assert((offsetof(TyreModelData,rr_slip)==0x34),"bad off");
		static_assert((offsetof(TyreModelData,camberGain)==0x38),"bad off");
		static_assert((offsetof(TyreModelData,pressureSpringGain)==0x3C),"bad off");
		static_assert((offsetof(TyreModelData,pressureFlexGain)==0x40),"bad off");
		static_assert((offsetof(TyreModelData,pressureRRGain)==0x44),"bad off");
		static_assert((offsetof(TyreModelData,pressureGainD)==0x48),"bad off");
		static_assert((offsetof(TyreModelData,idealPressure)==0x4C),"bad off");
		static_assert((offsetof(TyreModelData,pressureRef)==0x50),"bad off");
		static_assert((offsetof(TyreModelData,wearCurve)==0x58),"bad off");
		static_assert((offsetof(TyreModelData,dcamber0)==0xD8),"bad off");
		static_assert((offsetof(TyreModelData,dcamber1)==0xDC),"bad off");
		static_assert((offsetof(TyreModelData,dyLoadCurve)==0xE0),"bad off");
		static_assert((offsetof(TyreModelData,dxLoadCurve)==0x160),"bad off");
		static_assert((offsetof(TyreModelData,lsMultY)==0x1E0),"bad off");
		static_assert((offsetof(TyreModelData,lsExpY)==0x1E4),"bad off");
		static_assert((offsetof(TyreModelData,lsMultX)==0x1E8),"bad off");
		static_assert((offsetof(TyreModelData,lsExpX)==0x1EC),"bad off");
		static_assert((offsetof(TyreModelData,maxWearKM)==0x1F0),"bad off");
		static_assert((offsetof(TyreModelData,maxWearMult)==0x1F4),"bad off");
		static_assert((offsetof(TyreModelData,asy)==0x1F8),"bad off");
		static_assert((offsetof(TyreModelData,cfXmult)==0x1FC),"bad off");
		static_assert((offsetof(TyreModelData,brakeDXMod)==0x200),"bad off");
		static_assert((offsetof(TyreModelData,dCamberCurve)==0x208),"bad off");
		static_assert((offsetof(TyreModelData,useSmoothDCamberCurve)==0x288),"bad off");
		static_assert((offsetof(TyreModelData,combinedFactor)==0x28C),"bad off");
	};
};

//UDT: struct BrakeDisc @len=144
	//_Data: this+0x0, Member, Type: float, t
	//_Data: this+0x4, Member, Type: float, coolTransfer
	//_Data: this+0x8, Member, Type: float, torqueK
	//_Data: this+0xC, Member, Type: float, coolSpeedFactor
	//_Data: this+0x10, Member, Type: class Curve, perfCurve
	//_Func: public void BrakeDisc(const BrakeDisc &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void BrakeDisc(); @loc=static @len=54 @rva=2538976
	//_Func: public void ~BrakeDisc(); @loc=static @len=9 @rva=2547808
	//_Func: public BrakeDisc & operator=(const BrakeDisc &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct BrakeDisc {
public:
	float t;
	float coolTransfer;
	float torqueK;
	float coolSpeedFactor;
	Curve perfCurve;
	inline BrakeDisc() { }
	inline BrakeDisc(const BrakeDisc& other) = default;
	inline BrakeDisc& operator=(const BrakeDisc& other) = default;
	inline void ctor() { typedef void (BrakeDisc::*_fpt)(); auto _f=xcast<_fpt>(_drva(2538976)); (this->*_f)(); }
	inline void dtor() { typedef void (BrakeDisc::*_fpt)(); auto _f=xcast<_fpt>(_drva(2547808)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(BrakeDisc)==144),"bad size");
		static_assert((offsetof(BrakeDisc,t)==0x0),"bad off");
		static_assert((offsetof(BrakeDisc,coolTransfer)==0x4),"bad off");
		static_assert((offsetof(BrakeDisc,torqueK)==0x8),"bad off");
		static_assert((offsetof(BrakeDisc,coolSpeedFactor)==0xC),"bad off");
		static_assert((offsetof(BrakeDisc,perfCurve)==0x10),"bad off");
	};
};

//UDT: struct DynamicTempData @len=144
	//_Data: this+0x0, Member, Type: class Curve, temperatureCurve
	//_Data: this+0x80, Member, Type: double, temperatureStartTime
	//_Data: this+0x88, Member, Type: float, baseRoad
	//_Data: this+0x8C, Member, Type: float, baseAir
	//_Func: public void DynamicTempData(const DynamicTempData &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void DynamicTempData(); @loc=static @len=54 @rva=1256656
	//_Func: public void ~DynamicTempData(); @loc=static @len=5 @rva=1258144
	//_Func: public DynamicTempData & operator=(const DynamicTempData & __that); @loc=static @len=145 @rva=1259120
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct DynamicTempData {
public:
	Curve temperatureCurve;
	double temperatureStartTime;
	float baseRoad;
	float baseAir;
	inline DynamicTempData() { }
	inline DynamicTempData(const DynamicTempData& other) = default;
	inline DynamicTempData& operator=(const DynamicTempData& other) = default;
	inline void ctor() { typedef void (DynamicTempData::*_fpt)(); auto _f=xcast<_fpt>(_drva(1256656)); (this->*_f)(); }
	inline void dtor() { typedef void (DynamicTempData::*_fpt)(); auto _f=xcast<_fpt>(_drva(1258144)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(DynamicTempData)==144),"bad size");
		static_assert((offsetof(DynamicTempData,temperatureCurve)==0x0),"bad off");
		static_assert((offsetof(DynamicTempData,temperatureStartTime)==0x80),"bad off");
		static_assert((offsetof(DynamicTempData,baseRoad)==0x88),"bad off");
		static_assert((offsetof(DynamicTempData,baseAir)==0x8C),"bad off");
	};
};

//UDT: struct ClutchSequence @len=136
	//_Func: public void ClutchSequence(const ClutchSequence &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void ClutchSequence(Curve & c); @loc=static @len=154 @rva=2851616
	//_Func: public void ClutchSequence(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: class Curve, clutchCurve
	//_Data: this+0x80, Member, Type: float, currentTime
	//_Data: this+0x84, Member, Type: bool, isDone
	//_Func: public void ~ClutchSequence(); @loc=static @len=5 @rva=1258144
	//_Func: public ClutchSequence & operator=(const ClutchSequence & __that); @loc=static @len=132 @rva=2851840
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct ClutchSequence {
public:
	Curve clutchCurve;
	float currentTime;
	bool isDone;
	inline ClutchSequence() { }
	inline ClutchSequence(const ClutchSequence& other) = default;
	inline ClutchSequence& operator=(const ClutchSequence& other) = default;
	inline void ctor(Curve & c) { typedef void (ClutchSequence::*_fpt)(Curve &); auto _f=xcast<_fpt>(_drva(2851616)); (this->*_f)(c); }
	inline void dtor() { typedef void (ClutchSequence::*_fpt)(); auto _f=xcast<_fpt>(_drva(1258144)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(ClutchSequence)==136),"bad size");
		static_assert((offsetof(ClutchSequence,clutchCurve)==0x0),"bad off");
		static_assert((offsetof(ClutchSequence,currentTime)==0x80),"bad off");
		static_assert((offsetof(ClutchSequence,isDone)==0x84),"bad off");
	};
};

//UDT: struct acEngineData @len=296
	//_Func: public void acEngineData(const acEngineData &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void acEngineData(); @loc=static @len=125 @rva=2643104
	//_Data: this+0x0, Member, Type: class Curve, powerCurve
	//_Data: this+0x80, Member, Type: class Curve, coastCurve
	//_Data: this+0x100, Member, Type: float, coast2
	//_Data: this+0x104, Member, Type: float, coast1
	//_Data: this+0x108, Member, Type: float, coast0
	//_Data: this+0x10C, Member, Type: bool, useCoastCurve
	//_Data: this+0x110, Member, Type: int, minimum
	//_Data: this+0x114, Member, Type: int, limiter
	//_Data: this+0x118, Member, Type: int, limiterCycles
	//_Data: this+0x11C, Member, Type: float, overlapFreq
	//_Data: this+0x120, Member, Type: float, overlapGain
	//_Data: this+0x124, Member, Type: float, overlapIdealRPM
	//_Func: public void ~acEngineData(); @loc=static @len=45 @rva=2643504
	//_Func: public acEngineData & operator=(const acEngineData &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct acEngineData {
public:
	Curve powerCurve;
	Curve coastCurve;
	float coast2;
	float coast1;
	float coast0;
	bool useCoastCurve;
	int minimum;
	int limiter;
	int limiterCycles;
	float overlapFreq;
	float overlapGain;
	float overlapIdealRPM;
	inline acEngineData() { }
	inline acEngineData(const acEngineData& other) = default;
	inline acEngineData& operator=(const acEngineData& other) = default;
	inline void ctor() { typedef void (acEngineData::*_fpt)(); auto _f=xcast<_fpt>(_drva(2643104)); (this->*_f)(); }
	inline void dtor() { typedef void (acEngineData::*_fpt)(); auto _f=xcast<_fpt>(_drva(2643504)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(acEngineData)==296),"bad size");
		static_assert((offsetof(acEngineData,powerCurve)==0x0),"bad off");
		static_assert((offsetof(acEngineData,coastCurve)==0x80),"bad off");
		static_assert((offsetof(acEngineData,coast2)==0x100),"bad off");
		static_assert((offsetof(acEngineData,coast1)==0x104),"bad off");
		static_assert((offsetof(acEngineData,coast0)==0x108),"bad off");
		static_assert((offsetof(acEngineData,useCoastCurve)==0x10C),"bad off");
		static_assert((offsetof(acEngineData,minimum)==0x110),"bad off");
		static_assert((offsetof(acEngineData,limiter)==0x114),"bad off");
		static_assert((offsetof(acEngineData,limiterCycles)==0x118),"bad off");
		static_assert((offsetof(acEngineData,overlapFreq)==0x11C),"bad off");
		static_assert((offsetof(acEngineData,overlapGain)==0x120),"bad off");
		static_assert((offsetof(acEngineData,overlapIdealRPM)==0x124),"bad off");
	};
};

//UDT: struct CameraCarDefinition @len=76
	//_Func: public void CameraCarDefinition(const CameraCarDefinition &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void CameraCarDefinition(); @loc=static @len=160 @rva=839936
	//_Data: this+0x0, Member, Type: class mat44f, matrix
	//_Data: this+0x40, Member, Type: float, fov
	//_Data: this+0x44, Member, Type: float, exposure
	//_Data: this+0x48, Member, Type: bool, externalSound
//UDT;

struct CameraCarDefinition {
public:
	mat44f matrix;
	float fov;
	float exposure;
	bool externalSound;
	inline CameraCarDefinition() { }
	inline CameraCarDefinition(const CameraCarDefinition& other) = default;
	inline CameraCarDefinition& operator=(const CameraCarDefinition& other) = default;
	inline void ctor() { typedef void (CameraCarDefinition::*_fpt)(); auto _f=xcast<_fpt>(_drva(839936)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(CameraCarDefinition)==76),"bad size");
		static_assert((offsetof(CameraCarDefinition,matrix)==0x0),"bad off");
		static_assert((offsetof(CameraCarDefinition,fov)==0x40),"bad off");
		static_assert((offsetof(CameraCarDefinition,exposure)==0x44),"bad off");
		static_assert((offsetof(CameraCarDefinition,externalSound)==0x48),"bad off");
	};
};

//UDT: class sphere @len=16
	//_Func: public void sphere(const sphere &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void sphere(const vec3f &  _arg0, float  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public void sphere(); @loc=optimized @len=0 @rva=0
	//_Func: public sphere transform(const mat44f & matrix); @loc=static @len=346 @rva=2198528
	//_Data: this+0x0, Member, Type: class vec3f, center
	//_Data: this+0xC, Member, Type: float, radius
//UDT;

class sphere {
public:
	vec3f center;
	float radius;
	inline sphere() { }
	inline sphere(const sphere& other) = default;
	inline sphere& operator=(const sphere& other) = default;
	inline sphere transform(const mat44f & matrix) { typedef sphere (sphere::*_fpt)(const mat44f &); auto _f=xcast<_fpt>(_drva(2198528)); return (this->*_f)(matrix); }
	inline void _guard_obj() {
		static_assert((sizeof(sphere)==16),"bad size");
		static_assert((offsetof(sphere,center)==0x0),"bad off");
		static_assert((offsetof(sphere,radius)==0xC),"bad off");
	};
};

//UDT: struct OnSessionEndEvent @len=232
	//_Data: this+0x0, Member, Type: class Session, currentSession
	//_Data: this+0x70, Member, Type: struct SessionResult, result
	//_Func: public void OnSessionEndEvent(const OnSessionEndEvent & __that); @loc=static @len=150 @rva=1256720
	//_Func: public void OnSessionEndEvent(); @loc=static @len=124 @rva=610032
	//_Func: public void ~OnSessionEndEvent(); @loc=static @len=99 @rva=610896
	//_Func: public OnSessionEndEvent & operator=(const OnSessionEndEvent &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct OnSessionEndEvent {
public:
	Session currentSession;
	SessionResult result;
	inline OnSessionEndEvent() { }
	inline OnSessionEndEvent(const OnSessionEndEvent& other) = default;
	inline OnSessionEndEvent& operator=(const OnSessionEndEvent& other) = default;
	inline void ctor(const OnSessionEndEvent & __that) { typedef void (OnSessionEndEvent::*_fpt)(const OnSessionEndEvent &); auto _f=xcast<_fpt>(_drva(1256720)); (this->*_f)(__that); }
	inline void ctor() { typedef void (OnSessionEndEvent::*_fpt)(); auto _f=xcast<_fpt>(_drva(610032)); (this->*_f)(); }
	inline void dtor() { typedef void (OnSessionEndEvent::*_fpt)(); auto _f=xcast<_fpt>(_drva(610896)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(OnSessionEndEvent)==232),"bad size");
		static_assert((offsetof(OnSessionEndEvent,currentSession)==0x0),"bad off");
		static_assert((offsetof(OnSessionEndEvent,result)==0x70),"bad off");
	};
};

//UDT: class FFPostProcessor @len=144
	//_Func: public void FFPostProcessor(const FFPostProcessor &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void FFPostProcessor(); @loc=static @len=1297 @rva=2594144
	//_Func: public void ~FFPostProcessor(); @loc=static @len=9 @rva=2547808
	//_Data: this+0x0, Member, Type: bool, enabled
	//_Data: this+0x4, Member, Type: float, gamma
	//_Data: this+0x8, Member, Type: enum FFPostProcessType, type
	//_Data: this+0x10, Member, Type: class Curve, lut
	//_Func: public float getProcessedFF(float v); @loc=static @len=194 @rva=2595456
	//_Func: public FFPostProcessor & operator=(const FFPostProcessor &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class FFPostProcessor {
public:
	bool enabled;
	float gamma;
	FFPostProcessType type;
	Curve lut;
	inline FFPostProcessor() { }
	inline FFPostProcessor(const FFPostProcessor& other) = default;
	inline FFPostProcessor& operator=(const FFPostProcessor& other) = default;
	inline void ctor() { typedef void (FFPostProcessor::*_fpt)(); auto _f=xcast<_fpt>(_drva(2594144)); (this->*_f)(); }
	inline void dtor() { typedef void (FFPostProcessor::*_fpt)(); auto _f=xcast<_fpt>(_drva(2547808)); (this->*_f)(); }
	inline float getProcessedFF(float v) { typedef float (FFPostProcessor::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2595456)); return (this->*_f)(v); }
	inline void _guard_obj() {
		static_assert((sizeof(FFPostProcessor)==144),"bad size");
		static_assert((offsetof(FFPostProcessor,enabled)==0x0),"bad off");
		static_assert((offsetof(FFPostProcessor,gamma)==0x4),"bad off");
		static_assert((offsetof(FFPostProcessor,type)==0x8),"bad off");
		static_assert((offsetof(FFPostProcessor,lut)==0x10),"bad off");
	};
};

//UDT: class IMeshRenderFilter @len=16 @vfcount=2
	//_VTable: 
	//_Func: public void ~IMeshRenderFilter(); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Func: public bool isVisible(Renderable *  _arg0, const mat44f &  _arg1); @intro @pure @virtual vtpo=0 vfid=1 @loc=optimized @len=0 @rva=0
	//_Data: this+0x8, Member, Type: enum RenderPassID, passID
	//_Data: this+0xC, Member, Type: int, maxLayer
	//_Func: public void IMeshRenderFilter(const IMeshRenderFilter &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void IMeshRenderFilter(); @loc=optimized @len=0 @rva=0
	//_Func: public IMeshRenderFilter & operator=(const IMeshRenderFilter &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class IMeshRenderFilter {
public:
	RenderPassID passID;
	int maxLayer;
	inline IMeshRenderFilter() { }
	inline IMeshRenderFilter(const IMeshRenderFilter& other) = default;
	inline IMeshRenderFilter& operator=(const IMeshRenderFilter& other) = default;
	virtual ~IMeshRenderFilter();
	virtual bool isVisible_vf1(Renderable *  _arg0, const mat44f &  _arg1) = 0;
	inline bool isVisible(Renderable *  _arg0, const mat44f &  _arg1) { typedef bool (IMeshRenderFilter::*_fpt)(Renderable *, const mat44f &); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)( _arg0,  _arg1); }
	inline void _guard_obj() {
		static_assert((sizeof(IMeshRenderFilter)==16),"bad size");
		static_assert((offsetof(IMeshRenderFilter,passID)==0x8),"bad off");
		static_assert((offsetof(IMeshRenderFilter,maxLayer)==0xC),"bad off");
	};
};

//UDT: class MaterialResource @len=80
	//_Func: public void MaterialResource(const MaterialResource & __that); @loc=static @len=140 @rva=2137040
	//_Func: public void MaterialResource(ShaderResource *  _arg0); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: int, slot
	//_Data: this+0x8, Member, Type: class Texture, texture
	//_Data: this+0x30, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, name
	//_Func: public void ~MaterialResource(); @loc=static @len=57 @rva=2137904
	//_Func: public MaterialResource & operator=(const MaterialResource &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class MaterialResource {
public:
	int slot;
	Texture texture;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > name;
	inline MaterialResource() { }
	inline MaterialResource(const MaterialResource& other) = default;
	inline MaterialResource& operator=(const MaterialResource& other) = default;
	inline void ctor(const MaterialResource & __that) { typedef void (MaterialResource::*_fpt)(const MaterialResource &); auto _f=xcast<_fpt>(_drva(2137040)); (this->*_f)(__that); }
	inline void dtor() { typedef void (MaterialResource::*_fpt)(); auto _f=xcast<_fpt>(_drva(2137904)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(MaterialResource)==80),"bad size");
		static_assert((offsetof(MaterialResource,slot)==0x0),"bad off");
		static_assert((offsetof(MaterialResource,texture)==0x8),"bad off");
		static_assert((offsetof(MaterialResource,name)==0x30),"bad off");
	};
};

//UDT: class IRigidBody @len=8 @vfcount=42
	//_VTable: 
	//_Func: public void setMassExplicitInertia(float  _arg0, float  _arg1, float  _arg2, float  _arg3); @intro @pure @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Func: public bool isEnabled(); @intro @pure @virtual vtpo=0 vfid=1 @loc=optimized @len=0 @rva=0
	//_Func: public void setEnabled(bool  _arg0); @intro @pure @virtual vtpo=0 vfid=2 @loc=optimized @len=0 @rva=0
	//_Func: public void setAutoDisable(bool  _arg0); @intro @pure @virtual vtpo=0 vfid=3 @loc=optimized @len=0 @rva=0
	//_Func: public void removeCollisionObjects(); @intro @pure @virtual vtpo=0 vfid=4 @loc=optimized @len=0 @rva=0
	//_Func: public float getMass(); @intro @pure @virtual vtpo=0 vfid=5 @loc=optimized @len=0 @rva=0
	//_Func: public void release(); @intro @pure @virtual vtpo=0 vfid=6 @loc=optimized @len=0 @rva=0
	//_Func: public void setMassBox(float  _arg0, float  _arg1, float  _arg2, float  _arg3); @intro @pure @virtual vtpo=0 vfid=7 @loc=optimized @len=0 @rva=0
	//_Func: public vec3f getLocalInertia(); @intro @pure @virtual vtpo=0 vfid=8 @loc=optimized @len=0 @rva=0
	//_Func: public mat44f getWorldMatrix(float  _arg0); @intro @pure @virtual vtpo=0 vfid=9 @loc=optimized @len=0 @rva=0
	//_Func: public vec3f localToWorld(const vec3f &  _arg0); @intro @pure @virtual vtpo=0 vfid=10 @loc=optimized @len=0 @rva=0
	//_Func: public vec3f worldToLocal(const vec3f &  _arg0); @intro @pure @virtual vtpo=0 vfid=11 @loc=optimized @len=0 @rva=0
	//_Func: public vec3f localToWorldNormal(const vec3f &  _arg0); @intro @pure @virtual vtpo=0 vfid=12 @loc=optimized @len=0 @rva=0
	//_Func: public vec3f worldToLocalNormal(const vec3f &  _arg0); @intro @pure @virtual vtpo=0 vfid=13 @loc=optimized @len=0 @rva=0
	//_Func: public void stop(float  _arg0); @intro @pure @virtual vtpo=0 vfid=14 @loc=optimized @len=0 @rva=0
	//_Func: public vec3f getVelocity(); @intro @pure @virtual vtpo=0 vfid=15 @loc=optimized @len=0 @rva=0
	//_Func: public void setVelocity(const vec3f &  _arg0); @intro @pure @virtual vtpo=0 vfid=16 @loc=optimized @len=0 @rva=0
	//_Func: public void setAngularVelocity(const vec3f &  _arg0); @intro @pure @virtual vtpo=0 vfid=17 @loc=optimized @len=0 @rva=0
	//_Func: public void setPosition(const vec3f &  _arg0); @intro @pure @virtual vtpo=0 vfid=18 @loc=optimized @len=0 @rva=0
	//_Func: public void setRotation(const mat44f &  _arg0); @intro @pure @virtual vtpo=0 vfid=19 @loc=optimized @len=0 @rva=0
	//_Func: public vec3f getPosition(float  _arg0); @intro @pure @virtual vtpo=0 vfid=20 @loc=optimized @len=0 @rva=0
	//_Func: public vec3f getAngularVelocity(); @intro @pure @virtual vtpo=0 vfid=21 @loc=optimized @len=0 @rva=0
	//_Func: public vec3f getLocalAngularVelocity(); @intro @pure @virtual vtpo=0 vfid=22 @loc=optimized @len=0 @rva=0
	//_Func: public vec3f getLocalVelocity(); @intro @pure @virtual vtpo=0 vfid=23 @loc=optimized @len=0 @rva=0
	//_Func: public void setBoxColliderMask(unsigned __int64  _arg0, unsigned long  _arg1); @intro @pure @virtual vtpo=0 vfid=24 @loc=optimized @len=0 @rva=0
	//_Func: public unsigned __int64 addBoxCollider(const vec3f &  _arg0, const vec3f &  _arg1, unsigned int  _arg2, unsigned long  _arg3, unsigned int  _arg4); @intro @pure @virtual vtpo=0 vfid=25 @loc=optimized @len=0 @rva=0
	//_Func: public void addSphereCollider(const vec3f &  _arg0, float  _arg1, unsigned int  _arg2, ISphereCollisionCallback *  _arg3); @intro @pure @virtual vtpo=0 vfid=26 @loc=optimized @len=0 @rva=0
	//_Func: public void addLocalForce(const vec3f &  _arg0); @intro @pure @virtual vtpo=0 vfid=27 @loc=optimized @len=0 @rva=0
	//_Func: public void addLocalTorque(const vec3f &  _arg0); @intro @pure @virtual vtpo=0 vfid=28 @loc=optimized @len=0 @rva=0
	//_Func: public void addLocalForceAtPos(const vec3f &  _arg0, const vec3f &  _arg1); @intro @pure @virtual vtpo=0 vfid=29 @loc=optimized @len=0 @rva=0
	//_Func: public void addLocalForceAtLocalPos(const vec3f &  _arg0, const vec3f &  _arg1); @intro @pure @virtual vtpo=0 vfid=30 @loc=optimized @len=0 @rva=0
	//_Func: public void addForceAtLocalPos(const vec3f &  _arg0, const vec3f &  _arg1); @intro @pure @virtual vtpo=0 vfid=31 @loc=optimized @len=0 @rva=0
	//_Func: public vec3f getLocalPointVelocity(const vec3f &  _arg0); @intro @pure @virtual vtpo=0 vfid=32 @loc=optimized @len=0 @rva=0
	//_Func: public vec3f getPointVelocity(const vec3f &  _arg0); @intro @pure @virtual vtpo=0 vfid=33 @loc=optimized @len=0 @rva=0
	//_Func: public void addForceAtPos(const vec3f &  _arg0, const vec3f &  _arg1); @intro @pure @virtual vtpo=0 vfid=34 @loc=optimized @len=0 @rva=0
	//_Func: public void addTorque(const vec3f &  _arg0); @intro @pure @virtual vtpo=0 vfid=35 @loc=optimized @len=0 @rva=0
	//_Func: public void addMeshCollider(float *  _arg0, unsigned int  _arg1, unsigned short *  _arg2, unsigned int  _arg3, mat44f  _arg4, unsigned long  _arg5, unsigned long  _arg6, unsigned int  _arg7); @intro @pure @virtual vtpo=0 vfid=36 @loc=optimized @len=0 @rva=0
	//_Func: public void setMeshCollideCategory(unsigned int  _arg0, unsigned long  _arg1); @intro @pure @virtual vtpo=0 vfid=37 @loc=optimized @len=0 @rva=0
	//_Func: public void setMeshCollideMask(unsigned int  _arg0, unsigned long  _arg1); @intro @pure @virtual vtpo=0 vfid=38 @loc=optimized @len=0 @rva=0
	//_Func: public unsigned long getMeshCollideCategory(unsigned int  _arg0); @intro @pure @virtual vtpo=0 vfid=39 @loc=optimized @len=0 @rva=0
	//_Func: public unsigned long getMeshCollideMask(unsigned int  _arg0); @intro @pure @virtual vtpo=0 vfid=40 @loc=optimized @len=0 @rva=0
	//_Func: protected void ~IRigidBody(); @intro @virtual vtpo=0 vfid=41 @loc=optimized @len=0 @rva=0
	//_Func: public void IRigidBody(const IRigidBody &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void IRigidBody(); @loc=optimized @len=0 @rva=0
	//_Func: public IRigidBody & operator=(const IRigidBody &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: protected void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=41 @loc=optimized @len=0 @rva=0
//UDT;

class IRigidBody {
public:
	inline IRigidBody() { }
	inline IRigidBody(const IRigidBody& other) = default;
	inline IRigidBody& operator=(const IRigidBody& other) = default;
	virtual void setMassExplicitInertia_vf0(float  _arg0, float  _arg1, float  _arg2, float  _arg3) = 0;
	inline void setMassExplicitInertia(float  _arg0, float  _arg1, float  _arg2, float  _arg3) { typedef void (IRigidBody::*_fpt)(float, float, float, float); auto _f=xcast<_fpt>(get_vfp(this, 0)); return (this->*_f)( _arg0,  _arg1,  _arg2,  _arg3); }
	virtual bool isEnabled_vf1() = 0;
	inline bool isEnabled() { typedef bool (IRigidBody::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(); }
	virtual void setEnabled_vf2(bool  _arg0) = 0;
	inline void setEnabled(bool  _arg0) { typedef void (IRigidBody::*_fpt)(bool); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)( _arg0); }
	virtual void setAutoDisable_vf3(bool  _arg0) = 0;
	inline void setAutoDisable(bool  _arg0) { typedef void (IRigidBody::*_fpt)(bool); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)( _arg0); }
	virtual void removeCollisionObjects_vf4() = 0;
	inline void removeCollisionObjects() { typedef void (IRigidBody::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 4)); return (this->*_f)(); }
	virtual float getMass_vf5() = 0;
	inline float getMass() { typedef float (IRigidBody::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 5)); return (this->*_f)(); }
	virtual void release_vf6() = 0;
	inline void release() { typedef void (IRigidBody::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 6)); return (this->*_f)(); }
	virtual void setMassBox_vf7(float  _arg0, float  _arg1, float  _arg2, float  _arg3) = 0;
	inline void setMassBox(float  _arg0, float  _arg1, float  _arg2, float  _arg3) { typedef void (IRigidBody::*_fpt)(float, float, float, float); auto _f=xcast<_fpt>(get_vfp(this, 7)); return (this->*_f)( _arg0,  _arg1,  _arg2,  _arg3); }
	virtual vec3f getLocalInertia_vf8() = 0;
	inline vec3f getLocalInertia() { typedef vec3f (IRigidBody::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 8)); return (this->*_f)(); }
	virtual mat44f getWorldMatrix_vf9(float  _arg0) = 0;
	inline mat44f getWorldMatrix(float  _arg0) { typedef mat44f (IRigidBody::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 9)); return (this->*_f)( _arg0); }
	virtual vec3f localToWorld_vf10(const vec3f &  _arg0) = 0;
	inline vec3f localToWorld(const vec3f &  _arg0) { typedef vec3f (IRigidBody::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 10)); return (this->*_f)( _arg0); }
	virtual vec3f worldToLocal_vf11(const vec3f &  _arg0) = 0;
	inline vec3f worldToLocal(const vec3f &  _arg0) { typedef vec3f (IRigidBody::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 11)); return (this->*_f)( _arg0); }
	virtual vec3f localToWorldNormal_vf12(const vec3f &  _arg0) = 0;
	inline vec3f localToWorldNormal(const vec3f &  _arg0) { typedef vec3f (IRigidBody::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 12)); return (this->*_f)( _arg0); }
	virtual vec3f worldToLocalNormal_vf13(const vec3f &  _arg0) = 0;
	inline vec3f worldToLocalNormal(const vec3f &  _arg0) { typedef vec3f (IRigidBody::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 13)); return (this->*_f)( _arg0); }
	virtual void stop_vf14(float  _arg0) = 0;
	inline void stop(float  _arg0) { typedef void (IRigidBody::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 14)); return (this->*_f)( _arg0); }
	virtual vec3f getVelocity_vf15() = 0;
	inline vec3f getVelocity() { typedef vec3f (IRigidBody::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 15)); return (this->*_f)(); }
	virtual void setVelocity_vf16(const vec3f &  _arg0) = 0;
	inline void setVelocity(const vec3f &  _arg0) { typedef void (IRigidBody::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 16)); return (this->*_f)( _arg0); }
	virtual void setAngularVelocity_vf17(const vec3f &  _arg0) = 0;
	inline void setAngularVelocity(const vec3f &  _arg0) { typedef void (IRigidBody::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 17)); return (this->*_f)( _arg0); }
	virtual void setPosition_vf18(const vec3f &  _arg0) = 0;
	inline void setPosition(const vec3f &  _arg0) { typedef void (IRigidBody::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 18)); return (this->*_f)( _arg0); }
	virtual void setRotation_vf19(const mat44f &  _arg0) = 0;
	inline void setRotation(const mat44f &  _arg0) { typedef void (IRigidBody::*_fpt)(const mat44f &); auto _f=xcast<_fpt>(get_vfp(this, 19)); return (this->*_f)( _arg0); }
	virtual vec3f getPosition_vf20(float  _arg0) = 0;
	inline vec3f getPosition(float  _arg0) { typedef vec3f (IRigidBody::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 20)); return (this->*_f)( _arg0); }
	virtual vec3f getAngularVelocity_vf21() = 0;
	inline vec3f getAngularVelocity() { typedef vec3f (IRigidBody::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 21)); return (this->*_f)(); }
	virtual vec3f getLocalAngularVelocity_vf22() = 0;
	inline vec3f getLocalAngularVelocity() { typedef vec3f (IRigidBody::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 22)); return (this->*_f)(); }
	virtual vec3f getLocalVelocity_vf23() = 0;
	inline vec3f getLocalVelocity() { typedef vec3f (IRigidBody::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 23)); return (this->*_f)(); }
	virtual void setBoxColliderMask_vf24(unsigned __int64  _arg0, unsigned long  _arg1) = 0;
	inline void setBoxColliderMask(unsigned __int64  _arg0, unsigned long  _arg1) { typedef void (IRigidBody::*_fpt)(unsigned __int64, unsigned long); auto _f=xcast<_fpt>(get_vfp(this, 24)); return (this->*_f)( _arg0,  _arg1); }
	virtual unsigned __int64 addBoxCollider_vf25(const vec3f &  _arg0, const vec3f &  _arg1, unsigned int  _arg2, unsigned long  _arg3, unsigned int  _arg4) = 0;
	inline unsigned __int64 addBoxCollider(const vec3f &  _arg0, const vec3f &  _arg1, unsigned int  _arg2, unsigned long  _arg3, unsigned int  _arg4) { typedef unsigned __int64 (IRigidBody::*_fpt)(const vec3f &, const vec3f &, unsigned int, unsigned long, unsigned int); auto _f=xcast<_fpt>(get_vfp(this, 25)); return (this->*_f)( _arg0,  _arg1,  _arg2,  _arg3,  _arg4); }
	virtual void addSphereCollider_vf26(const vec3f &  _arg0, float  _arg1, unsigned int  _arg2, ISphereCollisionCallback *  _arg3) = 0;
	inline void addSphereCollider(const vec3f &  _arg0, float  _arg1, unsigned int  _arg2, ISphereCollisionCallback *  _arg3) { typedef void (IRigidBody::*_fpt)(const vec3f &, float, unsigned int, ISphereCollisionCallback *); auto _f=xcast<_fpt>(get_vfp(this, 26)); return (this->*_f)( _arg0,  _arg1,  _arg2,  _arg3); }
	virtual void addLocalForce_vf27(const vec3f &  _arg0) = 0;
	inline void addLocalForce(const vec3f &  _arg0) { typedef void (IRigidBody::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 27)); return (this->*_f)( _arg0); }
	virtual void addLocalTorque_vf28(const vec3f &  _arg0) = 0;
	inline void addLocalTorque(const vec3f &  _arg0) { typedef void (IRigidBody::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 28)); return (this->*_f)( _arg0); }
	virtual void addLocalForceAtPos_vf29(const vec3f &  _arg0, const vec3f &  _arg1) = 0;
	inline void addLocalForceAtPos(const vec3f &  _arg0, const vec3f &  _arg1) { typedef void (IRigidBody::*_fpt)(const vec3f &, const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 29)); return (this->*_f)( _arg0,  _arg1); }
	virtual void addLocalForceAtLocalPos_vf30(const vec3f &  _arg0, const vec3f &  _arg1) = 0;
	inline void addLocalForceAtLocalPos(const vec3f &  _arg0, const vec3f &  _arg1) { typedef void (IRigidBody::*_fpt)(const vec3f &, const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 30)); return (this->*_f)( _arg0,  _arg1); }
	virtual void addForceAtLocalPos_vf31(const vec3f &  _arg0, const vec3f &  _arg1) = 0;
	inline void addForceAtLocalPos(const vec3f &  _arg0, const vec3f &  _arg1) { typedef void (IRigidBody::*_fpt)(const vec3f &, const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 31)); return (this->*_f)( _arg0,  _arg1); }
	virtual vec3f getLocalPointVelocity_vf32(const vec3f &  _arg0) = 0;
	inline vec3f getLocalPointVelocity(const vec3f &  _arg0) { typedef vec3f (IRigidBody::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 32)); return (this->*_f)( _arg0); }
	virtual vec3f getPointVelocity_vf33(const vec3f &  _arg0) = 0;
	inline vec3f getPointVelocity(const vec3f &  _arg0) { typedef vec3f (IRigidBody::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 33)); return (this->*_f)( _arg0); }
	virtual void addForceAtPos_vf34(const vec3f &  _arg0, const vec3f &  _arg1) = 0;
	inline void addForceAtPos(const vec3f &  _arg0, const vec3f &  _arg1) { typedef void (IRigidBody::*_fpt)(const vec3f &, const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 34)); return (this->*_f)( _arg0,  _arg1); }
	virtual void addTorque_vf35(const vec3f &  _arg0) = 0;
	inline void addTorque(const vec3f &  _arg0) { typedef void (IRigidBody::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 35)); return (this->*_f)( _arg0); }
	virtual void addMeshCollider_vf36(float *  _arg0, unsigned int  _arg1, unsigned short *  _arg2, unsigned int  _arg3, mat44f  _arg4, unsigned long  _arg5, unsigned long  _arg6, unsigned int  _arg7) = 0;
	inline void addMeshCollider(float *  _arg0, unsigned int  _arg1, unsigned short *  _arg2, unsigned int  _arg3, mat44f  _arg4, unsigned long  _arg5, unsigned long  _arg6, unsigned int  _arg7) { typedef void (IRigidBody::*_fpt)(float *, unsigned int, unsigned short *, unsigned int, mat44f, unsigned long, unsigned long, unsigned int); auto _f=xcast<_fpt>(get_vfp(this, 36)); return (this->*_f)( _arg0,  _arg1,  _arg2,  _arg3,  _arg4,  _arg5,  _arg6,  _arg7); }
	virtual void setMeshCollideCategory_vf37(unsigned int  _arg0, unsigned long  _arg1) = 0;
	inline void setMeshCollideCategory(unsigned int  _arg0, unsigned long  _arg1) { typedef void (IRigidBody::*_fpt)(unsigned int, unsigned long); auto _f=xcast<_fpt>(get_vfp(this, 37)); return (this->*_f)( _arg0,  _arg1); }
	virtual void setMeshCollideMask_vf38(unsigned int  _arg0, unsigned long  _arg1) = 0;
	inline void setMeshCollideMask(unsigned int  _arg0, unsigned long  _arg1) { typedef void (IRigidBody::*_fpt)(unsigned int, unsigned long); auto _f=xcast<_fpt>(get_vfp(this, 38)); return (this->*_f)( _arg0,  _arg1); }
	virtual unsigned long getMeshCollideCategory_vf39(unsigned int  _arg0) = 0;
	inline unsigned long getMeshCollideCategory(unsigned int  _arg0) { typedef unsigned long (IRigidBody::*_fpt)(unsigned int); auto _f=xcast<_fpt>(get_vfp(this, 39)); return (this->*_f)( _arg0); }
	virtual unsigned long getMeshCollideMask_vf40(unsigned int  _arg0) = 0;
	inline unsigned long getMeshCollideMask(unsigned int  _arg0) { typedef unsigned long (IRigidBody::*_fpt)(unsigned int); auto _f=xcast<_fpt>(get_vfp(this, 40)); return (this->*_f)( _arg0); }
	virtual ~IRigidBody();
	inline void _guard_obj() {
		static_assert((sizeof(IRigidBody)==8),"bad size");
	};
};

//UDT: struct DynamicControllerStage @len=160
	//_Data: this+0x0, Member, Type: enum DynamicControllerInput, inputVar
	//_Data: this+0x4, Member, Type: enum DynamicControllerCombinatorMode, combinatorMode
	//_Data: this+0x8, Member, Type: class Curve, lut
	//_Data: this+0x88, Member, Type: float, filter
	//_Data: this+0x8C, Member, Type: float, upLimit
	//_Data: this+0x90, Member, Type: float, downLimit
	//_Data: this+0x94, Member, Type: float, currentValue
	//_Data: this+0x98, Member, Type: float, constValue
	//_Func: public void DynamicControllerStage(const DynamicControllerStage & __that); @loc=static @len=113 @rva=2546288
	//_Func: public void DynamicControllerStage(); @loc=static @len=62 @rva=2819968
	//_Func: public void ~DynamicControllerStage(); @loc=static @len=9 @rva=2549824
	//_Func: public DynamicControllerStage & operator=(const DynamicControllerStage &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct DynamicControllerStage {
public:
	DynamicControllerInput inputVar;
	DynamicControllerCombinatorMode combinatorMode;
	Curve lut;
	float filter;
	float upLimit;
	float downLimit;
	float currentValue;
	float constValue;
	inline DynamicControllerStage() { }
	inline DynamicControllerStage(const DynamicControllerStage& other) = default;
	inline DynamicControllerStage& operator=(const DynamicControllerStage& other) = default;
	inline void ctor(const DynamicControllerStage & __that) { typedef void (DynamicControllerStage::*_fpt)(const DynamicControllerStage &); auto _f=xcast<_fpt>(_drva(2546288)); (this->*_f)(__that); }
	inline void ctor() { typedef void (DynamicControllerStage::*_fpt)(); auto _f=xcast<_fpt>(_drva(2819968)); (this->*_f)(); }
	inline void dtor() { typedef void (DynamicControllerStage::*_fpt)(); auto _f=xcast<_fpt>(_drva(2549824)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(DynamicControllerStage)==160),"bad size");
		static_assert((offsetof(DynamicControllerStage,inputVar)==0x0),"bad off");
		static_assert((offsetof(DynamicControllerStage,combinatorMode)==0x4),"bad off");
		static_assert((offsetof(DynamicControllerStage,lut)==0x8),"bad off");
		static_assert((offsetof(DynamicControllerStage,filter)==0x88),"bad off");
		static_assert((offsetof(DynamicControllerStage,upLimit)==0x8C),"bad off");
		static_assert((offsetof(DynamicControllerStage,downLimit)==0x90),"bad off");
		static_assert((offsetof(DynamicControllerStage,currentValue)==0x94),"bad off");
		static_assert((offsetof(DynamicControllerStage,constValue)==0x98),"bad off");
	};
};

//UDT: struct SlipStream @len=104
	//_Func: public void ~SlipStream(); @loc=static @len=5 @rva=2796272
	//_Data: this+0x0, Member, Type: class Triangle, triangle
	//_Data: this+0x40, Member, Type: float, speedFactorMult
	//_Data: this+0x44, Member, Type: float, effectGainMult
	//_Data: this+0x48, Member, Type: class vec3f, dir
	//_Func: public void init(PhysicsEngine * pe); @loc=static @len=179 @rva=2796992
	//_Func: public float getSlipEffect(const vec3f & p); @loc=static @len=349 @rva=2796640
	//_Func: public void setPosition(const vec3f & pos, const vec3f & vel); @loc=static @len=677 @rva=2797184
	//_Func: public void setSpeedFactor(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public float getSpeedFactor(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x58, Member, Type: class PhysicsEngine *, physicsEngine
	//_Data: this+0x60, Member, Type: float, length
	//_Data: this+0x64, Member, Type: float, speedFactor
	//_Func: public void SlipStream(const SlipStream &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void SlipStream(); @loc=optimized @len=0 @rva=0
	//_Func: public SlipStream & operator=(const SlipStream &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct SlipStream {
public:
	Triangle triangle;
	float speedFactorMult;
	float effectGainMult;
	vec3f dir;
	PhysicsEngine * physicsEngine;
	float length;
	float speedFactor;
	inline SlipStream() { }
	inline SlipStream(const SlipStream& other) = default;
	inline SlipStream& operator=(const SlipStream& other) = default;
	inline void dtor() { typedef void (SlipStream::*_fpt)(); auto _f=xcast<_fpt>(_drva(2796272)); (this->*_f)(); }
	inline void init(PhysicsEngine * pe) { typedef void (SlipStream::*_fpt)(PhysicsEngine *); auto _f=xcast<_fpt>(_drva(2796992)); return (this->*_f)(pe); }
	inline float getSlipEffect(const vec3f & p) { typedef float (SlipStream::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2796640)); return (this->*_f)(p); }
	inline void setPosition(const vec3f & pos, const vec3f & vel) { typedef void (SlipStream::*_fpt)(const vec3f &, const vec3f &); auto _f=xcast<_fpt>(_drva(2797184)); return (this->*_f)(pos, vel); }
	inline void _guard_obj() {
		static_assert((sizeof(SlipStream)==104),"bad size");
		static_assert((offsetof(SlipStream,triangle)==0x0),"bad off");
		static_assert((offsetof(SlipStream,speedFactorMult)==0x40),"bad off");
		static_assert((offsetof(SlipStream,effectGainMult)==0x44),"bad off");
		static_assert((offsetof(SlipStream,dir)==0x48),"bad off");
		static_assert((offsetof(SlipStream,physicsEngine)==0x58),"bad off");
		static_assert((offsetof(SlipStream,length)==0x60),"bad off");
		static_assert((offsetof(SlipStream,speedFactor)==0x64),"bad off");
	};
};

//UDT: class BrushSlipProvider @len=56 @vfcount=1
	//_VTable: 
	//_Func: public void BrushSlipProvider(const BrushSlipProvider &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void BrushSlipProvider(float maxAngle, float xu, float flex); @loc=static @len=176 @rva=2830208
	//_Func: public void BrushSlipProvider(); @loc=static @len=52 @rva=2830384
	//_Func: public void ~BrushSlipProvider(); @loc=static @len=20 @rva=2830448
	//_Data: this+0x8, Member, Type: class BrushTyreModel, brushModel
	//_Data: this+0x24, Member, Type: float, asy
	//_Data: this+0x28, Member, Type: int, version
	//_Func: public TyreSlipOutput getSlipForce(const TyreSlipInput & input, bool useasy); @intro @virtual vtpo=0 vfid=0 @loc=static @len=157 @rva=2830736
	//_Func: public void setFromMaxSlipAngle(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public float getMaximum(); @loc=optimized @len=0 @rva=0
	//_Func: public float getMaxSlip(); @loc=optimized @len=0 @rva=0
	//_Func: public void calcMaximum(float load, float * maximum, float * max_slip); @loc=static @len=253 @rva=2830480
	//_Func: public void recomputeMaximum(); @loc=static @len=21 @rva=2830896
	//_Func: public void init(float  _arg0, float  _arg1, float  _arg2); @loc=optimized @len=0 @rva=0
	//_Data: this+0x2C, Member, Type: float, maximum
	//_Data: this+0x30, Member, Type: float, maxSlip
	//_Func: public BrushSlipProvider & operator=(const BrushSlipProvider & __that); @loc=static @len=52 @rva=2610224
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class BrushSlipProvider {
public:
	BrushTyreModel brushModel;
	float asy;
	int version;
	float maximum;
	float maxSlip;
	inline BrushSlipProvider() { }
	inline BrushSlipProvider(const BrushSlipProvider& other) = default;
	inline BrushSlipProvider& operator=(const BrushSlipProvider& other) = default;
	inline void ctor(float maxAngle, float xu, float flex) { typedef void (BrushSlipProvider::*_fpt)(float, float, float); auto _f=xcast<_fpt>(_drva(2830208)); (this->*_f)(maxAngle, xu, flex); }
	inline void ctor() { typedef void (BrushSlipProvider::*_fpt)(); auto _f=xcast<_fpt>(_drva(2830384)); (this->*_f)(); }
	inline void dtor() { typedef void (BrushSlipProvider::*_fpt)(); auto _f=xcast<_fpt>(_drva(2830448)); (this->*_f)(); }
	virtual TyreSlipOutput getSlipForce_vf0(const TyreSlipInput & input, bool useasy);
	inline TyreSlipOutput getSlipForce_impl(const TyreSlipInput & input, bool useasy) { typedef TyreSlipOutput (BrushSlipProvider::*_fpt)(const TyreSlipInput &, bool); auto _f=xcast<_fpt>(_drva(2830736)); return (this->*_f)(input, useasy); }
	inline TyreSlipOutput getSlipForce(const TyreSlipInput & input, bool useasy) { typedef TyreSlipOutput (BrushSlipProvider::*_fpt)(const TyreSlipInput &, bool); auto _f=xcast<_fpt>(get_vfp(this, 0)); return (this->*_f)(input, useasy); }
	inline void calcMaximum(float load, float * maximum, float * max_slip) { typedef void (BrushSlipProvider::*_fpt)(float, float *, float *); auto _f=xcast<_fpt>(_drva(2830480)); return (this->*_f)(load, maximum, max_slip); }
	inline void recomputeMaximum() { typedef void (BrushSlipProvider::*_fpt)(); auto _f=xcast<_fpt>(_drva(2830896)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(BrushSlipProvider)==56),"bad size");
		static_assert((offsetof(BrushSlipProvider,brushModel)==0x8),"bad off");
		static_assert((offsetof(BrushSlipProvider,asy)==0x24),"bad off");
		static_assert((offsetof(BrushSlipProvider,version)==0x28),"bad off");
		static_assert((offsetof(BrushSlipProvider,maximum)==0x2C),"bad off");
		static_assert((offsetof(BrushSlipProvider,maxSlip)==0x30),"bad off");
	};
};

//UDT: class ACCamera @len=248 @vfcount=1
	//_VTable: 
	//_Func: public void ACCamera(const ACCamera & __that); @loc=static @len=423 @rva=829808
	//_Func: public void ACCamera(); @loc=static @len=353 @rva=2048576
	//_Func: public void ~ACCamera(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=115 @rva=2048944
	//_Data: this+0x8, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, name
	//_Data: this+0x28, Member, Type: class mat44f, matrix
	//_Data: this+0x68, Member, Type: float, maxFov
	//_Data: this+0x6C, Member, Type: float, minFov
	//_Data: this+0x70, Member, Type: float, inPoint
	//_Data: this+0x74, Member, Type: float, outPoint
	//_Data: this+0x78, Member, Type: float, humanizer
	//_Data: this+0x7C, Member, Type: float[0x4], shadowSplits
	//_Data: this+0x8C, Member, Type: float, nearPlane
	//_Data: this+0x90, Member, Type: float, farPlane
	//_Data: this+0x94, Member, Type: float, minExposure
	//_Data: this+0x98, Member, Type: float, maxExposure
	//_Data: this+0x9C, Member, Type: float, dofFactor
	//_Data: this+0xA0, Member, Type: float, dofFocus
	//_Data: this+0xA4, Member, Type: float, dofRange
	//_Data: this+0xA8, Member, Type: bool, dofManual
	//_Data: this+0xAC, Member, Type: float, maxDistance
	//_Data: this+0xB0, Member, Type: float, minDistance
	//_Data: this+0xB8, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, splineFileName
	//_Data: this+0xD8, Member, Type: float, splineRotationY
	//_Data: this+0xE0, Member, Type: class Spline *, spline
	//_Data: this+0xE8, Member, Type: float, fovGamma
	//_Data: this+0xEC, Member, Type: bool, wasTriggered
	//_Data: this+0xED, Member, Type: bool, isCameraStretch
	//_Data: this+0xF0, Member, Type: float, splineAnimationLength
	//_Data: this+0xF4, Member, Type: bool, isFixed
	//_Func: public ACCamera & operator=(const ACCamera &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ACCamera {
public:
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > name;
	mat44f matrix;
	float maxFov;
	float minFov;
	float inPoint;
	float outPoint;
	float humanizer;
	float shadowSplits[4];
	float nearPlane;
	float farPlane;
	float minExposure;
	float maxExposure;
	float dofFactor;
	float dofFocus;
	float dofRange;
	bool dofManual;
	float maxDistance;
	float minDistance;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > splineFileName;
	float splineRotationY;
	Spline * spline;
	float fovGamma;
	bool wasTriggered;
	bool isCameraStretch;
	float splineAnimationLength;
	bool isFixed;
	inline ACCamera() { }
	inline ACCamera(const ACCamera& other) = default;
	inline ACCamera& operator=(const ACCamera& other) = default;
	inline void ctor(const ACCamera & __that) { typedef void (ACCamera::*_fpt)(const ACCamera &); auto _f=xcast<_fpt>(_drva(829808)); (this->*_f)(__that); }
	inline void ctor() { typedef void (ACCamera::*_fpt)(); auto _f=xcast<_fpt>(_drva(2048576)); (this->*_f)(); }
	virtual ~ACCamera();
	inline void dtor() { typedef void (ACCamera::*_fpt)(); auto _f=xcast<_fpt>(_drva(2048944)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(ACCamera)==248),"bad size");
		static_assert((offsetof(ACCamera,name)==0x8),"bad off");
		static_assert((offsetof(ACCamera,matrix)==0x28),"bad off");
		static_assert((offsetof(ACCamera,maxFov)==0x68),"bad off");
		static_assert((offsetof(ACCamera,minFov)==0x6C),"bad off");
		static_assert((offsetof(ACCamera,inPoint)==0x70),"bad off");
		static_assert((offsetof(ACCamera,outPoint)==0x74),"bad off");
		static_assert((offsetof(ACCamera,humanizer)==0x78),"bad off");
		static_assert((offsetof(ACCamera,shadowSplits)==0x7C),"bad off");
		static_assert((offsetof(ACCamera,nearPlane)==0x8C),"bad off");
		static_assert((offsetof(ACCamera,farPlane)==0x90),"bad off");
		static_assert((offsetof(ACCamera,minExposure)==0x94),"bad off");
		static_assert((offsetof(ACCamera,maxExposure)==0x98),"bad off");
		static_assert((offsetof(ACCamera,dofFactor)==0x9C),"bad off");
		static_assert((offsetof(ACCamera,dofFocus)==0xA0),"bad off");
		static_assert((offsetof(ACCamera,dofRange)==0xA4),"bad off");
		static_assert((offsetof(ACCamera,dofManual)==0xA8),"bad off");
		static_assert((offsetof(ACCamera,maxDistance)==0xAC),"bad off");
		static_assert((offsetof(ACCamera,minDistance)==0xB0),"bad off");
		static_assert((offsetof(ACCamera,splineFileName)==0xB8),"bad off");
		static_assert((offsetof(ACCamera,splineRotationY)==0xD8),"bad off");
		static_assert((offsetof(ACCamera,spline)==0xE0),"bad off");
		static_assert((offsetof(ACCamera,fovGamma)==0xE8),"bad off");
		static_assert((offsetof(ACCamera,wasTriggered)==0xEC),"bad off");
		static_assert((offsetof(ACCamera,isCameraStretch)==0xED),"bad off");
		static_assert((offsetof(ACCamera,splineAnimationLength)==0xF0),"bad off");
		static_assert((offsetof(ACCamera,isFixed)==0xF4),"bad off");
	};
};

//UDT: struct WingData @len=592
	//_Data: this+0x0, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, name
	//_Data: this+0x20, Member, Type: float, chord
	//_Data: this+0x24, Member, Type: float, span
	//_Data: this+0x28, Member, Type: class vec3f, position
	//_Data: this+0x38, Member, Type: class Curve, lutAOA_CL
	//_Data: this+0xB8, Member, Type: class Curve, lutAOA_CD
	//_Data: this+0x138, Member, Type: class Curve, lutGH_CL
	//_Data: this+0x1B8, Member, Type: class Curve, lutGH_CD
	//_Data: this+0x238, Member, Type: float, clGain
	//_Data: this+0x23C, Member, Type: float, cdGain
	//_Data: this+0x240, Member, Type: bool, hasController
	//_Data: this+0x244, Member, Type: float, yawGain
	//_Data: this+0x248, Member, Type: float, area
	//_Data: this+0x24C, Member, Type: bool, isVertical
	//_Func: public void WingData(const WingData & __that); @loc=static @len=249 @rva=845872
	//_Func: public void WingData(); @loc=static @len=145 @rva=2826944
	//_Func: public void ~WingData(); @loc=static @len=109 @rva=847680
	//_Func: public WingData & operator=(const WingData &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct WingData {
public:
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > name;
	float chord;
	float span;
	vec3f position;
	Curve lutAOA_CL;
	Curve lutAOA_CD;
	Curve lutGH_CL;
	Curve lutGH_CD;
	float clGain;
	float cdGain;
	bool hasController;
	float yawGain;
	float area;
	bool isVertical;
	inline WingData() { }
	inline WingData(const WingData& other) = default;
	inline WingData& operator=(const WingData& other) = default;
	inline void ctor(const WingData & __that) { typedef void (WingData::*_fpt)(const WingData &); auto _f=xcast<_fpt>(_drva(845872)); (this->*_f)(__that); }
	inline void ctor() { typedef void (WingData::*_fpt)(); auto _f=xcast<_fpt>(_drva(2826944)); (this->*_f)(); }
	inline void dtor() { typedef void (WingData::*_fpt)(); auto _f=xcast<_fpt>(_drva(847680)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(WingData)==592),"bad size");
		static_assert((offsetof(WingData,name)==0x0),"bad off");
		static_assert((offsetof(WingData,chord)==0x20),"bad off");
		static_assert((offsetof(WingData,span)==0x24),"bad off");
		static_assert((offsetof(WingData,position)==0x28),"bad off");
		static_assert((offsetof(WingData,lutAOA_CL)==0x38),"bad off");
		static_assert((offsetof(WingData,lutAOA_CD)==0xB8),"bad off");
		static_assert((offsetof(WingData,lutGH_CL)==0x138),"bad off");
		static_assert((offsetof(WingData,lutGH_CD)==0x1B8),"bad off");
		static_assert((offsetof(WingData,clGain)==0x238),"bad off");
		static_assert((offsetof(WingData,cdGain)==0x23C),"bad off");
		static_assert((offsetof(WingData,hasController)==0x240),"bad off");
		static_assert((offsetof(WingData,yawGain)==0x244),"bad off");
		static_assert((offsetof(WingData,area)==0x248),"bad off");
		static_assert((offsetof(WingData,isVertical)==0x24C),"bad off");
	};
};

//UDT: struct TractionControl @len=168
	//_Func: public void ~TractionControl(); @loc=static @len=9 @rva=2685136
	//_Data: this+0x0, Member, Type: bool, isPresent
	//_Data: this+0x1, Member, Type: bool, isActive
	//_Data: this+0x4, Member, Type: float, slipRatioLimit
	//_Data: this+0x8, Member, Type: bool, isInAction
	//_Data: this+0xC, Member, Type: float, frequency
	//_Func: public void init(Car * acar); @loc=static @len=1979 @rva=2685504
	//_Func: public void step(float dt); @loc=static @len=503 @rva=2687488
	//_Func: public void cycleMode(int value); @loc=static @len=202 @rva=2685152
	//_Func: public std::pair<unsigned int,unsigned int> getCurrentMode(); @loc=static @len=129 @rva=2685360
	//_Data: this+0x10, Member, Type: class Car *, car
	//_Data: this+0x18, Member, Type: float, minSpeedMS
	//_Data: this+0x1C, Member, Type: float, timeAccumulator
	//_Data: this+0x20, Member, Type: unsigned int, currentMode
	//_Data: this+0x24, Member, Type: bool, lastValue
	//_Data: this+0x28, Member, Type: class Curve, valueCurve
	//_Func: public void TractionControl(const TractionControl &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void TractionControl(); @loc=optimized @len=0 @rva=0
	//_Func: public TractionControl & operator=(const TractionControl &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct TractionControl {
public:
	bool isPresent;
	bool isActive;
	float slipRatioLimit;
	bool isInAction;
	float frequency;
	Car * car;
	float minSpeedMS;
	float timeAccumulator;
	unsigned int currentMode;
	bool lastValue;
	Curve valueCurve;
	inline TractionControl() { }
	inline TractionControl(const TractionControl& other) = default;
	inline TractionControl& operator=(const TractionControl& other) = default;
	inline void dtor() { typedef void (TractionControl::*_fpt)(); auto _f=xcast<_fpt>(_drva(2685136)); (this->*_f)(); }
	inline void init(Car * acar) { typedef void (TractionControl::*_fpt)(Car *); auto _f=xcast<_fpt>(_drva(2685504)); return (this->*_f)(acar); }
	inline void step(float dt) { typedef void (TractionControl::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2687488)); return (this->*_f)(dt); }
	inline void cycleMode(int value) { typedef void (TractionControl::*_fpt)(int); auto _f=xcast<_fpt>(_drva(2685152)); return (this->*_f)(value); }
	inline std::pair<unsigned int,unsigned int> getCurrentMode() { typedef std::pair<unsigned int,unsigned int> (TractionControl::*_fpt)(); auto _f=xcast<_fpt>(_drva(2685360)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(TractionControl)==168),"bad size");
		static_assert((offsetof(TractionControl,isPresent)==0x0),"bad off");
		static_assert((offsetof(TractionControl,isActive)==0x1),"bad off");
		static_assert((offsetof(TractionControl,slipRatioLimit)==0x4),"bad off");
		static_assert((offsetof(TractionControl,isInAction)==0x8),"bad off");
		static_assert((offsetof(TractionControl,frequency)==0xC),"bad off");
		static_assert((offsetof(TractionControl,car)==0x10),"bad off");
		static_assert((offsetof(TractionControl,minSpeedMS)==0x18),"bad off");
		static_assert((offsetof(TractionControl,timeAccumulator)==0x1C),"bad off");
		static_assert((offsetof(TractionControl,currentMode)==0x20),"bad off");
		static_assert((offsetof(TractionControl,lastValue)==0x24),"bad off");
		static_assert((offsetof(TractionControl,valueCurve)==0x28),"bad off");
	};
};

//UDT: struct ABS @len=168
	//_Func: public void ~ABS(); @loc=static @len=9 @rva=2681552
	//_Data: this+0x0, Member, Type: bool, isPresent
	//_Data: this+0x1, Member, Type: bool, isActive
	//_Data: this+0x4, Member, Type: float, slipRatioLimit
	//_Data: this+0x8, Member, Type: float, frequency
	//_Data: this+0xC, Member, Type: int, channels
	//_Func: public void init(Car * acar); @loc=static @len=2432 @rva=2681936
	//_Func: public void step(float td); @loc=static @len=696 @rva=2684432
	//_Func: public void cycleMode(int value); @loc=static @len=217 @rva=2681568
	//_Func: public std::pair<unsigned int,unsigned int> getCurrentMode(); @loc=static @len=132 @rva=2681792
	//_Func: public bool isInAction(); @loc=static @len=54 @rva=2684368
	//_Data: this+0x10, Member, Type: class Car *, car
	//_Data: this+0x18, Member, Type: float, timeAccumulator
	//_Data: this+0x20, Member, Type: class Curve, valueCurve
	//_Data: this+0xA0, Member, Type: unsigned int, currentMode
	//_Data: this+0xA4, Member, Type: float, currentValue
	//_Func: public void ABS(const ABS &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void ABS(); @loc=optimized @len=0 @rva=0
	//_Func: public ABS & operator=(const ABS &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct ABS {
public:
	bool isPresent;
	bool isActive;
	float slipRatioLimit;
	float frequency;
	int channels;
	Car * car;
	float timeAccumulator;
	Curve valueCurve;
	unsigned int currentMode;
	float currentValue;
	inline ABS() { }
	inline ABS(const ABS& other) = default;
	inline ABS& operator=(const ABS& other) = default;
	inline void dtor() { typedef void (ABS::*_fpt)(); auto _f=xcast<_fpt>(_drva(2681552)); (this->*_f)(); }
	inline void init(Car * acar) { typedef void (ABS::*_fpt)(Car *); auto _f=xcast<_fpt>(_drva(2681936)); return (this->*_f)(acar); }
	inline void step(float td) { typedef void (ABS::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2684432)); return (this->*_f)(td); }
	inline void cycleMode(int value) { typedef void (ABS::*_fpt)(int); auto _f=xcast<_fpt>(_drva(2681568)); return (this->*_f)(value); }
	inline std::pair<unsigned int,unsigned int> getCurrentMode() { typedef std::pair<unsigned int,unsigned int> (ABS::*_fpt)(); auto _f=xcast<_fpt>(_drva(2681792)); return (this->*_f)(); }
	inline bool isInAction() { typedef bool (ABS::*_fpt)(); auto _f=xcast<_fpt>(_drva(2684368)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(ABS)==168),"bad size");
		static_assert((offsetof(ABS,isPresent)==0x0),"bad off");
		static_assert((offsetof(ABS,isActive)==0x1),"bad off");
		static_assert((offsetof(ABS,slipRatioLimit)==0x4),"bad off");
		static_assert((offsetof(ABS,frequency)==0x8),"bad off");
		static_assert((offsetof(ABS,channels)==0xC),"bad off");
		static_assert((offsetof(ABS,car)==0x10),"bad off");
		static_assert((offsetof(ABS,timeAccumulator)==0x18),"bad off");
		static_assert((offsetof(ABS,valueCurve)==0x20),"bad off");
		static_assert((offsetof(ABS,currentMode)==0xA0),"bad off");
		static_assert((offsetof(ABS,currentValue)==0xA4),"bad off");
	};
};

//UDT: struct AutoBlip @len=168
	//_Func: public void ~AutoBlip(); @loc=static @len=9 @rva=2547808
	//_Data: this+0x0, Member, Type: bool, isActive
	//_Func: public void init(Car * acar); @loc=static @len=148 @rva=2857232
	//_Func: public void step(float dt); @loc=static @len=304 @rva=2858736
	//_Data: this+0x8, Member, Type: class Car *, car
	//_Data: this+0x10, Member, Type: class Curve, blipProfile
	//_Data: this+0x90, Member, Type: double, blipStartTime
	//_Data: this+0x98, Member, Type: bool, isElectronic
	//_Data: this+0xA0, Member, Type: double, blipPerformTime
	//_Func: private void loadINI(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * carModel); @loc=static @len=1332 @rva=2857392
	//_Func: public void AutoBlip(const AutoBlip &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void AutoBlip(); @loc=optimized @len=0 @rva=0
	//_Func: public AutoBlip & operator=(const AutoBlip &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct AutoBlip {
public:
	bool isActive;
	Car * car;
	Curve blipProfile;
	double blipStartTime;
	bool isElectronic;
	double blipPerformTime;
	inline AutoBlip() { }
	inline AutoBlip(const AutoBlip& other) = default;
	inline AutoBlip& operator=(const AutoBlip& other) = default;
	inline void dtor() { typedef void (AutoBlip::*_fpt)(); auto _f=xcast<_fpt>(_drva(2547808)); (this->*_f)(); }
	inline void init(Car * acar) { typedef void (AutoBlip::*_fpt)(Car *); auto _f=xcast<_fpt>(_drva(2857232)); return (this->*_f)(acar); }
	inline void step(float dt) { typedef void (AutoBlip::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2858736)); return (this->*_f)(dt); }
	inline void loadINI(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * carModel) { typedef void (AutoBlip::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *); auto _f=xcast<_fpt>(_drva(2857392)); return (this->*_f)(carModel); }
	inline void _guard_obj() {
		static_assert((sizeof(AutoBlip)==168),"bad size");
		static_assert((offsetof(AutoBlip,isActive)==0x0),"bad off");
		static_assert((offsetof(AutoBlip,car)==0x8),"bad off");
		static_assert((offsetof(AutoBlip,blipProfile)==0x10),"bad off");
		static_assert((offsetof(AutoBlip,blipStartTime)==0x90),"bad off");
		static_assert((offsetof(AutoBlip,isElectronic)==0x98),"bad off");
		static_assert((offsetof(AutoBlip,blipPerformTime)==0xA0),"bad off");
	};
};

//UDT: struct TyreThermalModel @len=224
	//_Data: this+0x0, Member, Type: int, elements
	//_Data: this+0x4, Member, Type: int, stripes
	//_Data: this+0x8, Member, Type: class std::vector<TyreThermalPatch,std::allocator<TyreThermalPatch> >, patches
	//_Data: this+0x20, Member, Type: double, phase
	//_Data: this+0x28, Member, Type: struct TyrePatchData, patchData
	//_Data: this+0x3C, Member, Type: float, coreTemp
	//_Data: this+0x40, Member, Type: class Curve, performanceCurve
	//_Data: this+0xC0, Member, Type: bool, isActive
	//_Data: this+0xC4, Member, Type: float, thermalMultD
	//_Data: this+0xC8, Member, Type: float, practicalTemp
	//_Data: this+0xCC, Member, Type: float, camberSpreadK
	//_Func: public void init(int a_elements, int a_stripes, Car * car); @loc=static @len=73 @rva=2810224
	//_Func: public void step(float dt, float angularSpeed, float camberRAD); @loc=static @len=1006 @rva=2810688
	//_Func: public void addThermalInput(float xpos, float pressureRel, float temp); @loc=static @len=621 @rva=2805904
	//_Func: public int getCurrentElementIndex(); @loc=optimized @len=0 @rva=0
	//_Func: public TyreThermalPatch & getPatchAt(int x, int y); @loc=static @len=393 @rva=2809776
	//_Func: public float getCurrentCPTemp(float camber); @loc=static @len=464 @rva=2808800
	//_Func: public float getCorrectedD(float d, float camberRAD); @loc=static @len=21 @rva=2808768
	//_Func: public float getAvgSurfaceTemp(); @loc=static @len=39 @rva=2808720
	//_Func: public void reset(); @loc=static @len=89 @rva=2810304
	//_Func: public void getIMO(float * out); @loc=static @len=512 @rva=2809264
	//_Func: public void setTemperature(float optimumTemp); @loc=static @len=33 @rva=2810640
	//_Func: public float getPracticalTemp(float camberRAD); @loc=static @len=38 @rva=2810176
	//_Func: public void addThermalCoreInput(float temp); @loc=static @len=17 @rva=2805872
	//_Data: this+0xD0, Member, Type: class Car *, car
	//_Data: this+0xD8, Member, Type: float, coreTInput
	//_Func: private void buildTyre(); @loc=static @len=2190 @rva=2806528
	//_Func: public void TyreThermalModel(const TyreThermalModel &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void TyreThermalModel(); @loc=static @len=144 @rva=2547584
	//_Func: public void ~TyreThermalModel(); @loc=static @len=46 @rva=2550256
	//_Func: public TyreThermalModel & operator=(const TyreThermalModel &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct TyreThermalModel {
public:
	int elements;
	int stripes;
	std::vector<TyreThermalPatch,std::allocator<TyreThermalPatch> > patches;
	double phase;
	TyrePatchData patchData;
	float coreTemp;
	Curve performanceCurve;
	bool isActive;
	float thermalMultD;
	float practicalTemp;
	float camberSpreadK;
	Car * car;
	float coreTInput;
	inline TyreThermalModel() { }
	inline TyreThermalModel(const TyreThermalModel& other) = default;
	inline TyreThermalModel& operator=(const TyreThermalModel& other) = default;
	inline void init(int a_elements, int a_stripes, Car * car) { typedef void (TyreThermalModel::*_fpt)(int, int, Car *); auto _f=xcast<_fpt>(_drva(2810224)); return (this->*_f)(a_elements, a_stripes, car); }
	inline void step(float dt, float angularSpeed, float camberRAD) { typedef void (TyreThermalModel::*_fpt)(float, float, float); auto _f=xcast<_fpt>(_drva(2810688)); return (this->*_f)(dt, angularSpeed, camberRAD); }
	inline void addThermalInput(float xpos, float pressureRel, float temp) { typedef void (TyreThermalModel::*_fpt)(float, float, float); auto _f=xcast<_fpt>(_drva(2805904)); return (this->*_f)(xpos, pressureRel, temp); }
	inline TyreThermalPatch & getPatchAt(int x, int y) { typedef TyreThermalPatch & (TyreThermalModel::*_fpt)(int, int); auto _f=xcast<_fpt>(_drva(2809776)); return (this->*_f)(x, y); }
	inline float getCurrentCPTemp(float camber) { typedef float (TyreThermalModel::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2808800)); return (this->*_f)(camber); }
	inline float getCorrectedD(float d, float camberRAD) { typedef float (TyreThermalModel::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2808768)); return (this->*_f)(d, camberRAD); }
	inline float getAvgSurfaceTemp() { typedef float (TyreThermalModel::*_fpt)(); auto _f=xcast<_fpt>(_drva(2808720)); return (this->*_f)(); }
	inline void reset() { typedef void (TyreThermalModel::*_fpt)(); auto _f=xcast<_fpt>(_drva(2810304)); return (this->*_f)(); }
	inline void getIMO(float * out) { typedef void (TyreThermalModel::*_fpt)(float *); auto _f=xcast<_fpt>(_drva(2809264)); return (this->*_f)(out); }
	inline void setTemperature(float optimumTemp) { typedef void (TyreThermalModel::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2810640)); return (this->*_f)(optimumTemp); }
	inline float getPracticalTemp(float camberRAD) { typedef float (TyreThermalModel::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2810176)); return (this->*_f)(camberRAD); }
	inline void addThermalCoreInput(float temp) { typedef void (TyreThermalModel::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2805872)); return (this->*_f)(temp); }
	inline void buildTyre() { typedef void (TyreThermalModel::*_fpt)(); auto _f=xcast<_fpt>(_drva(2806528)); return (this->*_f)(); }
	inline void ctor() { typedef void (TyreThermalModel::*_fpt)(); auto _f=xcast<_fpt>(_drva(2547584)); (this->*_f)(); }
	inline void dtor() { typedef void (TyreThermalModel::*_fpt)(); auto _f=xcast<_fpt>(_drva(2550256)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(TyreThermalModel)==224),"bad size");
		static_assert((offsetof(TyreThermalModel,elements)==0x0),"bad off");
		static_assert((offsetof(TyreThermalModel,stripes)==0x4),"bad off");
		static_assert((offsetof(TyreThermalModel,patches)==0x8),"bad off");
		static_assert((offsetof(TyreThermalModel,phase)==0x20),"bad off");
		static_assert((offsetof(TyreThermalModel,patchData)==0x28),"bad off");
		static_assert((offsetof(TyreThermalModel,coreTemp)==0x3C),"bad off");
		static_assert((offsetof(TyreThermalModel,performanceCurve)==0x40),"bad off");
		static_assert((offsetof(TyreThermalModel,isActive)==0xC0),"bad off");
		static_assert((offsetof(TyreThermalModel,thermalMultD)==0xC4),"bad off");
		static_assert((offsetof(TyreThermalModel,practicalTemp)==0xC8),"bad off");
		static_assert((offsetof(TyreThermalModel,camberSpreadK)==0xCC),"bad off");
		static_assert((offsetof(TyreThermalModel,car)==0xD0),"bad off");
		static_assert((offsetof(TyreThermalModel,coreTInput)==0xD8),"bad off");
	};
};

//UDT: struct Telemetry @len=256
	//_Func: public void ~Telemetry(); @loc=static @len=106 @rva=2866608
	//_Data: this+0x0, Member, Type: class std::vector<TelemetryChannel,std::allocator<TelemetryChannel> >, channels
	//_Data: this+0x18, Member, Type: bool, isEnabled
	//_Data: this+0x20, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, driverName
	//_Func: public void init(Car * car); @loc=static @len=11432 @rva=2867216
	//_Func: public void step(float td); @loc=static @len=987 @rva=2880944
	//_Func: public void save(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * filename); @loc=static @len=1337 @rva=2879600
	//_Data: this+0x40, Member, Type: bool, debugPhysics
	//_Data: this+0x41, Member, Type: bool, debugAI
	//_Data: this+0x48, Member, Type: class Car *, car
	//_Data: this+0x50, Member, Type: float, totLift
	//_Data: this+0x54, Member, Type: float, totDrag
	//_Data: this+0x58, Member, Type: float, lapBeacon
	//_Data: this+0x5C, Member, Type: float, carSpeedMS
	//_Data: this+0x60, Member, Type: float, roty
	//_Data: this+0x64, Member, Type: float, steerAngle
	//_Data: this+0x68, Member, Type: float, gas
	//_Data: this+0x6C, Member, Type: float, brake
	//_Data: this+0x70, Member, Type: float, gear
	//_Data: this+0x74, Member, Type: float, clutch
	//_Data: this+0x78, Member, Type: float, aiTargetSpeed
	//_Data: this+0x7C, Member, Type: float, aiBGTargetSpeed
	//_Data: this+0x80, Member, Type: float, aiOutsideOffset
	//_Data: this+0x84, Member, Type: float, rpms
	//_Data: this+0x88, Member, Type: float[0x4], susTravel
	//_Data: this+0x98, Member, Type: float[0x4], wheelSpeed
	//_Data: this+0xA8, Member, Type: struct TimeTransponder *, timeTransponder
	//_Data: this+0xB0, Member, Type: bool, exportEntireSession
	//_Data: this+0xB4, Member, Type: float, awdFrontShare
	//_Data: this+0xB8, Member, Type: float, awdCenterLock
	//_Data: this+0xBC, Member, Type: float, oversteerFactor
	//_Data: this+0xC0, Member, Type: float, rearSpeedRatio
	//_Data: this+0xC4, Member, Type: float, ebbInstant
	//_Data: this+0xC8, Member, Type: float, clutchOpenState
	//_Data: this+0xCC, Member, Type: float, engineVel
	//_Data: this+0xD0, Member, Type: float, driveVel
	//_Data: this+0xD4, Member, Type: float, rootVel
	//_Data: this+0xD8, Member, Type: float, clutchSlip
	//_Data: this+0xDC, Member, Type: float[0x4], avgSurfaceTemps
	//_Data: this+0xEC, Member, Type: float[0x4], practicalTemps
	//_Data: this+0xFC, Member, Type: float, splinePosition
	//_Func: public void Telemetry(const Telemetry &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void Telemetry(); @loc=static @len=160 @rva=2546480
	//_Func: public Telemetry & operator=(const Telemetry &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct Telemetry {
public:
	std::vector<TelemetryChannel,std::allocator<TelemetryChannel> > channels;
	bool isEnabled;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > driverName;
	bool debugPhysics;
	bool debugAI;
	Car * car;
	float totLift;
	float totDrag;
	float lapBeacon;
	float carSpeedMS;
	float roty;
	float steerAngle;
	float gas;
	float brake;
	float gear;
	float clutch;
	float aiTargetSpeed;
	float aiBGTargetSpeed;
	float aiOutsideOffset;
	float rpms;
	float susTravel[4];
	float wheelSpeed[4];
	TimeTransponder * timeTransponder;
	bool exportEntireSession;
	float awdFrontShare;
	float awdCenterLock;
	float oversteerFactor;
	float rearSpeedRatio;
	float ebbInstant;
	float clutchOpenState;
	float engineVel;
	float driveVel;
	float rootVel;
	float clutchSlip;
	float avgSurfaceTemps[4];
	float practicalTemps[4];
	float splinePosition;
	inline Telemetry() { }
	inline Telemetry(const Telemetry& other) = default;
	inline Telemetry& operator=(const Telemetry& other) = default;
	inline void dtor() { typedef void (Telemetry::*_fpt)(); auto _f=xcast<_fpt>(_drva(2866608)); (this->*_f)(); }
	inline void init(Car * car) { typedef void (Telemetry::*_fpt)(Car *); auto _f=xcast<_fpt>(_drva(2867216)); return (this->*_f)(car); }
	inline void step(float td) { typedef void (Telemetry::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2880944)); return (this->*_f)(td); }
	inline void save(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * filename) { typedef void (Telemetry::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *); auto _f=xcast<_fpt>(_drva(2879600)); return (this->*_f)(filename); }
	inline void ctor() { typedef void (Telemetry::*_fpt)(); auto _f=xcast<_fpt>(_drva(2546480)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(Telemetry)==256),"bad size");
		static_assert((offsetof(Telemetry,channels)==0x0),"bad off");
		static_assert((offsetof(Telemetry,isEnabled)==0x18),"bad off");
		static_assert((offsetof(Telemetry,driverName)==0x20),"bad off");
		static_assert((offsetof(Telemetry,debugPhysics)==0x40),"bad off");
		static_assert((offsetof(Telemetry,debugAI)==0x41),"bad off");
		static_assert((offsetof(Telemetry,car)==0x48),"bad off");
		static_assert((offsetof(Telemetry,totLift)==0x50),"bad off");
		static_assert((offsetof(Telemetry,totDrag)==0x54),"bad off");
		static_assert((offsetof(Telemetry,lapBeacon)==0x58),"bad off");
		static_assert((offsetof(Telemetry,carSpeedMS)==0x5C),"bad off");
		static_assert((offsetof(Telemetry,roty)==0x60),"bad off");
		static_assert((offsetof(Telemetry,steerAngle)==0x64),"bad off");
		static_assert((offsetof(Telemetry,gas)==0x68),"bad off");
		static_assert((offsetof(Telemetry,brake)==0x6C),"bad off");
		static_assert((offsetof(Telemetry,gear)==0x70),"bad off");
		static_assert((offsetof(Telemetry,clutch)==0x74),"bad off");
		static_assert((offsetof(Telemetry,aiTargetSpeed)==0x78),"bad off");
		static_assert((offsetof(Telemetry,aiBGTargetSpeed)==0x7C),"bad off");
		static_assert((offsetof(Telemetry,aiOutsideOffset)==0x80),"bad off");
		static_assert((offsetof(Telemetry,rpms)==0x84),"bad off");
		static_assert((offsetof(Telemetry,susTravel)==0x88),"bad off");
		static_assert((offsetof(Telemetry,wheelSpeed)==0x98),"bad off");
		static_assert((offsetof(Telemetry,timeTransponder)==0xA8),"bad off");
		static_assert((offsetof(Telemetry,exportEntireSession)==0xB0),"bad off");
		static_assert((offsetof(Telemetry,awdFrontShare)==0xB4),"bad off");
		static_assert((offsetof(Telemetry,awdCenterLock)==0xB8),"bad off");
		static_assert((offsetof(Telemetry,oversteerFactor)==0xBC),"bad off");
		static_assert((offsetof(Telemetry,rearSpeedRatio)==0xC0),"bad off");
		static_assert((offsetof(Telemetry,ebbInstant)==0xC4),"bad off");
		static_assert((offsetof(Telemetry,clutchOpenState)==0xC8),"bad off");
		static_assert((offsetof(Telemetry,engineVel)==0xCC),"bad off");
		static_assert((offsetof(Telemetry,driveVel)==0xD0),"bad off");
		static_assert((offsetof(Telemetry,rootVel)==0xD4),"bad off");
		static_assert((offsetof(Telemetry,clutchSlip)==0xD8),"bad off");
		static_assert((offsetof(Telemetry,avgSurfaceTemps)==0xDC),"bad off");
		static_assert((offsetof(Telemetry,practicalTemps)==0xEC),"bad off");
		static_assert((offsetof(Telemetry,splinePosition)==0xFC),"bad off");
	};
};

//UDT: class SCTM @len=488 @vfcount=2
	//_Base: class ITyreModel @off=0 @len=8
	//_Func: public void SCTM(const SCTM &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void SCTM(); @loc=static @len=159 @rva=4503744
	//_Func: public void ~SCTM(); @virtual vtpo=0 vfid=0 @loc=static @len=84 @rva=4503920
	//_Data: this+0x8, Member, Type: float, lsMultY
	//_Data: this+0xC, Member, Type: float, lsExpY
	//_Data: this+0x10, Member, Type: float, lsMultX
	//_Data: this+0x14, Member, Type: float, lsExpX
	//_Data: this+0x18, Member, Type: float, Fz0
	//_Data: this+0x1C, Member, Type: float, maxSlip0
	//_Data: this+0x20, Member, Type: float, maxSlip1
	//_Data: this+0x24, Member, Type: float, asy
	//_Data: this+0x28, Member, Type: float, falloffSpeed
	//_Data: this+0x2C, Member, Type: float, speedSensitivity
	//_Data: this+0x30, Member, Type: float, camberGain
	//_Data: this+0x34, Member, Type: float, dcamber0
	//_Data: this+0x38, Member, Type: float, dcamber1
	//_Data: this+0x3C, Member, Type: float, cfXmult
	//_Data: this+0x40, Member, Type: class Curve, dyLoadCurve
	//_Data: this+0xC0, Member, Type: class Curve, dxLoadCurve
	//_Data: this+0x140, Member, Type: float, pressureCfGain
	//_Data: this+0x144, Member, Type: float, brakeDXMod
	//_Data: this+0x148, Member, Type: class Curve, dCamberCurve
	//_Data: this+0x1C8, Member, Type: bool, useSmoothDCamberCurve
	//_Data: this+0x1CC, Member, Type: float, dCamberBlend
	//_Data: this+0x1D0, Member, Type: float, combinedFactor
	//_Data: this+0x1D4, Member, Type: float, dy0
	//_Data: this+0x1D8, Member, Type: float, dx0
	//_Data: this+0x1DC, Member, Type: float, pacE
	//_Data: this+0x1E0, Member, Type: float, pacCf
	//_Data: this+0x1E4, Member, Type: float, pacFlex
	//_Func: public TyreModelOutput solve(const TyreModelInput & in); @virtual vtpo=0 vfid=1 @loc=static @len=1444 @rva=4504608
	//_Func: public float getStaticDY(float load); @loc=static @len=109 @rva=4504496
	//_Func: public float getStaticDX(float load); @loc=static @len=115 @rva=4504368
	//_Func: private float getPureFY(float D, float cf, float load, float slip); @loc=static @len=188 @rva=4504176
	//_Func: private float getPureFX(float  _arg0, float  _arg1, float  _arg2, float  _arg3); @loc=optimized @len=0 @rva=0
	//_Func: public SCTM & operator=(const SCTM &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class SCTM : public ITyreModel {
public:
	float lsMultY;
	float lsExpY;
	float lsMultX;
	float lsExpX;
	float Fz0;
	float maxSlip0;
	float maxSlip1;
	float asy;
	float falloffSpeed;
	float speedSensitivity;
	float camberGain;
	float dcamber0;
	float dcamber1;
	float cfXmult;
	Curve dyLoadCurve;
	Curve dxLoadCurve;
	float pressureCfGain;
	float brakeDXMod;
	Curve dCamberCurve;
	bool useSmoothDCamberCurve;
	float dCamberBlend;
	float combinedFactor;
	float dy0;
	float dx0;
	float pacE;
	float pacCf;
	float pacFlex;
	inline SCTM() { }
	inline SCTM(const SCTM& other) = default;
	inline SCTM& operator=(const SCTM& other) = default;
	inline void ctor() { typedef void (SCTM::*_fpt)(); auto _f=xcast<_fpt>(_drva(4503744)); (this->*_f)(); }
	virtual ~SCTM();
	inline void dtor() { typedef void (SCTM::*_fpt)(); auto _f=xcast<_fpt>(_drva(4503920)); (this->*_f)(); }
	virtual TyreModelOutput solve_vf1(const TyreModelInput & in);
	inline TyreModelOutput solve_impl(const TyreModelInput & in) { typedef TyreModelOutput (SCTM::*_fpt)(const TyreModelInput &); auto _f=xcast<_fpt>(_drva(4504608)); return (this->*_f)(in); }
	inline TyreModelOutput solve(const TyreModelInput & in) { typedef TyreModelOutput (SCTM::*_fpt)(const TyreModelInput &); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(in); }
	inline float getStaticDY(float load) { typedef float (SCTM::*_fpt)(float); auto _f=xcast<_fpt>(_drva(4504496)); return (this->*_f)(load); }
	inline float getStaticDX(float load) { typedef float (SCTM::*_fpt)(float); auto _f=xcast<_fpt>(_drva(4504368)); return (this->*_f)(load); }
	inline float getPureFY(float D, float cf, float load, float slip) { typedef float (SCTM::*_fpt)(float, float, float, float); auto _f=xcast<_fpt>(_drva(4504176)); return (this->*_f)(D, cf, load, slip); }
	inline void _guard_obj() {
		static_assert((sizeof(SCTM)==488),"bad size");
		static_assert((offsetof(SCTM,lsMultY)==0x8),"bad off");
		static_assert((offsetof(SCTM,lsExpY)==0xC),"bad off");
		static_assert((offsetof(SCTM,lsMultX)==0x10),"bad off");
		static_assert((offsetof(SCTM,lsExpX)==0x14),"bad off");
		static_assert((offsetof(SCTM,Fz0)==0x18),"bad off");
		static_assert((offsetof(SCTM,maxSlip0)==0x1C),"bad off");
		static_assert((offsetof(SCTM,maxSlip1)==0x20),"bad off");
		static_assert((offsetof(SCTM,asy)==0x24),"bad off");
		static_assert((offsetof(SCTM,falloffSpeed)==0x28),"bad off");
		static_assert((offsetof(SCTM,speedSensitivity)==0x2C),"bad off");
		static_assert((offsetof(SCTM,camberGain)==0x30),"bad off");
		static_assert((offsetof(SCTM,dcamber0)==0x34),"bad off");
		static_assert((offsetof(SCTM,dcamber1)==0x38),"bad off");
		static_assert((offsetof(SCTM,cfXmult)==0x3C),"bad off");
		static_assert((offsetof(SCTM,dyLoadCurve)==0x40),"bad off");
		static_assert((offsetof(SCTM,dxLoadCurve)==0xC0),"bad off");
		static_assert((offsetof(SCTM,pressureCfGain)==0x140),"bad off");
		static_assert((offsetof(SCTM,brakeDXMod)==0x144),"bad off");
		static_assert((offsetof(SCTM,dCamberCurve)==0x148),"bad off");
		static_assert((offsetof(SCTM,useSmoothDCamberCurve)==0x1C8),"bad off");
		static_assert((offsetof(SCTM,dCamberBlend)==0x1CC),"bad off");
		static_assert((offsetof(SCTM,combinedFactor)==0x1D0),"bad off");
		static_assert((offsetof(SCTM,dy0)==0x1D4),"bad off");
		static_assert((offsetof(SCTM,dx0)==0x1D8),"bad off");
		static_assert((offsetof(SCTM,pacE)==0x1DC),"bad off");
		static_assert((offsetof(SCTM,pacCf)==0x1E0),"bad off");
		static_assert((offsetof(SCTM,pacFlex)==0x1E4),"bad off");
	};
};

//UDT: class ResourceStore @len=32 @vfcount=1
	//_VTable: 
	//_Func: public void ResourceStore(const ResourceStore &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void ResourceStore(GraphicsManager * rm); @loc=static @len=77 @rva=2097040
	//_Func: public void ~ResourceStore(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=192 @rva=2097120
	//_Func: public Texture getTexture(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & filename, bool onlyExisting); @loc=static @len=378 @rva=2097360
	//_Func: public Texture getTextureFromBuffer(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name, unsigned char * buffer, int size); @loc=static @len=364 @rva=2097744
	//_Func: public bool releaseTexture(const Texture &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public bool removeTexture(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void releaseAll(); @loc=optimized @len=0 @rva=0
	//_Func: public bool hasTexture(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name); @loc=static @len=110 @rva=2098112
	//_Data: this+0x8, Member, Type: class std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,Texture,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,Texture> > >, store
	//_Data: this+0x18, Member, Type: class GraphicsManager *, graphics
	//_Func: public ResourceStore & operator=(const ResourceStore &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ResourceStore {
public:
	std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,Texture,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,Texture> > > store;
	GraphicsManager * graphics;
	inline ResourceStore() { }
	inline ResourceStore(const ResourceStore& other) = default;
	inline ResourceStore& operator=(const ResourceStore& other) = default;
	inline void ctor(GraphicsManager * rm) { typedef void (ResourceStore::*_fpt)(GraphicsManager *); auto _f=xcast<_fpt>(_drva(2097040)); (this->*_f)(rm); }
	virtual ~ResourceStore();
	inline void dtor() { typedef void (ResourceStore::*_fpt)(); auto _f=xcast<_fpt>(_drva(2097120)); (this->*_f)(); }
	inline Texture getTexture(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & filename, bool onlyExisting) { typedef Texture (ResourceStore::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, bool); auto _f=xcast<_fpt>(_drva(2097360)); return (this->*_f)(filename, onlyExisting); }
	inline Texture getTextureFromBuffer(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name, unsigned char * buffer, int size) { typedef Texture (ResourceStore::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, unsigned char *, int); auto _f=xcast<_fpt>(_drva(2097744)); return (this->*_f)(name, buffer, size); }
	inline bool hasTexture(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name) { typedef bool (ResourceStore::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2098112)); return (this->*_f)(name); }
	inline void _guard_obj() {
		static_assert((sizeof(ResourceStore)==32),"bad size");
		static_assert((offsetof(ResourceStore,store)==0x8),"bad off");
		static_assert((offsetof(ResourceStore,graphics)==0x18),"bad off");
	};
};

//UDT: class ISuspension @len=56 @vfcount=25
	//_VTable: 
	//_Func: public void ~ISuspension(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=11 @rva=2886448
	//_Func: public mat44f getHubWorldMatrix(); @intro @pure @virtual vtpo=0 vfid=1 @loc=optimized @len=0 @rva=0
	//_Func: public vec3f getPointVelocity(const vec3f &  _arg0); @intro @pure @virtual vtpo=0 vfid=2 @loc=optimized @len=0 @rva=0
	//_Func: public void addForceAtPos(const vec3f &  _arg0, const vec3f &  _arg1, bool  _arg2, bool  _arg3); @intro @pure @virtual vtpo=0 vfid=3 @loc=optimized @len=0 @rva=0
	//_Func: public void addTorque(const vec3f &  _arg0); @intro @pure @virtual vtpo=0 vfid=4 @loc=optimized @len=0 @rva=0
	//_Func: public void setSteerLengthOffset(float  _arg0); @intro @pure @virtual vtpo=0 vfid=5 @loc=optimized @len=0 @rva=0
	//_Func: public float getSteerTorque(); @intro @pure @virtual vtpo=0 vfid=6 @loc=optimized @len=0 @rva=0
	//_Func: public vec3f getHubAngularVelocity(); @intro @pure @virtual vtpo=0 vfid=7 @loc=optimized @len=0 @rva=0
	//_Func: public void attach(); @intro @pure @virtual vtpo=0 vfid=8 @loc=optimized @len=0 @rva=0
	//_Func: public SuspensionStatus & getStatus(); @intro @pure @virtual vtpo=0 vfid=9 @loc=optimized @len=0 @rva=0
	//_Func: public vec3f getBasePosition(); @intro @pure @virtual vtpo=0 vfid=10 @loc=optimized @len=0 @rva=0
	//_Func: public float getK(); @intro @pure @virtual vtpo=0 vfid=11 @loc=optimized @len=0 @rva=0
	//_Func: public Damper * getDamper(); @intro @pure @virtual vtpo=0 vfid=12 @loc=optimized @len=0 @rva=0
	//_Func: public float getPackerRange(); @intro @pure @virtual vtpo=0 vfid=13 @loc=optimized @len=0 @rva=0
	//_Func: public std::vector<DebugLine,std::allocator<DebugLine> > getDebugLines(const mat44f &  _arg0, const mat44f &  _arg1); @intro @pure @virtual vtpo=0 vfid=14 @loc=optimized @len=0 @rva=0
	//_Func: public void setDamage(float  _arg0); @intro @pure @virtual vtpo=0 vfid=15 @loc=optimized @len=0 @rva=0
	//_Func: public void resetDamage(); @intro @pure @virtual vtpo=0 vfid=16 @loc=optimized @len=0 @rva=0
	//_Func: public float getDamage(); @intro @pure @virtual vtpo=0 vfid=17 @loc=optimized @len=0 @rva=0
	//_Func: public float getMass(); @intro @pure @virtual vtpo=0 vfid=18 @loc=optimized @len=0 @rva=0
	//_Func: public void stop(); @intro @pure @virtual vtpo=0 vfid=19 @loc=optimized @len=0 @rva=0
	//_Func: public vec3f getVelocity(); @intro @pure @virtual vtpo=0 vfid=20 @loc=optimized @len=0 @rva=0
	//_Func: public void getSteerBasis(vec3f &  _arg0, vec3f &  _arg1); @intro @pure @virtual vtpo=0 vfid=21 @loc=optimized @len=0 @rva=0
	//_Func: public void step(float  _arg0); @intro @pure @virtual vtpo=0 vfid=22 @loc=optimized @len=0 @rva=0
	//_Func: public void setERPCFM(float  _arg0, float  _arg1); @intro @pure @virtual vtpo=0 vfid=23 @loc=optimized @len=0 @rva=0
	//_Func: public void addLocalForceAndTorque(const vec3f &  _arg0, const vec3f &  _arg1, const vec3f &  _arg2); @intro @pure @virtual vtpo=0 vfid=24 @loc=optimized @len=0 @rva=0
	//_Data: this+0x8, Member, Type: float, k
	//_Data: this+0xC, Member, Type: float, progressiveK
	//_Data: this+0x10, Member, Type: float, bumpStopRate
	//_Data: this+0x14, Member, Type: float, bumpStopProgressive
	//_Data: this+0x18, Member, Type: float, staticCamber
	//_Data: this+0x1C, Member, Type: float, bumpStopUp
	//_Data: this+0x20, Member, Type: float, bumpStopDn
	//_Data: this+0x24, Member, Type: float, rodLength
	//_Data: this+0x28, Member, Type: float, toeOUT_Linear
	//_Data: this+0x2C, Member, Type: float, packerRange
	//_Data: this+0x30, Member, Type: float, baseCFM
	//_Func: public void ISuspension(const ISuspension &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void ISuspension(); @loc=optimized @len=0 @rva=0
	//_Func: public ISuspension & operator=(const ISuspension &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ISuspension {
public:
	float k;
	float progressiveK;
	float bumpStopRate;
	float bumpStopProgressive;
	float staticCamber;
	float bumpStopUp;
	float bumpStopDn;
	float rodLength;
	float toeOUT_Linear;
	float packerRange;
	float baseCFM;
	inline ISuspension() { }
	inline ISuspension(const ISuspension& other) = default;
	inline ISuspension& operator=(const ISuspension& other) = default;
	virtual ~ISuspension();
	inline void dtor() { typedef void (ISuspension::*_fpt)(); auto _f=xcast<_fpt>(_drva(2886448)); (this->*_f)(); }
	virtual mat44f getHubWorldMatrix_vf1() = 0;
	inline mat44f getHubWorldMatrix() { typedef mat44f (ISuspension::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(); }
	virtual vec3f getPointVelocity_vf2(const vec3f &  _arg0) = 0;
	inline vec3f getPointVelocity(const vec3f &  _arg0) { typedef vec3f (ISuspension::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)( _arg0); }
	virtual void addForceAtPos_vf3(const vec3f &  _arg0, const vec3f &  _arg1, bool  _arg2, bool  _arg3) = 0;
	inline void addForceAtPos(const vec3f &  _arg0, const vec3f &  _arg1, bool  _arg2, bool  _arg3) { typedef void (ISuspension::*_fpt)(const vec3f &, const vec3f &, bool, bool); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)( _arg0,  _arg1,  _arg2,  _arg3); }
	virtual void addTorque_vf4(const vec3f &  _arg0) = 0;
	inline void addTorque(const vec3f &  _arg0) { typedef void (ISuspension::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 4)); return (this->*_f)( _arg0); }
	virtual void setSteerLengthOffset_vf5(float  _arg0) = 0;
	inline void setSteerLengthOffset(float  _arg0) { typedef void (ISuspension::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 5)); return (this->*_f)( _arg0); }
	virtual float getSteerTorque_vf6() = 0;
	inline float getSteerTorque() { typedef float (ISuspension::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 6)); return (this->*_f)(); }
	virtual vec3f getHubAngularVelocity_vf7() = 0;
	inline vec3f getHubAngularVelocity() { typedef vec3f (ISuspension::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 7)); return (this->*_f)(); }
	virtual void attach_vf8() = 0;
	inline void attach() { typedef void (ISuspension::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 8)); return (this->*_f)(); }
	virtual SuspensionStatus & getStatus_vf9() = 0;
	inline SuspensionStatus & getStatus() { typedef SuspensionStatus & (ISuspension::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 9)); return (this->*_f)(); }
	virtual vec3f getBasePosition_vf10() = 0;
	inline vec3f getBasePosition() { typedef vec3f (ISuspension::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 10)); return (this->*_f)(); }
	virtual float getK_vf11() = 0;
	inline float getK() { typedef float (ISuspension::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 11)); return (this->*_f)(); }
	virtual Damper * getDamper_vf12() = 0;
	inline Damper * getDamper() { typedef Damper * (ISuspension::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 12)); return (this->*_f)(); }
	virtual float getPackerRange_vf13() = 0;
	inline float getPackerRange() { typedef float (ISuspension::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 13)); return (this->*_f)(); }
	virtual std::vector<DebugLine,std::allocator<DebugLine> > getDebugLines_vf14(const mat44f &  _arg0, const mat44f &  _arg1) = 0;
	inline std::vector<DebugLine,std::allocator<DebugLine> > getDebugLines(const mat44f &  _arg0, const mat44f &  _arg1) { typedef std::vector<DebugLine,std::allocator<DebugLine> > (ISuspension::*_fpt)(const mat44f &, const mat44f &); auto _f=xcast<_fpt>(get_vfp(this, 14)); return (this->*_f)( _arg0,  _arg1); }
	virtual void setDamage_vf15(float  _arg0) = 0;
	inline void setDamage(float  _arg0) { typedef void (ISuspension::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 15)); return (this->*_f)( _arg0); }
	virtual void resetDamage_vf16() = 0;
	inline void resetDamage() { typedef void (ISuspension::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 16)); return (this->*_f)(); }
	virtual float getDamage_vf17() = 0;
	inline float getDamage() { typedef float (ISuspension::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 17)); return (this->*_f)(); }
	virtual float getMass_vf18() = 0;
	inline float getMass() { typedef float (ISuspension::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 18)); return (this->*_f)(); }
	virtual void stop_vf19() = 0;
	inline void stop() { typedef void (ISuspension::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 19)); return (this->*_f)(); }
	virtual vec3f getVelocity_vf20() = 0;
	inline vec3f getVelocity() { typedef vec3f (ISuspension::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 20)); return (this->*_f)(); }
	virtual void getSteerBasis_vf21(vec3f &  _arg0, vec3f &  _arg1) = 0;
	inline void getSteerBasis(vec3f &  _arg0, vec3f &  _arg1) { typedef void (ISuspension::*_fpt)(vec3f &, vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 21)); return (this->*_f)( _arg0,  _arg1); }
	virtual void step_vf22(float  _arg0) = 0;
	inline void step(float  _arg0) { typedef void (ISuspension::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 22)); return (this->*_f)( _arg0); }
	virtual void setERPCFM_vf23(float  _arg0, float  _arg1) = 0;
	inline void setERPCFM(float  _arg0, float  _arg1) { typedef void (ISuspension::*_fpt)(float, float); auto _f=xcast<_fpt>(get_vfp(this, 23)); return (this->*_f)( _arg0,  _arg1); }
	virtual void addLocalForceAndTorque_vf24(const vec3f &  _arg0, const vec3f &  _arg1, const vec3f &  _arg2) = 0;
	inline void addLocalForceAndTorque(const vec3f &  _arg0, const vec3f &  _arg1, const vec3f &  _arg2) { typedef void (ISuspension::*_fpt)(const vec3f &, const vec3f &, const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 24)); return (this->*_f)( _arg0,  _arg1,  _arg2); }
	inline void _guard_obj() {
		static_assert((sizeof(ISuspension)==56),"bad size");
		static_assert((offsetof(ISuspension,k)==0x8),"bad off");
		static_assert((offsetof(ISuspension,progressiveK)==0xC),"bad off");
		static_assert((offsetof(ISuspension,bumpStopRate)==0x10),"bad off");
		static_assert((offsetof(ISuspension,bumpStopProgressive)==0x14),"bad off");
		static_assert((offsetof(ISuspension,staticCamber)==0x18),"bad off");
		static_assert((offsetof(ISuspension,bumpStopUp)==0x1C),"bad off");
		static_assert((offsetof(ISuspension,bumpStopDn)==0x20),"bad off");
		static_assert((offsetof(ISuspension,rodLength)==0x24),"bad off");
		static_assert((offsetof(ISuspension,toeOUT_Linear)==0x28),"bad off");
		static_assert((offsetof(ISuspension,packerRange)==0x2C),"bad off");
		static_assert((offsetof(ISuspension,baseCFM)==0x30),"bad off");
	};
};

//UDT: struct NetCarStateProviderDef @len=224
	//_Data: this+0x0, Member, Type: class ACClient *, client
	//_Data: this+0x8, Member, Type: unsigned char, sessionID
	//_Data: this+0x9, Member, Type: unsigned char, guid
	//_Data: this+0x10, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, driverName
	//_Data: this+0x30, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, team
	//_Data: this+0x50, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, nationCode
	//_Data: this+0x70, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, model
	//_Data: this+0x90, Member, Type: class IRayTrackCollisionProvider *, rayCastProvider
	//_Data: this+0x98, Member, Type: class PhysicsAvatar *, physicsAvatar
	//_Data: this+0xA0, Member, Type: class mat44f, pitPosition
	//_Func: public void NetCarStateProviderDef(const NetCarStateProviderDef &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void NetCarStateProviderDef(); @loc=optimized @len=0 @rva=0
	//_Func: public void ~NetCarStateProviderDef(); @loc=static @len=163 @rva=1660448
	//_Func: public NetCarStateProviderDef & operator=(const NetCarStateProviderDef &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct NetCarStateProviderDef {
public:
	ACClient * client;
	unsigned char sessionID;
	unsigned char guid;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > driverName;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > team;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > nationCode;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > model;
	IRayTrackCollisionProvider * rayCastProvider;
	PhysicsAvatar * physicsAvatar;
	mat44f pitPosition;
	inline NetCarStateProviderDef() { }
	inline NetCarStateProviderDef(const NetCarStateProviderDef& other) = default;
	inline NetCarStateProviderDef& operator=(const NetCarStateProviderDef& other) = default;
	inline void dtor() { typedef void (NetCarStateProviderDef::*_fpt)(); auto _f=xcast<_fpt>(_drva(1660448)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(NetCarStateProviderDef)==224),"bad size");
		static_assert((offsetof(NetCarStateProviderDef,client)==0x0),"bad off");
		static_assert((offsetof(NetCarStateProviderDef,sessionID)==0x8),"bad off");
		static_assert((offsetof(NetCarStateProviderDef,guid)==0x9),"bad off");
		static_assert((offsetof(NetCarStateProviderDef,driverName)==0x10),"bad off");
		static_assert((offsetof(NetCarStateProviderDef,team)==0x30),"bad off");
		static_assert((offsetof(NetCarStateProviderDef,nationCode)==0x50),"bad off");
		static_assert((offsetof(NetCarStateProviderDef,model)==0x70),"bad off");
		static_assert((offsetof(NetCarStateProviderDef,rayCastProvider)==0x90),"bad off");
		static_assert((offsetof(NetCarStateProviderDef,physicsAvatar)==0x98),"bad off");
		static_assert((offsetof(NetCarStateProviderDef,pitPosition)==0xA0),"bad off");
	};
};

//UDT: struct PenaltyManager @len=72
	//_Func: public void ~PenaltyManager(); @loc=static @len=71 @rva=2513088
	//_Data: this+0x0, Member, Type: class Event<OnPenaltyEvent>, evOnPenalty
	//_Func: public void init(Car * car); @loc=static @len=36 @rva=2514000
	//_Func: public void step(float dt); @loc=static @len=200 @rva=2514448
	//_Func: public void reset(); @loc=static @len=68 @rva=2514240
	//_Func: public bool hasPenalty(); @loc=optimized @len=0 @rva=0
	//_Func: public void addPenalty(PenaltyType  _arg0, unsigned int  _arg1, PenaltyDescription  _arg2); @loc=optimized @len=0 @rva=0
	//_Func: public std::vector<PenaltyRecord,std::allocator<PenaltyRecord> > getPenaltyRecords(); @loc=optimized @len=0 @rva=0
	//_Func: public void resetPenalty(); @loc=static @len=120 @rva=2514320
	//_Func: public bool checkBlackFlag(); @loc=static @len=25 @rva=2513936
	//_Func: public void addJumpStartPenalty(); @loc=static @len=375 @rva=2513552
	//_Func: public bool getIsServingPitPenalty(); @loc=optimized @len=0 @rva=0
	//_Func: public void setRearmPitPenalty(bool  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public short getPitPenaltyLaps(); @loc=optimized @len=0 @rva=0
	//_Func: public void decreasePitPenaltyLaps(bool isValidLap); @loc=static @len=27 @rva=2513968
	//_Data: this+0x18, Member, Type: class Car *, car
	//_Data: this+0x20, Member, Type: enum PenaltyType, pendingPenaltyType
	//_Data: this+0x24, Member, Type: bool, isServingPitPenalty
	//_Data: this+0x25, Member, Type: bool, rearmPitPenalty
	//_Data: this+0x26, Member, Type: short, pitPenaltyLaps
	//_Data: this+0x28, Member, Type: class std::vector<PenaltyRecord,std::allocator<PenaltyRecord> >, penaltyRecords
	//_Data: this+0x40, Member, Type: unsigned int, penaltySecs
	//_Data: this+0x44, Member, Type: float, inPitMeterCounter
	//_Func: public void PenaltyManager(const PenaltyManager &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void PenaltyManager(); @loc=optimized @len=0 @rva=0
	//_Func: public PenaltyManager & operator=(const PenaltyManager &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct PenaltyManager {
public:
	Event<OnPenaltyEvent> evOnPenalty;
	Car * car;
	PenaltyType pendingPenaltyType;
	bool isServingPitPenalty;
	bool rearmPitPenalty;
	short pitPenaltyLaps;
	std::vector<PenaltyRecord,std::allocator<PenaltyRecord> > penaltyRecords;
	unsigned int penaltySecs;
	float inPitMeterCounter;
	inline PenaltyManager() { }
	inline PenaltyManager(const PenaltyManager& other) = default;
	inline PenaltyManager& operator=(const PenaltyManager& other) = default;
	inline void dtor() { typedef void (PenaltyManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2513088)); (this->*_f)(); }
	inline void init(Car * car) { typedef void (PenaltyManager::*_fpt)(Car *); auto _f=xcast<_fpt>(_drva(2514000)); return (this->*_f)(car); }
	inline void step(float dt) { typedef void (PenaltyManager::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2514448)); return (this->*_f)(dt); }
	inline void reset() { typedef void (PenaltyManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2514240)); return (this->*_f)(); }
	inline void resetPenalty() { typedef void (PenaltyManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2514320)); return (this->*_f)(); }
	inline bool checkBlackFlag() { typedef bool (PenaltyManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2513936)); return (this->*_f)(); }
	inline void addJumpStartPenalty() { typedef void (PenaltyManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2513552)); return (this->*_f)(); }
	inline void decreasePitPenaltyLaps(bool isValidLap) { typedef void (PenaltyManager::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(2513968)); return (this->*_f)(isValidLap); }
	inline void _guard_obj() {
		static_assert((sizeof(PenaltyManager)==72),"bad size");
		static_assert((offsetof(PenaltyManager,evOnPenalty)==0x0),"bad off");
		static_assert((offsetof(PenaltyManager,car)==0x18),"bad off");
		static_assert((offsetof(PenaltyManager,pendingPenaltyType)==0x20),"bad off");
		static_assert((offsetof(PenaltyManager,isServingPitPenalty)==0x24),"bad off");
		static_assert((offsetof(PenaltyManager,rearmPitPenalty)==0x25),"bad off");
		static_assert((offsetof(PenaltyManager,pitPenaltyLaps)==0x26),"bad off");
		static_assert((offsetof(PenaltyManager,penaltyRecords)==0x28),"bad off");
		static_assert((offsetof(PenaltyManager,penaltySecs)==0x40),"bad off");
		static_assert((offsetof(PenaltyManager,inPitMeterCounter)==0x44),"bad off");
	};
};

//UDT: struct RenderState @len=504
	//_Func: public void RenderState(const RenderState &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void RenderState(); @loc=static @len=284 @rva=2105216
	//_Data: , Static Member, Type: const unsigned int, maxTextureNumber
	//_Data: this+0x0, Member, Type: void *[0x20], textures
	//_Data: this+0x100, Member, Type: enum CullMode, cullMode
	//_Data: this+0x104, Member, Type: enum BlendMode, blendMode
	//_Data: this+0x108, Member, Type: enum DepthMode, depthState
	//_Data: this+0x110, Member, Type: class Material *, material
	//_Data: this+0x118, Member, Type: class mat44f, projectionMatrix
	//_Data: this+0x158, Member, Type: class mat44f, viewMatrix
	//_Data: this+0x198, Member, Type: class mat44f, worldMatrix
	//_Data: this+0x1D8, Member, Type: class Shader *, shader
	//_Data: this+0x1E0, Member, Type: void *, currentRenderTarget
	//_Data: this+0x1E8, Member, Type: void *, currentDepth
	//_Data: this+0x1F0, Member, Type: bool, overrideNoMS
//UDT;

struct RenderState {
public:
	void * textures[32];
	CullMode cullMode;
	BlendMode blendMode;
	DepthMode depthState;
	Material * material;
	mat44f projectionMatrix;
	mat44f viewMatrix;
	mat44f worldMatrix;
	Shader * shader;
	void * currentRenderTarget;
	void * currentDepth;
	bool overrideNoMS;
	inline RenderState() { }
	inline RenderState(const RenderState& other) = default;
	inline RenderState& operator=(const RenderState& other) = default;
	inline void ctor() { typedef void (RenderState::*_fpt)(); auto _f=xcast<_fpt>(_drva(2105216)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(RenderState)==504),"bad size");
		static_assert((offsetof(RenderState,textures)==0x0),"bad off");
		static_assert((offsetof(RenderState,cullMode)==0x100),"bad off");
		static_assert((offsetof(RenderState,blendMode)==0x104),"bad off");
		static_assert((offsetof(RenderState,depthState)==0x108),"bad off");
		static_assert((offsetof(RenderState,material)==0x110),"bad off");
		static_assert((offsetof(RenderState,projectionMatrix)==0x118),"bad off");
		static_assert((offsetof(RenderState,viewMatrix)==0x158),"bad off");
		static_assert((offsetof(RenderState,worldMatrix)==0x198),"bad off");
		static_assert((offsetof(RenderState,shader)==0x1D8),"bad off");
		static_assert((offsetof(RenderState,currentRenderTarget)==0x1E0),"bad off");
		static_assert((offsetof(RenderState,currentDepth)==0x1E8),"bad off");
		static_assert((offsetof(RenderState,overrideNoMS)==0x1F0),"bad off");
	};
};

//UDT: class Spline @len=40 @vfcount=2
	//_VTable: 
	//_Func: public void Spline(const Spline &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void Spline(); @loc=static @len=34 @rva=2019712
	//_Func: public void ~Spline(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=60 @rva=2019760
	//_Func: public vec3f pointAt(unsigned int index); @loc=static @len=92 @rva=2025504
	//_Func: public void setPointAt(unsigned int index, vec3f point); @loc=static @len=75 @rva=2025904
	//_Func: public SplinePoint splinePointAt(unsigned int index); @loc=static @len=130 @rva=2025984
	//_Func: public float distanceAt(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void addPoint(const vec3f & p, int tag); @loc=static @len=188 @rva=2020960
	//_Func: public void addSplinePoint(const SplinePoint & p); @loc=static @len=9 @rva=2021152
	//_Func: public void reSampleSpline(int  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void clear(); @intro @virtual vtpo=0 vfid=1 @loc=static @len=16 @rva=2021616
	//_Func: public float length(); @loc=static @len=20 @rva=2024352
	//_Func: public unsigned int pointsCount(); @loc=static @len=39 @rva=2025600
	//_Func: public unsigned int closestPointIndex(const vec3f & point, float * distance); @loc=static @len=261 @rva=2021632
	//_Func: public unsigned int closestPointIndexWithBounds(const vec3f & point, const std::vector<SplineIndexBound,std::allocator<SplineIndexBound> > & bounds, float * distance); @loc=static @len=238 @rva=2021904
	//_Func: public std::vector<unsigned int,std::allocator<unsigned int> > closestPointIndicesFlat(const vec3f & point, unsigned int numberOfNeigbours, float * distance); @loc=static @len=1102 @rva=2022144
	//_Func: public vec3f getSplineDirection(const vec3f & point); @loc=static @len=313 @rva=2023888
	//_Func: public unsigned int wrapIndex(int index); @loc=static @len=197 @rva=2026192
	//_Func: public void loadFromCSV(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * filename); @loc=static @len=1111 @rva=2024384
	//_Func: public vec3f getPointSmooth(float v); @loc=static @len=371 @rva=2023504
	//_Func: public void applyMatrix(const mat44f & m); @loc=static @len=297 @rva=2021168
	//_Func: public int tagAt(unsigned int index); @loc=static @len=62 @rva=2026128
	//_Func: public bool isClosed(); @loc=static @len=134 @rva=2024208
	//_Func: public void reverse(); @loc=static @len=64 @rva=2025840
	//_Data: this+0x8, Member, Type: class std::vector<SplinePoint,std::allocator<SplinePoint> >, points
	//_Data: this+0x20, Member, Type: float, m_length
	//_Data: this+0x24, Member, Type: bool, m_closed
	//_Func: protected void smoothPoint(int  _arg0, int  _arg1, float  _arg2); @loc=optimized @len=0 @rva=0
	//_Func: protected void updateSplineLength(); @loc=optimized @len=0 @rva=0
	//_Func: protected float boundInsideSpline(float value); @loc=static @len=129 @rva=2021472
	//_Func: public Spline & operator=(const Spline &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class Spline {
public:
	std::vector<SplinePoint,std::allocator<SplinePoint> > points;
	float m_length;
	bool m_closed;
	inline Spline() { }
	inline Spline(const Spline& other) = default;
	inline Spline& operator=(const Spline& other) = default;
	inline void ctor() { typedef void (Spline::*_fpt)(); auto _f=xcast<_fpt>(_drva(2019712)); (this->*_f)(); }
	virtual ~Spline();
	inline void dtor() { typedef void (Spline::*_fpt)(); auto _f=xcast<_fpt>(_drva(2019760)); (this->*_f)(); }
	inline vec3f pointAt(unsigned int index) { typedef vec3f (Spline::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(2025504)); return (this->*_f)(index); }
	inline void setPointAt(unsigned int index, vec3f point) { typedef void (Spline::*_fpt)(unsigned int, vec3f); auto _f=xcast<_fpt>(_drva(2025904)); return (this->*_f)(index, point); }
	inline SplinePoint splinePointAt(unsigned int index) { typedef SplinePoint (Spline::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(2025984)); return (this->*_f)(index); }
	inline void addPoint(const vec3f & p, int tag) { typedef void (Spline::*_fpt)(const vec3f &, int); auto _f=xcast<_fpt>(_drva(2020960)); return (this->*_f)(p, tag); }
	inline void addSplinePoint(const SplinePoint & p) { typedef void (Spline::*_fpt)(const SplinePoint &); auto _f=xcast<_fpt>(_drva(2021152)); return (this->*_f)(p); }
	virtual void clear_vf1();
	inline void clear_impl() { typedef void (Spline::*_fpt)(); auto _f=xcast<_fpt>(_drva(2021616)); return (this->*_f)(); }
	inline void clear() { typedef void (Spline::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(); }
	inline float length() { typedef float (Spline::*_fpt)(); auto _f=xcast<_fpt>(_drva(2024352)); return (this->*_f)(); }
	inline unsigned int pointsCount() { typedef unsigned int (Spline::*_fpt)(); auto _f=xcast<_fpt>(_drva(2025600)); return (this->*_f)(); }
	inline unsigned int closestPointIndex(const vec3f & point, float * distance) { typedef unsigned int (Spline::*_fpt)(const vec3f &, float *); auto _f=xcast<_fpt>(_drva(2021632)); return (this->*_f)(point, distance); }
	inline unsigned int closestPointIndexWithBounds(const vec3f & point, const std::vector<SplineIndexBound,std::allocator<SplineIndexBound> > & bounds, float * distance) { typedef unsigned int (Spline::*_fpt)(const vec3f &, const std::vector<SplineIndexBound,std::allocator<SplineIndexBound> > &, float *); auto _f=xcast<_fpt>(_drva(2021904)); return (this->*_f)(point, bounds, distance); }
	inline std::vector<unsigned int,std::allocator<unsigned int> > closestPointIndicesFlat(const vec3f & point, unsigned int numberOfNeigbours, float * distance) { typedef std::vector<unsigned int,std::allocator<unsigned int> > (Spline::*_fpt)(const vec3f &, unsigned int, float *); auto _f=xcast<_fpt>(_drva(2022144)); return (this->*_f)(point, numberOfNeigbours, distance); }
	inline vec3f getSplineDirection(const vec3f & point) { typedef vec3f (Spline::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2023888)); return (this->*_f)(point); }
	inline unsigned int wrapIndex(int index) { typedef unsigned int (Spline::*_fpt)(int); auto _f=xcast<_fpt>(_drva(2026192)); return (this->*_f)(index); }
	inline void loadFromCSV(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * filename) { typedef void (Spline::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *); auto _f=xcast<_fpt>(_drva(2024384)); return (this->*_f)(filename); }
	inline vec3f getPointSmooth(float v) { typedef vec3f (Spline::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2023504)); return (this->*_f)(v); }
	inline void applyMatrix(const mat44f & m) { typedef void (Spline::*_fpt)(const mat44f &); auto _f=xcast<_fpt>(_drva(2021168)); return (this->*_f)(m); }
	inline int tagAt(unsigned int index) { typedef int (Spline::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(2026128)); return (this->*_f)(index); }
	inline bool isClosed() { typedef bool (Spline::*_fpt)(); auto _f=xcast<_fpt>(_drva(2024208)); return (this->*_f)(); }
	inline void reverse() { typedef void (Spline::*_fpt)(); auto _f=xcast<_fpt>(_drva(2025840)); return (this->*_f)(); }
	inline float boundInsideSpline(float value) { typedef float (Spline::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2021472)); return (this->*_f)(value); }
	inline void _guard_obj() {
		static_assert((sizeof(Spline)==40),"bad size");
		static_assert((offsetof(Spline,points)==0x8),"bad off");
		static_assert((offsetof(Spline,m_length)==0x20),"bad off");
		static_assert((offsetof(Spline,m_closed)==0x24),"bad off");
	};
};

//UDT: class MaterialVar @len=144
	//_Func: public void MaterialVar(const MaterialVar &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void MaterialVar(ShaderVariable * ivar); @loc=static @len=238 @rva=2137184
	//_Func: public void copyValues(const MaterialVar * mv); @loc=static @len=229 @rva=2140240
	//_Data: this+0x0, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, name
	//_Func: public int getSize(); @loc=optimized @len=0 @rva=0
	//_Func: public void setFloat(float v); @loc=static @len=84 @rva=383184
	//_Func: public float getFloat(); @loc=optimized @len=0 @rva=0
	//_Func: public void setFloat2(const vec2f &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public vec2f getFloat2(); @loc=optimized @len=0 @rva=0
	//_Func: public void setFloat3(const vec3f & v); @loc=static @len=94 @rva=918464
	//_Func: public vec3f getFloat3(); @loc=static @len=19 @rva=909296
	//_Func: public void setFloat4(const vec4f &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public vec4f getFloat4(); @loc=optimized @len=0 @rva=0
	//_Func: public void set(); @loc=static @len=79 @rva=383104
	//_Data: this+0x20, Member, Type: float, fValue
	//_Data: this+0x24, Member, Type: class vec2f, fValue2
	//_Data: this+0x2C, Member, Type: class vec3f, fValue3
	//_Data: this+0x38, Member, Type: class vec4f, fValue4
	//_Data: this+0x48, Member, Type: class mat44f, mValue
	//_Data: this+0x88, Member, Type: class ShaderVariable *, var
	//_Func: public void ~MaterialVar(); @loc=optimized @len=0 @rva=0
	//_Func: public MaterialVar & operator=(const MaterialVar &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class MaterialVar {
public:
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > name;
	float fValue;
	vec2f fValue2;
	vec3f fValue3;
	vec4f fValue4;
	mat44f mValue;
	ShaderVariable * var;
	inline MaterialVar() { }
	inline MaterialVar(const MaterialVar& other) = default;
	inline MaterialVar& operator=(const MaterialVar& other) = default;
	inline void ctor(ShaderVariable * ivar) { typedef void (MaterialVar::*_fpt)(ShaderVariable *); auto _f=xcast<_fpt>(_drva(2137184)); (this->*_f)(ivar); }
	inline void copyValues(const MaterialVar * mv) { typedef void (MaterialVar::*_fpt)(const MaterialVar *); auto _f=xcast<_fpt>(_drva(2140240)); return (this->*_f)(mv); }
	inline void setFloat(float v) { typedef void (MaterialVar::*_fpt)(float); auto _f=xcast<_fpt>(_drva(383184)); return (this->*_f)(v); }
	inline void setFloat3(const vec3f & v) { typedef void (MaterialVar::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(918464)); return (this->*_f)(v); }
	inline vec3f getFloat3() { typedef vec3f (MaterialVar::*_fpt)(); auto _f=xcast<_fpt>(_drva(909296)); return (this->*_f)(); }
	inline void set() { typedef void (MaterialVar::*_fpt)(); auto _f=xcast<_fpt>(_drva(383104)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(MaterialVar)==144),"bad size");
		static_assert((offsetof(MaterialVar,name)==0x0),"bad off");
		static_assert((offsetof(MaterialVar,fValue)==0x20),"bad off");
		static_assert((offsetof(MaterialVar,fValue2)==0x24),"bad off");
		static_assert((offsetof(MaterialVar,fValue3)==0x2C),"bad off");
		static_assert((offsetof(MaterialVar,fValue4)==0x38),"bad off");
		static_assert((offsetof(MaterialVar,mValue)==0x48),"bad off");
		static_assert((offsetof(MaterialVar,var)==0x88),"bad off");
	};
};

//UDT: class INIReader @len=104 @vfcount=1
	//_VTable: 
	//_Func: public void INIReader(const INIReader & __that); @loc=static @len=185 @rva=776000
	//_Func: protected void INIReader(); @loc=static @len=130 @rva=2310160
	//_Func: public void INIReader(const std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & stream); @loc=static @len=231 @rva=2310928
	//_Func: public void INIReader(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ifilename); @loc=static @len=612 @rva=2310304
	//_Func: public void ~INIReader(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=143 @rva=2311168
	//_Data: this+0x8, Member, Type: bool, ready
	//_Data: static, [0155A550][0003:00047550], Static Member, Type: class IErrorHandler *, errorHandler
	//_Data: static, [0155A558][0003:00047558], Static Member, Type: bool, crashAtError
	//_Data: this+0x9, Member, Type: bool, suppressErrorReporting
	//_Data: static, [0155A560][0003:00047560], Static Member, Type: class std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, openedFiles
	//_Data: static, [0151D0F9][0003:0000A0F9], Static Member, Type: bool, useCache
	//_Func: public void clearCache(); @pure @loc=static @len=75 @rva=2312464
	//_Func: public bool hasSection(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section); @loc=static @len=110 @rva=2322608
	//_Func: public bool hasKey(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & key); @loc=static @len=313 @rva=2322176
	//_Func: public int getHex(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & key); @loc=static @len=507 @rva=2316912
	//_Func: public int getInt(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & key); @loc=static @len=411 @rva=2317424
	//_Func: public float getFloat(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & key); @loc=static @len=431 @rva=2316480
	//_Func: public void getSections(std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > & outSections); @loc=static @len=300 @rva=2318272
	//_Func: public void getKeyes(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * section, std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > & keyes); @loc=static @len=419 @rva=2317840
	//_Func: public std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getSection(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getString(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & key); @loc=static @len=527 @rva=2318576
	//_Func: public vec2f getFloat2(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & key); @loc=static @len=53 @rva=2316128
	//_Func: public vec3f getFloat3(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & key); @loc=static @len=192 @rva=2316192
	//_Func: public vec4f getFloat4(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & key); @loc=static @len=96 @rva=2316384
	//_Func: public std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getFileName(); @loc=static @len=58 @rva=2316064
	//_Func: public void setVerboseMode(bool mode); @loc=static @len=20 @rva=2327152
	//_Func: public bool isEncrypted(); @loc=optimized @len=0 @rva=0
	//_Func: public Curve getCurve(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & key); @loc=static @len=1752 @rva=2314304
	//_Func: public void printCode(); @loc=static @len=28 @rva=2327120
	//_Data: this+0x10, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, filename
	//_Data: this+0x30, Member, Type: class std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,INISection,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,INISection> > >, sections
	//_Data: this+0x40, Member, Type: bool, m_isEncrypted
	//_Data: this+0x41, Member, Type: bool, verbose
	//_Data: static, [0155A578][0003:00047578], Static Member, Type: class std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,INISection,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,INISection> > >,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,INISection,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,INISection> > > > > >, cache
	//_Func: protected void load(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & filename); @loc=static @len=1058 @rva=2322752
	//_Func: protected void loadEncrypt(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & filename, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & dataFile); @loc=static @len=271 @rva=2323824
	//_Data: this+0x48, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, code
	//_Func: protected std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getSectionEx(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &  _arg0, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &  _arg1, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &  _arg2); @loc=optimized @len=0 @rva=0
	//_Func: protected void errorReport(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * message); @loc=static @len=300 @rva=2313840
	//_Func: protected void warningReport(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: protected void parse(); @loc=static @len=3021 @rva=2324096
	//_Func: protected void getVector2(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & key, float & x, float & y); @loc=static @len=570 @rva=2319104
	//_Func: protected void getVector3(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & key, float & x, float & y, float & z); @loc=static @len=1423 @rva=2319680
	//_Func: protected bool getVector4(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & key, float & x, float & y, float & z, float & w); @loc=static @len=1065 @rva=2321104
	//_Func: public INIReader & operator=(const INIReader & __that); @loc=static @len=201 @rva=776720
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class INIReader {
public:
	bool ready;
	bool suppressErrorReporting;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > filename;
	std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,INISection,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,INISection> > > sections;
	bool m_isEncrypted;
	bool verbose;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > code;
	inline INIReader() { }
	inline INIReader(const INIReader& other) = default;
	inline INIReader& operator=(const INIReader& other) = default;
	inline void ctor(const INIReader & __that) { typedef void (INIReader::*_fpt)(const INIReader &); auto _f=xcast<_fpt>(_drva(776000)); (this->*_f)(__that); }
	inline void ctor() { typedef void (INIReader::*_fpt)(); auto _f=xcast<_fpt>(_drva(2310160)); (this->*_f)(); }
	inline void ctor(const std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & stream) { typedef void (INIReader::*_fpt)(const std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2310928)); (this->*_f)(stream); }
	inline void ctor(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ifilename) { typedef void (INIReader::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2310304)); (this->*_f)(ifilename); }
	virtual ~INIReader();
	inline void dtor() { typedef void (INIReader::*_fpt)(); auto _f=xcast<_fpt>(_drva(2311168)); (this->*_f)(); }
	inline static void clearCache() { typedef void (*_fpt)(); auto _f=(_fpt)_drva(2312464); return _f(); }
	inline bool hasSection(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section) { typedef bool (INIReader::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2322608)); return (this->*_f)(section); }
	inline bool hasKey(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & key) { typedef bool (INIReader::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2322176)); return (this->*_f)(section, key); }
	inline int getHex(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & key) { typedef int (INIReader::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2316912)); return (this->*_f)(section, key); }
	inline int getInt(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & key) { typedef int (INIReader::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2317424)); return (this->*_f)(section, key); }
	inline float getFloat(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & key) { typedef float (INIReader::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2316480)); return (this->*_f)(section, key); }
	inline void getSections(std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > & outSections) { typedef void (INIReader::*_fpt)(std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > &); auto _f=xcast<_fpt>(_drva(2318272)); return (this->*_f)(outSections); }
	inline void getKeyes(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * section, std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > & keyes) { typedef void (INIReader::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > &); auto _f=xcast<_fpt>(_drva(2317840)); return (this->*_f)(section, keyes); }
	inline std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getString(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & key) { typedef std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > (INIReader::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2318576)); return (this->*_f)(section, key); }
	inline vec2f getFloat2(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & key) { typedef vec2f (INIReader::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2316128)); return (this->*_f)(section, key); }
	inline vec3f getFloat3(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & key) { typedef vec3f (INIReader::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2316192)); return (this->*_f)(section, key); }
	inline vec4f getFloat4(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & key) { typedef vec4f (INIReader::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2316384)); return (this->*_f)(section, key); }
	inline std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getFileName() { typedef std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > (INIReader::*_fpt)(); auto _f=xcast<_fpt>(_drva(2316064)); return (this->*_f)(); }
	inline void setVerboseMode(bool mode) { typedef void (INIReader::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(2327152)); return (this->*_f)(mode); }
	inline Curve getCurve(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & key) { typedef Curve (INIReader::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2314304)); return (this->*_f)(section, key); }
	inline void printCode() { typedef void (INIReader::*_fpt)(); auto _f=xcast<_fpt>(_drva(2327120)); return (this->*_f)(); }
	inline void load(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & filename) { typedef void (INIReader::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2322752)); return (this->*_f)(filename); }
	inline void loadEncrypt(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & filename, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & dataFile) { typedef void (INIReader::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2323824)); return (this->*_f)(filename, dataFile); }
	inline void errorReport(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * message) { typedef void (INIReader::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *); auto _f=xcast<_fpt>(_drva(2313840)); return (this->*_f)(message); }
	inline void parse() { typedef void (INIReader::*_fpt)(); auto _f=xcast<_fpt>(_drva(2324096)); return (this->*_f)(); }
	inline void getVector2(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & key, float & x, float & y) { typedef void (INIReader::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, float &, float &); auto _f=xcast<_fpt>(_drva(2319104)); return (this->*_f)(section, key, x, y); }
	inline void getVector3(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & key, float & x, float & y, float & z) { typedef void (INIReader::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, float &, float &, float &); auto _f=xcast<_fpt>(_drva(2319680)); return (this->*_f)(section, key, x, y, z); }
	inline bool getVector4(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & key, float & x, float & y, float & z, float & w) { typedef bool (INIReader::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, float &, float &, float &, float &); auto _f=xcast<_fpt>(_drva(2321104)); return (this->*_f)(section, key, x, y, z, w); }
	inline void _guard_obj() {
		static_assert((sizeof(INIReader)==104),"bad size");
		static_assert((offsetof(INIReader,ready)==0x8),"bad off");
		static_assert((offsetof(INIReader,suppressErrorReporting)==0x9),"bad off");
		static_assert((offsetof(INIReader,filename)==0x10),"bad off");
		static_assert((offsetof(INIReader,sections)==0x30),"bad off");
		static_assert((offsetof(INIReader,m_isEncrypted)==0x40),"bad off");
		static_assert((offsetof(INIReader,verbose)==0x41),"bad off");
		static_assert((offsetof(INIReader,code)==0x48),"bad off");
	};
};

//UDT: class UDPPacket @len=32
	//_Func: public void UDPPacket(const UDPPacket & r); @loc=static @len=104 @rva=2479904
	//_Func: public void UDPPacket(const UDPMessage & msg); @loc=static @len=158 @rva=2479744
	//_Func: public void UDPPacket(const std::vector<unsigned char,std::allocator<unsigned char> > & idata); @loc=static @len=107 @rva=2480016
	//_Func: public void UDPPacket(); @loc=static @len=61 @rva=2480128
	//_Func: public void ~UDPPacket(); @loc=static @len=36 @rva=2480192
	//_Data: this+0x0, Member, Type: class IPAddress, targetIP
	//_Func: public UDPPacket & operator=(const UDPPacket & r); @loc=static @len=76 @rva=2480240
	//_Func: public void writeString(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & st); @loc=static @len=210 @rva=2481520
	//_Func: public void writeString(const std::basic_string<char,std::char_traits<char>,std::allocator<char> > & st); @loc=static @len=201 @rva=2481312
	//_Func: public void writeStringANSI(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & st); @loc=static @len=93 @rva=2481744
	//_Func: public std::basic_string<char,std::char_traits<char>,std::allocator<char> > readString(); @loc=static @len=181 @rva=2480592
	//_Func: public std::basic_string<char,std::char_traits<char>,std::allocator<char> > readBigString(); @loc=optimized @len=0 @rva=0
	//_Func: public std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > readStringW(); @loc=static @len=209 @rva=2480784
	//_Func: public std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > readBigStringW(); @loc=static @len=209 @rva=2480368
	//_Func: public void write(void *  _arg0, int  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public void read(void *  _arg0, unsigned int  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public void seek(int  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public unsigned int getSize(); @loc=static @len=4 @rva=2480320
	//_Func: public void send(TCPSocket & sok); @loc=static @len=254 @rva=2481008
	//_Func: public void send(UDPSocket & sok); @loc=static @len=41 @rva=2481264
	//_Func: public bool isEOF(); @loc=static @len=18 @rva=2480336
	//_Func: public unsigned int getCurrentPos(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x10, Member, Type: unsigned char *, data
	//_Data: this+0x18, Member, Type: unsigned int, currentDataPos
	//_Data: this+0x1C, Member, Type: unsigned int, size
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class UDPPacket {
public:
	IPAddress targetIP;
	unsigned char * data;
	unsigned int currentDataPos;
	unsigned int size;
	inline UDPPacket() { }
	inline UDPPacket(const UDPPacket& other) = default;
	inline UDPPacket& operator=(const UDPPacket& other) = default;
	inline void ctor(const UDPPacket & r) { typedef void (UDPPacket::*_fpt)(const UDPPacket &); auto _f=xcast<_fpt>(_drva(2479904)); (this->*_f)(r); }
	inline void ctor(const UDPMessage & msg) { typedef void (UDPPacket::*_fpt)(const UDPMessage &); auto _f=xcast<_fpt>(_drva(2479744)); (this->*_f)(msg); }
	inline void ctor(const std::vector<unsigned char,std::allocator<unsigned char> > & idata) { typedef void (UDPPacket::*_fpt)(const std::vector<unsigned char,std::allocator<unsigned char> > &); auto _f=xcast<_fpt>(_drva(2480016)); (this->*_f)(idata); }
	inline void ctor() { typedef void (UDPPacket::*_fpt)(); auto _f=xcast<_fpt>(_drva(2480128)); (this->*_f)(); }
	inline void dtor() { typedef void (UDPPacket::*_fpt)(); auto _f=xcast<_fpt>(_drva(2480192)); (this->*_f)(); }
	inline void writeString(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & st) { typedef void (UDPPacket::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2481520)); return (this->*_f)(st); }
	inline void writeString(const std::basic_string<char,std::char_traits<char>,std::allocator<char> > & st) { typedef void (UDPPacket::*_fpt)(const std::basic_string<char,std::char_traits<char>,std::allocator<char> > &); auto _f=xcast<_fpt>(_drva(2481312)); return (this->*_f)(st); }
	inline void writeStringANSI(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & st) { typedef void (UDPPacket::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2481744)); return (this->*_f)(st); }
	inline std::basic_string<char,std::char_traits<char>,std::allocator<char> > readString() { typedef std::basic_string<char,std::char_traits<char>,std::allocator<char> > (UDPPacket::*_fpt)(); auto _f=xcast<_fpt>(_drva(2480592)); return (this->*_f)(); }
	inline std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > readStringW() { typedef std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > (UDPPacket::*_fpt)(); auto _f=xcast<_fpt>(_drva(2480784)); return (this->*_f)(); }
	inline std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > readBigStringW() { typedef std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > (UDPPacket::*_fpt)(); auto _f=xcast<_fpt>(_drva(2480368)); return (this->*_f)(); }
	inline unsigned int getSize() { typedef unsigned int (UDPPacket::*_fpt)(); auto _f=xcast<_fpt>(_drva(2480320)); return (this->*_f)(); }
	inline void send(TCPSocket & sok) { typedef void (UDPPacket::*_fpt)(TCPSocket &); auto _f=xcast<_fpt>(_drva(2481008)); return (this->*_f)(sok); }
	inline void send(UDPSocket & sok) { typedef void (UDPPacket::*_fpt)(UDPSocket &); auto _f=xcast<_fpt>(_drva(2481264)); return (this->*_f)(sok); }
	inline bool isEOF() { typedef bool (UDPPacket::*_fpt)(); auto _f=xcast<_fpt>(_drva(2480336)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(UDPPacket)==32),"bad size");
		static_assert((offsetof(UDPPacket,targetIP)==0x0),"bad off");
		static_assert((offsetof(UDPPacket,data)==0x10),"bad off");
		static_assert((offsetof(UDPPacket,currentDataPos)==0x18),"bad off");
		static_assert((offsetof(UDPPacket,size)==0x1C),"bad off");
	};
};

//UDT: class CameraDrivableManager @len=304 @vfcount=6
	//_Base: class GameObject @off=0 @len=88
	//_Func: public void CameraDrivableManager(const CameraDrivableManager &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void CameraDrivableManager(Sim * sim, CameraForward * camera); @loc=static @len=4927 @rva=805504
	//_Func: public void ~CameraDrivableManager(); @virtual vtpo=0 vfid=0 @loc=static @len=133 @rva=810432
	//_Data: this+0x58, Member, Type: enum DrivableCamera, currentMode
	//_Data: this+0x5C, Member, Type: struct ChaseCamData[0x2], chaseCamData
	//_Func: public void update(float deltaT); @virtual vtpo=0 vfid=1 @loc=static @len=363 @rva=813616
	//_Func: public void setCurrentCamera(int cameraIndex); @loc=static @len=9 @rva=813408
	//_Func: public bool nextMode(); @loc=static @len=22 @rva=812944
	//_Func: public const vec3f & getChaseOffset(); @loc=optimized @len=0 @rva=0
	//_Func: public const std::vector<DrivableCameraDef,std::allocator<DrivableCameraDef> > & getDrivableCameraPositions(); @loc=optimized @len=0 @rva=0
	//_Func: public void setDrivableCameraDefAt(int index, DrivableCameraDef def); @loc=static @len=55 @rva=813424
	//_Func: public int getChaseIndex(); @loc=optimized @len=0 @rva=0
	//_Func: public int getDrivableCount(); @loc=optimized @len=0 @rva=0
	//_Func: public bool shouldUseInternalSounds(); @loc=static @len=126 @rva=813488
	//_Data: this+0x78, Member, Type: class Sim *, sim
	//_Data: this+0x80, Member, Type: class CameraForward *, camera
	//_Data: this+0x88, Member, Type: class std::vector<DrivableCameraDef,std::allocator<DrivableCameraDef> >, drivableCameraPositions
	//_Data: this+0xA0, Member, Type: class mat44f, cameraMatrix
	//_Data: this+0xE0, Member, Type: class vec3f, currentOffset
	//_Data: this+0xF0, Member, Type: class std::vector<vec3f,std::allocator<vec3f> >, lookBackPoints
	//_Data: this+0x108, Member, Type: bool, isWorldAligned
	//_Data: this+0x10C, Member, Type: float, rotationChase
	//_Data: this+0x110, Member, Type: float, rotationDegrees
	//_Data: this+0x114, Member, Type: float, rotationSpeed
	//_Data: this+0x118, Member, Type: float, rotationAnimation
	//_Data: this+0x11C, Member, Type: float, accGXMul
	//_Data: this+0x120, Member, Type: float, accGZMul
	//_Data: this+0x124, Member, Type: float, chaseCamFilter
	//_Data: this+0x128, Member, Type: int, chaseIndex
	//_Func: private void updateChase(float dt); @loc=static @len=2603 @rva=815392
	//_Func: private void updateBumper(float dt); @loc=static @len=813 @rva=814576
	//_Func: private void updateBonnet(float dt); @loc=static @len=585 @rva=813984
	//_Func: private void updateDash(float dt); @loc=static @len=649 @rva=818000
	//_Func: private void updateLook(float deltaT); @loc=static @len=550 @rva=818656
	//_Func: private void lookBack(); @loc=static @len=290 @rva=812640
	//_Func: private void initChaseCamFromINI(); @loc=static @len=1184 @rva=811456
	//_Func: public CameraDrivableManager & operator=(const CameraDrivableManager &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class CameraDrivableManager : public GameObject {
public:
	DrivableCamera currentMode;
	ChaseCamData chaseCamData[2];
	Sim * sim;
	CameraForward * camera;
	std::vector<DrivableCameraDef,std::allocator<DrivableCameraDef> > drivableCameraPositions;
	mat44f cameraMatrix;
	vec3f currentOffset;
	std::vector<vec3f,std::allocator<vec3f> > lookBackPoints;
	bool isWorldAligned;
	float rotationChase;
	float rotationDegrees;
	float rotationSpeed;
	float rotationAnimation;
	float accGXMul;
	float accGZMul;
	float chaseCamFilter;
	int chaseIndex;
	inline CameraDrivableManager() { }
	inline CameraDrivableManager(const CameraDrivableManager& other) = default;
	inline CameraDrivableManager& operator=(const CameraDrivableManager& other) = default;
	inline void ctor(Sim * sim, CameraForward * camera) { typedef void (CameraDrivableManager::*_fpt)(Sim *, CameraForward *); auto _f=xcast<_fpt>(_drva(805504)); (this->*_f)(sim, camera); }
	virtual ~CameraDrivableManager();
	inline void dtor() { typedef void (CameraDrivableManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(810432)); (this->*_f)(); }
	virtual void update_vf1(float deltaT);
	inline void update_impl(float deltaT) { typedef void (CameraDrivableManager::*_fpt)(float); auto _f=xcast<_fpt>(_drva(813616)); return (this->*_f)(deltaT); }
	inline void update(float deltaT) { typedef void (CameraDrivableManager::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(deltaT); }
	inline void setCurrentCamera(int cameraIndex) { typedef void (CameraDrivableManager::*_fpt)(int); auto _f=xcast<_fpt>(_drva(813408)); return (this->*_f)(cameraIndex); }
	inline bool nextMode() { typedef bool (CameraDrivableManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(812944)); return (this->*_f)(); }
	inline void setDrivableCameraDefAt(int index, DrivableCameraDef def) { typedef void (CameraDrivableManager::*_fpt)(int, DrivableCameraDef); auto _f=xcast<_fpt>(_drva(813424)); return (this->*_f)(index, def); }
	inline bool shouldUseInternalSounds() { typedef bool (CameraDrivableManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(813488)); return (this->*_f)(); }
	inline void updateChase(float dt) { typedef void (CameraDrivableManager::*_fpt)(float); auto _f=xcast<_fpt>(_drva(815392)); return (this->*_f)(dt); }
	inline void updateBumper(float dt) { typedef void (CameraDrivableManager::*_fpt)(float); auto _f=xcast<_fpt>(_drva(814576)); return (this->*_f)(dt); }
	inline void updateBonnet(float dt) { typedef void (CameraDrivableManager::*_fpt)(float); auto _f=xcast<_fpt>(_drva(813984)); return (this->*_f)(dt); }
	inline void updateDash(float dt) { typedef void (CameraDrivableManager::*_fpt)(float); auto _f=xcast<_fpt>(_drva(818000)); return (this->*_f)(dt); }
	inline void updateLook(float deltaT) { typedef void (CameraDrivableManager::*_fpt)(float); auto _f=xcast<_fpt>(_drva(818656)); return (this->*_f)(deltaT); }
	inline void lookBack() { typedef void (CameraDrivableManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(812640)); return (this->*_f)(); }
	inline void initChaseCamFromINI() { typedef void (CameraDrivableManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(811456)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(CameraDrivableManager)==304),"bad size");
		static_assert((offsetof(CameraDrivableManager,currentMode)==0x58),"bad off");
		static_assert((offsetof(CameraDrivableManager,chaseCamData)==0x5C),"bad off");
		static_assert((offsetof(CameraDrivableManager,sim)==0x78),"bad off");
		static_assert((offsetof(CameraDrivableManager,camera)==0x80),"bad off");
		static_assert((offsetof(CameraDrivableManager,drivableCameraPositions)==0x88),"bad off");
		static_assert((offsetof(CameraDrivableManager,cameraMatrix)==0xA0),"bad off");
		static_assert((offsetof(CameraDrivableManager,currentOffset)==0xE0),"bad off");
		static_assert((offsetof(CameraDrivableManager,lookBackPoints)==0xF0),"bad off");
		static_assert((offsetof(CameraDrivableManager,isWorldAligned)==0x108),"bad off");
		static_assert((offsetof(CameraDrivableManager,rotationChase)==0x10C),"bad off");
		static_assert((offsetof(CameraDrivableManager,rotationDegrees)==0x110),"bad off");
		static_assert((offsetof(CameraDrivableManager,rotationSpeed)==0x114),"bad off");
		static_assert((offsetof(CameraDrivableManager,rotationAnimation)==0x118),"bad off");
		static_assert((offsetof(CameraDrivableManager,accGXMul)==0x11C),"bad off");
		static_assert((offsetof(CameraDrivableManager,accGZMul)==0x120),"bad off");
		static_assert((offsetof(CameraDrivableManager,chaseCamFilter)==0x124),"bad off");
		static_assert((offsetof(CameraDrivableManager,chaseIndex)==0x128),"bad off");
	};
};

//UDT: class IPhysicsCore @len=8 @vfcount=21
	//_VTable: 
	//_Func: public void resetCollisions(); @intro @pure @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Func: public void initMultithreading(); @intro @pure @virtual vtpo=0 vfid=1 @loc=optimized @len=0 @rva=0
	//_Func: public void step(float  _arg0); @intro @pure @virtual vtpo=0 vfid=2 @loc=optimized @len=0 @rva=0
	//_Func: public IRigidBody * createRigidBody(); @intro @pure @virtual vtpo=0 vfid=3 @loc=optimized @len=0 @rva=0
	//_Func: public void release(); @intro @pure @virtual vtpo=0 vfid=4 @loc=optimized @len=0 @rva=0
	//_Func: public IJoint * createDistanceJoint(IRigidBody *  _arg0, IRigidBody *  _arg1, const vec3f &  _arg2, const vec3f &  _arg3); @intro @pure @virtual vtpo=0 vfid=5 @loc=optimized @len=0 @rva=0
	//_Func: public IJoint * createBumpJoint(IRigidBody *  _arg0, IRigidBody *  _arg1, const vec3f &  _arg2, float  _arg3, float  _arg4); @intro @pure @virtual vtpo=0 vfid=6 @loc=optimized @len=0 @rva=0
	//_Func: public ICollisionObject * createCollisionMesh(float *  _arg0, unsigned int  _arg1, unsigned short *  _arg2, int  _arg3, const mat44f &  _arg4, IRigidBody *  _arg5, unsigned long  _arg6, unsigned long  _arg7, unsigned int  _arg8); @intro @pure @virtual vtpo=0 vfid=7 @loc=optimized @len=0 @rva=0
	//_Func: public RayCastHit rayCast(const vec3f &  _arg0, const vec3f &  _arg1, float  _arg2); @intro @pure @virtual vtpo=0 vfid=8 @loc=optimized @len=0 @rva=0
	//_Func: public void setCollisionCallback(ICollisionCallback *  _arg0); @intro @pure @virtual vtpo=0 vfid=9 @loc=optimized @len=0 @rva=0
	//_Func: public void reseatDistanceJointLocal(IJoint *  _arg0, const vec3f &  _arg1, const vec3f &  _arg2); @intro @pure @virtual vtpo=0 vfid=10 @loc=optimized @len=0 @rva=0
	//_Func: public void reseatDistanceJointLength(IJoint *  _arg0, float  _arg1); @intro @pure @virtual vtpo=0 vfid=11 @loc=optimized @len=0 @rva=0
	//_Func: public void setRigidBodyIterations(int  _arg0); @intro @pure @virtual vtpo=0 vfid=12 @loc=optimized @len=0 @rva=0
	//_Func: public IJoint * createSliderJoint(IRigidBody *  _arg0, IRigidBody *  _arg1, const vec3f &  _arg2); @intro @pure @virtual vtpo=0 vfid=13 @loc=optimized @len=0 @rva=0
	//_Func: public void setSliderAxis(IJoint *  _arg0, const vec3f &  _arg1, const vec3f &  _arg2); @intro @pure @virtual vtpo=0 vfid=14 @loc=optimized @len=0 @rva=0
	//_Func: public IJoint * createBallJoint(IRigidBody *  _arg0, IRigidBody *  _arg1, const vec3f &  _arg2); @intro @pure @virtual vtpo=0 vfid=15 @loc=optimized @len=0 @rva=0
	//_Func: public IJoint * createFixedJoint(IRigidBody *  _arg0, IRigidBody *  _arg1); @intro @pure @virtual vtpo=0 vfid=16 @loc=optimized @len=0 @rva=0
	//_Func: public IRayCaster * createRayCaster(float  _arg0); @intro @pure @virtual vtpo=0 vfid=17 @loc=optimized @len=0 @rva=0
	//_Func: public CoreCPUTimes getCoreCPUTimes(); @intro @pure @virtual vtpo=0 vfid=18 @loc=optimized @len=0 @rva=0
	//_Func: public void setNoCollisionSteps(int  _arg0); @intro @pure @virtual vtpo=0 vfid=19 @loc=optimized @len=0 @rva=0
	//_Func: protected void ~IPhysicsCore(); @intro @virtual vtpo=0 vfid=20 @loc=static @len=11 @rva=2931728
	//_Func: public void IPhysicsCore(const IPhysicsCore &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void IPhysicsCore(); @loc=optimized @len=0 @rva=0
	//_Func: public IPhysicsCore & operator=(const IPhysicsCore &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: protected void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=20 @loc=optimized @len=0 @rva=0
//UDT;

class IPhysicsCore {
public:
	inline IPhysicsCore() { }
	inline IPhysicsCore(const IPhysicsCore& other) = default;
	inline IPhysicsCore& operator=(const IPhysicsCore& other) = default;
	virtual void resetCollisions_vf0() = 0;
	inline void resetCollisions() { typedef void (IPhysicsCore::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 0)); return (this->*_f)(); }
	virtual void initMultithreading_vf1() = 0;
	inline void initMultithreading() { typedef void (IPhysicsCore::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(); }
	virtual void step_vf2(float  _arg0) = 0;
	inline void step(float  _arg0) { typedef void (IPhysicsCore::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)( _arg0); }
	virtual IRigidBody * createRigidBody_vf3() = 0;
	inline IRigidBody * createRigidBody() { typedef IRigidBody * (IPhysicsCore::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(); }
	virtual void release_vf4() = 0;
	inline void release() { typedef void (IPhysicsCore::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 4)); return (this->*_f)(); }
	virtual IJoint * createDistanceJoint_vf5(IRigidBody *  _arg0, IRigidBody *  _arg1, const vec3f &  _arg2, const vec3f &  _arg3) = 0;
	inline IJoint * createDistanceJoint(IRigidBody *  _arg0, IRigidBody *  _arg1, const vec3f &  _arg2, const vec3f &  _arg3) { typedef IJoint * (IPhysicsCore::*_fpt)(IRigidBody *, IRigidBody *, const vec3f &, const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 5)); return (this->*_f)( _arg0,  _arg1,  _arg2,  _arg3); }
	virtual IJoint * createBumpJoint_vf6(IRigidBody *  _arg0, IRigidBody *  _arg1, const vec3f &  _arg2, float  _arg3, float  _arg4) = 0;
	inline IJoint * createBumpJoint(IRigidBody *  _arg0, IRigidBody *  _arg1, const vec3f &  _arg2, float  _arg3, float  _arg4) { typedef IJoint * (IPhysicsCore::*_fpt)(IRigidBody *, IRigidBody *, const vec3f &, float, float); auto _f=xcast<_fpt>(get_vfp(this, 6)); return (this->*_f)( _arg0,  _arg1,  _arg2,  _arg3,  _arg4); }
	virtual ICollisionObject * createCollisionMesh_vf7(float *  _arg0, unsigned int  _arg1, unsigned short *  _arg2, int  _arg3, const mat44f &  _arg4, IRigidBody *  _arg5, unsigned long  _arg6, unsigned long  _arg7, unsigned int  _arg8) = 0;
	inline ICollisionObject * createCollisionMesh(float *  _arg0, unsigned int  _arg1, unsigned short *  _arg2, int  _arg3, const mat44f &  _arg4, IRigidBody *  _arg5, unsigned long  _arg6, unsigned long  _arg7, unsigned int  _arg8) { typedef ICollisionObject * (IPhysicsCore::*_fpt)(float *, unsigned int, unsigned short *, int, const mat44f &, IRigidBody *, unsigned long, unsigned long, unsigned int); auto _f=xcast<_fpt>(get_vfp(this, 7)); return (this->*_f)( _arg0,  _arg1,  _arg2,  _arg3,  _arg4,  _arg5,  _arg6,  _arg7,  _arg8); }
	virtual RayCastHit rayCast_vf8(const vec3f &  _arg0, const vec3f &  _arg1, float  _arg2) = 0;
	inline RayCastHit rayCast(const vec3f &  _arg0, const vec3f &  _arg1, float  _arg2) { typedef RayCastHit (IPhysicsCore::*_fpt)(const vec3f &, const vec3f &, float); auto _f=xcast<_fpt>(get_vfp(this, 8)); return (this->*_f)( _arg0,  _arg1,  _arg2); }
	virtual void setCollisionCallback_vf9(ICollisionCallback *  _arg0) = 0;
	inline void setCollisionCallback(ICollisionCallback *  _arg0) { typedef void (IPhysicsCore::*_fpt)(ICollisionCallback *); auto _f=xcast<_fpt>(get_vfp(this, 9)); return (this->*_f)( _arg0); }
	virtual void reseatDistanceJointLocal_vf10(IJoint *  _arg0, const vec3f &  _arg1, const vec3f &  _arg2) = 0;
	inline void reseatDistanceJointLocal(IJoint *  _arg0, const vec3f &  _arg1, const vec3f &  _arg2) { typedef void (IPhysicsCore::*_fpt)(IJoint *, const vec3f &, const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 10)); return (this->*_f)( _arg0,  _arg1,  _arg2); }
	virtual void reseatDistanceJointLength_vf11(IJoint *  _arg0, float  _arg1) = 0;
	inline void reseatDistanceJointLength(IJoint *  _arg0, float  _arg1) { typedef void (IPhysicsCore::*_fpt)(IJoint *, float); auto _f=xcast<_fpt>(get_vfp(this, 11)); return (this->*_f)( _arg0,  _arg1); }
	virtual void setRigidBodyIterations_vf12(int  _arg0) = 0;
	inline void setRigidBodyIterations(int  _arg0) { typedef void (IPhysicsCore::*_fpt)(int); auto _f=xcast<_fpt>(get_vfp(this, 12)); return (this->*_f)( _arg0); }
	virtual IJoint * createSliderJoint_vf13(IRigidBody *  _arg0, IRigidBody *  _arg1, const vec3f &  _arg2) = 0;
	inline IJoint * createSliderJoint(IRigidBody *  _arg0, IRigidBody *  _arg1, const vec3f &  _arg2) { typedef IJoint * (IPhysicsCore::*_fpt)(IRigidBody *, IRigidBody *, const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 13)); return (this->*_f)( _arg0,  _arg1,  _arg2); }
	virtual void setSliderAxis_vf14(IJoint *  _arg0, const vec3f &  _arg1, const vec3f &  _arg2) = 0;
	inline void setSliderAxis(IJoint *  _arg0, const vec3f &  _arg1, const vec3f &  _arg2) { typedef void (IPhysicsCore::*_fpt)(IJoint *, const vec3f &, const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 14)); return (this->*_f)( _arg0,  _arg1,  _arg2); }
	virtual IJoint * createBallJoint_vf15(IRigidBody *  _arg0, IRigidBody *  _arg1, const vec3f &  _arg2) = 0;
	inline IJoint * createBallJoint(IRigidBody *  _arg0, IRigidBody *  _arg1, const vec3f &  _arg2) { typedef IJoint * (IPhysicsCore::*_fpt)(IRigidBody *, IRigidBody *, const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 15)); return (this->*_f)( _arg0,  _arg1,  _arg2); }
	virtual IJoint * createFixedJoint_vf16(IRigidBody *  _arg0, IRigidBody *  _arg1) = 0;
	inline IJoint * createFixedJoint(IRigidBody *  _arg0, IRigidBody *  _arg1) { typedef IJoint * (IPhysicsCore::*_fpt)(IRigidBody *, IRigidBody *); auto _f=xcast<_fpt>(get_vfp(this, 16)); return (this->*_f)( _arg0,  _arg1); }
	virtual IRayCaster * createRayCaster_vf17(float  _arg0) = 0;
	inline IRayCaster * createRayCaster(float  _arg0) { typedef IRayCaster * (IPhysicsCore::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 17)); return (this->*_f)( _arg0); }
	virtual CoreCPUTimes getCoreCPUTimes_vf18() = 0;
	inline CoreCPUTimes getCoreCPUTimes() { typedef CoreCPUTimes (IPhysicsCore::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 18)); return (this->*_f)(); }
	virtual void setNoCollisionSteps_vf19(int  _arg0) = 0;
	inline void setNoCollisionSteps(int  _arg0) { typedef void (IPhysicsCore::*_fpt)(int); auto _f=xcast<_fpt>(get_vfp(this, 19)); return (this->*_f)( _arg0); }
	virtual ~IPhysicsCore();
	inline void dtor() { typedef void (IPhysicsCore::*_fpt)(); auto _f=xcast<_fpt>(_drva(2931728)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(IPhysicsCore)==8),"bad size");
	};
};

//UDT: struct CarPhysicsState @len=2928
	//_Func: public void CarPhysicsState(const CarPhysicsState & __that); @loc=static @len=2617 @rva=1179376
	//_Func: public void CarPhysicsState(); @loc=static @len=1570 @rva=781920
	//_Data: this+0x0, Member, Type: unsigned char, physicsGUID
	//_Data: this+0x4, Member, Type: class mat44f, worldMatrix
	//_Data: this+0x44, Member, Type: class mat44f[0x4], suspensionMatrix
	//_Data: this+0x144, Member, Type: class mat44f[0x4], tyreMatrix
	//_Data: this+0x244, Member, Type: float, engineRPM
	//_Data: this+0x248, Member, Type: bool, isEngineLimiterOn
	//_Data: this+0x24C, Member, Type: float[0x4], wheelAngularSpeed
	//_Data: this+0x25C, Member, Type: float, steer
	//_Data: this+0x260, Member, Type: float, gas
	//_Data: this+0x264, Member, Type: float, brake
	//_Data: this+0x268, Member, Type: float, clutch
	//_Data: this+0x26C, Member, Type: int, gear
	//_Data: this+0x270, Member, Type: class Speed, speed
	//_Data: this+0x274, Member, Type: class vec3f, velocity
	//_Data: this+0x280, Member, Type: class vec3f, localVelocity
	//_Data: this+0x28C, Member, Type: class vec3f, localAngularVelocity
	//_Data: this+0x298, Member, Type: class vec3f, angularVelocity
	//_Data: this+0x2A4, Member, Type: float[0x4], slipAngle
	//_Data: this+0x2B4, Member, Type: float[0x4], slipRatio
	//_Data: this+0x2C4, Member, Type: float[0x4], tyreSlip
	//_Data: this+0x2D4, Member, Type: float[0x4], ndSlip
	//_Data: this+0x2E4, Member, Type: float[0x4], load
	//_Data: this+0x2F4, Member, Type: float[0x4], Dy
	//_Data: this+0x304, Member, Type: float[0x4], Mz
	//_Data: this+0x314, Member, Type: float[0x4], tyreDirtyLevel
	//_Data: this+0x328, Member, Type: struct SurfaceDef[0x4], tyreSurfaceDef
	//_Data: this+0x648, Member, Type: float, cgHeight
	//_Data: this+0x64C, Member, Type: class vec3f, accG
	//_Data: this+0x658, Member, Type: unsigned int, lapTime
	//_Data: this+0x65C, Member, Type: unsigned int, lastLap
	//_Data: this+0x660, Member, Type: unsigned int, bestLap
	//_Data: this+0x664, Member, Type: unsigned int, lapCount
	//_Data: this+0x668, Member, Type: float, lastFF_Pure
	//_Data: this+0x66C, Member, Type: float, lastFF_Final
	//_Data: this+0x670, Member, Type: struct SCarStateAero, aero
	//_Data: this+0x67C, Member, Type: class vec3f[0x4], tyreContactPoint
	//_Data: this+0x6AC, Member, Type: class vec3f[0x4], tyreContactNormal
	//_Data: this+0x6DC, Member, Type: float[0x4], camberRAD
	//_Data: this+0x6EC, Member, Type: float[0x4], tyreRadius
	//_Data: this+0x6FC, Member, Type: float[0x4], tyreLoadedRadius
	//_Data: this+0x70C, Member, Type: float[0x4], suspensionTravel
	//_Data: this+0x71C, Member, Type: float, normalizedSplinePosition
	//_Data: this+0x720, Member, Type: float, driftPoints
	//_Data: this+0x724, Member, Type: float, instantDrift
	//_Data: this+0x728, Member, Type: bool, isDriftValid
	//_Data: this+0x72C, Member, Type: int, driftComboCounter
	//_Data: this+0x730, Member, Type: bool, driftBonusOn
	//_Data: this+0x734, Member, Type: float, drivetrainSpeed
	//_Data: this+0x738, Member, Type: float, turboBoost
	//_Data: this+0x73C, Member, Type: float, performanceMeter
	//_Data: this+0x740, Member, Type: float, performanceMeterSpeedDiffMS
	//_Data: this+0x744, Member, Type: bool, isGearGrinding
	//_Data: this+0x748, Member, Type: float, bodyWorkVolume
	//_Data: this+0x74C, Member, Type: float[0x4], tyreVirtualKM
	//_Data: this+0x75C, Member, Type: float[0x5], damageZoneLevel
	//_Data: this+0x770, Member, Type: int, limiterRPM
	//_Data: this+0x774, Member, Type: class plane4f, groundPlane
	//_Data: this+0x788, Member, Type: double, timeStamp
	//_Data: this+0x790, Member, Type: float, airDensity
	//_Data: this+0x794, Member, Type: float, fuel
	//_Data: this+0x798, Member, Type: float, fuelLaps
	//_Data: this+0x79C, Member, Type: float[0x2], rideHeight
	//_Data: this+0x7A4, Member, Type: bool, isRetired
	//_Data: this+0x7A8, Member, Type: float, engineLifeLeft
	//_Data: this+0x7AC, Member, Type: float, turboBov
	//_Data: this+0x7B0, Member, Type: float, turboBoostLevel
	//_Data: this+0x7B4, Member, Type: float[0x4], tyreGrain
	//_Data: this+0x7C4, Member, Type: float[0x4], tyreBlister
	//_Data: this+0x7D4, Member, Type: struct DriverActionsState, actionsState
	//_Data: this+0x7D8, Member, Type: enum CarSetupState, setupState
	//_Data: this+0x7DC, Member, Type: float[0x4], tyreInflation
	//_Data: this+0x7EC, Member, Type: float, kersCharge
	//_Data: this+0x7F0, Member, Type: float, kersInput
	//_Data: this+0x7F4, Member, Type: float, gearRpmWindow
	//_Data: this+0x7F8, Member, Type: float[0x4], susDamage
	//_Data: this+0x808, Member, Type: float[0x4], tyreFlatSpot
	//_Data: this+0x818, Member, Type: float, water
	//_Data: this+0x81C, Member, Type: struct TyreThermalState[0x4], tyreThermalStates
	//_Data: this+0xB1C, Member, Type: float[0x4], discTemps
	//_Data: this+0xB2C, Member, Type: float[0x4], wear
	//_Data: this+0xB3C, Member, Type: float[0x4], wearMult
	//_Data: this+0xB4C, Member, Type: float, lockControlsTime
	//_Data: this+0xB50, Member, Type: float, kersCurrentKJ
	//_Data: this+0xB54, Member, Type: bool, kersIsCharging
	//_Data: this+0xB58, Member, Type: unsigned int, statusBytes
	//_Data: this+0xB5C, Member, Type: unsigned char, p2pStatus
	//_Data: this+0xB5D, Member, Type: unsigned char, p2pActivations
	//_Data: this+0xB60, Member, Type: float, antiSquat
	//_Data: this+0xB64, Member, Type: float[0x2], caster
	//_Func: public void ~CarPhysicsState(); @loc=static @len=12 @rva=783504
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct CarPhysicsState {
public:
	unsigned char physicsGUID;
	mat44f worldMatrix;
	mat44f suspensionMatrix[4];
	mat44f tyreMatrix[4];
	float engineRPM;
	bool isEngineLimiterOn;
	float wheelAngularSpeed[4];
	float steer;
	float gas;
	float brake;
	float clutch;
	int gear;
	Speed speed;
	vec3f velocity;
	vec3f localVelocity;
	vec3f localAngularVelocity;
	vec3f angularVelocity;
	float slipAngle[4];
	float slipRatio[4];
	float tyreSlip[4];
	float ndSlip[4];
	float load[4];
	float Dy[4];
	float Mz[4];
	float tyreDirtyLevel[4];
	SurfaceDef tyreSurfaceDef[4];
	float cgHeight;
	vec3f accG;
	unsigned int lapTime;
	unsigned int lastLap;
	unsigned int bestLap;
	unsigned int lapCount;
	float lastFF_Pure;
	float lastFF_Final;
	SCarStateAero aero;
	vec3f tyreContactPoint[4];
	vec3f tyreContactNormal[4];
	float camberRAD[4];
	float tyreRadius[4];
	float tyreLoadedRadius[4];
	float suspensionTravel[4];
	float normalizedSplinePosition;
	float driftPoints;
	float instantDrift;
	bool isDriftValid;
	int driftComboCounter;
	bool driftBonusOn;
	float drivetrainSpeed;
	float turboBoost;
	float performanceMeter;
	float performanceMeterSpeedDiffMS;
	bool isGearGrinding;
	float bodyWorkVolume;
	float tyreVirtualKM[4];
	float damageZoneLevel[5];
	int limiterRPM;
	plane4f groundPlane;
	double timeStamp;
	float airDensity;
	float fuel;
	float fuelLaps;
	float rideHeight[2];
	bool isRetired;
	float engineLifeLeft;
	float turboBov;
	float turboBoostLevel;
	float tyreGrain[4];
	float tyreBlister[4];
	DriverActionsState actionsState;
	CarSetupState setupState;
	float tyreInflation[4];
	float kersCharge;
	float kersInput;
	float gearRpmWindow;
	float susDamage[4];
	float tyreFlatSpot[4];
	float water;
	TyreThermalState tyreThermalStates[4];
	float discTemps[4];
	float wear[4];
	float wearMult[4];
	float lockControlsTime;
	float kersCurrentKJ;
	bool kersIsCharging;
	unsigned int statusBytes;
	unsigned char p2pStatus;
	unsigned char p2pActivations;
	float antiSquat;
	float caster[2];
	inline CarPhysicsState() { }
	inline CarPhysicsState(const CarPhysicsState& other) = default;
	inline CarPhysicsState& operator=(const CarPhysicsState& other) = default;
	inline void ctor(const CarPhysicsState & __that) { typedef void (CarPhysicsState::*_fpt)(const CarPhysicsState &); auto _f=xcast<_fpt>(_drva(1179376)); (this->*_f)(__that); }
	inline void ctor() { typedef void (CarPhysicsState::*_fpt)(); auto _f=xcast<_fpt>(_drva(781920)); (this->*_f)(); }
	inline void dtor() { typedef void (CarPhysicsState::*_fpt)(); auto _f=xcast<_fpt>(_drva(783504)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(CarPhysicsState)==2928),"bad size");
		static_assert((offsetof(CarPhysicsState,physicsGUID)==0x0),"bad off");
		static_assert((offsetof(CarPhysicsState,worldMatrix)==0x4),"bad off");
		static_assert((offsetof(CarPhysicsState,suspensionMatrix)==0x44),"bad off");
		static_assert((offsetof(CarPhysicsState,tyreMatrix)==0x144),"bad off");
		static_assert((offsetof(CarPhysicsState,engineRPM)==0x244),"bad off");
		static_assert((offsetof(CarPhysicsState,isEngineLimiterOn)==0x248),"bad off");
		static_assert((offsetof(CarPhysicsState,wheelAngularSpeed)==0x24C),"bad off");
		static_assert((offsetof(CarPhysicsState,steer)==0x25C),"bad off");
		static_assert((offsetof(CarPhysicsState,gas)==0x260),"bad off");
		static_assert((offsetof(CarPhysicsState,brake)==0x264),"bad off");
		static_assert((offsetof(CarPhysicsState,clutch)==0x268),"bad off");
		static_assert((offsetof(CarPhysicsState,gear)==0x26C),"bad off");
		static_assert((offsetof(CarPhysicsState,speed)==0x270),"bad off");
		static_assert((offsetof(CarPhysicsState,velocity)==0x274),"bad off");
		static_assert((offsetof(CarPhysicsState,localVelocity)==0x280),"bad off");
		static_assert((offsetof(CarPhysicsState,localAngularVelocity)==0x28C),"bad off");
		static_assert((offsetof(CarPhysicsState,angularVelocity)==0x298),"bad off");
		static_assert((offsetof(CarPhysicsState,slipAngle)==0x2A4),"bad off");
		static_assert((offsetof(CarPhysicsState,slipRatio)==0x2B4),"bad off");
		static_assert((offsetof(CarPhysicsState,tyreSlip)==0x2C4),"bad off");
		static_assert((offsetof(CarPhysicsState,ndSlip)==0x2D4),"bad off");
		static_assert((offsetof(CarPhysicsState,load)==0x2E4),"bad off");
		static_assert((offsetof(CarPhysicsState,Dy)==0x2F4),"bad off");
		static_assert((offsetof(CarPhysicsState,Mz)==0x304),"bad off");
		static_assert((offsetof(CarPhysicsState,tyreDirtyLevel)==0x314),"bad off");
		static_assert((offsetof(CarPhysicsState,tyreSurfaceDef)==0x328),"bad off");
		static_assert((offsetof(CarPhysicsState,cgHeight)==0x648),"bad off");
		static_assert((offsetof(CarPhysicsState,accG)==0x64C),"bad off");
		static_assert((offsetof(CarPhysicsState,lapTime)==0x658),"bad off");
		static_assert((offsetof(CarPhysicsState,lastLap)==0x65C),"bad off");
		static_assert((offsetof(CarPhysicsState,bestLap)==0x660),"bad off");
		static_assert((offsetof(CarPhysicsState,lapCount)==0x664),"bad off");
		static_assert((offsetof(CarPhysicsState,lastFF_Pure)==0x668),"bad off");
		static_assert((offsetof(CarPhysicsState,lastFF_Final)==0x66C),"bad off");
		static_assert((offsetof(CarPhysicsState,aero)==0x670),"bad off");
		static_assert((offsetof(CarPhysicsState,tyreContactPoint)==0x67C),"bad off");
		static_assert((offsetof(CarPhysicsState,tyreContactNormal)==0x6AC),"bad off");
		static_assert((offsetof(CarPhysicsState,camberRAD)==0x6DC),"bad off");
		static_assert((offsetof(CarPhysicsState,tyreRadius)==0x6EC),"bad off");
		static_assert((offsetof(CarPhysicsState,tyreLoadedRadius)==0x6FC),"bad off");
		static_assert((offsetof(CarPhysicsState,suspensionTravel)==0x70C),"bad off");
		static_assert((offsetof(CarPhysicsState,normalizedSplinePosition)==0x71C),"bad off");
		static_assert((offsetof(CarPhysicsState,driftPoints)==0x720),"bad off");
		static_assert((offsetof(CarPhysicsState,instantDrift)==0x724),"bad off");
		static_assert((offsetof(CarPhysicsState,isDriftValid)==0x728),"bad off");
		static_assert((offsetof(CarPhysicsState,driftComboCounter)==0x72C),"bad off");
		static_assert((offsetof(CarPhysicsState,driftBonusOn)==0x730),"bad off");
		static_assert((offsetof(CarPhysicsState,drivetrainSpeed)==0x734),"bad off");
		static_assert((offsetof(CarPhysicsState,turboBoost)==0x738),"bad off");
		static_assert((offsetof(CarPhysicsState,performanceMeter)==0x73C),"bad off");
		static_assert((offsetof(CarPhysicsState,performanceMeterSpeedDiffMS)==0x740),"bad off");
		static_assert((offsetof(CarPhysicsState,isGearGrinding)==0x744),"bad off");
		static_assert((offsetof(CarPhysicsState,bodyWorkVolume)==0x748),"bad off");
		static_assert((offsetof(CarPhysicsState,tyreVirtualKM)==0x74C),"bad off");
		static_assert((offsetof(CarPhysicsState,damageZoneLevel)==0x75C),"bad off");
		static_assert((offsetof(CarPhysicsState,limiterRPM)==0x770),"bad off");
		static_assert((offsetof(CarPhysicsState,groundPlane)==0x774),"bad off");
		static_assert((offsetof(CarPhysicsState,timeStamp)==0x788),"bad off");
		static_assert((offsetof(CarPhysicsState,airDensity)==0x790),"bad off");
		static_assert((offsetof(CarPhysicsState,fuel)==0x794),"bad off");
		static_assert((offsetof(CarPhysicsState,fuelLaps)==0x798),"bad off");
		static_assert((offsetof(CarPhysicsState,rideHeight)==0x79C),"bad off");
		static_assert((offsetof(CarPhysicsState,isRetired)==0x7A4),"bad off");
		static_assert((offsetof(CarPhysicsState,engineLifeLeft)==0x7A8),"bad off");
		static_assert((offsetof(CarPhysicsState,turboBov)==0x7AC),"bad off");
		static_assert((offsetof(CarPhysicsState,turboBoostLevel)==0x7B0),"bad off");
		static_assert((offsetof(CarPhysicsState,tyreGrain)==0x7B4),"bad off");
		static_assert((offsetof(CarPhysicsState,tyreBlister)==0x7C4),"bad off");
		static_assert((offsetof(CarPhysicsState,actionsState)==0x7D4),"bad off");
		static_assert((offsetof(CarPhysicsState,setupState)==0x7D8),"bad off");
		static_assert((offsetof(CarPhysicsState,tyreInflation)==0x7DC),"bad off");
		static_assert((offsetof(CarPhysicsState,kersCharge)==0x7EC),"bad off");
		static_assert((offsetof(CarPhysicsState,kersInput)==0x7F0),"bad off");
		static_assert((offsetof(CarPhysicsState,gearRpmWindow)==0x7F4),"bad off");
		static_assert((offsetof(CarPhysicsState,susDamage)==0x7F8),"bad off");
		static_assert((offsetof(CarPhysicsState,tyreFlatSpot)==0x808),"bad off");
		static_assert((offsetof(CarPhysicsState,water)==0x818),"bad off");
		static_assert((offsetof(CarPhysicsState,tyreThermalStates)==0x81C),"bad off");
		static_assert((offsetof(CarPhysicsState,discTemps)==0xB1C),"bad off");
		static_assert((offsetof(CarPhysicsState,wear)==0xB2C),"bad off");
		static_assert((offsetof(CarPhysicsState,wearMult)==0xB3C),"bad off");
		static_assert((offsetof(CarPhysicsState,lockControlsTime)==0xB4C),"bad off");
		static_assert((offsetof(CarPhysicsState,kersCurrentKJ)==0xB50),"bad off");
		static_assert((offsetof(CarPhysicsState,kersIsCharging)==0xB54),"bad off");
		static_assert((offsetof(CarPhysicsState,statusBytes)==0xB58),"bad off");
		static_assert((offsetof(CarPhysicsState,p2pStatus)==0xB5C),"bad off");
		static_assert((offsetof(CarPhysicsState,p2pActivations)==0xB5D),"bad off");
		static_assert((offsetof(CarPhysicsState,antiSquat)==0xB60),"bad off");
		static_assert((offsetof(CarPhysicsState,caster)==0xB64),"bad off");
	};
};

//UDT: class CinematicFreeCamera @len=304 @vfcount=6
	//_Base: class GameObject @off=0 @len=88
	//_Func: public void CinematicFreeCamera(const CinematicFreeCamera &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void CinematicFreeCamera(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, Camera * aCamera, Game * aGame); @loc=static @len=378 @rva=442384
	//_Func: public void ~CinematicFreeCamera(); @virtual vtpo=0 vfid=0 @loc=static @len=97 @rva=442768
	//_Data: this+0x58, Member, Type: float, fov
	//_Data: this+0x5C, Member, Type: float, exposure
	//_Data: this+0x60, Member, Type: bool, ctrlLock
	//_Func: public float getMaxMultiplier(); @loc=optimized @len=0 @rva=0
	//_Func: public float getMinMultiplier(); @loc=optimized @len=0 @rva=0
	//_Func: public void update(float deltaT); @virtual vtpo=0 vfid=1 @loc=static @len=632 @rva=448896
	//_Func: public void setAudioDistanceScale(); @loc=static @len=27 @rva=448112
	//_Data: this+0x68, Member, Type: class Camera *, camera
	//_Func: protected void setMatrixMovementFromUserInput(mat44f & inputMatrix, float dt); @loc=static @len=199 @rva=448336
	//_Func: protected void setCameraParameterFromUserInput(float & aFov, float & aDofFactor, float deltaT); @loc=static @len=188 @rva=448144
	//_Data: this+0x70, Member, Type: float, moveSpeed
	//_Data: this+0x74, Member, Type: struct MovementDelays, delay
	//_Data: this+0x94, Member, Type: class Trigger, lockTrigger
	//_Data: this+0xA0, Member, Type: class Trigger, cinematicFeatureTrigger
	//_Data: this+0xAC, Member, Type: class Trigger, blurSwitch
	//_Data: this+0xB8, Member, Type: class CameraMouseControlBase, base
	//_Data: this+0xF8, Member, Type: float, movementDelay
	//_Data: this+0xFC, Member, Type: bool, useCinematicFeatures
	//_Data: this+0xFD, Member, Type: bool, lastMouseDown
	//_Data: this+0x100, Member, Type: struct tagPOINT, lastMousePoint
	//_Data: this+0x108, Member, Type: float, oldDeltaX
	//_Data: this+0x10C, Member, Type: float, oldDeltaY
	//_Data: this+0x110, Member, Type: float, mouseSpeed
	//_Data: this+0x114, Member, Type: float, mouseDelay
	//_Data: this+0x118, Member, Type: float, minMult
	//_Data: this+0x11C, Member, Type: float, maxMult
	//_Data: this+0x120, Member, Type: float, dofFactor
	//_Data: this+0x124, Member, Type: float, dofFocus
	//_Data: this+0x128, Member, Type: float, distanceScale
	//_Func: protected void loadSettingsFromINI(); @loc=static @len=1453 @rva=446304
	//_Func: protected void getKeyboardMovement(mat44f & matrix, float dt, float msp); @loc=static @len=1247 @rva=443776
	//_Func: protected void getMouseLook(mat44f & matrix, float dt, float speed); @loc=static @len=1277 @rva=445024
	//_Func: protected void getMouseLookYebis(mat44f &  _arg0, float  _arg1, float  _arg2); @loc=optimized @len=0 @rva=0
	//_Func: protected void standardMouseLook(float dt, float speed); @loc=static @len=342 @rva=448544
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class CinematicFreeCamera : public GameObject {
public:
	float fov;
	float exposure;
	bool ctrlLock;
	Camera * camera;
	float moveSpeed;
	MovementDelays delay;
	Trigger lockTrigger;
	Trigger cinematicFeatureTrigger;
	Trigger blurSwitch;
	CameraMouseControlBase base;
	float movementDelay;
	bool useCinematicFeatures;
	bool lastMouseDown;
	tagPOINT lastMousePoint;
	float oldDeltaX;
	float oldDeltaY;
	float mouseSpeed;
	float mouseDelay;
	float minMult;
	float maxMult;
	float dofFactor;
	float dofFocus;
	float distanceScale;
	inline CinematicFreeCamera() { }
	inline CinematicFreeCamera(const CinematicFreeCamera& other) = default;
	inline CinematicFreeCamera& operator=(const CinematicFreeCamera& other) = default;
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, Camera * aCamera, Game * aGame) { typedef void (CinematicFreeCamera::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, Camera *, Game *); auto _f=xcast<_fpt>(_drva(442384)); (this->*_f)(name, aCamera, aGame); }
	virtual ~CinematicFreeCamera();
	inline void dtor() { typedef void (CinematicFreeCamera::*_fpt)(); auto _f=xcast<_fpt>(_drva(442768)); (this->*_f)(); }
	virtual void update_vf1(float deltaT);
	inline void update_impl(float deltaT) { typedef void (CinematicFreeCamera::*_fpt)(float); auto _f=xcast<_fpt>(_drva(448896)); return (this->*_f)(deltaT); }
	inline void update(float deltaT) { typedef void (CinematicFreeCamera::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(deltaT); }
	inline void setAudioDistanceScale() { typedef void (CinematicFreeCamera::*_fpt)(); auto _f=xcast<_fpt>(_drva(448112)); return (this->*_f)(); }
	inline void setMatrixMovementFromUserInput(mat44f & inputMatrix, float dt) { typedef void (CinematicFreeCamera::*_fpt)(mat44f &, float); auto _f=xcast<_fpt>(_drva(448336)); return (this->*_f)(inputMatrix, dt); }
	inline void setCameraParameterFromUserInput(float & aFov, float & aDofFactor, float deltaT) { typedef void (CinematicFreeCamera::*_fpt)(float &, float &, float); auto _f=xcast<_fpt>(_drva(448144)); return (this->*_f)(aFov, aDofFactor, deltaT); }
	inline void loadSettingsFromINI() { typedef void (CinematicFreeCamera::*_fpt)(); auto _f=xcast<_fpt>(_drva(446304)); return (this->*_f)(); }
	inline void getKeyboardMovement(mat44f & matrix, float dt, float msp) { typedef void (CinematicFreeCamera::*_fpt)(mat44f &, float, float); auto _f=xcast<_fpt>(_drva(443776)); return (this->*_f)(matrix, dt, msp); }
	inline void getMouseLook(mat44f & matrix, float dt, float speed) { typedef void (CinematicFreeCamera::*_fpt)(mat44f &, float, float); auto _f=xcast<_fpt>(_drva(445024)); return (this->*_f)(matrix, dt, speed); }
	inline void standardMouseLook(float dt, float speed) { typedef void (CinematicFreeCamera::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(448544)); return (this->*_f)(dt, speed); }
	inline void _guard_obj() {
		static_assert((sizeof(CinematicFreeCamera)==304),"bad size");
		static_assert((offsetof(CinematicFreeCamera,fov)==0x58),"bad off");
		static_assert((offsetof(CinematicFreeCamera,exposure)==0x5C),"bad off");
		static_assert((offsetof(CinematicFreeCamera,ctrlLock)==0x60),"bad off");
		static_assert((offsetof(CinematicFreeCamera,camera)==0x68),"bad off");
		static_assert((offsetof(CinematicFreeCamera,moveSpeed)==0x70),"bad off");
		static_assert((offsetof(CinematicFreeCamera,delay)==0x74),"bad off");
		static_assert((offsetof(CinematicFreeCamera,lockTrigger)==0x94),"bad off");
		static_assert((offsetof(CinematicFreeCamera,cinematicFeatureTrigger)==0xA0),"bad off");
		static_assert((offsetof(CinematicFreeCamera,blurSwitch)==0xAC),"bad off");
		static_assert((offsetof(CinematicFreeCamera,base)==0xB8),"bad off");
		static_assert((offsetof(CinematicFreeCamera,movementDelay)==0xF8),"bad off");
		static_assert((offsetof(CinematicFreeCamera,useCinematicFeatures)==0xFC),"bad off");
		static_assert((offsetof(CinematicFreeCamera,lastMouseDown)==0xFD),"bad off");
		static_assert((offsetof(CinematicFreeCamera,lastMousePoint)==0x100),"bad off");
		static_assert((offsetof(CinematicFreeCamera,oldDeltaX)==0x108),"bad off");
		static_assert((offsetof(CinematicFreeCamera,oldDeltaY)==0x10C),"bad off");
		static_assert((offsetof(CinematicFreeCamera,mouseSpeed)==0x110),"bad off");
		static_assert((offsetof(CinematicFreeCamera,mouseDelay)==0x114),"bad off");
		static_assert((offsetof(CinematicFreeCamera,minMult)==0x118),"bad off");
		static_assert((offsetof(CinematicFreeCamera,maxMult)==0x11C),"bad off");
		static_assert((offsetof(CinematicFreeCamera,dofFactor)==0x120),"bad off");
		static_assert((offsetof(CinematicFreeCamera,dofFocus)==0x124),"bad off");
		static_assert((offsetof(CinematicFreeCamera,distanceScale)==0x128),"bad off");
	};
};

//UDT: class Node @len=224 @vfcount=11
	//_VTable: 
	//_Tag 17
	//_Tag 17
	//_Tag 17
	//_Tag 17
	//_Func: public void Node(const Node & node); @loc=static @len=329 @rva=2152896
	//_Func: public void Node(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & n); @loc=static @len=326 @rva=2153232
	//_Func: public void ~Node(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=237 @rva=2153568
	//_Data: this+0x8, Member, Type: class mat44f, matrix
	//_Data: this+0x48, Member, Type: class mat44f, matrixWS
	//_Data: this+0x88, Member, Type: bool, isWSIdentity
	//_Data: this+0x90, Member, Type: class std::vector<Node *,std::allocator<Node *> >, nodes
	//_Data: this+0xA8, Member, Type: class Node *, parent
	//_Data: this+0xB0, Member, Type: int, priority
	//_Data: this+0xB4, Member, Type: bool, needsMatrixWS
	//_Data: this+0xB8, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, name
	//_Func: public Node * getRootNode(); @loc=optimized @len=0 @rva=0
	//_Func: public void collapse(); @loc=optimized @len=0 @rva=0
	//_Func: public vec3f worldToLocal(const vec3f & pos); @loc=static @len=407 @rva=2156336
	//_Func: public vec3f worldToLocalNormal(const vec3f & pos); @loc=static @len=355 @rva=2156752
	//_Func: public vec3f localToWorld(const vec3f & pos); @loc=static @len=58 @rva=2155056
	//_Func: public vec3f localToWorldNormal(const vec3f &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public Node * getParent(); @loc=static @len=8 @rva=2154880
	//_Func: public void addChild(Node * n); @intro @virtual vtpo=0 vfid=1 @loc=static @len=66 @rva=2153856
	//_Func: public void compile(CompileContext * cc); @intro @virtual vtpo=0 vfid=2 @loc=static @len=110 @rva=2153936
	//_Func: public void render(RenderContext * rc); @intro @virtual vtpo=0 vfid=3 @loc=static @len=135 @rva=2155792
	//_Func: public void removeChild(Node * n); @intro @virtual vtpo=0 vfid=4 @loc=static @len=99 @rva=2155680
	//_Func: public Node * findChildByName(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & sname, bool recursive); @intro @virtual vtpo=0 vfid=5 @loc=static @len=268 @rva=2154048
	//_Func: public void findChildrenByName(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & nname, std::vector<Node *,std::allocator<Node *> > & result); @intro @virtual vtpo=0 vfid=6 @loc=static @len=254 @rva=2154320
	//_Func: public void findChildrenByPrefix(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & prefix, std::vector<Node *,std::allocator<Node *> > & result); @intro @virtual vtpo=0 vfid=7 @loc=static @len=302 @rva=2154576
	//_Func: public mat44f getWorldMatrix(); @intro @virtual vtpo=0 vfid=8 @loc=static @len=147 @rva=2154896
	//_Func: public void printTree(int ident); @intro @virtual vtpo=0 vfid=9 @loc=static @len=548 @rva=2155120
	//_Func: public void visit(std::function<bool __cdecl(Node *)> * onVisit, std::function<void __cdecl(Node *)> * onPostVisit); @loc=static @len=281 @rva=2156048
	//_Func: public void sortNodes(std::function<bool __cdecl(Node *,Node *)>  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public std::vector<Node *,std::allocator<Node *> > getNodesCopy(); @loc=optimized @len=0 @rva=0
	//_Func: public void renderAudio(); @intro @virtual vtpo=0 vfid=10 @loc=static @len=101 @rva=2155936
	//_Func: public void setActive(bool a); @loc=static @len=7 @rva=673008
	//_Func: public bool getActive(); @loc=static @len=8 @rva=418752
	//_Data: this+0xD8, Member, Type: bool, isActive
	//_Func: protected void fillHierarchy(std::vector<Node *,std::allocator<Node *> > &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public Node & operator=(const Node &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class Node {
public:
	mat44f matrix;
	mat44f matrixWS;
	bool isWSIdentity;
	std::vector<Node *,std::allocator<Node *> > nodes;
	Node * parent;
	int priority;
	bool needsMatrixWS;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > name;
	bool isActive;
	inline Node() { }
	inline Node(const Node& other) = default;
	inline Node& operator=(const Node& other) = default;
	inline void ctor(const Node & node) { typedef void (Node::*_fpt)(const Node &); auto _f=xcast<_fpt>(_drva(2152896)); (this->*_f)(node); }
	inline void ctor(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & n) { typedef void (Node::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2153232)); (this->*_f)(n); }
	virtual ~Node();
	inline void dtor() { typedef void (Node::*_fpt)(); auto _f=xcast<_fpt>(_drva(2153568)); (this->*_f)(); }
	inline vec3f worldToLocal(const vec3f & pos) { typedef vec3f (Node::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2156336)); return (this->*_f)(pos); }
	inline vec3f worldToLocalNormal(const vec3f & pos) { typedef vec3f (Node::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2156752)); return (this->*_f)(pos); }
	inline vec3f localToWorld(const vec3f & pos) { typedef vec3f (Node::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2155056)); return (this->*_f)(pos); }
	inline Node * getParent() { typedef Node * (Node::*_fpt)(); auto _f=xcast<_fpt>(_drva(2154880)); return (this->*_f)(); }
	virtual void addChild_vf1(Node * n);
	inline void addChild_impl(Node * n) { typedef void (Node::*_fpt)(Node *); auto _f=xcast<_fpt>(_drva(2153856)); return (this->*_f)(n); }
	inline void addChild(Node * n) { typedef void (Node::*_fpt)(Node *); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(n); }
	virtual void compile_vf2(CompileContext * cc);
	inline void compile_impl(CompileContext * cc) { typedef void (Node::*_fpt)(CompileContext *); auto _f=xcast<_fpt>(_drva(2153936)); return (this->*_f)(cc); }
	inline void compile(CompileContext * cc) { typedef void (Node::*_fpt)(CompileContext *); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)(cc); }
	virtual void render_vf3(RenderContext * rc);
	inline void render_impl(RenderContext * rc) { typedef void (Node::*_fpt)(RenderContext *); auto _f=xcast<_fpt>(_drva(2155792)); return (this->*_f)(rc); }
	inline void render(RenderContext * rc) { typedef void (Node::*_fpt)(RenderContext *); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(rc); }
	virtual void removeChild_vf4(Node * n);
	inline void removeChild_impl(Node * n) { typedef void (Node::*_fpt)(Node *); auto _f=xcast<_fpt>(_drva(2155680)); return (this->*_f)(n); }
	inline void removeChild(Node * n) { typedef void (Node::*_fpt)(Node *); auto _f=xcast<_fpt>(get_vfp(this, 4)); return (this->*_f)(n); }
	virtual Node * findChildByName_vf5(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & sname, bool recursive);
	inline Node * findChildByName_impl(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & sname, bool recursive) { typedef Node * (Node::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, bool); auto _f=xcast<_fpt>(_drva(2154048)); return (this->*_f)(sname, recursive); }
	inline Node * findChildByName(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & sname, bool recursive) { typedef Node * (Node::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, bool); auto _f=xcast<_fpt>(get_vfp(this, 5)); return (this->*_f)(sname, recursive); }
	virtual void findChildrenByName_vf6(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & nname, std::vector<Node *,std::allocator<Node *> > & result);
	inline void findChildrenByName_impl(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & nname, std::vector<Node *,std::allocator<Node *> > & result) { typedef void (Node::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, std::vector<Node *,std::allocator<Node *> > &); auto _f=xcast<_fpt>(_drva(2154320)); return (this->*_f)(nname, result); }
	inline void findChildrenByName(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & nname, std::vector<Node *,std::allocator<Node *> > & result) { typedef void (Node::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, std::vector<Node *,std::allocator<Node *> > &); auto _f=xcast<_fpt>(get_vfp(this, 6)); return (this->*_f)(nname, result); }
	virtual void findChildrenByPrefix_vf7(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & prefix, std::vector<Node *,std::allocator<Node *> > & result);
	inline void findChildrenByPrefix_impl(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & prefix, std::vector<Node *,std::allocator<Node *> > & result) { typedef void (Node::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, std::vector<Node *,std::allocator<Node *> > &); auto _f=xcast<_fpt>(_drva(2154576)); return (this->*_f)(prefix, result); }
	inline void findChildrenByPrefix(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & prefix, std::vector<Node *,std::allocator<Node *> > & result) { typedef void (Node::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, std::vector<Node *,std::allocator<Node *> > &); auto _f=xcast<_fpt>(get_vfp(this, 7)); return (this->*_f)(prefix, result); }
	virtual mat44f getWorldMatrix_vf8();
	inline mat44f getWorldMatrix_impl() { typedef mat44f (Node::*_fpt)(); auto _f=xcast<_fpt>(_drva(2154896)); return (this->*_f)(); }
	inline mat44f getWorldMatrix() { typedef mat44f (Node::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 8)); return (this->*_f)(); }
	virtual void printTree_vf9(int ident);
	inline void printTree_impl(int ident) { typedef void (Node::*_fpt)(int); auto _f=xcast<_fpt>(_drva(2155120)); return (this->*_f)(ident); }
	inline void printTree(int ident) { typedef void (Node::*_fpt)(int); auto _f=xcast<_fpt>(get_vfp(this, 9)); return (this->*_f)(ident); }
	inline void visit(std::function<bool __cdecl(Node *)> * onVisit, std::function<void __cdecl(Node *)> * onPostVisit) { typedef void (Node::*_fpt)(std::function<bool __cdecl(Node *)> *, std::function<void __cdecl(Node *)> *); auto _f=xcast<_fpt>(_drva(2156048)); return (this->*_f)(onVisit, onPostVisit); }
	virtual void renderAudio_vf10();
	inline void renderAudio_impl() { typedef void (Node::*_fpt)(); auto _f=xcast<_fpt>(_drva(2155936)); return (this->*_f)(); }
	inline void renderAudio() { typedef void (Node::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 10)); return (this->*_f)(); }
	inline void setActive(bool a) { typedef void (Node::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(673008)); return (this->*_f)(a); }
	inline bool getActive() { typedef bool (Node::*_fpt)(); auto _f=xcast<_fpt>(_drva(418752)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(Node)==224),"bad size");
		static_assert((offsetof(Node,matrix)==0x8),"bad off");
		static_assert((offsetof(Node,matrixWS)==0x48),"bad off");
		static_assert((offsetof(Node,isWSIdentity)==0x88),"bad off");
		static_assert((offsetof(Node,nodes)==0x90),"bad off");
		static_assert((offsetof(Node,parent)==0xA8),"bad off");
		static_assert((offsetof(Node,priority)==0xB0),"bad off");
		static_assert((offsetof(Node,needsMatrixWS)==0xB4),"bad off");
		static_assert((offsetof(Node,name)==0xB8),"bad off");
		static_assert((offsetof(Node,isActive)==0xD8),"bad off");
	};
};

//UDT: class RaceTimingServices @len=192 @vfcount=6
	//_Base: class GameObject @off=0 @len=88
	//_Func: public void RaceTimingServices(const RaceTimingServices &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void RaceTimingServices(Sim * asim); @loc=static @len=423 @rva=1326176
	//_Func: public void ~RaceTimingServices(); @virtual vtpo=0 vfid=0 @loc=static @len=335 @rva=1326912
	//_Func: public void onLapCompleted(const OnLapCompletedEvent & event); @loc=static @len=1381 @rva=1331968
	//_Func: public void onSectorSplit(const OnSectorSplitEvent & event); @loc=static @len=470 @rva=1333568
	//_Func: public Lap getLastLap(CarAvatar * car); @loc=static @len=114 @rva=1331024
	//_Func: public unsigned int getBestLap(); @loc=optimized @len=0 @rva=0
	//_Func: public Lap getBestLap(CarAvatar * car); @loc=static @len=46 @rva=1330128
	//_Func: public int getLapCount(CarAvatar * car); @loc=static @len=49 @rva=1330560
	//_Func: public unsigned int getSplit(CarAvatar * car, const int & sector); @loc=static @len=58 @rva=1331728
	//_Func: public int getSplit(CarAvatar * car); @loc=static @len=20 @rva=1331792
	//_Func: public void getCurrentLapSplits(CarAvatar * car, std::vector<unsigned int,std::allocator<unsigned int> > & currentSplits); @loc=static @len=31 @rva=1330448
	//_Func: public std::vector<Lap,std::allocator<Lap> > getLaps(CarAvatar * car); @loc=static @len=46 @rva=1330976
	//_Func: public unsigned int getLastSplit(CarAvatar * car, const int & sector); @loc=static @len=520 @rva=1331152
	//_Func: public unsigned int getBestSplit(const int & sector, const bool & isGlobal, CarAvatar * car); @loc=static @len=217 @rva=1330176
	//_Func: public bool isBestSplit(const int & sector, const int & t, const bool & isGlobal, CarAvatar * car); @loc=static @len=101 @rva=1331856
	//_Func: public void resetCurrentLaps(); @loc=static @len=505 @rva=1334576
	//_Func: public double getTotalTime(CarAvatar * car); @loc=static @len=18 @rva=1331824
	//_Func: public void shutdown(); @virtual vtpo=0 vfid=5 @loc=static @len=1786 @rva=1335120
	//_Func: public std::vector<LeaderboardEntry,std::allocator<LeaderboardEntry> > getLeaderboard(); @loc=static @len=38 @rva=1331680
	//_Func: public int getCarLeaderboardPosition(CarAvatar * car); @loc=static @len=44 @rva=1330400
	//_Func: public int getInstanceBestTime(CarAvatar * car); @loc=static @len=33 @rva=1330512
	//_Func: public void setHasCompletedFlag(CarAvatar * car, bool flag); @loc=static @len=27 @rva=1335088
	//_Func: public bool getHasCompletedFlag(CarAvatar * car); @loc=static @len=21 @rva=1330480
	//_Func: public void update(float dt); @virtual vtpo=0 vfid=1 @loc=static @len=5 @rva=1336912
	//_Data: this+0x58, Member, Type: class std::vector<LapDB *,std::allocator<LapDB *> >, lapDBs
	//_Data: this+0x70, Member, Type: class std::vector<LeaderboardEntry,std::allocator<LeaderboardEntry> >, leaderboard
	//_Data: this+0x88, Member, Type: class Sim *, sim
	//_Data: this+0x90, Member, Type: class std::map<CarAvatar *,Lap,std::less<CarAvatar *>,std::allocator<std::pair<CarAvatar * const,Lap> > >, instanceBestTimes
	//_Data: this+0xA0, Member, Type: class std::vector<unsigned int,std::allocator<unsigned int> >, bestSplits
	//_Data: this+0xB8, Member, Type: unsigned int, globalBestlap
	//_Func: protected LapDB * getLapDB(CarAvatar * car); @loc=static @len=347 @rva=1330624
	//_Func: protected void updateLeaderboard(); @loc=static @len=549 @rva=1336928
	//_Func: protected void onNewSession(const OnNewSessionEvent & message); @loc=static @len=206 @rva=1333360
	//_Func: public RaceTimingServices & operator=(const RaceTimingServices &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class RaceTimingServices : public GameObject {
public:
	std::vector<LapDB *,std::allocator<LapDB *> > lapDBs;
	std::vector<LeaderboardEntry,std::allocator<LeaderboardEntry> > leaderboard;
	Sim * sim;
	std::map<CarAvatar *,Lap,std::less<CarAvatar *>,std::allocator<std::pair<CarAvatar * const,Lap> > > instanceBestTimes;
	std::vector<unsigned int,std::allocator<unsigned int> > bestSplits;
	unsigned int globalBestlap;
	inline RaceTimingServices() { }
	inline RaceTimingServices(const RaceTimingServices& other) = default;
	inline RaceTimingServices& operator=(const RaceTimingServices& other) = default;
	inline void ctor(Sim * asim) { typedef void (RaceTimingServices::*_fpt)(Sim *); auto _f=xcast<_fpt>(_drva(1326176)); (this->*_f)(asim); }
	virtual ~RaceTimingServices();
	inline void dtor() { typedef void (RaceTimingServices::*_fpt)(); auto _f=xcast<_fpt>(_drva(1326912)); (this->*_f)(); }
	inline void onLapCompleted(const OnLapCompletedEvent & event) { typedef void (RaceTimingServices::*_fpt)(const OnLapCompletedEvent &); auto _f=xcast<_fpt>(_drva(1331968)); return (this->*_f)(event); }
	inline void onSectorSplit(const OnSectorSplitEvent & event) { typedef void (RaceTimingServices::*_fpt)(const OnSectorSplitEvent &); auto _f=xcast<_fpt>(_drva(1333568)); return (this->*_f)(event); }
	inline Lap getLastLap(CarAvatar * car) { typedef Lap (RaceTimingServices::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(1331024)); return (this->*_f)(car); }
	inline Lap getBestLap(CarAvatar * car) { typedef Lap (RaceTimingServices::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(1330128)); return (this->*_f)(car); }
	inline int getLapCount(CarAvatar * car) { typedef int (RaceTimingServices::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(1330560)); return (this->*_f)(car); }
	inline unsigned int getSplit(CarAvatar * car, const int & sector) { typedef unsigned int (RaceTimingServices::*_fpt)(CarAvatar *, const int &); auto _f=xcast<_fpt>(_drva(1331728)); return (this->*_f)(car, sector); }
	inline int getSplit(CarAvatar * car) { typedef int (RaceTimingServices::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(1331792)); return (this->*_f)(car); }
	inline void getCurrentLapSplits(CarAvatar * car, std::vector<unsigned int,std::allocator<unsigned int> > & currentSplits) { typedef void (RaceTimingServices::*_fpt)(CarAvatar *, std::vector<unsigned int,std::allocator<unsigned int> > &); auto _f=xcast<_fpt>(_drva(1330448)); return (this->*_f)(car, currentSplits); }
	inline std::vector<Lap,std::allocator<Lap> > getLaps(CarAvatar * car) { typedef std::vector<Lap,std::allocator<Lap> > (RaceTimingServices::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(1330976)); return (this->*_f)(car); }
	inline unsigned int getLastSplit(CarAvatar * car, const int & sector) { typedef unsigned int (RaceTimingServices::*_fpt)(CarAvatar *, const int &); auto _f=xcast<_fpt>(_drva(1331152)); return (this->*_f)(car, sector); }
	inline unsigned int getBestSplit(const int & sector, const bool & isGlobal, CarAvatar * car) { typedef unsigned int (RaceTimingServices::*_fpt)(const int &, const bool &, CarAvatar *); auto _f=xcast<_fpt>(_drva(1330176)); return (this->*_f)(sector, isGlobal, car); }
	inline bool isBestSplit(const int & sector, const int & t, const bool & isGlobal, CarAvatar * car) { typedef bool (RaceTimingServices::*_fpt)(const int &, const int &, const bool &, CarAvatar *); auto _f=xcast<_fpt>(_drva(1331856)); return (this->*_f)(sector, t, isGlobal, car); }
	inline void resetCurrentLaps() { typedef void (RaceTimingServices::*_fpt)(); auto _f=xcast<_fpt>(_drva(1334576)); return (this->*_f)(); }
	inline double getTotalTime(CarAvatar * car) { typedef double (RaceTimingServices::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(1331824)); return (this->*_f)(car); }
	virtual void shutdown_vf5();
	inline void shutdown_impl() { typedef void (RaceTimingServices::*_fpt)(); auto _f=xcast<_fpt>(_drva(1335120)); return (this->*_f)(); }
	inline void shutdown() { typedef void (RaceTimingServices::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 5)); return (this->*_f)(); }
	inline std::vector<LeaderboardEntry,std::allocator<LeaderboardEntry> > getLeaderboard() { typedef std::vector<LeaderboardEntry,std::allocator<LeaderboardEntry> > (RaceTimingServices::*_fpt)(); auto _f=xcast<_fpt>(_drva(1331680)); return (this->*_f)(); }
	inline int getCarLeaderboardPosition(CarAvatar * car) { typedef int (RaceTimingServices::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(1330400)); return (this->*_f)(car); }
	inline int getInstanceBestTime(CarAvatar * car) { typedef int (RaceTimingServices::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(1330512)); return (this->*_f)(car); }
	inline void setHasCompletedFlag(CarAvatar * car, bool flag) { typedef void (RaceTimingServices::*_fpt)(CarAvatar *, bool); auto _f=xcast<_fpt>(_drva(1335088)); return (this->*_f)(car, flag); }
	inline bool getHasCompletedFlag(CarAvatar * car) { typedef bool (RaceTimingServices::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(1330480)); return (this->*_f)(car); }
	virtual void update_vf1(float dt);
	inline void update_impl(float dt) { typedef void (RaceTimingServices::*_fpt)(float); auto _f=xcast<_fpt>(_drva(1336912)); return (this->*_f)(dt); }
	inline void update(float dt) { typedef void (RaceTimingServices::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(dt); }
	inline LapDB * getLapDB(CarAvatar * car) { typedef LapDB * (RaceTimingServices::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(1330624)); return (this->*_f)(car); }
	inline void updateLeaderboard() { typedef void (RaceTimingServices::*_fpt)(); auto _f=xcast<_fpt>(_drva(1336928)); return (this->*_f)(); }
	inline void onNewSession(const OnNewSessionEvent & message) { typedef void (RaceTimingServices::*_fpt)(const OnNewSessionEvent &); auto _f=xcast<_fpt>(_drva(1333360)); return (this->*_f)(message); }
	inline void _guard_obj() {
		static_assert((sizeof(RaceTimingServices)==192),"bad size");
		static_assert((offsetof(RaceTimingServices,lapDBs)==0x58),"bad off");
		static_assert((offsetof(RaceTimingServices,leaderboard)==0x70),"bad off");
		static_assert((offsetof(RaceTimingServices,sim)==0x88),"bad off");
		static_assert((offsetof(RaceTimingServices,instanceBestTimes)==0x90),"bad off");
		static_assert((offsetof(RaceTimingServices,bestSplits)==0xA0),"bad off");
		static_assert((offsetof(RaceTimingServices,globalBestlap)==0xB8),"bad off");
	};
};

//UDT: class Console @len=296 @multibase=3
	//_Base: class GameObject @off=0 @len=88
	//_Base: class IVarCallback @off=88 @len=8
	//_Base: class IKeyEventListener @off=96 @len=8
	//_Func: public void Console(const Console &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void Console(Sim * isim); @loc=static @len=879 @rva=1607872
	//_Func: public void ~Console(); @virtual vtpo=0 vfid=0 @loc=static @len=772 @rva=1608752
	//_Data: this+0x68, Member, Type: class Sim *, sim
	//_Data: this+0x70, Member, Type: class std::vector<SVar *,std::allocator<SVar *> >, vars
	//_Func: public Console & singleton(); @pure @loc=static @len=8 @rva=1624096
	//_Func: public void renderHUD(float dt); @virtual vtpo=0 vfid=3 @loc=static @len=672 @rva=1623376
	//_Func: public void onSetVar(SVar * var, float value); @virtual vtpo=88 vfid=0 @loc=static @len=2152 @rva=1619680
	//_Func: public void addVar(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, float * var, IVarCallback * callback, bool readOnly, float multiplier); @loc=static @len=358 @rva=1615552
	//_Func: public void addVarLambda(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, std::function<void __cdecl(SVar *,float)> * lambda, bool readyonly, float multiplier); @loc=static @len=414 @rva=1615920
	//_Func: public void show(bool mode); @loc=static @len=39 @rva=1624048
	//_Func: public bool isVisible(); @loc=static @len=5 @rva=1680480
	//_Func: public void addCommand(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name, std::function<bool __cdecl(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >)> * exeFun, std::function<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > __cdecl(void)> * helpFun); @loc=static @len=390 @rva=1615152
	//_Func: public void addCommand(ConsoleCommand *  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void onKeyChar(unsigned int key); @virtual vtpo=96 vfid=1 @loc=static @len=416 @rva=1619072
	//_Func: public void onKeyDown(const OnKeyEvent & message); @virtual vtpo=96 vfid=0 @loc=static @len=187 @rva=1619488
	//_Func: public void onNewCarLoaded(const OnNewCarLoadedEvent &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public Console & operator<<(const double &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public Console & operator<<(const float & v); @loc=static @len=409 @rva=1609952
	//_Func: public Console & operator<<(const int & v); @loc=static @len=409 @rva=1609536
	//_Func: public Console & operator<<(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * s); @loc=static @len=447 @rva=1610928
	//_Func: public Console & operator<<(std::basic_string<char,std::char_traits<char>,std::allocator<char> > * s); @loc=static @len=560 @rva=1610368
	//_Func: public Console & operator<<(const unsigned int &  _arg0); @loc=optimized @len=0 @rva=0
	//_Data: this+0x88, Member, Type: class std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, lines
	//_Data: this+0xA0, Member, Type: class std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, history
	//_Data: this+0xB8, Member, Type: unsigned int, historyPos
	//_Data: this+0xC0, Member, Type: class Font *, font
	//_Data: this+0xC8, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, commandLine
	//_Data: this+0xE8, Member, Type: class std::vector<ConsoleCommand *,std::allocator<ConsoleCommand *> >, commands
	//_Data: this+0x100, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, accumulator
	//_Data: static, [01559C08][0003:00046C08], Static Member, Type: class Console *, _singleton
	//_Data: this+0x120, Member, Type: bool, disableAutoShow
	//_Func: protected void parse(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * c); @loc=static @len=1246 @rva=1621840
	//_Func: protected void initCommands(); @loc=static @len=2553 @rva=1616512
	//_Func: protected void autoShow(); @loc=optimized @len=0 @rva=0
	//_Func: public Console & operator=(const Console &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class Console : public GameObject, public IVarCallback, public IKeyEventListener {
public:
	Sim * sim;
	std::vector<SVar *,std::allocator<SVar *> > vars;
	std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > lines;
	std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > history;
	unsigned int historyPos;
	Font * font;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > commandLine;
	std::vector<ConsoleCommand *,std::allocator<ConsoleCommand *> > commands;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > accumulator;
	bool disableAutoShow;
	inline Console() { }
	inline Console(const Console& other) = default;
	inline Console& operator=(const Console& other) = default;
	inline void ctor(Sim * isim) { typedef void (Console::*_fpt)(Sim *); auto _f=xcast<_fpt>(_drva(1607872)); (this->*_f)(isim); }
	virtual ~Console();
	inline void dtor() { typedef void (Console::*_fpt)(); auto _f=xcast<_fpt>(_drva(1608752)); (this->*_f)(); }
	inline static Console & singleton() { typedef Console & (*_fpt)(); auto _f=(_fpt)_drva(1624096); return _f(); }
	virtual void renderHUD_vf3(float dt);
	inline void renderHUD_impl(float dt) { typedef void (Console::*_fpt)(float); auto _f=xcast<_fpt>(_drva(1623376)); return (this->*_f)(dt); }
	inline void renderHUD(float dt) { typedef void (Console::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(dt); }
	virtual void onSetVar_vf0(SVar * var, float value);
	inline void onSetVar_impl(SVar * var, float value) { typedef void (Console::*_fpt)(SVar *, float); auto _f=xcast<_fpt>(_drva(1619680)); return (this->*_f)(var, value); }
	inline void onSetVar(SVar * var, float value) { typedef void (Console::*_fpt)(SVar *, float); auto _f=xcast<_fpt>(get_vfp(this, 0)); return (this->*_f)(var, value); }
	inline void addVar(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, float * var, IVarCallback * callback, bool readOnly, float multiplier) { typedef void (Console::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, float *, IVarCallback *, bool, float); auto _f=xcast<_fpt>(_drva(1615552)); return (this->*_f)(name, var, callback, readOnly, multiplier); }
	inline void addVarLambda(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, std::function<void __cdecl(SVar *,float)> * lambda, bool readyonly, float multiplier) { typedef void (Console::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, std::function<void __cdecl(SVar *,float)> *, bool, float); auto _f=xcast<_fpt>(_drva(1615920)); return (this->*_f)(name, lambda, readyonly, multiplier); }
	inline void show(bool mode) { typedef void (Console::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(1624048)); return (this->*_f)(mode); }
	inline bool isVisible() { typedef bool (Console::*_fpt)(); auto _f=xcast<_fpt>(_drva(1680480)); return (this->*_f)(); }
	inline void addCommand(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name, std::function<bool __cdecl(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >)> * exeFun, std::function<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > __cdecl(void)> * helpFun) { typedef void (Console::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, std::function<bool __cdecl(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >)> *, std::function<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > __cdecl(void)> *); auto _f=xcast<_fpt>(_drva(1615152)); return (this->*_f)(name, exeFun, helpFun); }
	virtual void onKeyChar_vf1(unsigned int key);
	inline void onKeyChar_impl(unsigned int key) { typedef void (Console::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(1619072)); return (this->*_f)(key); }
	inline void onKeyChar(unsigned int key) { typedef void (Console::*_fpt)(unsigned int); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(key); }
	virtual void onKeyDown_vf0(const OnKeyEvent & message);
	inline void onKeyDown_impl(const OnKeyEvent & message) { typedef void (Console::*_fpt)(const OnKeyEvent &); auto _f=xcast<_fpt>(_drva(1619488)); return (this->*_f)(message); }
	inline void onKeyDown(const OnKeyEvent & message) { typedef void (Console::*_fpt)(const OnKeyEvent &); auto _f=xcast<_fpt>(get_vfp(this, 0)); return (this->*_f)(message); }
	inline Console & operator<<(const float & v) { typedef Console & (Console::*_fpt)(const float &); auto _f=xcast<_fpt>(_drva(1609952)); return (this->*_f)(v); }
	inline Console & operator<<(const int & v) { typedef Console & (Console::*_fpt)(const int &); auto _f=xcast<_fpt>(_drva(1609536)); return (this->*_f)(v); }
	inline Console & operator<<(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * s) { typedef Console & (Console::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *); auto _f=xcast<_fpt>(_drva(1610928)); return (this->*_f)(s); }
	inline Console & operator<<(std::basic_string<char,std::char_traits<char>,std::allocator<char> > * s) { typedef Console & (Console::*_fpt)(std::basic_string<char,std::char_traits<char>,std::allocator<char> > *); auto _f=xcast<_fpt>(_drva(1610368)); return (this->*_f)(s); }
	inline void parse(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * c) { typedef void (Console::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *); auto _f=xcast<_fpt>(_drva(1621840)); return (this->*_f)(c); }
	inline void initCommands() { typedef void (Console::*_fpt)(); auto _f=xcast<_fpt>(_drva(1616512)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(Console)==296),"bad size");
		static_assert((offsetof(Console,sim)==0x68),"bad off");
		static_assert((offsetof(Console,vars)==0x70),"bad off");
		static_assert((offsetof(Console,lines)==0x88),"bad off");
		static_assert((offsetof(Console,history)==0xA0),"bad off");
		static_assert((offsetof(Console,historyPos)==0xB8),"bad off");
		static_assert((offsetof(Console,font)==0xC0),"bad off");
		static_assert((offsetof(Console,commandLine)==0xC8),"bad off");
		static_assert((offsetof(Console,commands)==0xE8),"bad off");
		static_assert((offsetof(Console,accumulator)==0x100),"bad off");
		static_assert((offsetof(Console,disableAutoShow)==0x120),"bad off");
	};
};

//UDT: class ksgui::Control @len=376 @vfcount=21
	//_VTable: 
	//_Func: public void Control(const ksgui_Control &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void Control(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & iname, ksgui_GUI * igui); @loc=static @len=942 @rva=2376016
	//_Func: public void ~Control(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=338 @rva=2376960
	//_Data: this+0x8, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, name
	//_Data: this+0x28, Member, Type: struct ksgui::ksRect, rect
	//_Data: this+0x38, Member, Type: class vec4f, backColor
	//_Data: this+0x48, Member, Type: class vec4f, borderColor
	//_Data: this+0x58, Member, Type: class vec4f, foreColor
	//_Data: this+0x68, Member, Type: class vec4f, highlightTextColor
	//_Data: this+0x78, Member, Type: bool, highlight
	//_Data: this+0x7C, Member, Type: class vec4f, backTextureColor
	//_Data: this+0x90, Member, Type: class std::shared_ptr<Font>, font
	//_Data: this+0xA0, Member, Type: class std::vector<ksgui::Control *,std::allocator<ksgui::Control *> >, controls
	//_Data: this+0xB8, Member, Type: class ksgui::Control *, parent
	//_Data: this+0xC0, Member, Type: enum eFontAlign, fontAlign
	//_Data: this+0xC8, Member, Type: class Event<ksgui::OnControlClicked>, evClicked
	//_Data: this+0xE0, Member, Type: void *, tag
	//_Data: this+0xE8, Member, Type: class Texture, backTexture
	//_Data: this+0x110, Member, Type: bool, drawBorder
	//_Data: this+0x111, Member, Type: bool, drawBackground
	//_Data: this+0x114, Member, Type: float, repeatInterval
	//_Data: this+0x118, Member, Type: float, fontScale
	//_Func: public void setVisible(bool value); @loc=static @len=22 @rva=2380192
	//_Func: public bool isVisible(); @loc=static @len=8 @rva=349312
	//_Func: public bool hitTest(int x, int y); @intro @virtual vtpo=0 vfid=1 @loc=static @len=60 @rva=2377520
	//_Func: public void addControl(ksgui_Control * c); @intro @virtual vtpo=0 vfid=2 @loc=static @len=48 @rva=2377360
	//_Func: public void render(float dt); @intro @virtual vtpo=0 vfid=3 @loc=static @len=835 @rva=2378624
	//_Func: public vec2f localToWorld(const vec2f & pos); @intro @virtual vtpo=0 vfid=4 @loc=static @len=95 @rva=2377584
	//_Func: public vec2f worldToLocal(const vec2f & pos); @intro @virtual vtpo=0 vfid=5 @loc=static @len=95 @rva=2380464
	//_Func: public void getWorldRect(ksgui_ksRect & irect); @intro @virtual vtpo=0 vfid=6 @loc=static @len=106 @rva=2377408
	//_Func: public float getWidth(); @loc=static @len=11 @rva=220128
	//_Func: public float getHeight(); @loc=static @len=11 @rva=220080
	//_Func: public void setPosition(float x, float y); @loc=static @len=102 @rva=2379936
	//_Func: public void setSize(float w, float h); @intro @virtual vtpo=0 vfid=7 @loc=static @len=118 @rva=2380064
	//_Func: public void onVisibleChanged(bool newValue); @intro @virtual vtpo=0 vfid=8 @loc=static @len=86 @rva=221168
	//_Func: public bool isMousePressing(); @intro @virtual vtpo=0 vfid=9 @loc=static @len=8 @rva=220144
	//_Func: public bool onMouseDown(const OnMouseDownEvent & message); @intro @virtual vtpo=0 vfid=10 @loc=static @len=279 @rva=2377872
	//_Func: public void onMouseUp(const OnMouseUpEvent & message); @intro @virtual vtpo=0 vfid=11 @loc=static @len=125 @rva=2378384
	//_Func: public void onMouseMove(const OnMouseMoveEvent & message); @intro @virtual vtpo=0 vfid=12 @loc=static @len=210 @rva=2378160
	//_Func: public void onMouseWheelMovedEvent(const OnMouseWheelMovedEvent & message); @intro @virtual vtpo=0 vfid=13 @loc=static @len=110 @rva=2378512
	//_Func: public void onKeyChar(unsigned int key); @intro @virtual vtpo=0 vfid=14 @loc=static @len=84 @rva=2377680
	//_Func: public void onKeyDown(const OnKeyEvent & message); @intro @virtual vtpo=0 vfid=15 @loc=static @len=85 @rva=2377776
	//_Func: public void setRepeatInterval(float i); @intro @virtual vtpo=0 vfid=16 @loc=static @len=9 @rva=2380048
	//_Func: public void setText(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & aText); @intro @virtual vtpo=0 vfid=17 @loc=static @len=25 @rva=2011536
	//_Func: public const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & getText(); @intro @virtual vtpo=0 vfid=18 @loc=static @len=8 @rva=220112
	//_Func: public void scaleByMult(float value); @intro @virtual vtpo=0 vfid=19 @loc=static @len=332 @rva=2379600
	//_Func: public void scaleByMult(); @intro @virtual vtpo=0 vfid=20 @loc=static @len=18 @rva=2386448
	//_Func: public void resetBaseRect(); @loc=static @len=123 @rva=2379472
	//_Data: this+0x120, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, text
	//_Data: this+0x140, Member, Type: bool, isHighlight
	//_Data: this+0x148, Member, Type: class ksgui::GUI *, gui
	//_Data: this+0x150, Member, Type: bool, visible
	//_Data: this+0x151, Member, Type: bool, isMouseDown
	//_Data: this+0x154, Member, Type: float, intervalCounter
	//_Data: this+0x158, Member, Type: bool, isRepeating
	//_Data: this+0x15C, Member, Type: float, scaleMult
	//_Data: this+0x160, Member, Type: class GLRenderer *, controlGLR
	//_Func: protected void stepRepeatInterval(float dt); @loc=static @len=236 @rva=2380224
	//_Data: this+0x168, Member, Type: struct ksgui::ksRect, rectBase
	//_Func: private float getWidthBase(); @loc=optimized @len=0 @rva=0
	//_Func: private float getHeightBase(); @loc=optimized @len=0 @rva=0
	//_Func: public ksgui_Control & operator=(const ksgui_Control &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ksgui_Control {
public:
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > name;
	ksgui_ksRect rect;
	vec4f backColor;
	vec4f borderColor;
	vec4f foreColor;
	vec4f highlightTextColor;
	bool highlight;
	vec4f backTextureColor;
	std::shared_ptr<Font> font;
	std::vector<ksgui_Control *,std::allocator<ksgui_Control *> > controls;
	ksgui_Control * parent;
	eFontAlign fontAlign;
	Event<ksgui_OnControlClicked> evClicked;
	void * tag;
	Texture backTexture;
	bool drawBorder;
	bool drawBackground;
	float repeatInterval;
	float fontScale;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > text;
	bool isHighlight;
	ksgui_GUI * gui;
	bool visible;
	bool isMouseDown;
	float intervalCounter;
	bool isRepeating;
	float scaleMult;
	GLRenderer * controlGLR;
	ksgui_ksRect rectBase;
	inline ksgui_Control() { }
	inline ksgui_Control(const ksgui_Control& other) = default;
	inline ksgui_Control& operator=(const ksgui_Control& other) = default;
	inline void ctor(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & iname, ksgui_GUI * igui) { typedef void (ksgui_Control::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, ksgui_GUI *); auto _f=xcast<_fpt>(_drva(2376016)); (this->*_f)(iname, igui); }
	virtual ~ksgui_Control();
	inline void dtor() { typedef void (ksgui_Control::*_fpt)(); auto _f=xcast<_fpt>(_drva(2376960)); (this->*_f)(); }
	inline void setVisible(bool value) { typedef void (ksgui_Control::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(2380192)); return (this->*_f)(value); }
	inline bool isVisible() { typedef bool (ksgui_Control::*_fpt)(); auto _f=xcast<_fpt>(_drva(349312)); return (this->*_f)(); }
	virtual bool hitTest_vf1(int x, int y);
	inline bool hitTest_impl(int x, int y) { typedef bool (ksgui_Control::*_fpt)(int, int); auto _f=xcast<_fpt>(_drva(2377520)); return (this->*_f)(x, y); }
	inline bool hitTest(int x, int y) { typedef bool (ksgui_Control::*_fpt)(int, int); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(x, y); }
	virtual void addControl_vf2(ksgui_Control * c);
	inline void addControl_impl(ksgui_Control * c) { typedef void (ksgui_Control::*_fpt)(ksgui_Control *); auto _f=xcast<_fpt>(_drva(2377360)); return (this->*_f)(c); }
	inline void addControl(ksgui_Control * c) { typedef void (ksgui_Control::*_fpt)(ksgui_Control *); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)(c); }
	virtual void render_vf3(float dt);
	inline void render_impl(float dt) { typedef void (ksgui_Control::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2378624)); return (this->*_f)(dt); }
	inline void render(float dt) { typedef void (ksgui_Control::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(dt); }
	virtual vec2f localToWorld_vf4(const vec2f & pos);
	inline vec2f localToWorld_impl(const vec2f & pos) { typedef vec2f (ksgui_Control::*_fpt)(const vec2f &); auto _f=xcast<_fpt>(_drva(2377584)); return (this->*_f)(pos); }
	inline vec2f localToWorld(const vec2f & pos) { typedef vec2f (ksgui_Control::*_fpt)(const vec2f &); auto _f=xcast<_fpt>(get_vfp(this, 4)); return (this->*_f)(pos); }
	virtual vec2f worldToLocal_vf5(const vec2f & pos);
	inline vec2f worldToLocal_impl(const vec2f & pos) { typedef vec2f (ksgui_Control::*_fpt)(const vec2f &); auto _f=xcast<_fpt>(_drva(2380464)); return (this->*_f)(pos); }
	inline vec2f worldToLocal(const vec2f & pos) { typedef vec2f (ksgui_Control::*_fpt)(const vec2f &); auto _f=xcast<_fpt>(get_vfp(this, 5)); return (this->*_f)(pos); }
	virtual void getWorldRect_vf6(ksgui_ksRect & irect);
	inline void getWorldRect_impl(ksgui_ksRect & irect) { typedef void (ksgui_Control::*_fpt)(ksgui_ksRect &); auto _f=xcast<_fpt>(_drva(2377408)); return (this->*_f)(irect); }
	inline void getWorldRect(ksgui_ksRect & irect) { typedef void (ksgui_Control::*_fpt)(ksgui_ksRect &); auto _f=xcast<_fpt>(get_vfp(this, 6)); return (this->*_f)(irect); }
	inline float getWidth() { typedef float (ksgui_Control::*_fpt)(); auto _f=xcast<_fpt>(_drva(220128)); return (this->*_f)(); }
	inline float getHeight() { typedef float (ksgui_Control::*_fpt)(); auto _f=xcast<_fpt>(_drva(220080)); return (this->*_f)(); }
	inline void setPosition(float x, float y) { typedef void (ksgui_Control::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2379936)); return (this->*_f)(x, y); }
	virtual void setSize_vf7(float w, float h);
	inline void setSize_impl(float w, float h) { typedef void (ksgui_Control::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2380064)); return (this->*_f)(w, h); }
	inline void setSize(float w, float h) { typedef void (ksgui_Control::*_fpt)(float, float); auto _f=xcast<_fpt>(get_vfp(this, 7)); return (this->*_f)(w, h); }
	virtual void onVisibleChanged_vf8(bool newValue);
	inline void onVisibleChanged_impl(bool newValue) { typedef void (ksgui_Control::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(221168)); return (this->*_f)(newValue); }
	inline void onVisibleChanged(bool newValue) { typedef void (ksgui_Control::*_fpt)(bool); auto _f=xcast<_fpt>(get_vfp(this, 8)); return (this->*_f)(newValue); }
	virtual bool isMousePressing_vf9();
	inline bool isMousePressing_impl() { typedef bool (ksgui_Control::*_fpt)(); auto _f=xcast<_fpt>(_drva(220144)); return (this->*_f)(); }
	inline bool isMousePressing() { typedef bool (ksgui_Control::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 9)); return (this->*_f)(); }
	virtual bool onMouseDown_vf10(const OnMouseDownEvent & message);
	inline bool onMouseDown_impl(const OnMouseDownEvent & message) { typedef bool (ksgui_Control::*_fpt)(const OnMouseDownEvent &); auto _f=xcast<_fpt>(_drva(2377872)); return (this->*_f)(message); }
	inline bool onMouseDown(const OnMouseDownEvent & message) { typedef bool (ksgui_Control::*_fpt)(const OnMouseDownEvent &); auto _f=xcast<_fpt>(get_vfp(this, 10)); return (this->*_f)(message); }
	virtual void onMouseUp_vf11(const OnMouseUpEvent & message);
	inline void onMouseUp_impl(const OnMouseUpEvent & message) { typedef void (ksgui_Control::*_fpt)(const OnMouseUpEvent &); auto _f=xcast<_fpt>(_drva(2378384)); return (this->*_f)(message); }
	inline void onMouseUp(const OnMouseUpEvent & message) { typedef void (ksgui_Control::*_fpt)(const OnMouseUpEvent &); auto _f=xcast<_fpt>(get_vfp(this, 11)); return (this->*_f)(message); }
	virtual void onMouseMove_vf12(const OnMouseMoveEvent & message);
	inline void onMouseMove_impl(const OnMouseMoveEvent & message) { typedef void (ksgui_Control::*_fpt)(const OnMouseMoveEvent &); auto _f=xcast<_fpt>(_drva(2378160)); return (this->*_f)(message); }
	inline void onMouseMove(const OnMouseMoveEvent & message) { typedef void (ksgui_Control::*_fpt)(const OnMouseMoveEvent &); auto _f=xcast<_fpt>(get_vfp(this, 12)); return (this->*_f)(message); }
	virtual void onMouseWheelMovedEvent_vf13(const OnMouseWheelMovedEvent & message);
	inline void onMouseWheelMovedEvent_impl(const OnMouseWheelMovedEvent & message) { typedef void (ksgui_Control::*_fpt)(const OnMouseWheelMovedEvent &); auto _f=xcast<_fpt>(_drva(2378512)); return (this->*_f)(message); }
	inline void onMouseWheelMovedEvent(const OnMouseWheelMovedEvent & message) { typedef void (ksgui_Control::*_fpt)(const OnMouseWheelMovedEvent &); auto _f=xcast<_fpt>(get_vfp(this, 13)); return (this->*_f)(message); }
	virtual void onKeyChar_vf14(unsigned int key);
	inline void onKeyChar_impl(unsigned int key) { typedef void (ksgui_Control::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(2377680)); return (this->*_f)(key); }
	inline void onKeyChar(unsigned int key) { typedef void (ksgui_Control::*_fpt)(unsigned int); auto _f=xcast<_fpt>(get_vfp(this, 14)); return (this->*_f)(key); }
	virtual void onKeyDown_vf15(const OnKeyEvent & message);
	inline void onKeyDown_impl(const OnKeyEvent & message) { typedef void (ksgui_Control::*_fpt)(const OnKeyEvent &); auto _f=xcast<_fpt>(_drva(2377776)); return (this->*_f)(message); }
	inline void onKeyDown(const OnKeyEvent & message) { typedef void (ksgui_Control::*_fpt)(const OnKeyEvent &); auto _f=xcast<_fpt>(get_vfp(this, 15)); return (this->*_f)(message); }
	virtual void setRepeatInterval_vf16(float i);
	inline void setRepeatInterval_impl(float i) { typedef void (ksgui_Control::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2380048)); return (this->*_f)(i); }
	inline void setRepeatInterval(float i) { typedef void (ksgui_Control::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 16)); return (this->*_f)(i); }
	virtual void setText_vf17(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & aText);
	inline void setText_impl(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & aText) { typedef void (ksgui_Control::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2011536)); return (this->*_f)(aText); }
	inline void setText(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & aText) { typedef void (ksgui_Control::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(get_vfp(this, 17)); return (this->*_f)(aText); }
	virtual const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & getText_vf18();
	inline const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & getText_impl() { typedef const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & (ksgui_Control::*_fpt)(); auto _f=xcast<_fpt>(_drva(220112)); return (this->*_f)(); }
	inline const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & getText() { typedef const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & (ksgui_Control::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 18)); return (this->*_f)(); }
	virtual void scaleByMult_vf19(float value);
	inline void scaleByMult_impl(float value) { typedef void (ksgui_Control::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2379600)); return (this->*_f)(value); }
	inline void scaleByMult(float value) { typedef void (ksgui_Control::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 19)); return (this->*_f)(value); }
	virtual void scaleByMult_vf20();
	inline void scaleByMult_impl() { typedef void (ksgui_Control::*_fpt)(); auto _f=xcast<_fpt>(_drva(2386448)); return (this->*_f)(); }
	inline void scaleByMult() { typedef void (ksgui_Control::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 20)); return (this->*_f)(); }
	inline void resetBaseRect() { typedef void (ksgui_Control::*_fpt)(); auto _f=xcast<_fpt>(_drva(2379472)); return (this->*_f)(); }
	inline void stepRepeatInterval(float dt) { typedef void (ksgui_Control::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2380224)); return (this->*_f)(dt); }
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_Control)==376),"bad size");
		static_assert((offsetof(ksgui_Control,name)==0x8),"bad off");
		static_assert((offsetof(ksgui_Control,rect)==0x28),"bad off");
		static_assert((offsetof(ksgui_Control,backColor)==0x38),"bad off");
		static_assert((offsetof(ksgui_Control,borderColor)==0x48),"bad off");
		static_assert((offsetof(ksgui_Control,foreColor)==0x58),"bad off");
		static_assert((offsetof(ksgui_Control,highlightTextColor)==0x68),"bad off");
		static_assert((offsetof(ksgui_Control,highlight)==0x78),"bad off");
		static_assert((offsetof(ksgui_Control,backTextureColor)==0x7C),"bad off");
		static_assert((offsetof(ksgui_Control,font)==0x90),"bad off");
		static_assert((offsetof(ksgui_Control,controls)==0xA0),"bad off");
		static_assert((offsetof(ksgui_Control,parent)==0xB8),"bad off");
		static_assert((offsetof(ksgui_Control,fontAlign)==0xC0),"bad off");
		static_assert((offsetof(ksgui_Control,evClicked)==0xC8),"bad off");
		static_assert((offsetof(ksgui_Control,tag)==0xE0),"bad off");
		static_assert((offsetof(ksgui_Control,backTexture)==0xE8),"bad off");
		static_assert((offsetof(ksgui_Control,drawBorder)==0x110),"bad off");
		static_assert((offsetof(ksgui_Control,drawBackground)==0x111),"bad off");
		static_assert((offsetof(ksgui_Control,repeatInterval)==0x114),"bad off");
		static_assert((offsetof(ksgui_Control,fontScale)==0x118),"bad off");
		static_assert((offsetof(ksgui_Control,text)==0x120),"bad off");
		static_assert((offsetof(ksgui_Control,isHighlight)==0x140),"bad off");
		static_assert((offsetof(ksgui_Control,gui)==0x148),"bad off");
		static_assert((offsetof(ksgui_Control,visible)==0x150),"bad off");
		static_assert((offsetof(ksgui_Control,isMouseDown)==0x151),"bad off");
		static_assert((offsetof(ksgui_Control,intervalCounter)==0x154),"bad off");
		static_assert((offsetof(ksgui_Control,isRepeating)==0x158),"bad off");
		static_assert((offsetof(ksgui_Control,scaleMult)==0x15C),"bad off");
		static_assert((offsetof(ksgui_Control,controlGLR)==0x160),"bad off");
		static_assert((offsetof(ksgui_Control,rectBase)==0x168),"bad off");
	};
};

//UDT: class ICarPhysicsStateProvider @len=8 @vfcount=3
	//_VTable: 
	//_Func: public void ~ICarPhysicsStateProvider(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=11 @rva=783520
	//_Func: public void getPhysicsState(CarPhysicsState &  _arg0); @intro @pure @virtual vtpo=0 vfid=1 @loc=optimized @len=0 @rva=0
	//_Func: public void getWingState(std::vector<WingState,std::allocator<WingState> > &  _arg0); @intro @pure @virtual vtpo=0 vfid=2 @loc=optimized @len=0 @rva=0
	//_Func: public void ICarPhysicsStateProvider(const ICarPhysicsStateProvider &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void ICarPhysicsStateProvider(); @loc=optimized @len=0 @rva=0
	//_Func: public ICarPhysicsStateProvider & operator=(const ICarPhysicsStateProvider &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ICarPhysicsStateProvider {
public:
	inline ICarPhysicsStateProvider() { }
	inline ICarPhysicsStateProvider(const ICarPhysicsStateProvider& other) = default;
	inline ICarPhysicsStateProvider& operator=(const ICarPhysicsStateProvider& other) = default;
	virtual ~ICarPhysicsStateProvider();
	inline void dtor() { typedef void (ICarPhysicsStateProvider::*_fpt)(); auto _f=xcast<_fpt>(_drva(783520)); (this->*_f)(); }
	virtual void getPhysicsState_vf1(CarPhysicsState &  _arg0) = 0;
	inline void getPhysicsState(CarPhysicsState &  _arg0) { typedef void (ICarPhysicsStateProvider::*_fpt)(CarPhysicsState &); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)( _arg0); }
	virtual void getWingState_vf2(std::vector<WingState,std::allocator<WingState> > &  _arg0) = 0;
	inline void getWingState(std::vector<WingState,std::allocator<WingState> > &  _arg0) { typedef void (ICarPhysicsStateProvider::*_fpt)(std::vector<WingState,std::allocator<WingState> > &); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)( _arg0); }
	inline void _guard_obj() {
		static_assert((sizeof(ICarPhysicsStateProvider)==8),"bad size");
	};
};

//UDT: class INIReaderDocuments @len=104 @vfcount=1
	//_Base: class INIReader @off=0 @len=104
	//_Func: public void INIReaderDocuments(const INIReaderDocuments &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void INIReaderDocuments(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * iniName, bool createFile); @loc=static @len=1637 @rva=2327376
	//_Func: public void ~INIReaderDocuments(); @virtual vtpo=0 vfid=0 @loc=static @len=15 @rva=2329024
	//_Data: static, [0155A588][0003:00047588], Static Member, Type: bool, initialized
	//_Data: static, [0151D100][0003:0000A100], Static Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, basePath
	//_Data: static, [0151D120][0003:0000A120], Static Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, programName
	//_Func: public INIReaderDocuments & operator=(const INIReaderDocuments &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class INIReaderDocuments : public INIReader {
public:
	inline INIReaderDocuments() { }
	inline INIReaderDocuments(const INIReaderDocuments& other) = default;
	inline INIReaderDocuments& operator=(const INIReaderDocuments& other) = default;
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * iniName, bool createFile) { typedef void (INIReaderDocuments::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, bool); auto _f=xcast<_fpt>(_drva(2327376)); (this->*_f)(iniName, createFile); }
	virtual ~INIReaderDocuments();
	inline void dtor() { typedef void (INIReaderDocuments::*_fpt)(); auto _f=xcast<_fpt>(_drva(2329024)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(INIReaderDocuments)==104),"bad size");
	};
};

//UDT: struct ACClient::ClientSessionTransition @len=216
	//_Data: this+0x0, Member, Type: bool, isTransitioning
	//_Data: this+0x8, Member, Type: class UDPPacket, sessionPacket
	//_Data: this+0x28, Member, Type: struct RemoteSessionResume, sessionResume
	//_Func: public void ClientSessionTransition(const ACClient_ClientSessionTransition &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void ClientSessionTransition(); @loc=optimized @len=0 @rva=0
	//_Func: public void ~ClientSessionTransition(); @loc=static @len=66 @rva=246384
	//_Func: public ACClient_ClientSessionTransition & operator=(const ACClient_ClientSessionTransition &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct ACClient_ClientSessionTransition {
public:
	bool isTransitioning;
	UDPPacket sessionPacket;
	RemoteSessionResume sessionResume;
	inline ACClient_ClientSessionTransition() { }
	inline ACClient_ClientSessionTransition(const ACClient_ClientSessionTransition& other) = default;
	inline ACClient_ClientSessionTransition& operator=(const ACClient_ClientSessionTransition& other) = default;
	inline void dtor() { typedef void (ACClient_ClientSessionTransition::*_fpt)(); auto _f=xcast<_fpt>(_drva(246384)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(ACClient_ClientSessionTransition)==216),"bad size");
		static_assert((offsetof(ACClient_ClientSessionTransition,isTransitioning)==0x0),"bad off");
		static_assert((offsetof(ACClient_ClientSessionTransition,sessionPacket)==0x8),"bad off");
		static_assert((offsetof(ACClient_ClientSessionTransition,sessionResume)==0x28),"bad off");
	};
};

//UDT: class ksgui::Label @len=384 @vfcount=21
	//_Base: class ksgui::Control @off=0 @len=376
	//_Func: public void Label(const ksgui_Label &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void Label(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * iname, ksgui_GUI * igui); @loc=static @len=521 @rva=2403696
	//_Func: public void ~Label(); @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Data: this+0x178, Member, Type: unsigned int, maxNumberOfCharDisplayed
	//_Func: public void render(float dt); @virtual vtpo=0 vfid=3 @loc=static @len=394 @rva=2404288
	//_Func: protected void scaleByMult(float value); @virtual vtpo=0 vfid=19 @loc=static @len=5 @rva=2404688
	//_Func: public ksgui_Label & operator=(const ksgui_Label &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ksgui_Label : public ksgui_Control {
public:
	unsigned int maxNumberOfCharDisplayed;
	inline ksgui_Label() { }
	inline ksgui_Label(const ksgui_Label& other) = default;
	inline ksgui_Label& operator=(const ksgui_Label& other) = default;
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * iname, ksgui_GUI * igui) { typedef void (ksgui_Label::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, ksgui_GUI *); auto _f=xcast<_fpt>(_drva(2403696)); (this->*_f)(iname, igui); }
	virtual ~ksgui_Label();
	virtual void render_vf3(float dt);
	inline void render_impl(float dt) { typedef void (ksgui_Label::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2404288)); return (this->*_f)(dt); }
	inline void render(float dt) { typedef void (ksgui_Label::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(dt); }
	virtual void scaleByMult_vf19(float value);
	inline void scaleByMult_impl(float value) { typedef void (ksgui_Label::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2404688)); return (this->*_f)(value); }
	inline void scaleByMult(float value) { typedef void (ksgui_Label::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 19)); return (this->*_f)(value); }
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_Label)==384),"bad size");
		static_assert((offsetof(ksgui_Label,maxNumberOfCharDisplayed)==0x178),"bad off");
	};
};

//UDT: class ksgui::ProgressBar @len=392 @vfcount=21
	//_Base: class ksgui::Control @off=0 @len=376
	//_Func: public void ProgressBar(const ksgui_ProgressBar &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void ProgressBar(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * iname, ksgui_GUI * igui); @loc=static @len=184 @rva=2416368
	//_Func: public void ~ProgressBar(); @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Data: this+0x178, Member, Type: float, maxValue
	//_Data: this+0x17C, Member, Type: float, minValue
	//_Data: this+0x180, Member, Type: float, value
	//_Data: this+0x184, Member, Type: bool, isVertical
	//_Data: this+0x185, Member, Type: bool, isInverted
	//_Func: public void render(float dt); @virtual vtpo=0 vfid=3 @loc=static @len=59 @rva=2416624
	//_Func: protected void renderVertical(float dt); @loc=static @len=329 @rva=2417120
	//_Func: protected void renderHorizontal(float dt); @loc=static @len=420 @rva=2416688
	//_Func: public ksgui_ProgressBar & operator=(const ksgui_ProgressBar &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ksgui_ProgressBar : public ksgui_Control {
public:
	float maxValue;
	float minValue;
	float value;
	bool isVertical;
	bool isInverted;
	inline ksgui_ProgressBar() { }
	inline ksgui_ProgressBar(const ksgui_ProgressBar& other) = default;
	inline ksgui_ProgressBar& operator=(const ksgui_ProgressBar& other) = default;
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * iname, ksgui_GUI * igui) { typedef void (ksgui_ProgressBar::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, ksgui_GUI *); auto _f=xcast<_fpt>(_drva(2416368)); (this->*_f)(iname, igui); }
	virtual ~ksgui_ProgressBar();
	virtual void render_vf3(float dt);
	inline void render_impl(float dt) { typedef void (ksgui_ProgressBar::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2416624)); return (this->*_f)(dt); }
	inline void render(float dt) { typedef void (ksgui_ProgressBar::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(dt); }
	inline void renderVertical(float dt) { typedef void (ksgui_ProgressBar::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2417120)); return (this->*_f)(dt); }
	inline void renderHorizontal(float dt) { typedef void (ksgui_ProgressBar::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2416688)); return (this->*_f)(dt); }
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_ProgressBar)==392),"bad size");
		static_assert((offsetof(ksgui_ProgressBar,maxValue)==0x178),"bad off");
		static_assert((offsetof(ksgui_ProgressBar,minValue)==0x17C),"bad off");
		static_assert((offsetof(ksgui_ProgressBar,value)==0x180),"bad off");
		static_assert((offsetof(ksgui_ProgressBar,isVertical)==0x184),"bad off");
		static_assert((offsetof(ksgui_ProgressBar,isInverted)==0x185),"bad off");
	};
};

//UDT: class ksgui::ConnectedLabel @len=472 @vfcount=21
	//_Base: class ksgui::Control @off=0 @len=376
	//_Func: public void ConnectedLabel(const ksgui_ConnectedLabel &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void ConnectedLabel(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & iname, ksgui_GUI * igui, int * var); @loc=static @len=155 @rva=4515840
	//_Func: public void ConnectedLabel(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & iname, ksgui_GUI * igui, float * var); @loc=static @len=151 @rva=4516000
	//_Func: public void ~ConnectedLabel(); @virtual vtpo=0 vfid=0 @loc=static @len=137 @rva=4516160
	//_Data: this+0x178, Member, Type: enum ksgui::VariableConnection, variableConnection
	//_Data: this+0x180, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, label
	//_Data: this+0x1A0, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, suffix
	//_Data: this+0x1C0, Member, Type: int, precision
	//_Func: public void render(float dt); @virtual vtpo=0 vfid=3 @loc=static @len=592 @rva=4516784
	//_Data: this+0x1C8, Member, Type: float *, fValue
	//_Data: this+0x1D0, Member, Type: int *, iValue
	//_Func: protected void init(); @loc=static @len=429 @rva=4516352
	//_Func: public ksgui_ConnectedLabel & operator=(const ksgui_ConnectedLabel &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ksgui_ConnectedLabel : public ksgui_Control {
public:
	ksgui_VariableConnection variableConnection;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > label;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > suffix;
	int precision;
	float * fValue;
	int * iValue;
	inline ksgui_ConnectedLabel() { }
	inline ksgui_ConnectedLabel(const ksgui_ConnectedLabel& other) = default;
	inline ksgui_ConnectedLabel& operator=(const ksgui_ConnectedLabel& other) = default;
	inline void ctor(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & iname, ksgui_GUI * igui, int * var) { typedef void (ksgui_ConnectedLabel::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, ksgui_GUI *, int *); auto _f=xcast<_fpt>(_drva(4515840)); (this->*_f)(iname, igui, var); }
	inline void ctor(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & iname, ksgui_GUI * igui, float * var) { typedef void (ksgui_ConnectedLabel::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, ksgui_GUI *, float *); auto _f=xcast<_fpt>(_drva(4516000)); (this->*_f)(iname, igui, var); }
	virtual ~ksgui_ConnectedLabel();
	inline void dtor() { typedef void (ksgui_ConnectedLabel::*_fpt)(); auto _f=xcast<_fpt>(_drva(4516160)); (this->*_f)(); }
	virtual void render_vf3(float dt);
	inline void render_impl(float dt) { typedef void (ksgui_ConnectedLabel::*_fpt)(float); auto _f=xcast<_fpt>(_drva(4516784)); return (this->*_f)(dt); }
	inline void render(float dt) { typedef void (ksgui_ConnectedLabel::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(dt); }
	inline void init() { typedef void (ksgui_ConnectedLabel::*_fpt)(); auto _f=xcast<_fpt>(_drva(4516352)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_ConnectedLabel)==472),"bad size");
		static_assert((offsetof(ksgui_ConnectedLabel,variableConnection)==0x178),"bad off");
		static_assert((offsetof(ksgui_ConnectedLabel,label)==0x180),"bad off");
		static_assert((offsetof(ksgui_ConnectedLabel,suffix)==0x1A0),"bad off");
		static_assert((offsetof(ksgui_ConnectedLabel,precision)==0x1C0),"bad off");
		static_assert((offsetof(ksgui_ConnectedLabel,fValue)==0x1C8),"bad off");
		static_assert((offsetof(ksgui_ConnectedLabel,iValue)==0x1D0),"bad off");
	};
};

//UDT: struct CarPhysicsInfo @len=320
	//_Data: this+0x0, Member, Type: float, steerLock
	//_Data: this+0x4, Member, Type: int, maxGear
	//_Data: this+0x8, Member, Type: float, caster
	//_Data: this+0xC, Member, Type: float[0x4], tyreRadius
	//_Data: this+0x1C, Member, Type: float[0x4], tyreWidth
	//_Data: this+0x2C, Member, Type: float, totalMass
	//_Data: this+0x30, Member, Type: float, bodyMass
	//_Data: this+0x34, Member, Type: float[0x4], unsprungWeights
	//_Data: this+0x48, Member, Type: class std::vector<WingData,std::allocator<WingData> >, wingData
	//_Data: this+0x60, Member, Type: float, maxTorqueNM
	//_Data: this+0x64, Member, Type: float, maxPowerW
	//_Data: this+0x68, Member, Type: float[0x4], bumpStopsUp
	//_Data: this+0x78, Member, Type: float[0x4], bumpStopsDn
	//_Data: this+0x88, Member, Type: double, maxFuel
	//_Data: this+0x90, Member, Type: class vec3f[0x2], ridePickupPoint
	//_Data: this+0xA8, Member, Type: class vec3f[0x4], susBasePos
	//_Data: this+0xD8, Member, Type: class std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, tyreCompounds
	//_Data: this+0xF0, Member, Type: float, minHeightM
	//_Data: this+0xF4, Member, Type: float[0x4], wheelAngularInertia
	//_Data: this+0x104, Member, Type: struct KPI, kpi
	//_Data: this+0x10C, Member, Type: float, maxTurboBoost
	//_Data: this+0x110, Member, Type: int, turboCount
	//_Data: this+0x114, Member, Type: float, kersMaxJ
	//_Data: this+0x118, Member, Type: float, ersMaxJ
	//_Data: this+0x11C, Member, Type: float, powerClassIndex
	//_Data: this+0x120, Member, Type: bool, hasKERS
	//_Data: this+0x121, Member, Type: bool, hasERS
	//_Data: this+0x122, Member, Type: bool, hasCockpitERSRecovery
	//_Data: this+0x123, Member, Type: bool, hasCockpitERSDeliveryProfile
	//_Data: this+0x124, Member, Type: bool, hasCockpitEngineBrake
	//_Data: this+0x125, Member, Type: bool, hasCockpitERSMguHMode
	//_Data: this+0x126, Member, Type: bool, hasDRS
	//_Data: this+0x128, Member, Type: int, engineBrakeSettingsCount
	//_Data: this+0x12C, Member, Type: int, ersPowerControllerCount
	//_Data: this+0x130, Member, Type: int, engineDamageRPM
	//_Data: this+0x134, Member, Type: bool, hasAdjustableTurbo
	//_Data: this+0x138, Member, Type: int, maxRpm
	//_Func: public void CarPhysicsInfo(const CarPhysicsInfo &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void CarPhysicsInfo(); @loc=static @len=192 @rva=844768
	//_Func: public void ~CarPhysicsInfo(); @loc=static @len=84 @rva=847488
	//_Func: public CarPhysicsInfo & operator=(const CarPhysicsInfo & __that); @loc=static @len=702 @rva=1596080
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct CarPhysicsInfo {
public:
	float steerLock;
	int maxGear;
	float caster;
	float tyreRadius[4];
	float tyreWidth[4];
	float totalMass;
	float bodyMass;
	float unsprungWeights[4];
	std::vector<WingData,std::allocator<WingData> > wingData;
	float maxTorqueNM;
	float maxPowerW;
	float bumpStopsUp[4];
	float bumpStopsDn[4];
	double maxFuel;
	vec3f ridePickupPoint[2];
	vec3f susBasePos[4];
	std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > tyreCompounds;
	float minHeightM;
	float wheelAngularInertia[4];
	KPI kpi;
	float maxTurboBoost;
	int turboCount;
	float kersMaxJ;
	float ersMaxJ;
	float powerClassIndex;
	bool hasKERS;
	bool hasERS;
	bool hasCockpitERSRecovery;
	bool hasCockpitERSDeliveryProfile;
	bool hasCockpitEngineBrake;
	bool hasCockpitERSMguHMode;
	bool hasDRS;
	int engineBrakeSettingsCount;
	int ersPowerControllerCount;
	int engineDamageRPM;
	bool hasAdjustableTurbo;
	int maxRpm;
	inline CarPhysicsInfo() { }
	inline CarPhysicsInfo(const CarPhysicsInfo& other) = default;
	inline CarPhysicsInfo& operator=(const CarPhysicsInfo& other) = default;
	inline void ctor() { typedef void (CarPhysicsInfo::*_fpt)(); auto _f=xcast<_fpt>(_drva(844768)); (this->*_f)(); }
	inline void dtor() { typedef void (CarPhysicsInfo::*_fpt)(); auto _f=xcast<_fpt>(_drva(847488)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(CarPhysicsInfo)==320),"bad size");
		static_assert((offsetof(CarPhysicsInfo,steerLock)==0x0),"bad off");
		static_assert((offsetof(CarPhysicsInfo,maxGear)==0x4),"bad off");
		static_assert((offsetof(CarPhysicsInfo,caster)==0x8),"bad off");
		static_assert((offsetof(CarPhysicsInfo,tyreRadius)==0xC),"bad off");
		static_assert((offsetof(CarPhysicsInfo,tyreWidth)==0x1C),"bad off");
		static_assert((offsetof(CarPhysicsInfo,totalMass)==0x2C),"bad off");
		static_assert((offsetof(CarPhysicsInfo,bodyMass)==0x30),"bad off");
		static_assert((offsetof(CarPhysicsInfo,unsprungWeights)==0x34),"bad off");
		static_assert((offsetof(CarPhysicsInfo,wingData)==0x48),"bad off");
		static_assert((offsetof(CarPhysicsInfo,maxTorqueNM)==0x60),"bad off");
		static_assert((offsetof(CarPhysicsInfo,maxPowerW)==0x64),"bad off");
		static_assert((offsetof(CarPhysicsInfo,bumpStopsUp)==0x68),"bad off");
		static_assert((offsetof(CarPhysicsInfo,bumpStopsDn)==0x78),"bad off");
		static_assert((offsetof(CarPhysicsInfo,maxFuel)==0x88),"bad off");
		static_assert((offsetof(CarPhysicsInfo,ridePickupPoint)==0x90),"bad off");
		static_assert((offsetof(CarPhysicsInfo,susBasePos)==0xA8),"bad off");
		static_assert((offsetof(CarPhysicsInfo,tyreCompounds)==0xD8),"bad off");
		static_assert((offsetof(CarPhysicsInfo,minHeightM)==0xF0),"bad off");
		static_assert((offsetof(CarPhysicsInfo,wheelAngularInertia)==0xF4),"bad off");
		static_assert((offsetof(CarPhysicsInfo,kpi)==0x104),"bad off");
		static_assert((offsetof(CarPhysicsInfo,maxTurboBoost)==0x10C),"bad off");
		static_assert((offsetof(CarPhysicsInfo,turboCount)==0x110),"bad off");
		static_assert((offsetof(CarPhysicsInfo,kersMaxJ)==0x114),"bad off");
		static_assert((offsetof(CarPhysicsInfo,ersMaxJ)==0x118),"bad off");
		static_assert((offsetof(CarPhysicsInfo,powerClassIndex)==0x11C),"bad off");
		static_assert((offsetof(CarPhysicsInfo,hasKERS)==0x120),"bad off");
		static_assert((offsetof(CarPhysicsInfo,hasERS)==0x121),"bad off");
		static_assert((offsetof(CarPhysicsInfo,hasCockpitERSRecovery)==0x122),"bad off");
		static_assert((offsetof(CarPhysicsInfo,hasCockpitERSDeliveryProfile)==0x123),"bad off");
		static_assert((offsetof(CarPhysicsInfo,hasCockpitEngineBrake)==0x124),"bad off");
		static_assert((offsetof(CarPhysicsInfo,hasCockpitERSMguHMode)==0x125),"bad off");
		static_assert((offsetof(CarPhysicsInfo,hasDRS)==0x126),"bad off");
		static_assert((offsetof(CarPhysicsInfo,engineBrakeSettingsCount)==0x128),"bad off");
		static_assert((offsetof(CarPhysicsInfo,ersPowerControllerCount)==0x12C),"bad off");
		static_assert((offsetof(CarPhysicsInfo,engineDamageRPM)==0x130),"bad off");
		static_assert((offsetof(CarPhysicsInfo,hasAdjustableTurbo)==0x134),"bad off");
		static_assert((offsetof(CarPhysicsInfo,maxRpm)==0x138),"bad off");
	};
};

//UDT: class BoundingFrustum @len=232 @vfcount=1
	//_VTable: 
	//_Func: public void BoundingFrustum(const BoundingFrustum &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void BoundingFrustum(const mat44f & iviewProj); @loc=static @len=186 @rva=2263488
	//_Func: public void ~BoundingFrustum(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=11 @rva=2263680
	//_Data: this+0x8, Member, Type: class mat44f, matViewProj
	//_Data: this+0x48, Member, Type: class plane4f[0x6], planes
	//_Func: public void getCorners(std::vector<vec3f,std::allocator<vec3f> > & corners); @loc=static @len=1874 @rva=2263744
	//_Func: public void setMatrix(const mat44f & value); @loc=static @len=1453 @rva=2265744
	//_Func: public bool intersect(const sphere & s); @loc=static @len=109 @rva=2265632
	//_Data: this+0xA8, Member, Type: class mat44f, invViewProj
	//_Func: public BoundingFrustum & operator=(const BoundingFrustum &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class BoundingFrustum {
public:
	mat44f matViewProj;
	plane4f planes[6];
	mat44f invViewProj;
	inline BoundingFrustum() { }
	inline BoundingFrustum(const BoundingFrustum& other) = default;
	inline BoundingFrustum& operator=(const BoundingFrustum& other) = default;
	inline void ctor(const mat44f & iviewProj) { typedef void (BoundingFrustum::*_fpt)(const mat44f &); auto _f=xcast<_fpt>(_drva(2263488)); (this->*_f)(iviewProj); }
	virtual ~BoundingFrustum();
	inline void dtor() { typedef void (BoundingFrustum::*_fpt)(); auto _f=xcast<_fpt>(_drva(2263680)); (this->*_f)(); }
	inline void getCorners(std::vector<vec3f,std::allocator<vec3f> > & corners) { typedef void (BoundingFrustum::*_fpt)(std::vector<vec3f,std::allocator<vec3f> > &); auto _f=xcast<_fpt>(_drva(2263744)); return (this->*_f)(corners); }
	inline void setMatrix(const mat44f & value) { typedef void (BoundingFrustum::*_fpt)(const mat44f &); auto _f=xcast<_fpt>(_drva(2265744)); return (this->*_f)(value); }
	inline bool intersect(const sphere & s) { typedef bool (BoundingFrustum::*_fpt)(const sphere &); auto _f=xcast<_fpt>(_drva(2265632)); return (this->*_f)(s); }
	inline void _guard_obj() {
		static_assert((sizeof(BoundingFrustum)==232),"bad size");
		static_assert((offsetof(BoundingFrustum,matViewProj)==0x8),"bad off");
		static_assert((offsetof(BoundingFrustum,planes)==0x48),"bad off");
		static_assert((offsetof(BoundingFrustum,invViewProj)==0xA8),"bad off");
	};
};

//UDT: class DynamicController @len=40
	//_Func: public void DynamicController(const DynamicController &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void DynamicController(); @loc=static @len=24 @rva=2819936
	//_Func: public void DynamicController(Car * car, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & filename); @loc=static @len=5164 @rva=2814768
	//_Func: public void ~DynamicController(); @loc=static @len=9 @rva=2820032
	//_Func: public float eval(); @loc=static @len=364 @rva=2821120
	//_Func: public float getOversteerFactor(Car * car); @pure @loc=static @len=92 @rva=2822608
	//_Func: public float getRearSpeedRatio(Car * car); @pure @loc=static @len=61 @rva=2822704
	//_Func: public float getInput(DynamicControllerInput input); @loc=static @len=1116 @rva=2821488
	//_Func: public bool isReady(); @loc=static @len=5 @rva=2864688
	//_Data: this+0x0, Member, Type: class Car *, car
	//_Data: this+0x8, Member, Type: class std::vector<DynamicControllerStage,std::allocator<DynamicControllerStage> >, stages
	//_Data: this+0x20, Member, Type: bool, ready
	//_Func: public DynamicController & operator=(const DynamicController & __that); @loc=static @len=56 @rva=2550784
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class DynamicController {
public:
	Car * car;
	std::vector<DynamicControllerStage,std::allocator<DynamicControllerStage> > stages;
	bool ready;
	inline DynamicController() { }
	inline DynamicController(const DynamicController& other) = default;
	inline DynamicController& operator=(const DynamicController& other) = default;
	inline void ctor() { typedef void (DynamicController::*_fpt)(); auto _f=xcast<_fpt>(_drva(2819936)); (this->*_f)(); }
	inline void ctor(Car * car, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & filename) { typedef void (DynamicController::*_fpt)(Car *, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2814768)); (this->*_f)(car, filename); }
	inline void dtor() { typedef void (DynamicController::*_fpt)(); auto _f=xcast<_fpt>(_drva(2820032)); (this->*_f)(); }
	inline float eval() { typedef float (DynamicController::*_fpt)(); auto _f=xcast<_fpt>(_drva(2821120)); return (this->*_f)(); }
	inline static float getOversteerFactor(Car * car) { typedef float (*_fpt)(Car *); auto _f=(_fpt)_drva(2822608); return _f(car); }
	inline static float getRearSpeedRatio(Car * car) { typedef float (*_fpt)(Car *); auto _f=(_fpt)_drva(2822704); return _f(car); }
	inline float getInput(DynamicControllerInput input) { typedef float (DynamicController::*_fpt)(DynamicControllerInput); auto _f=xcast<_fpt>(_drva(2821488)); return (this->*_f)(input); }
	inline bool isReady() { typedef bool (DynamicController::*_fpt)(); auto _f=xcast<_fpt>(_drva(2864688)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(DynamicController)==40),"bad size");
		static_assert((offsetof(DynamicController,car)==0x0),"bad off");
		static_assert((offsetof(DynamicController,stages)==0x8),"bad off");
		static_assert((offsetof(DynamicController,ready)==0x20),"bad off");
	};
};

//UDT: struct Autoclutch @len=424
	//_Func: public void ~Autoclutch(); @loc=static @len=62 @rva=2851776
	//_Data: this+0x0, Member, Type: float, rpmMin
	//_Data: this+0x4, Member, Type: float, rpmMax
	//_Data: this+0x8, Member, Type: float, clutchSpeed
	//_Data: this+0xC, Member, Type: bool, useAutoOnStart
	//_Data: this+0xD, Member, Type: bool, useAutoOnChange
	//_Data: this+0xE, Member, Type: bool, isForced
	//_Func: public void init(Car * car); @loc=static @len=179 @rva=2852816
	//_Func: public void step(float dt); @loc=static @len=519 @rva=2856336
	//_Func: public void onGearRequest(const OnGearRequestEvent & ev); @loc=static @len=267 @rva=2855760
	//_Func: public bool isInChangeSequence(); @loc=optimized @len=0 @rva=0
	//_Func: public void setDownshiftProfile(Curve & dp); @loc=static @len=122 @rva=2750528
	//_Func: public float getDownshiftSequenceDuration(); @loc=static @len=63 @rva=2741152
	//_Data: this+0x10, Member, Type: class Car *, car
	//_Data: this+0x18, Member, Type: struct ClutchSequence, clutchSequence
	//_Data: this+0xA0, Member, Type: class Curve, upshiftProfile
	//_Data: this+0x120, Member, Type: class Curve, downshiftProfile
	//_Data: this+0x1A0, Member, Type: float, clutchValueSignal
	//_Func: protected void stepSequence(float dt); @loc=static @len=168 @rva=2856864
	//_Func: protected void loadINI(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * carModel); @loc=static @len=2746 @rva=2853008
	//_Func: public void Autoclutch(const Autoclutch &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void Autoclutch(); @loc=static @len=126 @rva=2538848
	//_Func: public Autoclutch & operator=(const Autoclutch &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct Autoclutch {
public:
	float rpmMin;
	float rpmMax;
	float clutchSpeed;
	bool useAutoOnStart;
	bool useAutoOnChange;
	bool isForced;
	Car * car;
	ClutchSequence clutchSequence;
	Curve upshiftProfile;
	Curve downshiftProfile;
	float clutchValueSignal;
	inline Autoclutch() { }
	inline Autoclutch(const Autoclutch& other) = default;
	inline Autoclutch& operator=(const Autoclutch& other) = default;
	inline void dtor() { typedef void (Autoclutch::*_fpt)(); auto _f=xcast<_fpt>(_drva(2851776)); (this->*_f)(); }
	inline void init(Car * car) { typedef void (Autoclutch::*_fpt)(Car *); auto _f=xcast<_fpt>(_drva(2852816)); return (this->*_f)(car); }
	inline void step(float dt) { typedef void (Autoclutch::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2856336)); return (this->*_f)(dt); }
	inline void onGearRequest(const OnGearRequestEvent & ev) { typedef void (Autoclutch::*_fpt)(const OnGearRequestEvent &); auto _f=xcast<_fpt>(_drva(2855760)); return (this->*_f)(ev); }
	inline void setDownshiftProfile(Curve & dp) { typedef void (Autoclutch::*_fpt)(Curve &); auto _f=xcast<_fpt>(_drva(2750528)); return (this->*_f)(dp); }
	inline float getDownshiftSequenceDuration() { typedef float (Autoclutch::*_fpt)(); auto _f=xcast<_fpt>(_drva(2741152)); return (this->*_f)(); }
	inline void stepSequence(float dt) { typedef void (Autoclutch::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2856864)); return (this->*_f)(dt); }
	inline void loadINI(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * carModel) { typedef void (Autoclutch::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *); auto _f=xcast<_fpt>(_drva(2853008)); return (this->*_f)(carModel); }
	inline void ctor() { typedef void (Autoclutch::*_fpt)(); auto _f=xcast<_fpt>(_drva(2538848)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(Autoclutch)==424),"bad size");
		static_assert((offsetof(Autoclutch,rpmMin)==0x0),"bad off");
		static_assert((offsetof(Autoclutch,rpmMax)==0x4),"bad off");
		static_assert((offsetof(Autoclutch,clutchSpeed)==0x8),"bad off");
		static_assert((offsetof(Autoclutch,useAutoOnStart)==0xC),"bad off");
		static_assert((offsetof(Autoclutch,useAutoOnChange)==0xD),"bad off");
		static_assert((offsetof(Autoclutch,isForced)==0xE),"bad off");
		static_assert((offsetof(Autoclutch,car)==0x10),"bad off");
		static_assert((offsetof(Autoclutch,clutchSequence)==0x18),"bad off");
		static_assert((offsetof(Autoclutch,upshiftProfile)==0xA0),"bad off");
		static_assert((offsetof(Autoclutch,downshiftProfile)==0x120),"bad off");
		static_assert((offsetof(Autoclutch,clutchValueSignal)==0x1A0),"bad off");
	};
};

//UDT: class DIControlInput @len=72 @vfcount=3
	//_VTable: 
	//_Func: public void DIControlInput(const DIControlInput &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void DIControlInput(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * iname, DirectInput * di); @loc=static @len=189 @rva=532208
	//_Func: public void ~DIControlInput(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=59 @rva=532400
	//_Data: this+0x8, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, name
	//_Data: this+0x28, Member, Type: class InputDevice *, device
	//_Func: public void load(INIReader &  _arg0, bool  _arg1); @intro @pure @virtual vtpo=0 vfid=1 @loc=optimized @len=0 @rva=0
	//_Func: public float getValue(bool  _arg0); @intro @pure @virtual vtpo=0 vfid=2 @loc=optimized @len=0 @rva=0
	//_Func: public Axis getAxis(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x30, Member, Type: class DirectInput *, directInput
	//_Data: this+0x38, Member, Type: struct Axis, axis
	//_Func: public DIControlInput & operator=(const DIControlInput &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class DIControlInput {
public:
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > name;
	InputDevice * device;
	DirectInput * directInput;
	Axis axis;
	inline DIControlInput() { }
	inline DIControlInput(const DIControlInput& other) = default;
	inline DIControlInput& operator=(const DIControlInput& other) = default;
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * iname, DirectInput * di) { typedef void (DIControlInput::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, DirectInput *); auto _f=xcast<_fpt>(_drva(532208)); (this->*_f)(iname, di); }
	virtual ~DIControlInput();
	inline void dtor() { typedef void (DIControlInput::*_fpt)(); auto _f=xcast<_fpt>(_drva(532400)); (this->*_f)(); }
	virtual void load_vf1(INIReader &  _arg0, bool  _arg1) = 0;
	inline void load(INIReader &  _arg0, bool  _arg1) { typedef void (DIControlInput::*_fpt)(INIReader &, bool); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)( _arg0,  _arg1); }
	virtual float getValue_vf2(bool  _arg0) = 0;
	inline float getValue(bool  _arg0) { typedef float (DIControlInput::*_fpt)(bool); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)( _arg0); }
	inline void _guard_obj() {
		static_assert((sizeof(DIControlInput)==72),"bad size");
		static_assert((offsetof(DIControlInput,name)==0x8),"bad off");
		static_assert((offsetof(DIControlInput,device)==0x28),"bad off");
		static_assert((offsetof(DIControlInput,directInput)==0x30),"bad off");
		static_assert((offsetof(DIControlInput,axis)==0x38),"bad off");
	};
};

//UDT: class ksgui::TextBox @len=400 @vfcount=21
	//_Base: class ksgui::Control @off=0 @len=376
	//_Func: public void TextBox(const ksgui_TextBox &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void TextBox(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, ksgui_GUI * gui, eFontType fontType); @loc=static @len=309 @rva=2417456
	//_Func: public void ~TextBox(); @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Func: public void setText(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void setFormattedText(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * aText); @loc=static @len=1004 @rva=2418400
	//_Func: public void render(float dt); @virtual vtpo=0 vfid=3 @loc=static @len=305 @rva=2418080
	//_Func: public bool onMouseDown(const OnMouseDownEvent & message); @virtual vtpo=0 vfid=10 @loc=static @len=16 @rva=2418064
	//_Data: this+0x178, Member, Type: class std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, textLines
	//_Func: public ksgui_TextBox & operator=(const ksgui_TextBox &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ksgui_TextBox : public ksgui_Control {
public:
	std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > textLines;
	inline ksgui_TextBox() { }
	inline ksgui_TextBox(const ksgui_TextBox& other) = default;
	inline ksgui_TextBox& operator=(const ksgui_TextBox& other) = default;
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, ksgui_GUI * gui, eFontType fontType) { typedef void (ksgui_TextBox::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, ksgui_GUI *, eFontType); auto _f=xcast<_fpt>(_drva(2417456)); (this->*_f)(name, gui, fontType); }
	virtual ~ksgui_TextBox();
	inline void setFormattedText(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * aText) { typedef void (ksgui_TextBox::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *); auto _f=xcast<_fpt>(_drva(2418400)); return (this->*_f)(aText); }
	virtual void render_vf3(float dt);
	inline void render_impl(float dt) { typedef void (ksgui_TextBox::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2418080)); return (this->*_f)(dt); }
	inline void render(float dt) { typedef void (ksgui_TextBox::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(dt); }
	virtual bool onMouseDown_vf10(const OnMouseDownEvent & message);
	inline bool onMouseDown_impl(const OnMouseDownEvent & message) { typedef bool (ksgui_TextBox::*_fpt)(const OnMouseDownEvent &); auto _f=xcast<_fpt>(_drva(2418064)); return (this->*_f)(message); }
	inline bool onMouseDown(const OnMouseDownEvent & message) { typedef bool (ksgui_TextBox::*_fpt)(const OnMouseDownEvent &); auto _f=xcast<_fpt>(get_vfp(this, 10)); return (this->*_f)(message); }
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_TextBox)==400),"bad size");
		static_assert((offsetof(ksgui_TextBox,textLines)==0x178),"bad off");
	};
};

//UDT: class ksgui::PopOver @len=392 @vfcount=21
	//_Base: class ksgui::Control @off=0 @len=376
	//_Func: public void PopOver(const ksgui_PopOver &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void PopOver(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, ksgui_GUI * aGui); @loc=static @len=733 @rva=2447104
	//_Func: public void ~PopOver(); @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Func: public void render(float dt); @virtual vtpo=0 vfid=3 @loc=static @len=79 @rva=2447904
	//_Func: public void renderPopOver(float dt); @loc=static @len=572 @rva=2447984
	//_Func: public void setText(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * aText); @loc=static @len=163 @rva=2448672
	//_Func: public void setLabelTitle(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * aTitle); @loc=static @len=106 @rva=2448560
	//_Data: this+0x178, Member, Type: class ksgui::TextBox *, textBox
	//_Data: this+0x180, Member, Type: class ksgui::Label *, title
	//_Func: public ksgui_PopOver & operator=(const ksgui_PopOver &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ksgui_PopOver : public ksgui_Control {
public:
	ksgui_TextBox * textBox;
	ksgui_Label * title;
	inline ksgui_PopOver() { }
	inline ksgui_PopOver(const ksgui_PopOver& other) = default;
	inline ksgui_PopOver& operator=(const ksgui_PopOver& other) = default;
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, ksgui_GUI * aGui) { typedef void (ksgui_PopOver::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, ksgui_GUI *); auto _f=xcast<_fpt>(_drva(2447104)); (this->*_f)(name, aGui); }
	virtual ~ksgui_PopOver();
	virtual void render_vf3(float dt);
	inline void render_impl(float dt) { typedef void (ksgui_PopOver::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2447904)); return (this->*_f)(dt); }
	inline void render(float dt) { typedef void (ksgui_PopOver::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(dt); }
	inline void renderPopOver(float dt) { typedef void (ksgui_PopOver::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2447984)); return (this->*_f)(dt); }
	inline void setText(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * aText) { typedef void (ksgui_PopOver::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *); auto _f=xcast<_fpt>(_drva(2448672)); return (this->*_f)(aText); }
	inline void setLabelTitle(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * aTitle) { typedef void (ksgui_PopOver::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *); auto _f=xcast<_fpt>(_drva(2448560)); return (this->*_f)(aTitle); }
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_PopOver)==392),"bad size");
		static_assert((offsetof(ksgui_PopOver,textBox)==0x178),"bad off");
		static_assert((offsetof(ksgui_PopOver,title)==0x180),"bad off");
	};
};

//UDT: class ksgui::CheckBox @len=424 @vfcount=21
	//_Base: class ksgui::Control @off=0 @len=376
	//_Func: public void CheckBox(const ksgui_CheckBox &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void CheckBox(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, ksgui_GUI * gui); @loc=static @len=551 @rva=2402416
	//_Func: public void ~CheckBox(); @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Data: this+0x178, Member, Type: class Event<ksgui::OnCheckBoxChanged>, evOnCheckBoxChanged
	//_Func: public void render(float dt); @virtual vtpo=0 vfid=3 @loc=static @len=326 @rva=2403312
	//_Func: public void setCheck(bool aCheck); @loc=static @len=41 @rva=2403648
	//_Func: public bool isChecked(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x190, Member, Type: bool, boxValue
	//_Data: this+0x198, Member, Type: class ksgui::Control *, box
	//_Data: this+0x1A0, Member, Type: class ksgui::Control *, label
	//_Func: public ksgui_CheckBox & operator=(const ksgui_CheckBox &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ksgui_CheckBox : public ksgui_Control {
public:
	Event<ksgui_OnCheckBoxChanged> evOnCheckBoxChanged;
	bool boxValue;
	ksgui_Control * box;
	ksgui_Control * label;
	inline ksgui_CheckBox() { }
	inline ksgui_CheckBox(const ksgui_CheckBox& other) = default;
	inline ksgui_CheckBox& operator=(const ksgui_CheckBox& other) = default;
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, ksgui_GUI * gui) { typedef void (ksgui_CheckBox::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, ksgui_GUI *); auto _f=xcast<_fpt>(_drva(2402416)); (this->*_f)(name, gui); }
	virtual ~ksgui_CheckBox();
	virtual void render_vf3(float dt);
	inline void render_impl(float dt) { typedef void (ksgui_CheckBox::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2403312)); return (this->*_f)(dt); }
	inline void render(float dt) { typedef void (ksgui_CheckBox::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(dt); }
	inline void setCheck(bool aCheck) { typedef void (ksgui_CheckBox::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(2403648)); return (this->*_f)(aCheck); }
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_CheckBox)==424),"bad size");
		static_assert((offsetof(ksgui_CheckBox,evOnCheckBoxChanged)==0x178),"bad off");
		static_assert((offsetof(ksgui_CheckBox,boxValue)==0x190),"bad off");
		static_assert((offsetof(ksgui_CheckBox,box)==0x198),"bad off");
		static_assert((offsetof(ksgui_CheckBox,label)==0x1A0),"bad off");
	};
};

//UDT: struct TyreCompoundDef @len=1008
	//_Func: public void TyreCompoundDef(const TyreCompoundDef & __that); @loc=static @len=380 @rva=2608864
	//_Func: public void TyreCompoundDef(); @loc=static @len=296 @rva=2609248
	//_Data: this+0x0, Member, Type: unsigned int, index
	//_Data: this+0x8, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, name
	//_Data: this+0x28, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, shortName
	//_Data: this+0x48, Member, Type: struct TyreModelData, modelData
	//_Data: this+0x2D8, Member, Type: struct TyreData, data
	//_Data: this+0x320, Member, Type: class BrushSlipProvider, slipProvider
	//_Data: this+0x358, Member, Type: float, pressureStatic
	//_Data: this+0x35C, Member, Type: struct TyrePatchData, thermalPatchData
	//_Data: this+0x370, Member, Type: class Curve, thermalPerformanceCurve
	//_Func: public void ~TyreCompoundDef(); @loc=static @len=188 @rva=2549984
	//_Func: public TyreCompoundDef & operator=(const TyreCompoundDef &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct TyreCompoundDef {
public:
	unsigned int index;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > name;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > shortName;
	TyreModelData modelData;
	TyreData data;
	BrushSlipProvider slipProvider;
	float pressureStatic;
	TyrePatchData thermalPatchData;
	Curve thermalPerformanceCurve;
	inline TyreCompoundDef() { }
	inline TyreCompoundDef(const TyreCompoundDef& other) = default;
	inline TyreCompoundDef& operator=(const TyreCompoundDef& other) = default;
	inline void ctor(const TyreCompoundDef & __that) { typedef void (TyreCompoundDef::*_fpt)(const TyreCompoundDef &); auto _f=xcast<_fpt>(_drva(2608864)); (this->*_f)(__that); }
	inline void ctor() { typedef void (TyreCompoundDef::*_fpt)(); auto _f=xcast<_fpt>(_drva(2609248)); (this->*_f)(); }
	inline void dtor() { typedef void (TyreCompoundDef::*_fpt)(); auto _f=xcast<_fpt>(_drva(2549984)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(TyreCompoundDef)==1008),"bad size");
		static_assert((offsetof(TyreCompoundDef,index)==0x0),"bad off");
		static_assert((offsetof(TyreCompoundDef,name)==0x8),"bad off");
		static_assert((offsetof(TyreCompoundDef,shortName)==0x28),"bad off");
		static_assert((offsetof(TyreCompoundDef,modelData)==0x48),"bad off");
		static_assert((offsetof(TyreCompoundDef,data)==0x2D8),"bad off");
		static_assert((offsetof(TyreCompoundDef,slipProvider)==0x320),"bad off");
		static_assert((offsetof(TyreCompoundDef,pressureStatic)==0x358),"bad off");
		static_assert((offsetof(TyreCompoundDef,thermalPatchData)==0x35C),"bad off");
		static_assert((offsetof(TyreCompoundDef,thermalPerformanceCurve)==0x370),"bad off");
	};
};

//UDT: class ksgui::CustomSpinner @len=472 @vfcount=21
	//_Base: class ksgui::Control @off=0 @len=376
	//_Func: public void CustomSpinner(const ksgui_CustomSpinner &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void CustomSpinner(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, ksgui_GUI * aGui, CustomSpinnerMode aMode); @loc=static @len=1417 @rva=2419408
	//_Func: public void ~CustomSpinner(); @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Data: this+0x178, Member, Type: bool, pressToIncrement
	//_Data: this+0x180, Member, Type: class ksgui::Control *, leftButton
	//_Data: this+0x188, Member, Type: class ksgui::Control *, rightButton
	//_Data: this+0x190, Member, Type: class ksgui::Control *, upButton
	//_Data: this+0x198, Member, Type: class ksgui::Control *, downButton
	//_Data: this+0x1A0, Member, Type: class ksgui::Label *, title
	//_Data: this+0x1A8, Member, Type: class Texture, bar
	//_Data: this+0x1D0, Member, Type: float, barPositionNormalized
	//_Func: public void setSize(float w, float h); @virtual vtpo=0 vfid=7 @loc=static @len=755 @rva=2422512
	//_Func: public void render(float dt); @virtual vtpo=0 vfid=3 @loc=static @len=760 @rva=2420928
	//_Func: protected void scaleByMult(float value); @virtual vtpo=0 vfid=19 @loc=static @len=43 @rva=2422464
	//_Data: this+0x1D4, Member, Type: enum CustomSpinnerMode, mode
	//_Func: private void resize(float value); @loc=static @len=765 @rva=2421696
	//_Func: public ksgui_CustomSpinner & operator=(const ksgui_CustomSpinner &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ksgui_CustomSpinner : public ksgui_Control {
public:
	bool pressToIncrement;
	ksgui_Control * leftButton;
	ksgui_Control * rightButton;
	ksgui_Control * upButton;
	ksgui_Control * downButton;
	ksgui_Label * title;
	Texture bar;
	float barPositionNormalized;
	CustomSpinnerMode mode;
	inline ksgui_CustomSpinner() { }
	inline ksgui_CustomSpinner(const ksgui_CustomSpinner& other) = default;
	inline ksgui_CustomSpinner& operator=(const ksgui_CustomSpinner& other) = default;
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, ksgui_GUI * aGui, CustomSpinnerMode aMode) { typedef void (ksgui_CustomSpinner::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, ksgui_GUI *, CustomSpinnerMode); auto _f=xcast<_fpt>(_drva(2419408)); (this->*_f)(name, aGui, aMode); }
	virtual ~ksgui_CustomSpinner();
	virtual void setSize_vf7(float w, float h);
	inline void setSize_impl(float w, float h) { typedef void (ksgui_CustomSpinner::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2422512)); return (this->*_f)(w, h); }
	inline void setSize(float w, float h) { typedef void (ksgui_CustomSpinner::*_fpt)(float, float); auto _f=xcast<_fpt>(get_vfp(this, 7)); return (this->*_f)(w, h); }
	virtual void render_vf3(float dt);
	inline void render_impl(float dt) { typedef void (ksgui_CustomSpinner::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2420928)); return (this->*_f)(dt); }
	inline void render(float dt) { typedef void (ksgui_CustomSpinner::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(dt); }
	virtual void scaleByMult_vf19(float value);
	inline void scaleByMult_impl(float value) { typedef void (ksgui_CustomSpinner::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2422464)); return (this->*_f)(value); }
	inline void scaleByMult(float value) { typedef void (ksgui_CustomSpinner::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 19)); return (this->*_f)(value); }
	inline void resize(float value) { typedef void (ksgui_CustomSpinner::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2421696)); return (this->*_f)(value); }
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_CustomSpinner)==472),"bad size");
		static_assert((offsetof(ksgui_CustomSpinner,pressToIncrement)==0x178),"bad off");
		static_assert((offsetof(ksgui_CustomSpinner,leftButton)==0x180),"bad off");
		static_assert((offsetof(ksgui_CustomSpinner,rightButton)==0x188),"bad off");
		static_assert((offsetof(ksgui_CustomSpinner,upButton)==0x190),"bad off");
		static_assert((offsetof(ksgui_CustomSpinner,downButton)==0x198),"bad off");
		static_assert((offsetof(ksgui_CustomSpinner,title)==0x1A0),"bad off");
		static_assert((offsetof(ksgui_CustomSpinner,bar)==0x1A8),"bad off");
		static_assert((offsetof(ksgui_CustomSpinner,barPositionNormalized)==0x1D0),"bad off");
		static_assert((offsetof(ksgui_CustomSpinner,mode)==0x1D4),"bad off");
	};
};

//UDT: struct DynamicWingController @len=176
	//_Func: public void DynamicWingController(const DynamicWingController & __that); @loc=static @len=111 @rva=2839024
	//_Func: public void DynamicWingController(const CarPhysicsState * state, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & carUnixName, INIReader & ini, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section); @loc=static @len=118 @rva=2793072
	//_Func: public void DynamicWingController(Car * car, INIReader & ini, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section); @loc=static @len=120 @rva=2792944
	//_Func: public void ~DynamicWingController(); @loc=static @len=9 @rva=1147056
	//_Tag 12
	//_Tag 12
	//_Data: this+0x0, Member, Type: float, outputAngle
	//_Data: this+0x4, Member, Type: float, upLimit
	//_Data: this+0x8, Member, Type: float, downLimit
	//_Data: this+0xC, Member, Type: enum DynamicWingController::eCombinatorMode, combinatorMode
	//_Func: public void step(); @loc=static @len=115 @rva=2796144
	//_Data: this+0x10, Member, Type: enum DynamicWingController::eInputVar, inputVar
	//_Data: this+0x18, Member, Type: class Curve, lut
	//_Data: this+0x98, Member, Type: float, filter
	//_Data: this+0xA0, Member, Type: const struct CarPhysicsState *, state
	//_Data: this+0xA8, Member, Type: class Car *, car
	//_Func: protected float getInput(); @loc=static @len=480 @rva=2793200
	//_Func: protected void initCommon(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & carUnixName, INIReader & ini, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section); @loc=static @len=2450 @rva=2793680
	//_Func: public DynamicWingController & operator=(const DynamicWingController &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct DynamicWingController {
public:
	float outputAngle;
	float upLimit;
	float downLimit;
	DynamicWingController_eCombinatorMode combinatorMode;
	DynamicWingController_eInputVar inputVar;
	Curve lut;
	float filter;
	const CarPhysicsState * state;
	Car * car;
	inline DynamicWingController() { }
	inline DynamicWingController(const DynamicWingController& other) = default;
	inline DynamicWingController& operator=(const DynamicWingController& other) = default;
	inline void ctor(const DynamicWingController & __that) { typedef void (DynamicWingController::*_fpt)(const DynamicWingController &); auto _f=xcast<_fpt>(_drva(2839024)); (this->*_f)(__that); }
	inline void ctor(const CarPhysicsState * state, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & carUnixName, INIReader & ini, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section) { typedef void (DynamicWingController::*_fpt)(const CarPhysicsState *, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, INIReader &, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2793072)); (this->*_f)(state, carUnixName, ini, section); }
	inline void ctor(Car * car, INIReader & ini, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section) { typedef void (DynamicWingController::*_fpt)(Car *, INIReader &, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2792944)); (this->*_f)(car, ini, section); }
	inline void dtor() { typedef void (DynamicWingController::*_fpt)(); auto _f=xcast<_fpt>(_drva(1147056)); (this->*_f)(); }
	inline void step() { typedef void (DynamicWingController::*_fpt)(); auto _f=xcast<_fpt>(_drva(2796144)); return (this->*_f)(); }
	inline float getInput() { typedef float (DynamicWingController::*_fpt)(); auto _f=xcast<_fpt>(_drva(2793200)); return (this->*_f)(); }
	inline void initCommon(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & carUnixName, INIReader & ini, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section) { typedef void (DynamicWingController::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, INIReader &, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2793680)); return (this->*_f)(carUnixName, ini, section); }
	inline void _guard_obj() {
		static_assert((sizeof(DynamicWingController)==176),"bad size");
		static_assert((offsetof(DynamicWingController,outputAngle)==0x0),"bad off");
		static_assert((offsetof(DynamicWingController,upLimit)==0x4),"bad off");
		static_assert((offsetof(DynamicWingController,downLimit)==0x8),"bad off");
		static_assert((offsetof(DynamicWingController,combinatorMode)==0xC),"bad off");
		static_assert((offsetof(DynamicWingController,inputVar)==0x10),"bad off");
		static_assert((offsetof(DynamicWingController,lut)==0x18),"bad off");
		static_assert((offsetof(DynamicWingController,filter)==0x98),"bad off");
		static_assert((offsetof(DynamicWingController,state)==0xA0),"bad off");
		static_assert((offsetof(DynamicWingController,car)==0xA8),"bad off");
	};
};

//UDT: class ksgui::TextInput @len=464 @vfcount=21
	//_Base: class ksgui::Control @off=0 @len=376
	//_Func: public void TextInput(const ksgui_TextInput &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void TextInput(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, ksgui_GUI * gui); @loc=static @len=579 @rva=2380560
	//_Func: public void ~TextInput(); @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Data: this+0x178, Member, Type: class vec4f, backColorFocus
	//_Data: this+0x188, Member, Type: class vec4f, backColorUnfocus
	//_Data: this+0x198, Member, Type: class Event<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, evValidate
	//_Data: this+0x1B0, Member, Type: class Event<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, evKeyDown
	//_Func: public bool onMouseDown(const OnMouseDownEvent & message); @virtual vtpo=0 vfid=10 @loc=static @len=26 @rva=2381536
	//_Func: public void render(float dt); @virtual vtpo=0 vfid=3 @loc=static @len=284 @rva=2381568
	//_Func: public void onKeyChar(unsigned int key); @virtual vtpo=0 vfid=14 @loc=static @len=266 @rva=2381264
	//_Func: public void onKeyDown(const OnKeyEvent & message); @virtual vtpo=0 vfid=15 @loc=static @len=3 @rva=96368
	//_Func: public void setFocus(bool  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void validateText(); @loc=static @len=109 @rva=2381856
	//_Data: this+0x1C8, Member, Type: bool, hasFocus
	//_Data: this+0x1CC, Member, Type: unsigned int, maxNumberOfChar
	//_Func: private bool hasSpaceToWrite(); @loc=optimized @len=0 @rva=0
	//_Func: public ksgui_TextInput & operator=(const ksgui_TextInput &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ksgui_TextInput : public ksgui_Control {
public:
	vec4f backColorFocus;
	vec4f backColorUnfocus;
	Event<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > evValidate;
	Event<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > evKeyDown;
	bool hasFocus;
	unsigned int maxNumberOfChar;
	inline ksgui_TextInput() { }
	inline ksgui_TextInput(const ksgui_TextInput& other) = default;
	inline ksgui_TextInput& operator=(const ksgui_TextInput& other) = default;
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, ksgui_GUI * gui) { typedef void (ksgui_TextInput::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, ksgui_GUI *); auto _f=xcast<_fpt>(_drva(2380560)); (this->*_f)(name, gui); }
	virtual ~ksgui_TextInput();
	virtual bool onMouseDown_vf10(const OnMouseDownEvent & message);
	inline bool onMouseDown_impl(const OnMouseDownEvent & message) { typedef bool (ksgui_TextInput::*_fpt)(const OnMouseDownEvent &); auto _f=xcast<_fpt>(_drva(2381536)); return (this->*_f)(message); }
	inline bool onMouseDown(const OnMouseDownEvent & message) { typedef bool (ksgui_TextInput::*_fpt)(const OnMouseDownEvent &); auto _f=xcast<_fpt>(get_vfp(this, 10)); return (this->*_f)(message); }
	virtual void render_vf3(float dt);
	inline void render_impl(float dt) { typedef void (ksgui_TextInput::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2381568)); return (this->*_f)(dt); }
	inline void render(float dt) { typedef void (ksgui_TextInput::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(dt); }
	virtual void onKeyChar_vf14(unsigned int key);
	inline void onKeyChar_impl(unsigned int key) { typedef void (ksgui_TextInput::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(2381264)); return (this->*_f)(key); }
	inline void onKeyChar(unsigned int key) { typedef void (ksgui_TextInput::*_fpt)(unsigned int); auto _f=xcast<_fpt>(get_vfp(this, 14)); return (this->*_f)(key); }
	virtual void onKeyDown_vf15(const OnKeyEvent & message);
	inline void onKeyDown_impl(const OnKeyEvent & message) { typedef void (ksgui_TextInput::*_fpt)(const OnKeyEvent &); auto _f=xcast<_fpt>(_drva(96368)); return (this->*_f)(message); }
	inline void onKeyDown(const OnKeyEvent & message) { typedef void (ksgui_TextInput::*_fpt)(const OnKeyEvent &); auto _f=xcast<_fpt>(get_vfp(this, 15)); return (this->*_f)(message); }
	inline void validateText() { typedef void (ksgui_TextInput::*_fpt)(); auto _f=xcast<_fpt>(_drva(2381856)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_TextInput)==464),"bad size");
		static_assert((offsetof(ksgui_TextInput,backColorFocus)==0x178),"bad off");
		static_assert((offsetof(ksgui_TextInput,backColorUnfocus)==0x188),"bad off");
		static_assert((offsetof(ksgui_TextInput,evValidate)==0x198),"bad off");
		static_assert((offsetof(ksgui_TextInput,evKeyDown)==0x1B0),"bad off");
		static_assert((offsetof(ksgui_TextInput,hasFocus)==0x1C8),"bad off");
		static_assert((offsetof(ksgui_TextInput,maxNumberOfChar)==0x1CC),"bad off");
	};
};

//UDT: class CameraOnBoardFree @len=432 @vfcount=6
	//_Base: class CinematicFreeCamera @off=0 @len=304
	//_Func: public void CameraOnBoardFree(const CameraOnBoardFree &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void CameraOnBoardFree(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, Camera * a_camera, Sim * a_sim); @loc=static @len=2289 @rva=1134848
	//_Func: public void ~CameraOnBoardFree(); @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Data: this+0x130, Member, Type: bool, lockCamera
	//_Func: public void update(float dt); @virtual vtpo=0 vfid=1 @loc=static @len=1369 @rva=1138096
	//_Func: public bool isInEscMode(); @loc=optimized @len=0 @rva=0
	//_Func: public void setIntroMode(bool value); @loc=static @len=7 @rva=1137792
	//_Func: public void setPosition(const vec3f & pos); @loc=static @len=27 @rva=1697728
	//_Func: public vec3f updateSphericalCoord(float deltaT); @loc=static @len=289 @rva=1140704
	//_Func: public void forceThetaPhi(float aTheta, float aPhi, float aRadius); @loc=static @len=31 @rva=1137552
	//_Data: this+0x138, Member, Type: struct CameraValue *, theta
	//_Data: this+0x140, Member, Type: struct CameraValue *, phi
	//_Data: this+0x148, Member, Type: float, radius
	//_Data: this+0x14C, Member, Type: float, minimumRadius
	//_Data: this+0x150, Member, Type: float, maximumRadius
	//_Data: this+0x154, Member, Type: bool, useSphericalCoords
	//_Data: this+0x158, Member, Type: class mat44f, matrix
	//_Data: this+0x198, Member, Type: class Sim *, sim
	//_Data: this+0x1A0, Member, Type: bool, isEscMode
	//_Data: this+0x1A4, Member, Type: float, escModeDOFFactor
	//_Data: this+0x1A8, Member, Type: float, rotationSpeed
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class CameraOnBoardFree : public CinematicFreeCamera {
public:
	bool lockCamera;
	CameraValue * theta;
	CameraValue * phi;
	float radius;
	float minimumRadius;
	float maximumRadius;
	bool useSphericalCoords;
	mat44f matrix;
	Sim * sim;
	bool isEscMode;
	float escModeDOFFactor;
	float rotationSpeed;
	inline CameraOnBoardFree() { }
	inline CameraOnBoardFree(const CameraOnBoardFree& other) = default;
	inline CameraOnBoardFree& operator=(const CameraOnBoardFree& other) = default;
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, Camera * a_camera, Sim * a_sim) { typedef void (CameraOnBoardFree::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, Camera *, Sim *); auto _f=xcast<_fpt>(_drva(1134848)); (this->*_f)(name, a_camera, a_sim); }
	virtual ~CameraOnBoardFree();
	virtual void update_vf1(float dt);
	inline void update_impl(float dt) { typedef void (CameraOnBoardFree::*_fpt)(float); auto _f=xcast<_fpt>(_drva(1138096)); return (this->*_f)(dt); }
	inline void update(float dt) { typedef void (CameraOnBoardFree::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(dt); }
	inline void setIntroMode(bool value) { typedef void (CameraOnBoardFree::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(1137792)); return (this->*_f)(value); }
	inline void setPosition(const vec3f & pos) { typedef void (CameraOnBoardFree::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(1697728)); return (this->*_f)(pos); }
	inline vec3f updateSphericalCoord(float deltaT) { typedef vec3f (CameraOnBoardFree::*_fpt)(float); auto _f=xcast<_fpt>(_drva(1140704)); return (this->*_f)(deltaT); }
	inline void forceThetaPhi(float aTheta, float aPhi, float aRadius) { typedef void (CameraOnBoardFree::*_fpt)(float, float, float); auto _f=xcast<_fpt>(_drva(1137552)); return (this->*_f)(aTheta, aPhi, aRadius); }
	inline void _guard_obj() {
		static_assert((sizeof(CameraOnBoardFree)==432),"bad size");
		static_assert((offsetof(CameraOnBoardFree,lockCamera)==0x130),"bad off");
		static_assert((offsetof(CameraOnBoardFree,theta)==0x138),"bad off");
		static_assert((offsetof(CameraOnBoardFree,phi)==0x140),"bad off");
		static_assert((offsetof(CameraOnBoardFree,radius)==0x148),"bad off");
		static_assert((offsetof(CameraOnBoardFree,minimumRadius)==0x14C),"bad off");
		static_assert((offsetof(CameraOnBoardFree,maximumRadius)==0x150),"bad off");
		static_assert((offsetof(CameraOnBoardFree,useSphericalCoords)==0x154),"bad off");
		static_assert((offsetof(CameraOnBoardFree,matrix)==0x158),"bad off");
		static_assert((offsetof(CameraOnBoardFree,sim)==0x198),"bad off");
		static_assert((offsetof(CameraOnBoardFree,isEscMode)==0x1A0),"bad off");
		static_assert((offsetof(CameraOnBoardFree,escModeDOFFactor)==0x1A4),"bad off");
		static_assert((offsetof(CameraOnBoardFree,rotationSpeed)==0x1A8),"bad off");
	};
};

//UDT: class ksgui::ListBoxRow @len=424 @vfcount=21
	//_Base: class ksgui::Control @off=0 @len=376
	//_Func: public void ListBoxRow(const ksgui_ListBoxRow &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void ListBoxRow(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, unsigned int numberOfColumns, ksgui_GUI * aGui); @loc=static @len=1007 @rva=2448848
	//_Func: public void ~ListBoxRow(); @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Data: this+0x178, Member, Type: class vec4f, rowBackground
	//_Data: this+0x188, Member, Type: int, id
	//_Data: this+0x18C, Member, Type: bool, drawRowBackground
	//_Func: public unsigned int getColumnCount(); @loc=optimized @len=0 @rva=0
	//_Func: public void setSize(float width, float height); @virtual vtpo=0 vfid=7 @loc=static @len=216 @rva=2451392
	//_Func: public void setPosition(float x, float y); @loc=static @len=202 @rva=2450864
	//_Func: public void setRow(ksgui_ListBoxRowData * data); @loc=static @len=308 @rva=2451072
	//_Func: public void setColor(vec4f  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void setColor(vec4f  _arg0, unsigned int  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public void setFontSize(float size); @loc=static @len=75 @rva=2450784
	//_Func: public void clear(); @loc=static @len=225 @rva=2449984
	//_Func: public void setFontAlignment(unsigned int  _arg0, eFontAlign  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public void setFontAlignment(eFontAlign alignment); @loc=static @len=70 @rva=2450704
	//_Func: public ksgui_Label * getColumn(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void render(float dt); @virtual vtpo=0 vfid=3 @loc=static @len=332 @rva=2450368
	//_Data: this+0x190, Member, Type: class std::vector<ksgui::Label *,std::allocator<ksgui::Label *> >, columns
	//_Func: public ksgui_ListBoxRow & operator=(const ksgui_ListBoxRow &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ksgui_ListBoxRow : public ksgui_Control {
public:
	vec4f rowBackground;
	int id;
	bool drawRowBackground;
	std::vector<ksgui_Label *,std::allocator<ksgui_Label *> > columns;
	inline ksgui_ListBoxRow() { }
	inline ksgui_ListBoxRow(const ksgui_ListBoxRow& other) = default;
	inline ksgui_ListBoxRow& operator=(const ksgui_ListBoxRow& other) = default;
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, unsigned int numberOfColumns, ksgui_GUI * aGui) { typedef void (ksgui_ListBoxRow::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, unsigned int, ksgui_GUI *); auto _f=xcast<_fpt>(_drva(2448848)); (this->*_f)(name, numberOfColumns, aGui); }
	virtual ~ksgui_ListBoxRow();
	virtual void setSize_vf7(float width, float height);
	inline void setSize_impl(float width, float height) { typedef void (ksgui_ListBoxRow::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2451392)); return (this->*_f)(width, height); }
	inline void setSize(float width, float height) { typedef void (ksgui_ListBoxRow::*_fpt)(float, float); auto _f=xcast<_fpt>(get_vfp(this, 7)); return (this->*_f)(width, height); }
	inline void setPosition(float x, float y) { typedef void (ksgui_ListBoxRow::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2450864)); return (this->*_f)(x, y); }
	inline void setRow(ksgui_ListBoxRowData * data) { typedef void (ksgui_ListBoxRow::*_fpt)(ksgui_ListBoxRowData *); auto _f=xcast<_fpt>(_drva(2451072)); return (this->*_f)(data); }
	inline void setFontSize(float size) { typedef void (ksgui_ListBoxRow::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2450784)); return (this->*_f)(size); }
	inline void clear() { typedef void (ksgui_ListBoxRow::*_fpt)(); auto _f=xcast<_fpt>(_drva(2449984)); return (this->*_f)(); }
	inline void setFontAlignment(eFontAlign alignment) { typedef void (ksgui_ListBoxRow::*_fpt)(eFontAlign); auto _f=xcast<_fpt>(_drva(2450704)); return (this->*_f)(alignment); }
	virtual void render_vf3(float dt);
	inline void render_impl(float dt) { typedef void (ksgui_ListBoxRow::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2450368)); return (this->*_f)(dt); }
	inline void render(float dt) { typedef void (ksgui_ListBoxRow::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(dt); }
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_ListBoxRow)==424),"bad size");
		static_assert((offsetof(ksgui_ListBoxRow,rowBackground)==0x178),"bad off");
		static_assert((offsetof(ksgui_ListBoxRow,id)==0x188),"bad off");
		static_assert((offsetof(ksgui_ListBoxRow,drawRowBackground)==0x18C),"bad off");
		static_assert((offsetof(ksgui_ListBoxRow,columns)==0x190),"bad off");
	};
};

//UDT: class ksgui::ActiveButton @len=576 @vfcount=21
	//_Base: class ksgui::Control @off=0 @len=376
	//_Func: public void ActiveButton(const ksgui_ActiveButton &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void ActiveButton(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, ksgui_GUI * gui); @loc=static @len=594 @rva=2404704
	//_Func: public void ~ActiveButton(); @virtual vtpo=0 vfid=0 @loc=static @len=120 @rva=2405312
	//_Data: this+0x178, Member, Type: class vec2f, textCoord
	//_Data: this+0x180, Member, Type: class vec4f, unselectedColor
	//_Data: this+0x190, Member, Type: class vec4f, selectedColor
	//_Data: this+0x1A0, Member, Type: class vec4f, rollOnColor
	//_Data: this+0x1B0, Member, Type: class vec4f, inactiveColor
	//_Data: this+0x1C0, Member, Type: enum ksgui::eActiveButtonStates, status
	//_Data: this+0x1C4, Member, Type: bool, blanked
	//_Data: this+0x1C5, Member, Type: bool, highlightOnCursorOver
	//_Data: this+0x1C6, Member, Type: bool, isActive
	//_Func: public void setMultipleTexture(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * filename); @loc=static @len=894 @rva=2406144
	//_Func: public void render(float dt); @virtual vtpo=0 vfid=3 @loc=static @len=489 @rva=2405648
	//_Func: public void onMouseMove(const OnMouseMoveEvent & message); @virtual vtpo=0 vfid=12 @loc=static @len=130 @rva=2405488
	//_Func: public void select(); @loc=optimized @len=0 @rva=0
	//_Func: public void deselect(); @loc=optimized @len=0 @rva=0
	//_Func: public void setSelected(bool value); @loc=static @len=17 @rva=2407040
	//_Func: public bool isSelected(); @loc=optimized @len=0 @rva=0
	//_Func: public void onVisibleChanged(bool newValue); @virtual vtpo=0 vfid=8 @loc=static @len=11 @rva=2405632
	//_Func: public void setText(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & aText); @virtual vtpo=0 vfid=17 @loc=static @len=25 @rva=2407072
	//_Func: public void setUsingMultipleTexture(bool  _arg0); @loc=optimized @len=0 @rva=0
	//_Data: this+0x1C8, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, activeButtonText
	//_Data: this+0x1E8, Member, Type: bool, selected
	//_Data: this+0x1E9, Member, Type: bool, usingMultipleTextures
	//_Data: this+0x1EC, Member, Type: enum ksgui::eActiveButtonStates, oldStatus
	//_Data: this+0x1F0, Member, Type: class Texture, textureOn
	//_Data: this+0x218, Member, Type: class Texture, textureOff
	//_Func: public ksgui_ActiveButton & operator=(const ksgui_ActiveButton &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ksgui_ActiveButton : public ksgui_Control {
public:
	vec2f textCoord;
	vec4f unselectedColor;
	vec4f selectedColor;
	vec4f rollOnColor;
	vec4f inactiveColor;
	ksgui_eActiveButtonStates status;
	bool blanked;
	bool highlightOnCursorOver;
	bool isActive;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > activeButtonText;
	bool selected;
	bool usingMultipleTextures;
	ksgui_eActiveButtonStates oldStatus;
	Texture textureOn;
	Texture textureOff;
	inline ksgui_ActiveButton() { }
	inline ksgui_ActiveButton(const ksgui_ActiveButton& other) = default;
	inline ksgui_ActiveButton& operator=(const ksgui_ActiveButton& other) = default;
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, ksgui_GUI * gui) { typedef void (ksgui_ActiveButton::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, ksgui_GUI *); auto _f=xcast<_fpt>(_drva(2404704)); (this->*_f)(name, gui); }
	virtual ~ksgui_ActiveButton();
	inline void dtor() { typedef void (ksgui_ActiveButton::*_fpt)(); auto _f=xcast<_fpt>(_drva(2405312)); (this->*_f)(); }
	inline void setMultipleTexture(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * filename) { typedef void (ksgui_ActiveButton::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *); auto _f=xcast<_fpt>(_drva(2406144)); return (this->*_f)(filename); }
	virtual void render_vf3(float dt);
	inline void render_impl(float dt) { typedef void (ksgui_ActiveButton::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2405648)); return (this->*_f)(dt); }
	inline void render(float dt) { typedef void (ksgui_ActiveButton::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(dt); }
	virtual void onMouseMove_vf12(const OnMouseMoveEvent & message);
	inline void onMouseMove_impl(const OnMouseMoveEvent & message) { typedef void (ksgui_ActiveButton::*_fpt)(const OnMouseMoveEvent &); auto _f=xcast<_fpt>(_drva(2405488)); return (this->*_f)(message); }
	inline void onMouseMove(const OnMouseMoveEvent & message) { typedef void (ksgui_ActiveButton::*_fpt)(const OnMouseMoveEvent &); auto _f=xcast<_fpt>(get_vfp(this, 12)); return (this->*_f)(message); }
	inline void setSelected(bool value) { typedef void (ksgui_ActiveButton::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(2407040)); return (this->*_f)(value); }
	virtual void onVisibleChanged_vf8(bool newValue);
	inline void onVisibleChanged_impl(bool newValue) { typedef void (ksgui_ActiveButton::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(2405632)); return (this->*_f)(newValue); }
	inline void onVisibleChanged(bool newValue) { typedef void (ksgui_ActiveButton::*_fpt)(bool); auto _f=xcast<_fpt>(get_vfp(this, 8)); return (this->*_f)(newValue); }
	virtual void setText_vf17(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & aText);
	inline void setText_impl(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & aText) { typedef void (ksgui_ActiveButton::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2407072)); return (this->*_f)(aText); }
	inline void setText(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & aText) { typedef void (ksgui_ActiveButton::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(get_vfp(this, 17)); return (this->*_f)(aText); }
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_ActiveButton)==576),"bad size");
		static_assert((offsetof(ksgui_ActiveButton,textCoord)==0x178),"bad off");
		static_assert((offsetof(ksgui_ActiveButton,unselectedColor)==0x180),"bad off");
		static_assert((offsetof(ksgui_ActiveButton,selectedColor)==0x190),"bad off");
		static_assert((offsetof(ksgui_ActiveButton,rollOnColor)==0x1A0),"bad off");
		static_assert((offsetof(ksgui_ActiveButton,inactiveColor)==0x1B0),"bad off");
		static_assert((offsetof(ksgui_ActiveButton,status)==0x1C0),"bad off");
		static_assert((offsetof(ksgui_ActiveButton,blanked)==0x1C4),"bad off");
		static_assert((offsetof(ksgui_ActiveButton,highlightOnCursorOver)==0x1C5),"bad off");
		static_assert((offsetof(ksgui_ActiveButton,isActive)==0x1C6),"bad off");
		static_assert((offsetof(ksgui_ActiveButton,activeButtonText)==0x1C8),"bad off");
		static_assert((offsetof(ksgui_ActiveButton,selected)==0x1E8),"bad off");
		static_assert((offsetof(ksgui_ActiveButton,usingMultipleTextures)==0x1E9),"bad off");
		static_assert((offsetof(ksgui_ActiveButton,oldStatus)==0x1EC),"bad off");
		static_assert((offsetof(ksgui_ActiveButton,textureOn)==0x1F0),"bad off");
		static_assert((offsetof(ksgui_ActiveButton,textureOff)==0x218),"bad off");
	};
};

//UDT: class ksgui::MovingBar @len=512 @vfcount=21
	//_Base: class ksgui::Control @off=0 @len=376
	//_Func: public void MovingBar(const ksgui_MovingBar &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void MovingBar(ksgui_ScrollBar * scrollBar, ksgui_GUI * aGui); @loc=static @len=755 @rva=2468704
	//_Func: public void ~MovingBar(); @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Func: public bool onMouseDown(const OnMouseDownEvent & message); @virtual vtpo=0 vfid=10 @loc=static @len=160 @rva=2471936
	//_Func: public void onMouseMove(const OnMouseMoveEvent & message); @virtual vtpo=0 vfid=12 @loc=static @len=383 @rva=2472112
	//_Func: public void onMouseUp(const OnMouseUpEvent & message); @virtual vtpo=0 vfid=11 @loc=static @len=12 @rva=2472640
	//_Func: public void render(float dt); @virtual vtpo=0 vfid=3 @loc=static @len=391 @rva=2472912
	//_Data: this+0x178, Member, Type: class ksgui::ScrollBar *, sb
	//_Data: this+0x180, Member, Type: class Texture, upperTexture
	//_Data: this+0x1A8, Member, Type: class Texture, lowerTexture
	//_Data: this+0x1D0, Member, Type: class Texture, middleTexture
	//_Data: this+0x1F8, Member, Type: class vec2f, pressingPoint
	//_Func: private vec2f getCenter(); @loc=optimized @len=0 @rva=0
	//_Func: public ksgui_MovingBar & operator=(const ksgui_MovingBar &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ksgui_MovingBar : public ksgui_Control {
public:
	ksgui_ScrollBar * sb;
	Texture upperTexture;
	Texture lowerTexture;
	Texture middleTexture;
	vec2f pressingPoint;
	inline ksgui_MovingBar() { }
	inline ksgui_MovingBar(const ksgui_MovingBar& other) = default;
	inline ksgui_MovingBar& operator=(const ksgui_MovingBar& other) = default;
	inline void ctor(ksgui_ScrollBar * scrollBar, ksgui_GUI * aGui) { typedef void (ksgui_MovingBar::*_fpt)(ksgui_ScrollBar *, ksgui_GUI *); auto _f=xcast<_fpt>(_drva(2468704)); (this->*_f)(scrollBar, aGui); }
	virtual ~ksgui_MovingBar();
	virtual bool onMouseDown_vf10(const OnMouseDownEvent & message);
	inline bool onMouseDown_impl(const OnMouseDownEvent & message) { typedef bool (ksgui_MovingBar::*_fpt)(const OnMouseDownEvent &); auto _f=xcast<_fpt>(_drva(2471936)); return (this->*_f)(message); }
	inline bool onMouseDown(const OnMouseDownEvent & message) { typedef bool (ksgui_MovingBar::*_fpt)(const OnMouseDownEvent &); auto _f=xcast<_fpt>(get_vfp(this, 10)); return (this->*_f)(message); }
	virtual void onMouseMove_vf12(const OnMouseMoveEvent & message);
	inline void onMouseMove_impl(const OnMouseMoveEvent & message) { typedef void (ksgui_MovingBar::*_fpt)(const OnMouseMoveEvent &); auto _f=xcast<_fpt>(_drva(2472112)); return (this->*_f)(message); }
	inline void onMouseMove(const OnMouseMoveEvent & message) { typedef void (ksgui_MovingBar::*_fpt)(const OnMouseMoveEvent &); auto _f=xcast<_fpt>(get_vfp(this, 12)); return (this->*_f)(message); }
	virtual void onMouseUp_vf11(const OnMouseUpEvent & message);
	inline void onMouseUp_impl(const OnMouseUpEvent & message) { typedef void (ksgui_MovingBar::*_fpt)(const OnMouseUpEvent &); auto _f=xcast<_fpt>(_drva(2472640)); return (this->*_f)(message); }
	inline void onMouseUp(const OnMouseUpEvent & message) { typedef void (ksgui_MovingBar::*_fpt)(const OnMouseUpEvent &); auto _f=xcast<_fpt>(get_vfp(this, 11)); return (this->*_f)(message); }
	virtual void render_vf3(float dt);
	inline void render_impl(float dt) { typedef void (ksgui_MovingBar::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2472912)); return (this->*_f)(dt); }
	inline void render(float dt) { typedef void (ksgui_MovingBar::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(dt); }
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_MovingBar)==512),"bad size");
		static_assert((offsetof(ksgui_MovingBar,sb)==0x178),"bad off");
		static_assert((offsetof(ksgui_MovingBar,upperTexture)==0x180),"bad off");
		static_assert((offsetof(ksgui_MovingBar,lowerTexture)==0x1A8),"bad off");
		static_assert((offsetof(ksgui_MovingBar,middleTexture)==0x1D0),"bad off");
		static_assert((offsetof(ksgui_MovingBar,pressingPoint)==0x1F8),"bad off");
	};
};

//UDT: class RigidBodyODE @len=72 @vfcount=42
	//_Base: class IRigidBody @off=0 @len=8
	//_Func: public void RigidBodyODE(const RigidBodyODE &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void RigidBodyODE(PhysicsCore * core); @loc=static @len=138 @rva=2938880
	//_Func: public void ~RigidBodyODE(); @virtual vtpo=0 vfid=41 @loc=static @len=139 @rva=2939104
	//_Data: this+0x8, Member, Type: struct dxBody *, id
	//_Data: this+0x10, Member, Type: class std::vector<dxGeom *,std::allocator<dxGeom *> >, geoms
	//_Func: public void setAutoDisable(bool mode); @virtual vtpo=0 vfid=3 @loc=static @len=25 @rva=2943040
	//_Func: public void setAngularVelocity(const vec3f & vel); @virtual vtpo=0 vfid=17 @loc=static @len=23 @rva=2943008
	//_Func: public void removeCollisionObjects(); @virtual vtpo=0 vfid=4 @loc=static @len=3 @rva=96368
	//_Func: public float getMass(); @virtual vtpo=0 vfid=5 @loc=static @len=45 @rva=2942320
	//_Func: public void release(); @virtual vtpo=0 vfid=6 @loc=static @len=21 @rva=2942976
	//_Func: public void setMassExplicitInertia(float totalMass, float x, float y, float z); @virtual vtpo=0 vfid=0 @loc=static @len=136 @rva=2943248
	//_Func: public void setMassBox(float m, float x, float y, float z); @virtual vtpo=0 vfid=7 @loc=static @len=124 @rva=2943120
	//_Func: public vec3f getLocalInertia(); @virtual vtpo=0 vfid=8 @loc=static @len=89 @rva=2942080
	//_Func: public mat44f getWorldMatrix(float interpolationT); @virtual vtpo=0 vfid=9 @loc=static @len=154 @rva=2942656
	//_Func: public vec3f localToWorld(const vec3f & p); @virtual vtpo=0 vfid=10 @loc=static @len=57 @rva=2942848
	//_Func: public vec3f worldToLocal(const vec3f & p); @virtual vtpo=0 vfid=11 @loc=static @len=57 @rva=2943792
	//_Func: public vec3f localToWorldNormal(const vec3f & p); @virtual vtpo=0 vfid=12 @loc=static @len=57 @rva=2942912
	//_Func: public vec3f worldToLocalNormal(const vec3f & p); @virtual vtpo=0 vfid=13 @loc=static @len=57 @rva=2943856
	//_Func: public void stop(float amount); @virtual vtpo=0 vfid=14 @loc=static @len=86 @rva=2943696
	//_Func: public vec3f getVelocity(); @virtual vtpo=0 vfid=15 @loc=static @len=49 @rva=2942592
	//_Func: public void setVelocity(const vec3f & vel); @virtual vtpo=0 vfid=16 @loc=static @len=23 @rva=2943664
	//_Func: public void setPosition(const vec3f & pos); @virtual vtpo=0 vfid=18 @loc=static @len=23 @rva=2943456
	//_Func: public void setRotation(const mat44f & mat); @virtual vtpo=0 vfid=19 @loc=static @len=149 @rva=2943488
	//_Func: public vec3f getPosition(float interpolationT); @virtual vtpo=0 vfid=20 @loc=static @len=43 @rva=2942528
	//_Func: public vec3f getAngularVelocity(); @virtual vtpo=0 vfid=21 @loc=static @len=43 @rva=2941936
	//_Func: public vec3f getLocalAngularVelocity(); @virtual vtpo=0 vfid=22 @loc=static @len=66 @rva=2942000
	//_Func: public vec3f getLocalVelocity(); @virtual vtpo=0 vfid=23 @loc=static @len=63 @rva=2942240
	//_Func: public void setBoxColliderMask(unsigned __int64 box, unsigned long mask); @virtual vtpo=0 vfid=24 @loc=static @len=11 @rva=2943072
	//_Func: public unsigned __int64 addBoxCollider(const vec3f & pos, const vec3f & size, unsigned int category, unsigned long mask, unsigned int spaceId); @virtual vtpo=0 vfid=25 @loc=static @len=291 @rva=2940336
	//_Func: public void addSphereCollider(const vec3f & pos, float radius, unsigned int group, ISphereCollisionCallback * callback); @virtual vtpo=0 vfid=26 @loc=static @len=3 @rva=96368
	//_Func: public void addLocalForce(const vec3f & f); @virtual vtpo=0 vfid=27 @loc=static @len=53 @rva=2940800
	//_Func: public void addLocalTorque(const vec3f & t); @virtual vtpo=0 vfid=28 @loc=static @len=23 @rva=2941024
	//_Func: public void addLocalForceAtPos(const vec3f & f, const vec3f & p); @virtual vtpo=0 vfid=29 @loc=static @len=67 @rva=2940944
	//_Func: public void addLocalForceAtLocalPos(const vec3f & f, const vec3f & p); @virtual vtpo=0 vfid=30 @loc=static @len=67 @rva=2940864
	//_Func: public void addForceAtLocalPos(const vec3f & f, const vec3f & p); @virtual vtpo=0 vfid=31 @loc=static @len=67 @rva=2940640
	//_Func: public vec3f getLocalPointVelocity(const vec3f & p); @virtual vtpo=0 vfid=32 @loc=static @len=57 @rva=2942176
	//_Func: public vec3f getPointVelocity(const vec3f & p); @virtual vtpo=0 vfid=33 @loc=static @len=57 @rva=2942464
	//_Func: public void addForceAtPos(const vec3f & f, const vec3f & p); @virtual vtpo=0 vfid=34 @loc=static @len=67 @rva=2940720
	//_Func: public void addTorque(const vec3f & t); @virtual vtpo=0 vfid=35 @loc=static @len=23 @rva=2941904
	//_Func: public void addMeshCollider(float * vertices, unsigned int verticesCount, unsigned short * indices, unsigned int indicesCount, mat44f * mat, unsigned long category, unsigned long collideMask, unsigned int spaceId); @virtual vtpo=0 vfid=0 @loc=static @len=837 @rva=2941056
	//_Func: public void setMeshCollideCategory(unsigned int meshIndex, unsigned long category); @virtual vtpo=0 vfid=37 @loc=static @len=25 @rva=2943392
	//_Func: public void setMeshCollideMask(unsigned int meshIndex, unsigned long mask); @virtual vtpo=0 vfid=38 @loc=static @len=25 @rva=2943424
	//_Func: public unsigned long getMeshCollideCategory(unsigned int meshIndex); @virtual vtpo=0 vfid=39 @loc=static @len=45 @rva=2942368
	//_Func: public unsigned long getMeshCollideMask(unsigned int meshIndex); @virtual vtpo=0 vfid=40 @loc=static @len=45 @rva=2942416
	//_Func: public bool isEnabled(); @virtual vtpo=0 vfid=1 @loc=static @len=23 @rva=2942816
	//_Func: public void setEnabled(bool value); @virtual vtpo=0 vfid=2 @loc=static @len=17 @rva=2943088
	//_Data: this+0x28, Member, Type: class PhysicsCore *, core
	//_Data: this+0x30, Member, Type: class std::vector<std::shared_ptr<BodyCollisionMesh>,std::allocator<std::shared_ptr<BodyCollisionMesh> > >, collisionMeshes
	//_Func: public RigidBodyODE & operator=(const RigidBodyODE &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=41 @loc=optimized @len=0 @rva=0
//UDT;

class RigidBodyODE : public IRigidBody {
public:
	dxBody * id;
	std::vector<dxGeom *,std::allocator<dxGeom *> > geoms;
	PhysicsCore * core;
	std::vector<std::shared_ptr<BodyCollisionMesh>,std::allocator<std::shared_ptr<BodyCollisionMesh> > > collisionMeshes;
	inline RigidBodyODE() { }
	inline RigidBodyODE(const RigidBodyODE& other) = default;
	inline RigidBodyODE& operator=(const RigidBodyODE& other) = default;
	inline void ctor(PhysicsCore * core) { typedef void (RigidBodyODE::*_fpt)(PhysicsCore *); auto _f=xcast<_fpt>(_drva(2938880)); (this->*_f)(core); }
	virtual ~RigidBodyODE();
	inline void dtor() { typedef void (RigidBodyODE::*_fpt)(); auto _f=xcast<_fpt>(_drva(2939104)); (this->*_f)(); }
	virtual void setAutoDisable_vf3(bool mode);
	inline void setAutoDisable_impl(bool mode) { typedef void (RigidBodyODE::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(2943040)); return (this->*_f)(mode); }
	inline void setAutoDisable(bool mode) { typedef void (RigidBodyODE::*_fpt)(bool); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(mode); }
	virtual void setAngularVelocity_vf17(const vec3f & vel);
	inline void setAngularVelocity_impl(const vec3f & vel) { typedef void (RigidBodyODE::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2943008)); return (this->*_f)(vel); }
	inline void setAngularVelocity(const vec3f & vel) { typedef void (RigidBodyODE::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 17)); return (this->*_f)(vel); }
	virtual void removeCollisionObjects_vf4();
	inline void removeCollisionObjects_impl() { typedef void (RigidBodyODE::*_fpt)(); auto _f=xcast<_fpt>(_drva(96368)); return (this->*_f)(); }
	inline void removeCollisionObjects() { typedef void (RigidBodyODE::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 4)); return (this->*_f)(); }
	virtual float getMass_vf5();
	inline float getMass_impl() { typedef float (RigidBodyODE::*_fpt)(); auto _f=xcast<_fpt>(_drva(2942320)); return (this->*_f)(); }
	inline float getMass() { typedef float (RigidBodyODE::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 5)); return (this->*_f)(); }
	virtual void release_vf6();
	inline void release_impl() { typedef void (RigidBodyODE::*_fpt)(); auto _f=xcast<_fpt>(_drva(2942976)); return (this->*_f)(); }
	inline void release() { typedef void (RigidBodyODE::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 6)); return (this->*_f)(); }
	virtual void setMassExplicitInertia_vf0(float totalMass, float x, float y, float z);
	inline void setMassExplicitInertia_impl(float totalMass, float x, float y, float z) { typedef void (RigidBodyODE::*_fpt)(float, float, float, float); auto _f=xcast<_fpt>(_drva(2943248)); return (this->*_f)(totalMass, x, y, z); }
	inline void setMassExplicitInertia(float totalMass, float x, float y, float z) { typedef void (RigidBodyODE::*_fpt)(float, float, float, float); auto _f=xcast<_fpt>(get_vfp(this, 0)); return (this->*_f)(totalMass, x, y, z); }
	virtual void setMassBox_vf7(float m, float x, float y, float z);
	inline void setMassBox_impl(float m, float x, float y, float z) { typedef void (RigidBodyODE::*_fpt)(float, float, float, float); auto _f=xcast<_fpt>(_drva(2943120)); return (this->*_f)(m, x, y, z); }
	inline void setMassBox(float m, float x, float y, float z) { typedef void (RigidBodyODE::*_fpt)(float, float, float, float); auto _f=xcast<_fpt>(get_vfp(this, 7)); return (this->*_f)(m, x, y, z); }
	virtual vec3f getLocalInertia_vf8();
	inline vec3f getLocalInertia_impl() { typedef vec3f (RigidBodyODE::*_fpt)(); auto _f=xcast<_fpt>(_drva(2942080)); return (this->*_f)(); }
	inline vec3f getLocalInertia() { typedef vec3f (RigidBodyODE::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 8)); return (this->*_f)(); }
	virtual mat44f getWorldMatrix_vf9(float interpolationT);
	inline mat44f getWorldMatrix_impl(float interpolationT) { typedef mat44f (RigidBodyODE::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2942656)); return (this->*_f)(interpolationT); }
	inline mat44f getWorldMatrix(float interpolationT) { typedef mat44f (RigidBodyODE::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 9)); return (this->*_f)(interpolationT); }
	virtual vec3f localToWorld_vf10(const vec3f & p);
	inline vec3f localToWorld_impl(const vec3f & p) { typedef vec3f (RigidBodyODE::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2942848)); return (this->*_f)(p); }
	inline vec3f localToWorld(const vec3f & p) { typedef vec3f (RigidBodyODE::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 10)); return (this->*_f)(p); }
	virtual vec3f worldToLocal_vf11(const vec3f & p);
	inline vec3f worldToLocal_impl(const vec3f & p) { typedef vec3f (RigidBodyODE::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2943792)); return (this->*_f)(p); }
	inline vec3f worldToLocal(const vec3f & p) { typedef vec3f (RigidBodyODE::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 11)); return (this->*_f)(p); }
	virtual vec3f localToWorldNormal_vf12(const vec3f & p);
	inline vec3f localToWorldNormal_impl(const vec3f & p) { typedef vec3f (RigidBodyODE::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2942912)); return (this->*_f)(p); }
	inline vec3f localToWorldNormal(const vec3f & p) { typedef vec3f (RigidBodyODE::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 12)); return (this->*_f)(p); }
	virtual vec3f worldToLocalNormal_vf13(const vec3f & p);
	inline vec3f worldToLocalNormal_impl(const vec3f & p) { typedef vec3f (RigidBodyODE::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2943856)); return (this->*_f)(p); }
	inline vec3f worldToLocalNormal(const vec3f & p) { typedef vec3f (RigidBodyODE::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 13)); return (this->*_f)(p); }
	virtual void stop_vf14(float amount);
	inline void stop_impl(float amount) { typedef void (RigidBodyODE::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2943696)); return (this->*_f)(amount); }
	inline void stop(float amount) { typedef void (RigidBodyODE::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 14)); return (this->*_f)(amount); }
	virtual vec3f getVelocity_vf15();
	inline vec3f getVelocity_impl() { typedef vec3f (RigidBodyODE::*_fpt)(); auto _f=xcast<_fpt>(_drva(2942592)); return (this->*_f)(); }
	inline vec3f getVelocity() { typedef vec3f (RigidBodyODE::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 15)); return (this->*_f)(); }
	virtual void setVelocity_vf16(const vec3f & vel);
	inline void setVelocity_impl(const vec3f & vel) { typedef void (RigidBodyODE::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2943664)); return (this->*_f)(vel); }
	inline void setVelocity(const vec3f & vel) { typedef void (RigidBodyODE::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 16)); return (this->*_f)(vel); }
	virtual void setPosition_vf18(const vec3f & pos);
	inline void setPosition_impl(const vec3f & pos) { typedef void (RigidBodyODE::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2943456)); return (this->*_f)(pos); }
	inline void setPosition(const vec3f & pos) { typedef void (RigidBodyODE::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 18)); return (this->*_f)(pos); }
	virtual void setRotation_vf19(const mat44f & mat);
	inline void setRotation_impl(const mat44f & mat) { typedef void (RigidBodyODE::*_fpt)(const mat44f &); auto _f=xcast<_fpt>(_drva(2943488)); return (this->*_f)(mat); }
	inline void setRotation(const mat44f & mat) { typedef void (RigidBodyODE::*_fpt)(const mat44f &); auto _f=xcast<_fpt>(get_vfp(this, 19)); return (this->*_f)(mat); }
	virtual vec3f getPosition_vf20(float interpolationT);
	inline vec3f getPosition_impl(float interpolationT) { typedef vec3f (RigidBodyODE::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2942528)); return (this->*_f)(interpolationT); }
	inline vec3f getPosition(float interpolationT) { typedef vec3f (RigidBodyODE::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 20)); return (this->*_f)(interpolationT); }
	virtual vec3f getAngularVelocity_vf21();
	inline vec3f getAngularVelocity_impl() { typedef vec3f (RigidBodyODE::*_fpt)(); auto _f=xcast<_fpt>(_drva(2941936)); return (this->*_f)(); }
	inline vec3f getAngularVelocity() { typedef vec3f (RigidBodyODE::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 21)); return (this->*_f)(); }
	virtual vec3f getLocalAngularVelocity_vf22();
	inline vec3f getLocalAngularVelocity_impl() { typedef vec3f (RigidBodyODE::*_fpt)(); auto _f=xcast<_fpt>(_drva(2942000)); return (this->*_f)(); }
	inline vec3f getLocalAngularVelocity() { typedef vec3f (RigidBodyODE::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 22)); return (this->*_f)(); }
	virtual vec3f getLocalVelocity_vf23();
	inline vec3f getLocalVelocity_impl() { typedef vec3f (RigidBodyODE::*_fpt)(); auto _f=xcast<_fpt>(_drva(2942240)); return (this->*_f)(); }
	inline vec3f getLocalVelocity() { typedef vec3f (RigidBodyODE::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 23)); return (this->*_f)(); }
	virtual void setBoxColliderMask_vf24(unsigned __int64 box, unsigned long mask);
	inline void setBoxColliderMask_impl(unsigned __int64 box, unsigned long mask) { typedef void (RigidBodyODE::*_fpt)(unsigned __int64, unsigned long); auto _f=xcast<_fpt>(_drva(2943072)); return (this->*_f)(box, mask); }
	inline void setBoxColliderMask(unsigned __int64 box, unsigned long mask) { typedef void (RigidBodyODE::*_fpt)(unsigned __int64, unsigned long); auto _f=xcast<_fpt>(get_vfp(this, 24)); return (this->*_f)(box, mask); }
	virtual unsigned __int64 addBoxCollider_vf25(const vec3f & pos, const vec3f & size, unsigned int category, unsigned long mask, unsigned int spaceId);
	inline unsigned __int64 addBoxCollider_impl(const vec3f & pos, const vec3f & size, unsigned int category, unsigned long mask, unsigned int spaceId) { typedef unsigned __int64 (RigidBodyODE::*_fpt)(const vec3f &, const vec3f &, unsigned int, unsigned long, unsigned int); auto _f=xcast<_fpt>(_drva(2940336)); return (this->*_f)(pos, size, category, mask, spaceId); }
	inline unsigned __int64 addBoxCollider(const vec3f & pos, const vec3f & size, unsigned int category, unsigned long mask, unsigned int spaceId) { typedef unsigned __int64 (RigidBodyODE::*_fpt)(const vec3f &, const vec3f &, unsigned int, unsigned long, unsigned int); auto _f=xcast<_fpt>(get_vfp(this, 25)); return (this->*_f)(pos, size, category, mask, spaceId); }
	virtual void addSphereCollider_vf26(const vec3f & pos, float radius, unsigned int group, ISphereCollisionCallback * callback);
	inline void addSphereCollider_impl(const vec3f & pos, float radius, unsigned int group, ISphereCollisionCallback * callback) { typedef void (RigidBodyODE::*_fpt)(const vec3f &, float, unsigned int, ISphereCollisionCallback *); auto _f=xcast<_fpt>(_drva(96368)); return (this->*_f)(pos, radius, group, callback); }
	inline void addSphereCollider(const vec3f & pos, float radius, unsigned int group, ISphereCollisionCallback * callback) { typedef void (RigidBodyODE::*_fpt)(const vec3f &, float, unsigned int, ISphereCollisionCallback *); auto _f=xcast<_fpt>(get_vfp(this, 26)); return (this->*_f)(pos, radius, group, callback); }
	virtual void addLocalForce_vf27(const vec3f & f);
	inline void addLocalForce_impl(const vec3f & f) { typedef void (RigidBodyODE::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2940800)); return (this->*_f)(f); }
	inline void addLocalForce(const vec3f & f) { typedef void (RigidBodyODE::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 27)); return (this->*_f)(f); }
	virtual void addLocalTorque_vf28(const vec3f & t);
	inline void addLocalTorque_impl(const vec3f & t) { typedef void (RigidBodyODE::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2941024)); return (this->*_f)(t); }
	inline void addLocalTorque(const vec3f & t) { typedef void (RigidBodyODE::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 28)); return (this->*_f)(t); }
	virtual void addLocalForceAtPos_vf29(const vec3f & f, const vec3f & p);
	inline void addLocalForceAtPos_impl(const vec3f & f, const vec3f & p) { typedef void (RigidBodyODE::*_fpt)(const vec3f &, const vec3f &); auto _f=xcast<_fpt>(_drva(2940944)); return (this->*_f)(f, p); }
	inline void addLocalForceAtPos(const vec3f & f, const vec3f & p) { typedef void (RigidBodyODE::*_fpt)(const vec3f &, const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 29)); return (this->*_f)(f, p); }
	virtual void addLocalForceAtLocalPos_vf30(const vec3f & f, const vec3f & p);
	inline void addLocalForceAtLocalPos_impl(const vec3f & f, const vec3f & p) { typedef void (RigidBodyODE::*_fpt)(const vec3f &, const vec3f &); auto _f=xcast<_fpt>(_drva(2940864)); return (this->*_f)(f, p); }
	inline void addLocalForceAtLocalPos(const vec3f & f, const vec3f & p) { typedef void (RigidBodyODE::*_fpt)(const vec3f &, const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 30)); return (this->*_f)(f, p); }
	virtual void addForceAtLocalPos_vf31(const vec3f & f, const vec3f & p);
	inline void addForceAtLocalPos_impl(const vec3f & f, const vec3f & p) { typedef void (RigidBodyODE::*_fpt)(const vec3f &, const vec3f &); auto _f=xcast<_fpt>(_drva(2940640)); return (this->*_f)(f, p); }
	inline void addForceAtLocalPos(const vec3f & f, const vec3f & p) { typedef void (RigidBodyODE::*_fpt)(const vec3f &, const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 31)); return (this->*_f)(f, p); }
	virtual vec3f getLocalPointVelocity_vf32(const vec3f & p);
	inline vec3f getLocalPointVelocity_impl(const vec3f & p) { typedef vec3f (RigidBodyODE::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2942176)); return (this->*_f)(p); }
	inline vec3f getLocalPointVelocity(const vec3f & p) { typedef vec3f (RigidBodyODE::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 32)); return (this->*_f)(p); }
	virtual vec3f getPointVelocity_vf33(const vec3f & p);
	inline vec3f getPointVelocity_impl(const vec3f & p) { typedef vec3f (RigidBodyODE::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2942464)); return (this->*_f)(p); }
	inline vec3f getPointVelocity(const vec3f & p) { typedef vec3f (RigidBodyODE::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 33)); return (this->*_f)(p); }
	virtual void addForceAtPos_vf34(const vec3f & f, const vec3f & p);
	inline void addForceAtPos_impl(const vec3f & f, const vec3f & p) { typedef void (RigidBodyODE::*_fpt)(const vec3f &, const vec3f &); auto _f=xcast<_fpt>(_drva(2940720)); return (this->*_f)(f, p); }
	inline void addForceAtPos(const vec3f & f, const vec3f & p) { typedef void (RigidBodyODE::*_fpt)(const vec3f &, const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 34)); return (this->*_f)(f, p); }
	virtual void addTorque_vf35(const vec3f & t);
	inline void addTorque_impl(const vec3f & t) { typedef void (RigidBodyODE::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2941904)); return (this->*_f)(t); }
	inline void addTorque(const vec3f & t) { typedef void (RigidBodyODE::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 35)); return (this->*_f)(t); }
	virtual void addMeshCollider_vf0(float * vertices, unsigned int verticesCount, unsigned short * indices, unsigned int indicesCount, mat44f * mat, unsigned long category, unsigned long collideMask, unsigned int spaceId);
	inline void addMeshCollider_impl(float * vertices, unsigned int verticesCount, unsigned short * indices, unsigned int indicesCount, mat44f * mat, unsigned long category, unsigned long collideMask, unsigned int spaceId) { typedef void (RigidBodyODE::*_fpt)(float *, unsigned int, unsigned short *, unsigned int, mat44f *, unsigned long, unsigned long, unsigned int); auto _f=xcast<_fpt>(_drva(2941056)); return (this->*_f)(vertices, verticesCount, indices, indicesCount, mat, category, collideMask, spaceId); }
	inline void addMeshCollider(float * vertices, unsigned int verticesCount, unsigned short * indices, unsigned int indicesCount, mat44f * mat, unsigned long category, unsigned long collideMask, unsigned int spaceId) { typedef void (RigidBodyODE::*_fpt)(float *, unsigned int, unsigned short *, unsigned int, mat44f *, unsigned long, unsigned long, unsigned int); auto _f=xcast<_fpt>(get_vfp(this, 0)); return (this->*_f)(vertices, verticesCount, indices, indicesCount, mat, category, collideMask, spaceId); }
	virtual void setMeshCollideCategory_vf37(unsigned int meshIndex, unsigned long category);
	inline void setMeshCollideCategory_impl(unsigned int meshIndex, unsigned long category) { typedef void (RigidBodyODE::*_fpt)(unsigned int, unsigned long); auto _f=xcast<_fpt>(_drva(2943392)); return (this->*_f)(meshIndex, category); }
	inline void setMeshCollideCategory(unsigned int meshIndex, unsigned long category) { typedef void (RigidBodyODE::*_fpt)(unsigned int, unsigned long); auto _f=xcast<_fpt>(get_vfp(this, 37)); return (this->*_f)(meshIndex, category); }
	virtual void setMeshCollideMask_vf38(unsigned int meshIndex, unsigned long mask);
	inline void setMeshCollideMask_impl(unsigned int meshIndex, unsigned long mask) { typedef void (RigidBodyODE::*_fpt)(unsigned int, unsigned long); auto _f=xcast<_fpt>(_drva(2943424)); return (this->*_f)(meshIndex, mask); }
	inline void setMeshCollideMask(unsigned int meshIndex, unsigned long mask) { typedef void (RigidBodyODE::*_fpt)(unsigned int, unsigned long); auto _f=xcast<_fpt>(get_vfp(this, 38)); return (this->*_f)(meshIndex, mask); }
	virtual unsigned long getMeshCollideCategory_vf39(unsigned int meshIndex);
	inline unsigned long getMeshCollideCategory_impl(unsigned int meshIndex) { typedef unsigned long (RigidBodyODE::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(2942368)); return (this->*_f)(meshIndex); }
	inline unsigned long getMeshCollideCategory(unsigned int meshIndex) { typedef unsigned long (RigidBodyODE::*_fpt)(unsigned int); auto _f=xcast<_fpt>(get_vfp(this, 39)); return (this->*_f)(meshIndex); }
	virtual unsigned long getMeshCollideMask_vf40(unsigned int meshIndex);
	inline unsigned long getMeshCollideMask_impl(unsigned int meshIndex) { typedef unsigned long (RigidBodyODE::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(2942416)); return (this->*_f)(meshIndex); }
	inline unsigned long getMeshCollideMask(unsigned int meshIndex) { typedef unsigned long (RigidBodyODE::*_fpt)(unsigned int); auto _f=xcast<_fpt>(get_vfp(this, 40)); return (this->*_f)(meshIndex); }
	virtual bool isEnabled_vf1();
	inline bool isEnabled_impl() { typedef bool (RigidBodyODE::*_fpt)(); auto _f=xcast<_fpt>(_drva(2942816)); return (this->*_f)(); }
	inline bool isEnabled() { typedef bool (RigidBodyODE::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(); }
	virtual void setEnabled_vf2(bool value);
	inline void setEnabled_impl(bool value) { typedef void (RigidBodyODE::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(2943088)); return (this->*_f)(value); }
	inline void setEnabled(bool value) { typedef void (RigidBodyODE::*_fpt)(bool); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)(value); }
	inline void _guard_obj() {
		static_assert((sizeof(RigidBodyODE)==72),"bad size");
		static_assert((offsetof(RigidBodyODE,id)==0x8),"bad off");
		static_assert((offsetof(RigidBodyODE,geoms)==0x10),"bad off");
		static_assert((offsetof(RigidBodyODE,core)==0x28),"bad off");
		static_assert((offsetof(RigidBodyODE,collisionMeshes)==0x30),"bad off");
	};
};

//UDT: class InterpolatingSpline @len=112 @vfcount=2
	//_Base: class Spline @off=0 @len=40
	//_Func: public void InterpolatingSpline(const InterpolatingSpline &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void InterpolatingSpline(); @loc=static @len=84 @rva=2026704
	//_Func: public void ~InterpolatingSpline(); @virtual vtpo=0 vfid=0 @loc=static @len=180 @rva=2026816
	//_Func: public float worldToSpline(const vec3f & pos, int closestIndex); @loc=static @len=1510 @rva=2046960
	//_Func: public vec3f splineToWorld(float pos); @loc=static @len=276 @rva=2046496
	//_Func: public float getNormalizedPosition(unsigned int index); @loc=static @len=102 @rva=2043264
	//_Func: public unsigned int getLastIndexFromNorm(float t, float * blendToNext); @loc=static @len=493 @rva=2042768
	//_Func: public void bezierEndopoint(); @loc=static @len=593 @rva=2029344
	//_Func: public void setInterpolationMode(eAISplineInterpolationMode  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public eAISplineInterpolationMode getInterpolationMode(); @loc=optimized @len=0 @rva=0
	//_Func: public float wrapPosition(float pos); @loc=static @len=94 @rva=2048480
	//_Func: public void addPoint(const vec3f & p, int tag); @loc=static @len=9 @rva=2029312
	//_Func: public void addSplinePoint(const SplinePoint & p); @loc=static @len=9 @rva=2029328
	//_Func: public void addPoints(const std::vector<vec3f,std::allocator<vec3f> > &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public float getDistanceFromSpline(const vec3f &  _arg0, float  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public float getSignedDistanceFromSpline(const vec3f & p, float splinePosition); @loc=static @len=564 @rva=2043376
	//_Func: public void computeSplineCoefficients(); @loc=static @len=1167 @rva=2038048
	//_Func: public void filterPointsTooClose(float minDistance); @loc=static @len=902 @rva=2041856
	//_Func: public void clear(); @virtual vtpo=0 vfid=1 @loc=static @len=56 @rva=2035008
	//_Func: public void buildGrid(); @loc=static @len=1105 @rva=2029952
	//_Func: public void deleteGrid(); @loc=optimized @len=0 @rva=0
	//_Func: public void saveGrid(std::basic_ofstream<char,std::char_traits<char> > & out); @loc=static @len=705 @rva=2045776
	//_Func: public void loadGrid(std::basic_ifstream<char,std::char_traits<char> > & in); @loc=static @len=690 @rva=2044320
	//_Func: public bool isGridOn(); @loc=static @len=9 @rva=2043952
	//_Func: public unsigned int closestPointIndex(const vec3f & point, float * distance); @loc=static @len=31 @rva=2035072
	//_Func: public void computeSplineLength(); @loc=static @len=2435 @rva=2039216
	//_Func: public vec3f linearProjection(const vec3f & point, int closestIndex); @loc=static @len=347 @rva=2043968
	//_Func: public void popBack(); @loc=static @len=6 @rva=2045024
	//_Data: this+0x28, Member, Type: class std::vector<std::vector<GridElement,std::allocator<GridElement> >,std::allocator<std::vector<GridElement,std::allocator<GridElement> > > >, grid
	//_Data: this+0x40, Member, Type: struct GridData *, gridData
	//_Data: this+0x48, Member, Type: class CubicSpline<float,vec3f>, cubicSpline
	//_Data: this+0x68, Member, Type: bool, isSplineReady
	//_Data: this+0x6C, Member, Type: enum eAISplineInterpolationMode, interpolationMode
	//_Func: private vec3f calculateNthBezier(float t); @loc=static @len=551 @rva=2033408
	//_Func: private vec3f calculateCubicBezier(float t); @loc=static @len=756 @rva=2032192
	//_Func: private vec3f calculateCatmullRom(float t); @loc=static @len=1105 @rva=2031072
	//_Func: private vec3f calculateUniformBSpline(float t); @loc=static @len=1027 @rva=2033968
	//_Func: private vec3f calculateCubicSpline(float pos); @loc=static @len=64 @rva=2032960
	//_Func: private vec3f calculateLinear(float pos); @loc=static @len=373 @rva=2033024
	//_Func: private unsigned int closestPointIndexGrid(const vec3f & position, float * distance); @loc=static @len=467 @rva=2035104
	//_Func: public InterpolatingSpline & operator=(const InterpolatingSpline &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class InterpolatingSpline : public Spline {
public:
	std::vector<std::vector<GridElement,std::allocator<GridElement> >,std::allocator<std::vector<GridElement,std::allocator<GridElement> > > > grid;
	GridData * gridData;
	CubicSpline<float,vec3f> cubicSpline;
	bool isSplineReady;
	eAISplineInterpolationMode interpolationMode;
	inline InterpolatingSpline() { }
	inline InterpolatingSpline(const InterpolatingSpline& other) = default;
	inline InterpolatingSpline& operator=(const InterpolatingSpline& other) = default;
	inline void ctor() { typedef void (InterpolatingSpline::*_fpt)(); auto _f=xcast<_fpt>(_drva(2026704)); (this->*_f)(); }
	virtual ~InterpolatingSpline();
	inline void dtor() { typedef void (InterpolatingSpline::*_fpt)(); auto _f=xcast<_fpt>(_drva(2026816)); (this->*_f)(); }
	inline float worldToSpline(const vec3f & pos, int closestIndex) { typedef float (InterpolatingSpline::*_fpt)(const vec3f &, int); auto _f=xcast<_fpt>(_drva(2046960)); return (this->*_f)(pos, closestIndex); }
	inline vec3f splineToWorld(float pos) { typedef vec3f (InterpolatingSpline::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2046496)); return (this->*_f)(pos); }
	inline float getNormalizedPosition(unsigned int index) { typedef float (InterpolatingSpline::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(2043264)); return (this->*_f)(index); }
	inline unsigned int getLastIndexFromNorm(float t, float * blendToNext) { typedef unsigned int (InterpolatingSpline::*_fpt)(float, float *); auto _f=xcast<_fpt>(_drva(2042768)); return (this->*_f)(t, blendToNext); }
	inline void bezierEndopoint() { typedef void (InterpolatingSpline::*_fpt)(); auto _f=xcast<_fpt>(_drva(2029344)); return (this->*_f)(); }
	inline float wrapPosition(float pos) { typedef float (InterpolatingSpline::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2048480)); return (this->*_f)(pos); }
	inline void addPoint(const vec3f & p, int tag) { typedef void (InterpolatingSpline::*_fpt)(const vec3f &, int); auto _f=xcast<_fpt>(_drva(2029312)); return (this->*_f)(p, tag); }
	inline void addSplinePoint(const SplinePoint & p) { typedef void (InterpolatingSpline::*_fpt)(const SplinePoint &); auto _f=xcast<_fpt>(_drva(2029328)); return (this->*_f)(p); }
	inline float getSignedDistanceFromSpline(const vec3f & p, float splinePosition) { typedef float (InterpolatingSpline::*_fpt)(const vec3f &, float); auto _f=xcast<_fpt>(_drva(2043376)); return (this->*_f)(p, splinePosition); }
	inline void computeSplineCoefficients() { typedef void (InterpolatingSpline::*_fpt)(); auto _f=xcast<_fpt>(_drva(2038048)); return (this->*_f)(); }
	inline void filterPointsTooClose(float minDistance) { typedef void (InterpolatingSpline::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2041856)); return (this->*_f)(minDistance); }
	virtual void clear_vf1();
	inline void clear_impl() { typedef void (InterpolatingSpline::*_fpt)(); auto _f=xcast<_fpt>(_drva(2035008)); return (this->*_f)(); }
	inline void clear() { typedef void (InterpolatingSpline::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(); }
	inline void buildGrid() { typedef void (InterpolatingSpline::*_fpt)(); auto _f=xcast<_fpt>(_drva(2029952)); return (this->*_f)(); }
	inline void saveGrid(std::basic_ofstream<char,std::char_traits<char> > & out) { typedef void (InterpolatingSpline::*_fpt)(std::basic_ofstream<char,std::char_traits<char> > &); auto _f=xcast<_fpt>(_drva(2045776)); return (this->*_f)(out); }
	inline void loadGrid(std::basic_ifstream<char,std::char_traits<char> > & in) { typedef void (InterpolatingSpline::*_fpt)(std::basic_ifstream<char,std::char_traits<char> > &); auto _f=xcast<_fpt>(_drva(2044320)); return (this->*_f)(in); }
	inline bool isGridOn() { typedef bool (InterpolatingSpline::*_fpt)(); auto _f=xcast<_fpt>(_drva(2043952)); return (this->*_f)(); }
	inline unsigned int closestPointIndex(const vec3f & point, float * distance) { typedef unsigned int (InterpolatingSpline::*_fpt)(const vec3f &, float *); auto _f=xcast<_fpt>(_drva(2035072)); return (this->*_f)(point, distance); }
	inline void computeSplineLength() { typedef void (InterpolatingSpline::*_fpt)(); auto _f=xcast<_fpt>(_drva(2039216)); return (this->*_f)(); }
	inline vec3f linearProjection(const vec3f & point, int closestIndex) { typedef vec3f (InterpolatingSpline::*_fpt)(const vec3f &, int); auto _f=xcast<_fpt>(_drva(2043968)); return (this->*_f)(point, closestIndex); }
	inline void popBack() { typedef void (InterpolatingSpline::*_fpt)(); auto _f=xcast<_fpt>(_drva(2045024)); return (this->*_f)(); }
	inline vec3f calculateNthBezier(float t) { typedef vec3f (InterpolatingSpline::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2033408)); return (this->*_f)(t); }
	inline vec3f calculateCubicBezier(float t) { typedef vec3f (InterpolatingSpline::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2032192)); return (this->*_f)(t); }
	inline vec3f calculateCatmullRom(float t) { typedef vec3f (InterpolatingSpline::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2031072)); return (this->*_f)(t); }
	inline vec3f calculateUniformBSpline(float t) { typedef vec3f (InterpolatingSpline::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2033968)); return (this->*_f)(t); }
	inline vec3f calculateCubicSpline(float pos) { typedef vec3f (InterpolatingSpline::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2032960)); return (this->*_f)(pos); }
	inline vec3f calculateLinear(float pos) { typedef vec3f (InterpolatingSpline::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2033024)); return (this->*_f)(pos); }
	inline unsigned int closestPointIndexGrid(const vec3f & position, float * distance) { typedef unsigned int (InterpolatingSpline::*_fpt)(const vec3f &, float *); auto _f=xcast<_fpt>(_drva(2035104)); return (this->*_f)(position, distance); }
	inline void _guard_obj() {
		static_assert((sizeof(InterpolatingSpline)==112),"bad size");
		static_assert((offsetof(InterpolatingSpline,grid)==0x28),"bad off");
		static_assert((offsetof(InterpolatingSpline,gridData)==0x40),"bad off");
		static_assert((offsetof(InterpolatingSpline,cubicSpline)==0x48),"bad off");
		static_assert((offsetof(InterpolatingSpline,isSplineReady)==0x68),"bad off");
		static_assert((offsetof(InterpolatingSpline,interpolationMode)==0x6C),"bad off");
	};
};

//UDT: class ksgui::Form @len=440 @vfcount=23
	//_Base: class ksgui::Control @off=0 @len=376
	//_Func: public void Form(const ksgui_Form &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void Form(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * iname, ksgui_GUI * igui, bool icanBeScaled); @loc=static @len=2859 @rva=2381968
	//_Func: public void ~Form(); @virtual vtpo=0 vfid=0 @loc=static @len=15 @rva=2384832
	//_Func: public void setAutoHideMode(bool mode); @loc=static @len=176 @rva=2386480
	//_Func: public void render(float dt); @virtual vtpo=0 vfid=3 @loc=static @len=5 @rva=2386144
	//_Func: public void onMouseMove(const OnMouseMoveEvent & message); @virtual vtpo=0 vfid=12 @loc=static @len=262 @rva=2385696
	//_Func: public void onTitleClicked(const ksgui_OnControlClicked & message); @intro @virtual vtpo=0 vfid=21 @loc=static @len=38 @rva=2385968
	//_Func: public void onKeyChar(unsigned int key); @virtual vtpo=0 vfid=14 @loc=static @len=14 @rva=2385664
	//_Func: public void onKeyDown(const OnKeyEvent & message); @virtual vtpo=0 vfid=15 @loc=static @len=14 @rva=2385680
	//_Func: public void onIconClicked(const ksgui_OnControlClicked &  _arg0); @loc=optimized @len=0 @rva=0
	//_Data: this+0x178, Member, Type: class ksgui::Control *, formTitle
	//_Func: public void setSize(float w, float h); @virtual vtpo=0 vfid=7 @loc=static @len=137 @rva=2387296
	//_Func: public void setIcon(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * fileName); @loc=static @len=390 @rva=2386704
	//_Func: public void setPosition(float left, float top); @loc=static @len=5 @rva=2387280
	//_Func: public Texture getIcon(); @loc=optimized @len=0 @rva=0
	//_Func: public void setIconVisible(bool visible); @loc=static @len=133 @rva=2387136
	//_Func: public void setIconPosition(float x, float y); @loc=static @len=12 @rva=2387104
	//_Func: public void setIconSize(float width, float height); @loc=static @len=14 @rva=2387120
	//_Func: public void onVisibleChanged(bool newValue); @virtual vtpo=0 vfid=8 @loc=static @len=119 @rva=2386016
	//_Func: public void shutdown(); @intro @virtual vtpo=0 vfid=22 @loc=static @len=3 @rva=96368
	//_Func: public bool isBLocked(); @loc=optimized @len=0 @rva=0
	//_Func: public void setBlocked(bool value); @loc=static @len=46 @rva=2386656
	//_Func: public bool isDevApp(); @loc=optimized @len=0 @rva=0
	//_Func: public void setScaleMult(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void setScaleToBeSaved(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public float getScaleToBeSaved(); @loc=optimized @len=0 @rva=0
	//_Func: public bool hitTest(int x, int y); @virtual vtpo=0 vfid=1 @loc=static @len=84 @rva=2385568
	//_Func: public void updateScaleByMult(); @loc=static @len=36 @rva=2387440
	//_Func: public float getHeaderHeight(); @loc=static @len=9 @rva=3194240
	//_Data: this+0x180, Member, Type: bool, devApp
	//_Data: this+0x181, Member, Type: bool, autohide
	//_Data: this+0x182, Member, Type: bool, blocked
	//_Data: this+0x184, Member, Type: float, scaleToBeSaved
	//_Data: this+0x188, Member, Type: bool, canBeScaled
	//_Data: this+0x190, Member, Type: class ksgui::Control *, icon
	//_Data: this+0x198, Member, Type: class ksgui::ActiveButton *, pinIcon
	//_Data: this+0x1A0, Member, Type: class ksgui::Control *, zoomInIcon
	//_Data: this+0x1A8, Member, Type: class ksgui::Control *, zoomOutIcon
	//_Func: protected void scaleByMult(float value); @virtual vtpo=0 vfid=19 @loc=static @len=280 @rva=2386160
	//_Func: protected void scaleByMult(); @virtual vtpo=0 vfid=20 @loc=static @len=18 @rva=2386448
	//_Data: this+0x1B0, Member, Type: float, HEADER_HEIGHT
	//_Data: this+0x1B4, Member, Type: float, scaleStep
	//_Func: public ksgui_Form & operator=(const ksgui_Form &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ksgui_Form : public ksgui_Control {
public:
	ksgui_Control * formTitle;
	bool devApp;
	bool autohide;
	bool blocked;
	float scaleToBeSaved;
	bool canBeScaled;
	ksgui_Control * icon;
	ksgui_ActiveButton * pinIcon;
	ksgui_Control * zoomInIcon;
	ksgui_Control * zoomOutIcon;
	float HEADER_HEIGHT;
	float scaleStep;
	inline ksgui_Form() { }
	inline ksgui_Form(const ksgui_Form& other) = default;
	inline ksgui_Form& operator=(const ksgui_Form& other) = default;
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * iname, ksgui_GUI * igui, bool icanBeScaled) { typedef void (ksgui_Form::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, ksgui_GUI *, bool); auto _f=xcast<_fpt>(_drva(2381968)); (this->*_f)(iname, igui, icanBeScaled); }
	virtual ~ksgui_Form();
	inline void dtor() { typedef void (ksgui_Form::*_fpt)(); auto _f=xcast<_fpt>(_drva(2384832)); (this->*_f)(); }
	inline void setAutoHideMode(bool mode) { typedef void (ksgui_Form::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(2386480)); return (this->*_f)(mode); }
	virtual void render_vf3(float dt);
	inline void render_impl(float dt) { typedef void (ksgui_Form::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2386144)); return (this->*_f)(dt); }
	inline void render(float dt) { typedef void (ksgui_Form::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(dt); }
	virtual void onMouseMove_vf12(const OnMouseMoveEvent & message);
	inline void onMouseMove_impl(const OnMouseMoveEvent & message) { typedef void (ksgui_Form::*_fpt)(const OnMouseMoveEvent &); auto _f=xcast<_fpt>(_drva(2385696)); return (this->*_f)(message); }
	inline void onMouseMove(const OnMouseMoveEvent & message) { typedef void (ksgui_Form::*_fpt)(const OnMouseMoveEvent &); auto _f=xcast<_fpt>(get_vfp(this, 12)); return (this->*_f)(message); }
	virtual void onTitleClicked_vf21(const ksgui_OnControlClicked & message);
	inline void onTitleClicked_impl(const ksgui_OnControlClicked & message) { typedef void (ksgui_Form::*_fpt)(const ksgui_OnControlClicked &); auto _f=xcast<_fpt>(_drva(2385968)); return (this->*_f)(message); }
	inline void onTitleClicked(const ksgui_OnControlClicked & message) { typedef void (ksgui_Form::*_fpt)(const ksgui_OnControlClicked &); auto _f=xcast<_fpt>(get_vfp(this, 21)); return (this->*_f)(message); }
	virtual void onKeyChar_vf14(unsigned int key);
	inline void onKeyChar_impl(unsigned int key) { typedef void (ksgui_Form::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(2385664)); return (this->*_f)(key); }
	inline void onKeyChar(unsigned int key) { typedef void (ksgui_Form::*_fpt)(unsigned int); auto _f=xcast<_fpt>(get_vfp(this, 14)); return (this->*_f)(key); }
	virtual void onKeyDown_vf15(const OnKeyEvent & message);
	inline void onKeyDown_impl(const OnKeyEvent & message) { typedef void (ksgui_Form::*_fpt)(const OnKeyEvent &); auto _f=xcast<_fpt>(_drva(2385680)); return (this->*_f)(message); }
	inline void onKeyDown(const OnKeyEvent & message) { typedef void (ksgui_Form::*_fpt)(const OnKeyEvent &); auto _f=xcast<_fpt>(get_vfp(this, 15)); return (this->*_f)(message); }
	virtual void setSize_vf7(float w, float h);
	inline void setSize_impl(float w, float h) { typedef void (ksgui_Form::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2387296)); return (this->*_f)(w, h); }
	inline void setSize(float w, float h) { typedef void (ksgui_Form::*_fpt)(float, float); auto _f=xcast<_fpt>(get_vfp(this, 7)); return (this->*_f)(w, h); }
	inline void setIcon(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * fileName) { typedef void (ksgui_Form::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *); auto _f=xcast<_fpt>(_drva(2386704)); return (this->*_f)(fileName); }
	inline void setPosition(float left, float top) { typedef void (ksgui_Form::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2387280)); return (this->*_f)(left, top); }
	inline void setIconVisible(bool visible) { typedef void (ksgui_Form::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(2387136)); return (this->*_f)(visible); }
	inline void setIconPosition(float x, float y) { typedef void (ksgui_Form::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2387104)); return (this->*_f)(x, y); }
	inline void setIconSize(float width, float height) { typedef void (ksgui_Form::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2387120)); return (this->*_f)(width, height); }
	virtual void onVisibleChanged_vf8(bool newValue);
	inline void onVisibleChanged_impl(bool newValue) { typedef void (ksgui_Form::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(2386016)); return (this->*_f)(newValue); }
	inline void onVisibleChanged(bool newValue) { typedef void (ksgui_Form::*_fpt)(bool); auto _f=xcast<_fpt>(get_vfp(this, 8)); return (this->*_f)(newValue); }
	virtual void shutdown_vf22();
	inline void shutdown_impl() { typedef void (ksgui_Form::*_fpt)(); auto _f=xcast<_fpt>(_drva(96368)); return (this->*_f)(); }
	inline void shutdown() { typedef void (ksgui_Form::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 22)); return (this->*_f)(); }
	inline void setBlocked(bool value) { typedef void (ksgui_Form::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(2386656)); return (this->*_f)(value); }
	virtual bool hitTest_vf1(int x, int y);
	inline bool hitTest_impl(int x, int y) { typedef bool (ksgui_Form::*_fpt)(int, int); auto _f=xcast<_fpt>(_drva(2385568)); return (this->*_f)(x, y); }
	inline bool hitTest(int x, int y) { typedef bool (ksgui_Form::*_fpt)(int, int); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(x, y); }
	inline void updateScaleByMult() { typedef void (ksgui_Form::*_fpt)(); auto _f=xcast<_fpt>(_drva(2387440)); return (this->*_f)(); }
	inline float getHeaderHeight() { typedef float (ksgui_Form::*_fpt)(); auto _f=xcast<_fpt>(_drva(3194240)); return (this->*_f)(); }
	virtual void scaleByMult_vf19(float value);
	inline void scaleByMult_impl(float value) { typedef void (ksgui_Form::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2386160)); return (this->*_f)(value); }
	inline void scaleByMult(float value) { typedef void (ksgui_Form::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 19)); return (this->*_f)(value); }
	virtual void scaleByMult_vf20();
	inline void scaleByMult_impl() { typedef void (ksgui_Form::*_fpt)(); auto _f=xcast<_fpt>(_drva(2386448)); return (this->*_f)(); }
	inline void scaleByMult() { typedef void (ksgui_Form::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 20)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_Form)==440),"bad size");
		static_assert((offsetof(ksgui_Form,formTitle)==0x178),"bad off");
		static_assert((offsetof(ksgui_Form,devApp)==0x180),"bad off");
		static_assert((offsetof(ksgui_Form,autohide)==0x181),"bad off");
		static_assert((offsetof(ksgui_Form,blocked)==0x182),"bad off");
		static_assert((offsetof(ksgui_Form,scaleToBeSaved)==0x184),"bad off");
		static_assert((offsetof(ksgui_Form,canBeScaled)==0x188),"bad off");
		static_assert((offsetof(ksgui_Form,icon)==0x190),"bad off");
		static_assert((offsetof(ksgui_Form,pinIcon)==0x198),"bad off");
		static_assert((offsetof(ksgui_Form,zoomInIcon)==0x1A0),"bad off");
		static_assert((offsetof(ksgui_Form,zoomOutIcon)==0x1A8),"bad off");
		static_assert((offsetof(ksgui_Form,HEADER_HEIGHT)==0x1B0),"bad off");
		static_assert((offsetof(ksgui_Form,scaleStep)==0x1B4),"bad off");
	};
};

//UDT: class ksgui::TaskBarIcon @len=536 @vfcount=21
	//_Base: class ksgui::Control @off=0 @len=376
	//_Func: public void TaskBarIcon(const ksgui_TaskBarIcon &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void TaskBarIcon(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, std::shared_ptr<Font> * appFont, ksgui_GUI * igui); @loc=static @len=1211 @rva=2474464
	//_Func: public void ~TaskBarIcon(); @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Data: this+0x178, Member, Type: enum eTaskBarStatus, status
	//_Data: this+0x17C, Member, Type: bool, isOver
	//_Func: public void onMouseMove(const OnMouseMoveEvent & message); @virtual vtpo=0 vfid=12 @loc=static @len=264 @rva=2475968
	//_Func: public void render(float dt); @virtual vtpo=0 vfid=3 @loc=static @len=363 @rva=2476240
	//_Func: public void setDescriptionText(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * text); @loc=static @len=280 @rva=2476608
	//_Func: public void hide(bool value); @loc=static @len=159 @rva=2475808
	//_Data: this+0x180, Member, Type: class Texture, texture
	//_Data: this+0x1A8, Member, Type: class Texture, textureOn
	//_Data: this+0x1D0, Member, Type: class vec4f, unselectedColor
	//_Data: this+0x1E0, Member, Type: class vec4f, selectedColor
	//_Data: this+0x1F0, Member, Type: class vec4f, rollOverColor
	//_Data: this+0x200, Member, Type: class ksgui::Control *, descriptionRect
	//_Data: this+0x208, Member, Type: class ksgui::Label *, descriptionLabel
	//_Data: this+0x210, Member, Type: float, targetX
	//_Func: private void setIcon(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * filename); @loc=static @len=847 @rva=2476896
	//_Func: public ksgui_TaskBarIcon & operator=(const ksgui_TaskBarIcon &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ksgui_TaskBarIcon : public ksgui_Control {
public:
	eTaskBarStatus status;
	bool isOver;
	Texture texture;
	Texture textureOn;
	vec4f unselectedColor;
	vec4f selectedColor;
	vec4f rollOverColor;
	ksgui_Control * descriptionRect;
	ksgui_Label * descriptionLabel;
	float targetX;
	inline ksgui_TaskBarIcon() { }
	inline ksgui_TaskBarIcon(const ksgui_TaskBarIcon& other) = default;
	inline ksgui_TaskBarIcon& operator=(const ksgui_TaskBarIcon& other) = default;
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, std::shared_ptr<Font> * appFont, ksgui_GUI * igui) { typedef void (ksgui_TaskBarIcon::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, std::shared_ptr<Font> *, ksgui_GUI *); auto _f=xcast<_fpt>(_drva(2474464)); (this->*_f)(name, appFont, igui); }
	virtual ~ksgui_TaskBarIcon();
	virtual void onMouseMove_vf12(const OnMouseMoveEvent & message);
	inline void onMouseMove_impl(const OnMouseMoveEvent & message) { typedef void (ksgui_TaskBarIcon::*_fpt)(const OnMouseMoveEvent &); auto _f=xcast<_fpt>(_drva(2475968)); return (this->*_f)(message); }
	inline void onMouseMove(const OnMouseMoveEvent & message) { typedef void (ksgui_TaskBarIcon::*_fpt)(const OnMouseMoveEvent &); auto _f=xcast<_fpt>(get_vfp(this, 12)); return (this->*_f)(message); }
	virtual void render_vf3(float dt);
	inline void render_impl(float dt) { typedef void (ksgui_TaskBarIcon::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2476240)); return (this->*_f)(dt); }
	inline void render(float dt) { typedef void (ksgui_TaskBarIcon::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(dt); }
	inline void setDescriptionText(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * text) { typedef void (ksgui_TaskBarIcon::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *); auto _f=xcast<_fpt>(_drva(2476608)); return (this->*_f)(text); }
	inline void hide(bool value) { typedef void (ksgui_TaskBarIcon::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(2475808)); return (this->*_f)(value); }
	inline void setIcon(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * filename) { typedef void (ksgui_TaskBarIcon::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *); auto _f=xcast<_fpt>(_drva(2476896)); return (this->*_f)(filename); }
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_TaskBarIcon)==536),"bad size");
		static_assert((offsetof(ksgui_TaskBarIcon,status)==0x178),"bad off");
		static_assert((offsetof(ksgui_TaskBarIcon,isOver)==0x17C),"bad off");
		static_assert((offsetof(ksgui_TaskBarIcon,texture)==0x180),"bad off");
		static_assert((offsetof(ksgui_TaskBarIcon,textureOn)==0x1A8),"bad off");
		static_assert((offsetof(ksgui_TaskBarIcon,unselectedColor)==0x1D0),"bad off");
		static_assert((offsetof(ksgui_TaskBarIcon,selectedColor)==0x1E0),"bad off");
		static_assert((offsetof(ksgui_TaskBarIcon,rollOverColor)==0x1F0),"bad off");
		static_assert((offsetof(ksgui_TaskBarIcon,descriptionRect)==0x200),"bad off");
		static_assert((offsetof(ksgui_TaskBarIcon,descriptionLabel)==0x208),"bad off");
		static_assert((offsetof(ksgui_TaskBarIcon,targetX)==0x210),"bad off");
	};
};

//UDT: class CameraOnBoard @len=368 @vfcount=6
	//_Base: class GameObject @off=0 @len=88
	//_Func: public void CameraOnBoard(const CameraOnBoard &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void CameraOnBoard(Game * igame, CameraForward * cam, Sim * aSim); @loc=static @len=4320 @rva=820448
	//_Func: public void ~CameraOnBoard(); @virtual vtpo=0 vfid=0 @loc=static @len=204 @rva=824816
	//_Data: this+0x58, Member, Type: class CameraForward *, camera
	//_Data: this+0x60, Member, Type: class vec3f, offset
	//_Func: public void update(float deltaT); @virtual vtpo=0 vfid=1 @loc=static @len=2658 @rva=827040
	//_Func: public void setPlayerPitch(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void setPlayerFov(float aFov); @loc=static @len=9 @rva=1697712
	//_Func: public float getPlayerPitch(); @loc=optimized @len=0 @rva=0
	//_Func: public float getPlayerFov(); @loc=static @len=9 @rva=811440
	//_Func: public float getPlayerFarPlane(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x70, Member, Type: class Sim *, sim
	//_Data: this+0x78, Member, Type: class CarAvatar *, car
	//_Data: this+0x80, Member, Type: bool, stillCamera
	//_Data: this+0x84, Member, Type: class vec3f, gForceMix
	//_Data: this+0x90, Member, Type: float, onBoardFov
	//_Data: this+0x94, Member, Type: float, gForceLagMix
	//_Data: this+0x98, Member, Type: float, headRotationDegrees
	//_Data: this+0x9C, Member, Type: float, headRotationAnimation
	//_Data: this+0xA0, Member, Type: float, headRotationSpeed
	//_Data: this+0xA4, Member, Type: float, shakeMul
	//_Data: this+0xA8, Member, Type: float, farPlane
	//_Data: this+0xB0, Member, Type: class std::vector<vec3f,std::allocator<vec3f> >, lookBackPoints
	//_Data: this+0xC8, Member, Type: class std::vector<CameraOnBoardCustomSettings,std::allocator<CameraOnBoardCustomSettings> >, customCameraSettings
	//_Data: this+0xE0, Member, Type: class vec3f, gForceMixCurrentOffset
	//_Data: this+0xEC, Member, Type: class vec3f, shakeFreq
	//_Data: this+0xF8, Member, Type: class vec3f, shakeScale
	//_Data: this+0x108, Member, Type: class SignalGenerator3D<SinSignalGenerator>, shakeGenerator
	//_Data: this+0x160, Member, Type: bool, isWorldAligned
	//_Data: this+0x164, Member, Type: class TrackIR, trackIR
	//_Func: protected void lookLeftRight(float dt); @loc=static @len=499 @rva=826240
	//_Func: protected void lookBack(); @loc=static @len=287 @rva=825952
	//_Func: protected void setCameraFrozen(bool  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public CameraOnBoard & operator=(const CameraOnBoard &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class CameraOnBoard : public GameObject {
public:
	CameraForward * camera;
	vec3f offset;
	Sim * sim;
	CarAvatar * car;
	bool stillCamera;
	vec3f gForceMix;
	float onBoardFov;
	float gForceLagMix;
	float headRotationDegrees;
	float headRotationAnimation;
	float headRotationSpeed;
	float shakeMul;
	float farPlane;
	std::vector<vec3f,std::allocator<vec3f> > lookBackPoints;
	std::vector<CameraOnBoardCustomSettings,std::allocator<CameraOnBoardCustomSettings> > customCameraSettings;
	vec3f gForceMixCurrentOffset;
	vec3f shakeFreq;
	vec3f shakeScale;
	SignalGenerator3D<SinSignalGenerator> shakeGenerator;
	bool isWorldAligned;
	TrackIR trackIR;
	inline CameraOnBoard() { }
	inline CameraOnBoard(const CameraOnBoard& other) = default;
	inline CameraOnBoard& operator=(const CameraOnBoard& other) = default;
	inline void ctor(Game * igame, CameraForward * cam, Sim * aSim) { typedef void (CameraOnBoard::*_fpt)(Game *, CameraForward *, Sim *); auto _f=xcast<_fpt>(_drva(820448)); (this->*_f)(igame, cam, aSim); }
	virtual ~CameraOnBoard();
	inline void dtor() { typedef void (CameraOnBoard::*_fpt)(); auto _f=xcast<_fpt>(_drva(824816)); (this->*_f)(); }
	virtual void update_vf1(float deltaT);
	inline void update_impl(float deltaT) { typedef void (CameraOnBoard::*_fpt)(float); auto _f=xcast<_fpt>(_drva(827040)); return (this->*_f)(deltaT); }
	inline void update(float deltaT) { typedef void (CameraOnBoard::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(deltaT); }
	inline void setPlayerFov(float aFov) { typedef void (CameraOnBoard::*_fpt)(float); auto _f=xcast<_fpt>(_drva(1697712)); return (this->*_f)(aFov); }
	inline float getPlayerFov() { typedef float (CameraOnBoard::*_fpt)(); auto _f=xcast<_fpt>(_drva(811440)); return (this->*_f)(); }
	inline void lookLeftRight(float dt) { typedef void (CameraOnBoard::*_fpt)(float); auto _f=xcast<_fpt>(_drva(826240)); return (this->*_f)(dt); }
	inline void lookBack() { typedef void (CameraOnBoard::*_fpt)(); auto _f=xcast<_fpt>(_drva(825952)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(CameraOnBoard)==368),"bad size");
		static_assert((offsetof(CameraOnBoard,camera)==0x58),"bad off");
		static_assert((offsetof(CameraOnBoard,offset)==0x60),"bad off");
		static_assert((offsetof(CameraOnBoard,sim)==0x70),"bad off");
		static_assert((offsetof(CameraOnBoard,car)==0x78),"bad off");
		static_assert((offsetof(CameraOnBoard,stillCamera)==0x80),"bad off");
		static_assert((offsetof(CameraOnBoard,gForceMix)==0x84),"bad off");
		static_assert((offsetof(CameraOnBoard,onBoardFov)==0x90),"bad off");
		static_assert((offsetof(CameraOnBoard,gForceLagMix)==0x94),"bad off");
		static_assert((offsetof(CameraOnBoard,headRotationDegrees)==0x98),"bad off");
		static_assert((offsetof(CameraOnBoard,headRotationAnimation)==0x9C),"bad off");
		static_assert((offsetof(CameraOnBoard,headRotationSpeed)==0xA0),"bad off");
		static_assert((offsetof(CameraOnBoard,shakeMul)==0xA4),"bad off");
		static_assert((offsetof(CameraOnBoard,farPlane)==0xA8),"bad off");
		static_assert((offsetof(CameraOnBoard,lookBackPoints)==0xB0),"bad off");
		static_assert((offsetof(CameraOnBoard,customCameraSettings)==0xC8),"bad off");
		static_assert((offsetof(CameraOnBoard,gForceMixCurrentOffset)==0xE0),"bad off");
		static_assert((offsetof(CameraOnBoard,shakeFreq)==0xEC),"bad off");
		static_assert((offsetof(CameraOnBoard,shakeScale)==0xF8),"bad off");
		static_assert((offsetof(CameraOnBoard,shakeGenerator)==0x108),"bad off");
		static_assert((offsetof(CameraOnBoard,isWorldAligned)==0x160),"bad off");
		static_assert((offsetof(CameraOnBoard,trackIR)==0x164),"bad off");
	};
};

//UDT: class SuspensionML @len=200 @vfcount=25
	//_Base: class ISuspension @off=0 @len=56
	//_Func: public void SuspensionML(const SuspensionML &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void SuspensionML(Car * car, int index); @loc=static @len=299 @rva=2919968
	//_Func: public void ~SuspensionML(); @virtual vtpo=0 vfid=0 @loc=static @len=111 @rva=2920272
	//_Data: this+0x38, Member, Type: class IRigidBody *, hub
	//_Data: this+0x40, Member, Type: struct SuspensionStatus, status
	//_Data: this+0x48, Member, Type: class Damper, damper
	//_Func: public vec3f getBasePosition(); @virtual vtpo=0 vfid=10 @loc=static @len=25 @rva=2921520
	//_Func: public SuspensionStatus & getStatus(); @virtual vtpo=0 vfid=9 @loc=static @len=5 @rva=2922448
	//_Func: public IRigidBody * getHub(); @loc=optimized @len=0 @rva=0
	//_Func: public void attach(); @virtual vtpo=0 vfid=8 @loc=static @len=5 @rva=2921504
	//_Func: public void step(float dt); @virtual vtpo=0 vfid=22 @loc=static @len=653 @rva=2927360
	//_Func: public mat44f getHubWorldMatrix(); @virtual vtpo=0 vfid=1 @loc=static @len=219 @rva=2922176
	//_Func: public vec3f getPointVelocity(const vec3f & p); @virtual vtpo=0 vfid=2 @loc=static @len=31 @rva=2922416
	//_Func: public void addForceAtPos(const vec3f & force, const vec3f & pos, bool driven, bool addToSteerTorque); @virtual vtpo=0 vfid=3 @loc=static @len=276 @rva=2920912
	//_Func: public void addTorque(const vec3f & torque); @virtual vtpo=0 vfid=4 @loc=static @len=152 @rva=2921344
	//_Func: public void setSteerLengthOffset(float o); @virtual vtpo=0 vfid=5 @loc=static @len=188 @rva=2927168
	//_Func: public void getSteerBasis(vec3f & center, vec3f & axis); @virtual vtpo=0 vfid=21 @loc=static @len=345 @rva=2922464
	//_Func: public float getSteerTorque(); @virtual vtpo=0 vfid=6 @loc=static @len=9 @rva=2922816
	//_Func: public vec3f getHubAngularVelocity(); @virtual vtpo=0 vfid=7 @loc=static @len=31 @rva=2922144
	//_Func: public float getK(); @virtual vtpo=0 vfid=11 @loc=static @len=6 @rva=2890720
	//_Func: public Damper * getDamper(); @virtual vtpo=0 vfid=12 @loc=static @len=5 @rva=2921584
	//_Func: public float getPackerRange(); @virtual vtpo=0 vfid=13 @loc=static @len=6 @rva=2740064
	//_Func: public std::vector<DebugLine,std::allocator<DebugLine> > getDebugLines(const mat44f & bodyMatrix, const mat44f & hubMatrix); @virtual vtpo=0 vfid=14 @loc=static @len=534 @rva=2921600
	//_Func: public void setDamage(float amount); @virtual vtpo=0 vfid=15 @loc=static @len=79 @rva=2926976
	//_Func: public void resetDamage(); @virtual vtpo=0 vfid=16 @loc=static @len=11 @rva=2926960
	//_Func: public float getDamage(); @virtual vtpo=0 vfid=17 @loc=static @len=29 @rva=2921552
	//_Func: public float getMass(); @virtual vtpo=0 vfid=18 @loc=static @len=11 @rva=2922400
	//_Func: public void stop(); @virtual vtpo=0 vfid=19 @loc=static @len=19 @rva=2928016
	//_Func: public vec3f getVelocity(); @virtual vtpo=0 vfid=20 @loc=static @len=28 @rva=2922832
	//_Func: public void setERPCFM(float erp, float cfm); @virtual vtpo=0 vfid=23 @loc=static @len=3 @rva=96368
	//_Func: public void addLocalForceAndTorque(const vec3f & force, const vec3f & torque, const vec3f & driveTorque); @virtual vtpo=0 vfid=24 @loc=static @len=144 @rva=2921200
	//_Data: this+0x60, Member, Type: class Car *, car
	//_Data: this+0x68, Member, Type: int, index
	//_Data: this+0x70, Member, Type: class std::vector<MLJoint,std::allocator<MLJoint> >, joints
	//_Data: this+0x88, Member, Type: float, hubMass
	//_Data: this+0x8C, Member, Type: class vec3f, basePosition
	//_Data: this+0x98, Member, Type: float, steerTorque
	//_Data: this+0x9C, Member, Type: struct SusDamageDef, damageData
	//_Data: this+0xB8, Member, Type: class vec3f, baseCarSteerPosition
	//_Func: private void loadINI(int index); @loc=static @len=3847 @rva=2922864
	//_Func: private void setPositions(); @loc=static @len=105 @rva=2927056
	//_Func: public SuspensionML & operator=(const SuspensionML &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class SuspensionML : public ISuspension {
public:
	IRigidBody * hub;
	SuspensionStatus status;
	Damper damper;
	Car * car;
	int index;
	std::vector<MLJoint,std::allocator<MLJoint> > joints;
	float hubMass;
	vec3f basePosition;
	float steerTorque;
	SusDamageDef damageData;
	vec3f baseCarSteerPosition;
	inline SuspensionML() { }
	inline SuspensionML(const SuspensionML& other) = default;
	inline SuspensionML& operator=(const SuspensionML& other) = default;
	inline void ctor(Car * car, int index) { typedef void (SuspensionML::*_fpt)(Car *, int); auto _f=xcast<_fpt>(_drva(2919968)); (this->*_f)(car, index); }
	virtual ~SuspensionML();
	inline void dtor() { typedef void (SuspensionML::*_fpt)(); auto _f=xcast<_fpt>(_drva(2920272)); (this->*_f)(); }
	virtual vec3f getBasePosition_vf10();
	inline vec3f getBasePosition_impl() { typedef vec3f (SuspensionML::*_fpt)(); auto _f=xcast<_fpt>(_drva(2921520)); return (this->*_f)(); }
	inline vec3f getBasePosition() { typedef vec3f (SuspensionML::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 10)); return (this->*_f)(); }
	virtual SuspensionStatus & getStatus_vf9();
	inline SuspensionStatus & getStatus_impl() { typedef SuspensionStatus & (SuspensionML::*_fpt)(); auto _f=xcast<_fpt>(_drva(2922448)); return (this->*_f)(); }
	inline SuspensionStatus & getStatus() { typedef SuspensionStatus & (SuspensionML::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 9)); return (this->*_f)(); }
	virtual void attach_vf8();
	inline void attach_impl() { typedef void (SuspensionML::*_fpt)(); auto _f=xcast<_fpt>(_drva(2921504)); return (this->*_f)(); }
	inline void attach() { typedef void (SuspensionML::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 8)); return (this->*_f)(); }
	virtual void step_vf22(float dt);
	inline void step_impl(float dt) { typedef void (SuspensionML::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2927360)); return (this->*_f)(dt); }
	inline void step(float dt) { typedef void (SuspensionML::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 22)); return (this->*_f)(dt); }
	virtual mat44f getHubWorldMatrix_vf1();
	inline mat44f getHubWorldMatrix_impl() { typedef mat44f (SuspensionML::*_fpt)(); auto _f=xcast<_fpt>(_drva(2922176)); return (this->*_f)(); }
	inline mat44f getHubWorldMatrix() { typedef mat44f (SuspensionML::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(); }
	virtual vec3f getPointVelocity_vf2(const vec3f & p);
	inline vec3f getPointVelocity_impl(const vec3f & p) { typedef vec3f (SuspensionML::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2922416)); return (this->*_f)(p); }
	inline vec3f getPointVelocity(const vec3f & p) { typedef vec3f (SuspensionML::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)(p); }
	virtual void addForceAtPos_vf3(const vec3f & force, const vec3f & pos, bool driven, bool addToSteerTorque);
	inline void addForceAtPos_impl(const vec3f & force, const vec3f & pos, bool driven, bool addToSteerTorque) { typedef void (SuspensionML::*_fpt)(const vec3f &, const vec3f &, bool, bool); auto _f=xcast<_fpt>(_drva(2920912)); return (this->*_f)(force, pos, driven, addToSteerTorque); }
	inline void addForceAtPos(const vec3f & force, const vec3f & pos, bool driven, bool addToSteerTorque) { typedef void (SuspensionML::*_fpt)(const vec3f &, const vec3f &, bool, bool); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(force, pos, driven, addToSteerTorque); }
	virtual void addTorque_vf4(const vec3f & torque);
	inline void addTorque_impl(const vec3f & torque) { typedef void (SuspensionML::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2921344)); return (this->*_f)(torque); }
	inline void addTorque(const vec3f & torque) { typedef void (SuspensionML::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 4)); return (this->*_f)(torque); }
	virtual void setSteerLengthOffset_vf5(float o);
	inline void setSteerLengthOffset_impl(float o) { typedef void (SuspensionML::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2927168)); return (this->*_f)(o); }
	inline void setSteerLengthOffset(float o) { typedef void (SuspensionML::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 5)); return (this->*_f)(o); }
	virtual void getSteerBasis_vf21(vec3f & center, vec3f & axis);
	inline void getSteerBasis_impl(vec3f & center, vec3f & axis) { typedef void (SuspensionML::*_fpt)(vec3f &, vec3f &); auto _f=xcast<_fpt>(_drva(2922464)); return (this->*_f)(center, axis); }
	inline void getSteerBasis(vec3f & center, vec3f & axis) { typedef void (SuspensionML::*_fpt)(vec3f &, vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 21)); return (this->*_f)(center, axis); }
	virtual float getSteerTorque_vf6();
	inline float getSteerTorque_impl() { typedef float (SuspensionML::*_fpt)(); auto _f=xcast<_fpt>(_drva(2922816)); return (this->*_f)(); }
	inline float getSteerTorque() { typedef float (SuspensionML::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 6)); return (this->*_f)(); }
	virtual vec3f getHubAngularVelocity_vf7();
	inline vec3f getHubAngularVelocity_impl() { typedef vec3f (SuspensionML::*_fpt)(); auto _f=xcast<_fpt>(_drva(2922144)); return (this->*_f)(); }
	inline vec3f getHubAngularVelocity() { typedef vec3f (SuspensionML::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 7)); return (this->*_f)(); }
	virtual float getK_vf11();
	inline float getK_impl() { typedef float (SuspensionML::*_fpt)(); auto _f=xcast<_fpt>(_drva(2890720)); return (this->*_f)(); }
	inline float getK() { typedef float (SuspensionML::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 11)); return (this->*_f)(); }
	virtual Damper * getDamper_vf12();
	inline Damper * getDamper_impl() { typedef Damper * (SuspensionML::*_fpt)(); auto _f=xcast<_fpt>(_drva(2921584)); return (this->*_f)(); }
	inline Damper * getDamper() { typedef Damper * (SuspensionML::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 12)); return (this->*_f)(); }
	virtual float getPackerRange_vf13();
	inline float getPackerRange_impl() { typedef float (SuspensionML::*_fpt)(); auto _f=xcast<_fpt>(_drva(2740064)); return (this->*_f)(); }
	inline float getPackerRange() { typedef float (SuspensionML::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 13)); return (this->*_f)(); }
	virtual std::vector<DebugLine,std::allocator<DebugLine> > getDebugLines_vf14(const mat44f & bodyMatrix, const mat44f & hubMatrix);
	inline std::vector<DebugLine,std::allocator<DebugLine> > getDebugLines_impl(const mat44f & bodyMatrix, const mat44f & hubMatrix) { typedef std::vector<DebugLine,std::allocator<DebugLine> > (SuspensionML::*_fpt)(const mat44f &, const mat44f &); auto _f=xcast<_fpt>(_drva(2921600)); return (this->*_f)(bodyMatrix, hubMatrix); }
	inline std::vector<DebugLine,std::allocator<DebugLine> > getDebugLines(const mat44f & bodyMatrix, const mat44f & hubMatrix) { typedef std::vector<DebugLine,std::allocator<DebugLine> > (SuspensionML::*_fpt)(const mat44f &, const mat44f &); auto _f=xcast<_fpt>(get_vfp(this, 14)); return (this->*_f)(bodyMatrix, hubMatrix); }
	virtual void setDamage_vf15(float amount);
	inline void setDamage_impl(float amount) { typedef void (SuspensionML::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2926976)); return (this->*_f)(amount); }
	inline void setDamage(float amount) { typedef void (SuspensionML::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 15)); return (this->*_f)(amount); }
	virtual void resetDamage_vf16();
	inline void resetDamage_impl() { typedef void (SuspensionML::*_fpt)(); auto _f=xcast<_fpt>(_drva(2926960)); return (this->*_f)(); }
	inline void resetDamage() { typedef void (SuspensionML::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 16)); return (this->*_f)(); }
	virtual float getDamage_vf17();
	inline float getDamage_impl() { typedef float (SuspensionML::*_fpt)(); auto _f=xcast<_fpt>(_drva(2921552)); return (this->*_f)(); }
	inline float getDamage() { typedef float (SuspensionML::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 17)); return (this->*_f)(); }
	virtual float getMass_vf18();
	inline float getMass_impl() { typedef float (SuspensionML::*_fpt)(); auto _f=xcast<_fpt>(_drva(2922400)); return (this->*_f)(); }
	inline float getMass() { typedef float (SuspensionML::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 18)); return (this->*_f)(); }
	virtual void stop_vf19();
	inline void stop_impl() { typedef void (SuspensionML::*_fpt)(); auto _f=xcast<_fpt>(_drva(2928016)); return (this->*_f)(); }
	inline void stop() { typedef void (SuspensionML::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 19)); return (this->*_f)(); }
	virtual vec3f getVelocity_vf20();
	inline vec3f getVelocity_impl() { typedef vec3f (SuspensionML::*_fpt)(); auto _f=xcast<_fpt>(_drva(2922832)); return (this->*_f)(); }
	inline vec3f getVelocity() { typedef vec3f (SuspensionML::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 20)); return (this->*_f)(); }
	virtual void setERPCFM_vf23(float erp, float cfm);
	inline void setERPCFM_impl(float erp, float cfm) { typedef void (SuspensionML::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(96368)); return (this->*_f)(erp, cfm); }
	inline void setERPCFM(float erp, float cfm) { typedef void (SuspensionML::*_fpt)(float, float); auto _f=xcast<_fpt>(get_vfp(this, 23)); return (this->*_f)(erp, cfm); }
	virtual void addLocalForceAndTorque_vf24(const vec3f & force, const vec3f & torque, const vec3f & driveTorque);
	inline void addLocalForceAndTorque_impl(const vec3f & force, const vec3f & torque, const vec3f & driveTorque) { typedef void (SuspensionML::*_fpt)(const vec3f &, const vec3f &, const vec3f &); auto _f=xcast<_fpt>(_drva(2921200)); return (this->*_f)(force, torque, driveTorque); }
	inline void addLocalForceAndTorque(const vec3f & force, const vec3f & torque, const vec3f & driveTorque) { typedef void (SuspensionML::*_fpt)(const vec3f &, const vec3f &, const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 24)); return (this->*_f)(force, torque, driveTorque); }
	inline void loadINI(int index) { typedef void (SuspensionML::*_fpt)(int); auto _f=xcast<_fpt>(_drva(2922864)); return (this->*_f)(index); }
	inline void setPositions() { typedef void (SuspensionML::*_fpt)(); auto _f=xcast<_fpt>(_drva(2927056)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(SuspensionML)==200),"bad size");
		static_assert((offsetof(SuspensionML,hub)==0x38),"bad off");
		static_assert((offsetof(SuspensionML,status)==0x40),"bad off");
		static_assert((offsetof(SuspensionML,damper)==0x48),"bad off");
		static_assert((offsetof(SuspensionML,car)==0x60),"bad off");
		static_assert((offsetof(SuspensionML,index)==0x68),"bad off");
		static_assert((offsetof(SuspensionML,joints)==0x70),"bad off");
		static_assert((offsetof(SuspensionML,hubMass)==0x88),"bad off");
		static_assert((offsetof(SuspensionML,basePosition)==0x8C),"bad off");
		static_assert((offsetof(SuspensionML,steerTorque)==0x98),"bad off");
		static_assert((offsetof(SuspensionML,damageData)==0x9C),"bad off");
		static_assert((offsetof(SuspensionML,baseCarSteerPosition)==0xB8),"bad off");
	};
};

//UDT: class ksgui::GameScreen @len=432 @vfcount=22
	//_Base: class ksgui::Control @off=0 @len=376
	//_Func: public void GameScreen(const ksgui_GameScreen &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void GameScreen(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * iname, ksgui_GUI * igui); @loc=static @len=163 @rva=2427856
	//_Func: public void ~GameScreen(); @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Data: this+0x178, Member, Type: bool, appInteractionEnabled
	//_Data: this+0x180, Member, Type: class Event<bool>, evDesktopShown
	//_Func: public void render(float dt); @virtual vtpo=0 vfid=3 @loc=static @len=138 @rva=2428384
	//_Func: public void addControl(ksgui_Control * c, bool addToTaskBar); @intro @virtual vtpo=0 vfid=21 @loc=static @len=110 @rva=2428176
	//_Func: public void showDesktop(); @loc=static @len=585 @rva=2428528
	//_Func: public int getOldAppsCount(); @loc=static @len=19 @rva=2428288
	//_Func: public void shutdown(); @loc=static @len=240 @rva=2429120
	//_Func: public bool onMouseDown(const OnMouseDownEvent & message); @virtual vtpo=0 vfid=10 @loc=static @len=16 @rva=2428320
	//_Func: public void onMouseUp(const OnMouseUpEvent & message); @virtual vtpo=0 vfid=11 @loc=static @len=14 @rva=2428352
	//_Func: public void onMouseMove(const OnMouseMoveEvent & message); @virtual vtpo=0 vfid=12 @loc=static @len=14 @rva=2428336
	//_Func: public void onMouseWheelMovedEvent(const OnMouseWheelMovedEvent & message); @virtual vtpo=0 vfid=13 @loc=static @len=14 @rva=2428368
	//_Data: this+0x198, Member, Type: class std::vector<int,std::allocator<int> >, oldAppsOpened
	//_Func: public ksgui_GameScreen & operator=(const ksgui_GameScreen &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ksgui_GameScreen : public ksgui_Control {
public:
	bool appInteractionEnabled;
	Event<bool> evDesktopShown;
	std::vector<int,std::allocator<int> > oldAppsOpened;
	inline ksgui_GameScreen() { }
	inline ksgui_GameScreen(const ksgui_GameScreen& other) = default;
	inline ksgui_GameScreen& operator=(const ksgui_GameScreen& other) = default;
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * iname, ksgui_GUI * igui) { typedef void (ksgui_GameScreen::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, ksgui_GUI *); auto _f=xcast<_fpt>(_drva(2427856)); (this->*_f)(iname, igui); }
	virtual ~ksgui_GameScreen();
	virtual void render_vf3(float dt);
	inline void render_impl(float dt) { typedef void (ksgui_GameScreen::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2428384)); return (this->*_f)(dt); }
	inline void render(float dt) { typedef void (ksgui_GameScreen::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(dt); }
	virtual void addControl_vf21(ksgui_Control * c, bool addToTaskBar);
	inline void addControl_impl(ksgui_Control * c, bool addToTaskBar) { typedef void (ksgui_GameScreen::*_fpt)(ksgui_Control *, bool); auto _f=xcast<_fpt>(_drva(2428176)); return (this->*_f)(c, addToTaskBar); }
	inline void addControl(ksgui_Control * c, bool addToTaskBar) { typedef void (ksgui_GameScreen::*_fpt)(ksgui_Control *, bool); auto _f=xcast<_fpt>(get_vfp(this, 21)); return (this->*_f)(c, addToTaskBar); }
	inline void showDesktop() { typedef void (ksgui_GameScreen::*_fpt)(); auto _f=xcast<_fpt>(_drva(2428528)); return (this->*_f)(); }
	inline int getOldAppsCount() { typedef int (ksgui_GameScreen::*_fpt)(); auto _f=xcast<_fpt>(_drva(2428288)); return (this->*_f)(); }
	inline void shutdown() { typedef void (ksgui_GameScreen::*_fpt)(); auto _f=xcast<_fpt>(_drva(2429120)); return (this->*_f)(); }
	virtual bool onMouseDown_vf10(const OnMouseDownEvent & message);
	inline bool onMouseDown_impl(const OnMouseDownEvent & message) { typedef bool (ksgui_GameScreen::*_fpt)(const OnMouseDownEvent &); auto _f=xcast<_fpt>(_drva(2428320)); return (this->*_f)(message); }
	inline bool onMouseDown(const OnMouseDownEvent & message) { typedef bool (ksgui_GameScreen::*_fpt)(const OnMouseDownEvent &); auto _f=xcast<_fpt>(get_vfp(this, 10)); return (this->*_f)(message); }
	virtual void onMouseUp_vf11(const OnMouseUpEvent & message);
	inline void onMouseUp_impl(const OnMouseUpEvent & message) { typedef void (ksgui_GameScreen::*_fpt)(const OnMouseUpEvent &); auto _f=xcast<_fpt>(_drva(2428352)); return (this->*_f)(message); }
	inline void onMouseUp(const OnMouseUpEvent & message) { typedef void (ksgui_GameScreen::*_fpt)(const OnMouseUpEvent &); auto _f=xcast<_fpt>(get_vfp(this, 11)); return (this->*_f)(message); }
	virtual void onMouseMove_vf12(const OnMouseMoveEvent & message);
	inline void onMouseMove_impl(const OnMouseMoveEvent & message) { typedef void (ksgui_GameScreen::*_fpt)(const OnMouseMoveEvent &); auto _f=xcast<_fpt>(_drva(2428336)); return (this->*_f)(message); }
	inline void onMouseMove(const OnMouseMoveEvent & message) { typedef void (ksgui_GameScreen::*_fpt)(const OnMouseMoveEvent &); auto _f=xcast<_fpt>(get_vfp(this, 12)); return (this->*_f)(message); }
	virtual void onMouseWheelMovedEvent_vf13(const OnMouseWheelMovedEvent & message);
	inline void onMouseWheelMovedEvent_impl(const OnMouseWheelMovedEvent & message) { typedef void (ksgui_GameScreen::*_fpt)(const OnMouseWheelMovedEvent &); auto _f=xcast<_fpt>(_drva(2428368)); return (this->*_f)(message); }
	inline void onMouseWheelMovedEvent(const OnMouseWheelMovedEvent & message) { typedef void (ksgui_GameScreen::*_fpt)(const OnMouseWheelMovedEvent &); auto _f=xcast<_fpt>(get_vfp(this, 13)); return (this->*_f)(message); }
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_GameScreen)==432),"bad size");
		static_assert((offsetof(ksgui_GameScreen,appInteractionEnabled)==0x178),"bad off");
		static_assert((offsetof(ksgui_GameScreen,evDesktopShown)==0x180),"bad off");
		static_assert((offsetof(ksgui_GameScreen,oldAppsOpened)==0x198),"bad off");
	};
};

//UDT: class ksgui::Slider @len=456 @vfcount=21
	//_Base: class ksgui::Control @off=0 @len=376
	//_Func: public void Slider(const ksgui_Slider &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void Slider(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, ksgui_GUI * myGui, bool dressed); @loc=static @len=1705 @rva=2423280
	//_Func: public void ~Slider(); @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Data: this+0x178, Member, Type: class Event<ksgui::OnSliderInteraction>, evOnSliderInteraction
	//_Data: this+0x190, Member, Type: class Event<ksgui::OnCutExtremesChanged>, evOnCutExtremesChanged
	//_Func: public void setValue(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void render(float dt); @virtual vtpo=0 vfid=3 @loc=static @len=652 @rva=2426240
	//_Func: public bool onMouseDown(const OnMouseDownEvent & message); @virtual vtpo=0 vfid=10 @loc=static @len=335 @rva=2425280
	//_Func: public void onMouseMove(const OnMouseMoveEvent & message); @virtual vtpo=0 vfid=12 @loc=static @len=392 @rva=2425616
	//_Func: public void onMouseUp(const OnMouseUpEvent & message); @virtual vtpo=0 vfid=11 @loc=static @len=221 @rva=2426016
	//_Func: public void didSelectACutMarker(const ksgui_OnControlClicked &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void setSize(float w, float h); @virtual vtpo=0 vfid=7 @loc=static @len=27 @rva=2427504
	//_Func: public void updateMarkers(); @loc=static @len=307 @rva=2427536
	//_Func: public void resetMarkers(); @loc=static @len=293 @rva=2426896
	//_Func: public void setMarkerLeftPosition(float perc); @loc=static @len=158 @rva=2427200
	//_Func: public void setMarkerRightPosition(float perc); @loc=static @len=142 @rva=2427360
	//_Data: this+0x1A8, Member, Type: float, value
	//_Data: this+0x1B0, Member, Type: class ksgui::Control *, mPos
	//_Data: this+0x1B8, Member, Type: class ksgui::Control *, markerLeft
	//_Data: this+0x1C0, Member, Type: class ksgui::Control *, markerRight
	//_Func: public ksgui_Slider & operator=(const ksgui_Slider &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ksgui_Slider : public ksgui_Control {
public:
	Event<ksgui_OnSliderInteraction> evOnSliderInteraction;
	Event<ksgui_OnCutExtremesChanged> evOnCutExtremesChanged;
	float value;
	ksgui_Control * mPos;
	ksgui_Control * markerLeft;
	ksgui_Control * markerRight;
	inline ksgui_Slider() { }
	inline ksgui_Slider(const ksgui_Slider& other) = default;
	inline ksgui_Slider& operator=(const ksgui_Slider& other) = default;
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, ksgui_GUI * myGui, bool dressed) { typedef void (ksgui_Slider::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, ksgui_GUI *, bool); auto _f=xcast<_fpt>(_drva(2423280)); (this->*_f)(name, myGui, dressed); }
	virtual ~ksgui_Slider();
	virtual void render_vf3(float dt);
	inline void render_impl(float dt) { typedef void (ksgui_Slider::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2426240)); return (this->*_f)(dt); }
	inline void render(float dt) { typedef void (ksgui_Slider::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(dt); }
	virtual bool onMouseDown_vf10(const OnMouseDownEvent & message);
	inline bool onMouseDown_impl(const OnMouseDownEvent & message) { typedef bool (ksgui_Slider::*_fpt)(const OnMouseDownEvent &); auto _f=xcast<_fpt>(_drva(2425280)); return (this->*_f)(message); }
	inline bool onMouseDown(const OnMouseDownEvent & message) { typedef bool (ksgui_Slider::*_fpt)(const OnMouseDownEvent &); auto _f=xcast<_fpt>(get_vfp(this, 10)); return (this->*_f)(message); }
	virtual void onMouseMove_vf12(const OnMouseMoveEvent & message);
	inline void onMouseMove_impl(const OnMouseMoveEvent & message) { typedef void (ksgui_Slider::*_fpt)(const OnMouseMoveEvent &); auto _f=xcast<_fpt>(_drva(2425616)); return (this->*_f)(message); }
	inline void onMouseMove(const OnMouseMoveEvent & message) { typedef void (ksgui_Slider::*_fpt)(const OnMouseMoveEvent &); auto _f=xcast<_fpt>(get_vfp(this, 12)); return (this->*_f)(message); }
	virtual void onMouseUp_vf11(const OnMouseUpEvent & message);
	inline void onMouseUp_impl(const OnMouseUpEvent & message) { typedef void (ksgui_Slider::*_fpt)(const OnMouseUpEvent &); auto _f=xcast<_fpt>(_drva(2426016)); return (this->*_f)(message); }
	inline void onMouseUp(const OnMouseUpEvent & message) { typedef void (ksgui_Slider::*_fpt)(const OnMouseUpEvent &); auto _f=xcast<_fpt>(get_vfp(this, 11)); return (this->*_f)(message); }
	virtual void setSize_vf7(float w, float h);
	inline void setSize_impl(float w, float h) { typedef void (ksgui_Slider::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2427504)); return (this->*_f)(w, h); }
	inline void setSize(float w, float h) { typedef void (ksgui_Slider::*_fpt)(float, float); auto _f=xcast<_fpt>(get_vfp(this, 7)); return (this->*_f)(w, h); }
	inline void updateMarkers() { typedef void (ksgui_Slider::*_fpt)(); auto _f=xcast<_fpt>(_drva(2427536)); return (this->*_f)(); }
	inline void resetMarkers() { typedef void (ksgui_Slider::*_fpt)(); auto _f=xcast<_fpt>(_drva(2426896)); return (this->*_f)(); }
	inline void setMarkerLeftPosition(float perc) { typedef void (ksgui_Slider::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2427200)); return (this->*_f)(perc); }
	inline void setMarkerRightPosition(float perc) { typedef void (ksgui_Slider::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2427360)); return (this->*_f)(perc); }
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_Slider)==456),"bad size");
		static_assert((offsetof(ksgui_Slider,evOnSliderInteraction)==0x178),"bad off");
		static_assert((offsetof(ksgui_Slider,evOnCutExtremesChanged)==0x190),"bad off");
		static_assert((offsetof(ksgui_Slider,value)==0x1A8),"bad off");
		static_assert((offsetof(ksgui_Slider,mPos)==0x1B0),"bad off");
		static_assert((offsetof(ksgui_Slider,markerLeft)==0x1B8),"bad off");
		static_assert((offsetof(ksgui_Slider,markerRight)==0x1C0),"bad off");
	};
};

//UDT: class ksgui::ScrollBar @len=448 @vfcount=21
	//_Base: class ksgui::Control @off=0 @len=376
	//_Func: public void ScrollBar(const ksgui_ScrollBar &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void ScrollBar(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * iname, ksgui_GUI * igui, bool isDressed); @loc=static @len=1446 @rva=2469472
	//_Func: public void ~ScrollBar(); @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Data: this+0x178, Member, Type: class Event<ksgui::OnScrollBarValueChanged>, evOnValueChanged
	//_Data: this+0x190, Member, Type: class ksgui::Control *, butPlus
	//_Data: this+0x198, Member, Type: class ksgui::Control *, butMinus
	//_Func: public void setItemsPerPage(unsigned int v); @loc=static @len=24 @rva=2474160
	//_Func: public void setSize(float w, float h); @virtual vtpo=0 vfid=7 @loc=static @len=91 @rva=2474224
	//_Func: public unsigned int getItemsPerPage(); @loc=static @len=7 @rva=2471920
	//_Func: public void setItemsNumber(unsigned int v); @loc=static @len=7 @rva=2474144
	//_Func: public int getItemsNumber(); @loc=optimized @len=0 @rva=0
	//_Func: public float getLastItem(); @loc=optimized @len=0 @rva=0
	//_Func: public void setValue(unsigned int v); @loc=static @len=139 @rva=2474320
	//_Func: public void render(float dt); @virtual vtpo=0 vfid=3 @loc=static @len=822 @rva=2473312
	//_Func: public int getValue(); @loc=optimized @len=0 @rva=0
	//_Func: public void setRepeatInterval(float i); @virtual vtpo=0 vfid=16 @loc=static @len=31 @rva=2474192
	//_Func: public bool onMouseDown(const OnMouseDownEvent & message); @virtual vtpo=0 vfid=10 @loc=static @len=5 @rva=2472096
	//_Func: public void onMouseUp(const OnMouseUpEvent & message); @virtual vtpo=0 vfid=11 @loc=static @len=5 @rva=2472656
	//_Func: public void onMouseMove(const OnMouseMoveEvent & message); @virtual vtpo=0 vfid=12 @loc=static @len=134 @rva=2472496
	//_Func: public int getStep(); @loc=optimized @len=0 @rva=0
	//_Func: public int getMinValue(); @loc=optimized @len=0 @rva=0
	//_Func: public int getMaxValue(); @loc=optimized @len=0 @rva=0
	//_Func: public float getPercentage(); @loc=optimized @len=0 @rva=0
	//_Func: public void onMouseWheelMovedEvent(const OnMouseWheelMovedEvent & message); @virtual vtpo=0 vfid=13 @loc=static @len=225 @rva=2472672
	//_Data: this+0x1A0, Member, Type: bool, dressed
	//_Data: this+0x1A4, Member, Type: unsigned int, minValue
	//_Data: this+0x1A8, Member, Type: unsigned int, maxValue
	//_Data: this+0x1AC, Member, Type: unsigned int, step
	//_Data: this+0x1B0, Member, Type: unsigned int, value
	//_Data: this+0x1B8, Member, Type: class ksgui::MovingBar *, bar
	//_Func: private void drawArrow(ksgui_Control * button, ksgui_eArrowsDirection direction); @loc=static @len=535 @rva=2471376
	//_Func: public ksgui_ScrollBar & operator=(const ksgui_ScrollBar &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ksgui_ScrollBar : public ksgui_Control {
public:
	Event<ksgui_OnScrollBarValueChanged> evOnValueChanged;
	ksgui_Control * butPlus;
	ksgui_Control * butMinus;
	bool dressed;
	unsigned int minValue;
	unsigned int maxValue;
	unsigned int step;
	unsigned int value;
	ksgui_MovingBar * bar;
	inline ksgui_ScrollBar() { }
	inline ksgui_ScrollBar(const ksgui_ScrollBar& other) = default;
	inline ksgui_ScrollBar& operator=(const ksgui_ScrollBar& other) = default;
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * iname, ksgui_GUI * igui, bool isDressed) { typedef void (ksgui_ScrollBar::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, ksgui_GUI *, bool); auto _f=xcast<_fpt>(_drva(2469472)); (this->*_f)(iname, igui, isDressed); }
	virtual ~ksgui_ScrollBar();
	inline void setItemsPerPage(unsigned int v) { typedef void (ksgui_ScrollBar::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(2474160)); return (this->*_f)(v); }
	virtual void setSize_vf7(float w, float h);
	inline void setSize_impl(float w, float h) { typedef void (ksgui_ScrollBar::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2474224)); return (this->*_f)(w, h); }
	inline void setSize(float w, float h) { typedef void (ksgui_ScrollBar::*_fpt)(float, float); auto _f=xcast<_fpt>(get_vfp(this, 7)); return (this->*_f)(w, h); }
	inline unsigned int getItemsPerPage() { typedef unsigned int (ksgui_ScrollBar::*_fpt)(); auto _f=xcast<_fpt>(_drva(2471920)); return (this->*_f)(); }
	inline void setItemsNumber(unsigned int v) { typedef void (ksgui_ScrollBar::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(2474144)); return (this->*_f)(v); }
	inline void setValue(unsigned int v) { typedef void (ksgui_ScrollBar::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(2474320)); return (this->*_f)(v); }
	virtual void render_vf3(float dt);
	inline void render_impl(float dt) { typedef void (ksgui_ScrollBar::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2473312)); return (this->*_f)(dt); }
	inline void render(float dt) { typedef void (ksgui_ScrollBar::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(dt); }
	virtual void setRepeatInterval_vf16(float i);
	inline void setRepeatInterval_impl(float i) { typedef void (ksgui_ScrollBar::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2474192)); return (this->*_f)(i); }
	inline void setRepeatInterval(float i) { typedef void (ksgui_ScrollBar::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 16)); return (this->*_f)(i); }
	virtual bool onMouseDown_vf10(const OnMouseDownEvent & message);
	inline bool onMouseDown_impl(const OnMouseDownEvent & message) { typedef bool (ksgui_ScrollBar::*_fpt)(const OnMouseDownEvent &); auto _f=xcast<_fpt>(_drva(2472096)); return (this->*_f)(message); }
	inline bool onMouseDown(const OnMouseDownEvent & message) { typedef bool (ksgui_ScrollBar::*_fpt)(const OnMouseDownEvent &); auto _f=xcast<_fpt>(get_vfp(this, 10)); return (this->*_f)(message); }
	virtual void onMouseUp_vf11(const OnMouseUpEvent & message);
	inline void onMouseUp_impl(const OnMouseUpEvent & message) { typedef void (ksgui_ScrollBar::*_fpt)(const OnMouseUpEvent &); auto _f=xcast<_fpt>(_drva(2472656)); return (this->*_f)(message); }
	inline void onMouseUp(const OnMouseUpEvent & message) { typedef void (ksgui_ScrollBar::*_fpt)(const OnMouseUpEvent &); auto _f=xcast<_fpt>(get_vfp(this, 11)); return (this->*_f)(message); }
	virtual void onMouseMove_vf12(const OnMouseMoveEvent & message);
	inline void onMouseMove_impl(const OnMouseMoveEvent & message) { typedef void (ksgui_ScrollBar::*_fpt)(const OnMouseMoveEvent &); auto _f=xcast<_fpt>(_drva(2472496)); return (this->*_f)(message); }
	inline void onMouseMove(const OnMouseMoveEvent & message) { typedef void (ksgui_ScrollBar::*_fpt)(const OnMouseMoveEvent &); auto _f=xcast<_fpt>(get_vfp(this, 12)); return (this->*_f)(message); }
	virtual void onMouseWheelMovedEvent_vf13(const OnMouseWheelMovedEvent & message);
	inline void onMouseWheelMovedEvent_impl(const OnMouseWheelMovedEvent & message) { typedef void (ksgui_ScrollBar::*_fpt)(const OnMouseWheelMovedEvent &); auto _f=xcast<_fpt>(_drva(2472672)); return (this->*_f)(message); }
	inline void onMouseWheelMovedEvent(const OnMouseWheelMovedEvent & message) { typedef void (ksgui_ScrollBar::*_fpt)(const OnMouseWheelMovedEvent &); auto _f=xcast<_fpt>(get_vfp(this, 13)); return (this->*_f)(message); }
	inline void drawArrow(ksgui_Control * button, ksgui_eArrowsDirection direction) { typedef void (ksgui_ScrollBar::*_fpt)(ksgui_Control *, ksgui_eArrowsDirection); auto _f=xcast<_fpt>(_drva(2471376)); return (this->*_f)(button, direction); }
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_ScrollBar)==448),"bad size");
		static_assert((offsetof(ksgui_ScrollBar,evOnValueChanged)==0x178),"bad off");
		static_assert((offsetof(ksgui_ScrollBar,butPlus)==0x190),"bad off");
		static_assert((offsetof(ksgui_ScrollBar,butMinus)==0x198),"bad off");
		static_assert((offsetof(ksgui_ScrollBar,dressed)==0x1A0),"bad off");
		static_assert((offsetof(ksgui_ScrollBar,minValue)==0x1A4),"bad off");
		static_assert((offsetof(ksgui_ScrollBar,maxValue)==0x1A8),"bad off");
		static_assert((offsetof(ksgui_ScrollBar,step)==0x1AC),"bad off");
		static_assert((offsetof(ksgui_ScrollBar,value)==0x1B0),"bad off");
		static_assert((offsetof(ksgui_ScrollBar,bar)==0x1B8),"bad off");
	};
};

//UDT: class SuspensionAxle @len=176 @vfcount=25
	//_Base: class ISuspension @off=0 @len=56
	//_Func: public void SuspensionAxle(const SuspensionAxle &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void SuspensionAxle(Car * car, RigidAxleSide side, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & carDataPath); @loc=static @len=4450 @rva=2911120
	//_Func: public void ~SuspensionAxle(); @virtual vtpo=0 vfid=0 @loc=static @len=111 @rva=2915584
	//_Func: public mat44f getHubWorldMatrix(); @virtual vtpo=0 vfid=1 @loc=static @len=126 @rva=2917440
	//_Func: public vec3f getPointVelocity(const vec3f & p); @virtual vtpo=0 vfid=2 @loc=static @len=31 @rva=2917600
	//_Func: public void addForceAtPos(const vec3f & force, const vec3f & pos, bool driven, bool addToSteerTorque); @virtual vtpo=0 vfid=3 @loc=static @len=14 @rva=2916096
	//_Func: public void addTorque(const vec3f & torque); @virtual vtpo=0 vfid=4 @loc=static @len=14 @rva=2916256
	//_Func: public void setSteerLengthOffset(float o); @virtual vtpo=0 vfid=5 @loc=static @len=3 @rva=96368
	//_Func: public float getSteerTorque(); @virtual vtpo=0 vfid=6 @loc=static @len=4 @rva=4518448
	//_Func: public vec3f getHubAngularVelocity(); @virtual vtpo=0 vfid=7 @loc=static @len=31 @rva=2917408
	//_Func: public void attach(); @virtual vtpo=0 vfid=8 @loc=static @len=5 @rva=2916272
	//_Func: public SuspensionStatus & getStatus(); @virtual vtpo=0 vfid=9 @loc=static @len=5 @rva=2917632
	//_Func: public vec3f getBasePosition(); @virtual vtpo=0 vfid=10 @loc=static @len=59 @rva=2916288
	//_Func: public float getK(); @virtual vtpo=0 vfid=11 @loc=static @len=6 @rva=2890720
	//_Func: public Damper * getDamper(); @virtual vtpo=0 vfid=12 @loc=static @len=5 @rva=2916352
	//_Func: public float getPackerRange(); @virtual vtpo=0 vfid=13 @loc=static @len=4 @rva=4518448
	//_Func: public std::vector<DebugLine,std::allocator<DebugLine> > getDebugLines(const mat44f & bodyMatrix, const mat44f & hubMatrix); @virtual vtpo=0 vfid=14 @loc=static @len=1035 @rva=2916368
	//_Func: public void setDamage(float amount); @virtual vtpo=0 vfid=15 @loc=static @len=3 @rva=96368
	//_Func: public void resetDamage(); @virtual vtpo=0 vfid=16 @loc=static @len=3 @rva=96368
	//_Func: public float getDamage(); @virtual vtpo=0 vfid=17 @loc=static @len=4 @rva=4518448
	//_Func: public float getMass(); @virtual vtpo=0 vfid=18 @loc=static @len=27 @rva=2917568
	//_Func: public void stop(); @virtual vtpo=0 vfid=19 @loc=static @len=19 @rva=2919856
	//_Func: public vec3f getVelocity(); @virtual vtpo=0 vfid=20 @loc=static @len=69 @rva=2917792
	//_Func: public void step(float dt); @virtual vtpo=0 vfid=22 @loc=static @len=1598 @rva=2918256
	//_Func: public void printRollCenter(float tyreRadius); @loc=static @len=3 @rva=96368
	//_Func: public void getSteerBasis(vec3f & center, vec3f & axis); @virtual vtpo=0 vfid=21 @loc=static @len=143 @rva=2917648
	//_Func: public void setERPCFM(float erp, float cfm); @virtual vtpo=0 vfid=23 @loc=static @len=94 @rva=2918016
	//_Func: public void addLocalForceAndTorque(const vec3f & force, const vec3f & torque, const vec3f & driveTorque); @virtual vtpo=0 vfid=24 @loc=static @len=144 @rva=2916112
	//_Data: this+0x38, Member, Type: enum RigidAxleSide, side
	//_Data: this+0x3C, Member, Type: class Damper, damper
	//_Data: this+0x58, Member, Type: class Car *, car
	//_Data: this+0x60, Member, Type: class IRigidBody *, axle
	//_Data: this+0x68, Member, Type: struct SuspensionStatus, status
	//_Data: this+0x70, Member, Type: class vec3f, axleBasePos
	//_Data: this+0x7C, Member, Type: float, track
	//_Data: this+0x80, Member, Type: float, referenceY
	//_Data: this+0x88, Member, Type: class std::vector<AxleJoint,std::allocator<AxleJoint> >, joints
	//_Data: this+0xA0, Member, Type: class vec3f, leafSpringK
	//_Data: this+0xAC, Member, Type: float, attachRelativePos
	//_Func: private void setPositions(); @loc=static @len=140 @rva=2918112
	//_Func: public SuspensionAxle & operator=(const SuspensionAxle &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class SuspensionAxle : public ISuspension {
public:
	RigidAxleSide side;
	Damper damper;
	Car * car;
	IRigidBody * axle;
	SuspensionStatus status;
	vec3f axleBasePos;
	float track;
	float referenceY;
	std::vector<AxleJoint,std::allocator<AxleJoint> > joints;
	vec3f leafSpringK;
	float attachRelativePos;
	inline SuspensionAxle() { }
	inline SuspensionAxle(const SuspensionAxle& other) = default;
	inline SuspensionAxle& operator=(const SuspensionAxle& other) = default;
	inline void ctor(Car * car, RigidAxleSide side, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & carDataPath) { typedef void (SuspensionAxle::*_fpt)(Car *, RigidAxleSide, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2911120)); (this->*_f)(car, side, carDataPath); }
	virtual ~SuspensionAxle();
	inline void dtor() { typedef void (SuspensionAxle::*_fpt)(); auto _f=xcast<_fpt>(_drva(2915584)); (this->*_f)(); }
	virtual mat44f getHubWorldMatrix_vf1();
	inline mat44f getHubWorldMatrix_impl() { typedef mat44f (SuspensionAxle::*_fpt)(); auto _f=xcast<_fpt>(_drva(2917440)); return (this->*_f)(); }
	inline mat44f getHubWorldMatrix() { typedef mat44f (SuspensionAxle::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(); }
	virtual vec3f getPointVelocity_vf2(const vec3f & p);
	inline vec3f getPointVelocity_impl(const vec3f & p) { typedef vec3f (SuspensionAxle::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2917600)); return (this->*_f)(p); }
	inline vec3f getPointVelocity(const vec3f & p) { typedef vec3f (SuspensionAxle::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)(p); }
	virtual void addForceAtPos_vf3(const vec3f & force, const vec3f & pos, bool driven, bool addToSteerTorque);
	inline void addForceAtPos_impl(const vec3f & force, const vec3f & pos, bool driven, bool addToSteerTorque) { typedef void (SuspensionAxle::*_fpt)(const vec3f &, const vec3f &, bool, bool); auto _f=xcast<_fpt>(_drva(2916096)); return (this->*_f)(force, pos, driven, addToSteerTorque); }
	inline void addForceAtPos(const vec3f & force, const vec3f & pos, bool driven, bool addToSteerTorque) { typedef void (SuspensionAxle::*_fpt)(const vec3f &, const vec3f &, bool, bool); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(force, pos, driven, addToSteerTorque); }
	virtual void addTorque_vf4(const vec3f & torque);
	inline void addTorque_impl(const vec3f & torque) { typedef void (SuspensionAxle::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2916256)); return (this->*_f)(torque); }
	inline void addTorque(const vec3f & torque) { typedef void (SuspensionAxle::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 4)); return (this->*_f)(torque); }
	virtual void setSteerLengthOffset_vf5(float o);
	inline void setSteerLengthOffset_impl(float o) { typedef void (SuspensionAxle::*_fpt)(float); auto _f=xcast<_fpt>(_drva(96368)); return (this->*_f)(o); }
	inline void setSteerLengthOffset(float o) { typedef void (SuspensionAxle::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 5)); return (this->*_f)(o); }
	virtual float getSteerTorque_vf6();
	inline float getSteerTorque_impl() { typedef float (SuspensionAxle::*_fpt)(); auto _f=xcast<_fpt>(_drva(4518448)); return (this->*_f)(); }
	inline float getSteerTorque() { typedef float (SuspensionAxle::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 6)); return (this->*_f)(); }
	virtual vec3f getHubAngularVelocity_vf7();
	inline vec3f getHubAngularVelocity_impl() { typedef vec3f (SuspensionAxle::*_fpt)(); auto _f=xcast<_fpt>(_drva(2917408)); return (this->*_f)(); }
	inline vec3f getHubAngularVelocity() { typedef vec3f (SuspensionAxle::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 7)); return (this->*_f)(); }
	virtual void attach_vf8();
	inline void attach_impl() { typedef void (SuspensionAxle::*_fpt)(); auto _f=xcast<_fpt>(_drva(2916272)); return (this->*_f)(); }
	inline void attach() { typedef void (SuspensionAxle::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 8)); return (this->*_f)(); }
	virtual SuspensionStatus & getStatus_vf9();
	inline SuspensionStatus & getStatus_impl() { typedef SuspensionStatus & (SuspensionAxle::*_fpt)(); auto _f=xcast<_fpt>(_drva(2917632)); return (this->*_f)(); }
	inline SuspensionStatus & getStatus() { typedef SuspensionStatus & (SuspensionAxle::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 9)); return (this->*_f)(); }
	virtual vec3f getBasePosition_vf10();
	inline vec3f getBasePosition_impl() { typedef vec3f (SuspensionAxle::*_fpt)(); auto _f=xcast<_fpt>(_drva(2916288)); return (this->*_f)(); }
	inline vec3f getBasePosition() { typedef vec3f (SuspensionAxle::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 10)); return (this->*_f)(); }
	virtual float getK_vf11();
	inline float getK_impl() { typedef float (SuspensionAxle::*_fpt)(); auto _f=xcast<_fpt>(_drva(2890720)); return (this->*_f)(); }
	inline float getK() { typedef float (SuspensionAxle::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 11)); return (this->*_f)(); }
	virtual Damper * getDamper_vf12();
	inline Damper * getDamper_impl() { typedef Damper * (SuspensionAxle::*_fpt)(); auto _f=xcast<_fpt>(_drva(2916352)); return (this->*_f)(); }
	inline Damper * getDamper() { typedef Damper * (SuspensionAxle::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 12)); return (this->*_f)(); }
	virtual float getPackerRange_vf13();
	inline float getPackerRange_impl() { typedef float (SuspensionAxle::*_fpt)(); auto _f=xcast<_fpt>(_drva(4518448)); return (this->*_f)(); }
	inline float getPackerRange() { typedef float (SuspensionAxle::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 13)); return (this->*_f)(); }
	virtual std::vector<DebugLine,std::allocator<DebugLine> > getDebugLines_vf14(const mat44f & bodyMatrix, const mat44f & hubMatrix);
	inline std::vector<DebugLine,std::allocator<DebugLine> > getDebugLines_impl(const mat44f & bodyMatrix, const mat44f & hubMatrix) { typedef std::vector<DebugLine,std::allocator<DebugLine> > (SuspensionAxle::*_fpt)(const mat44f &, const mat44f &); auto _f=xcast<_fpt>(_drva(2916368)); return (this->*_f)(bodyMatrix, hubMatrix); }
	inline std::vector<DebugLine,std::allocator<DebugLine> > getDebugLines(const mat44f & bodyMatrix, const mat44f & hubMatrix) { typedef std::vector<DebugLine,std::allocator<DebugLine> > (SuspensionAxle::*_fpt)(const mat44f &, const mat44f &); auto _f=xcast<_fpt>(get_vfp(this, 14)); return (this->*_f)(bodyMatrix, hubMatrix); }
	virtual void setDamage_vf15(float amount);
	inline void setDamage_impl(float amount) { typedef void (SuspensionAxle::*_fpt)(float); auto _f=xcast<_fpt>(_drva(96368)); return (this->*_f)(amount); }
	inline void setDamage(float amount) { typedef void (SuspensionAxle::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 15)); return (this->*_f)(amount); }
	virtual void resetDamage_vf16();
	inline void resetDamage_impl() { typedef void (SuspensionAxle::*_fpt)(); auto _f=xcast<_fpt>(_drva(96368)); return (this->*_f)(); }
	inline void resetDamage() { typedef void (SuspensionAxle::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 16)); return (this->*_f)(); }
	virtual float getDamage_vf17();
	inline float getDamage_impl() { typedef float (SuspensionAxle::*_fpt)(); auto _f=xcast<_fpt>(_drva(4518448)); return (this->*_f)(); }
	inline float getDamage() { typedef float (SuspensionAxle::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 17)); return (this->*_f)(); }
	virtual float getMass_vf18();
	inline float getMass_impl() { typedef float (SuspensionAxle::*_fpt)(); auto _f=xcast<_fpt>(_drva(2917568)); return (this->*_f)(); }
	inline float getMass() { typedef float (SuspensionAxle::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 18)); return (this->*_f)(); }
	virtual void stop_vf19();
	inline void stop_impl() { typedef void (SuspensionAxle::*_fpt)(); auto _f=xcast<_fpt>(_drva(2919856)); return (this->*_f)(); }
	inline void stop() { typedef void (SuspensionAxle::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 19)); return (this->*_f)(); }
	virtual vec3f getVelocity_vf20();
	inline vec3f getVelocity_impl() { typedef vec3f (SuspensionAxle::*_fpt)(); auto _f=xcast<_fpt>(_drva(2917792)); return (this->*_f)(); }
	inline vec3f getVelocity() { typedef vec3f (SuspensionAxle::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 20)); return (this->*_f)(); }
	virtual void step_vf22(float dt);
	inline void step_impl(float dt) { typedef void (SuspensionAxle::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2918256)); return (this->*_f)(dt); }
	inline void step(float dt) { typedef void (SuspensionAxle::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 22)); return (this->*_f)(dt); }
	inline void printRollCenter(float tyreRadius) { typedef void (SuspensionAxle::*_fpt)(float); auto _f=xcast<_fpt>(_drva(96368)); return (this->*_f)(tyreRadius); }
	virtual void getSteerBasis_vf21(vec3f & center, vec3f & axis);
	inline void getSteerBasis_impl(vec3f & center, vec3f & axis) { typedef void (SuspensionAxle::*_fpt)(vec3f &, vec3f &); auto _f=xcast<_fpt>(_drva(2917648)); return (this->*_f)(center, axis); }
	inline void getSteerBasis(vec3f & center, vec3f & axis) { typedef void (SuspensionAxle::*_fpt)(vec3f &, vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 21)); return (this->*_f)(center, axis); }
	virtual void setERPCFM_vf23(float erp, float cfm);
	inline void setERPCFM_impl(float erp, float cfm) { typedef void (SuspensionAxle::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2918016)); return (this->*_f)(erp, cfm); }
	inline void setERPCFM(float erp, float cfm) { typedef void (SuspensionAxle::*_fpt)(float, float); auto _f=xcast<_fpt>(get_vfp(this, 23)); return (this->*_f)(erp, cfm); }
	virtual void addLocalForceAndTorque_vf24(const vec3f & force, const vec3f & torque, const vec3f & driveTorque);
	inline void addLocalForceAndTorque_impl(const vec3f & force, const vec3f & torque, const vec3f & driveTorque) { typedef void (SuspensionAxle::*_fpt)(const vec3f &, const vec3f &, const vec3f &); auto _f=xcast<_fpt>(_drva(2916112)); return (this->*_f)(force, torque, driveTorque); }
	inline void addLocalForceAndTorque(const vec3f & force, const vec3f & torque, const vec3f & driveTorque) { typedef void (SuspensionAxle::*_fpt)(const vec3f &, const vec3f &, const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 24)); return (this->*_f)(force, torque, driveTorque); }
	inline void setPositions() { typedef void (SuspensionAxle::*_fpt)(); auto _f=xcast<_fpt>(_drva(2918112)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(SuspensionAxle)==176),"bad size");
		static_assert((offsetof(SuspensionAxle,side)==0x38),"bad off");
		static_assert((offsetof(SuspensionAxle,damper)==0x3C),"bad off");
		static_assert((offsetof(SuspensionAxle,car)==0x58),"bad off");
		static_assert((offsetof(SuspensionAxle,axle)==0x60),"bad off");
		static_assert((offsetof(SuspensionAxle,status)==0x68),"bad off");
		static_assert((offsetof(SuspensionAxle,axleBasePos)==0x70),"bad off");
		static_assert((offsetof(SuspensionAxle,track)==0x7C),"bad off");
		static_assert((offsetof(SuspensionAxle,referenceY)==0x80),"bad off");
		static_assert((offsetof(SuspensionAxle,joints)==0x88),"bad off");
		static_assert((offsetof(SuspensionAxle,leafSpringK)==0xA0),"bad off");
		static_assert((offsetof(SuspensionAxle,attachRelativePos)==0xAC),"bad off");
	};
};

//UDT: class SuspensionStrut @len=488 @vfcount=25
	//_Base: class ISuspension @off=0 @len=56
	//_Func: public void SuspensionStrut(const SuspensionStrut &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void SuspensionStrut(Car * car, int index); @loc=static @len=1059 @rva=2898128
	//_Func: public void ~SuspensionStrut(); @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Data: this+0x38, Member, Type: class IRigidBody *, carBody
	//_Data: this+0x40, Member, Type: class IRigidBody *, hub
	//_Data: this+0x48, Member, Type: class vec3f, basePosition
	//_Data: this+0x58, Member, Type: class IJoint *[0x5], joints
	//_Data: this+0x80, Member, Type: class IJoint *, bumpStopJoint
	//_Data: this+0x88, Member, Type: struct SStrutSuspensionData, dataRelToWheel
	//_Data: this+0xF8, Member, Type: struct SStrutSuspensionData, dataRelToBody
	//_Data: this+0x168, Member, Type: class Damper, damper
	//_Data: this+0x180, Member, Type: struct SuspensionStatus, status
	//_Data: this+0x188, Member, Type: int, index
	//_Func: public vec3f getBasePosition(); @virtual vtpo=0 vfid=10 @loc=static @len=19 @rva=2901648
	//_Func: public SuspensionStatus & getStatus(); @virtual vtpo=0 vfid=9 @loc=static @len=8 @rva=2903392
	//_Func: public IRigidBody * getHub(); @loc=optimized @len=0 @rva=0
	//_Func: public void attach(); @virtual vtpo=0 vfid=8 @loc=static @len=1419 @rva=2900224
	//_Func: public void setPositions(); @loc=static @len=814 @rva=2908688
	//_Func: public void step(float dt); @virtual vtpo=0 vfid=22 @loc=static @len=1312 @rva=2909696
	//_Func: public void addForceAtPos(const vec3f & force, const vec3f & pos, bool driven, bool addToSteerTorque); @virtual vtpo=0 vfid=3 @loc=static @len=280 @rva=2899296
	//_Func: public void getSteerBasis(vec3f & center, vec3f & axis); @virtual vtpo=0 vfid=21 @loc=static @len=340 @rva=2903408
	//_Func: public mat44f getHubWorldMatrix(); @virtual vtpo=0 vfid=1 @loc=static @len=219 @rva=2903120
	//_Func: public vec3f getPointVelocity(const vec3f & p); @virtual vtpo=0 vfid=2 @loc=static @len=31 @rva=2903360
	//_Func: public void addTorque(const vec3f & torque); @virtual vtpo=0 vfid=4 @loc=static @len=152 @rva=2900064
	//_Func: public void setSteerLengthOffset(float o); @virtual vtpo=0 vfid=5 @loc=static @len=182 @rva=2909504
	//_Func: public float getSteerTorque(); @virtual vtpo=0 vfid=6 @loc=static @len=9 @rva=2903760
	//_Func: public void setSteerTorque(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public vec3f getHubAngularVelocity(); @virtual vtpo=0 vfid=7 @loc=static @len=31 @rva=2890688
	//_Func: public float getK(); @virtual vtpo=0 vfid=11 @loc=static @len=6 @rva=2890720
	//_Func: public Damper * getDamper(); @virtual vtpo=0 vfid=12 @loc=static @len=8 @rva=2901712
	//_Func: public float getPackerRange(); @virtual vtpo=0 vfid=13 @loc=static @len=6 @rva=2740064
	//_Func: public std::vector<DebugLine,std::allocator<DebugLine> > getDebugLines(const mat44f & bodyMatrix, const mat44f & hubMatrix); @virtual vtpo=0 vfid=14 @loc=static @len=1392 @rva=2901728
	//_Func: public void setDamage(float amount); @virtual vtpo=0 vfid=15 @loc=static @len=79 @rva=2908512
	//_Func: public float getDamage(); @virtual vtpo=0 vfid=17 @loc=static @len=29 @rva=2901680
	//_Func: public void resetDamage(); @virtual vtpo=0 vfid=16 @loc=static @len=11 @rva=2908496
	//_Func: public float getMass(); @virtual vtpo=0 vfid=18 @loc=static @len=11 @rva=2903344
	//_Func: public void stop(); @virtual vtpo=0 vfid=19 @loc=static @len=19 @rva=2911008
	//_Func: public vec3f getVelocity(); @virtual vtpo=0 vfid=20 @loc=static @len=28 @rva=2891120
	//_Func: public void setERPCFM(float erp, float cfm); @virtual vtpo=0 vfid=23 @loc=static @len=93 @rva=2908592
	//_Func: public void addLocalForceAndTorque(const vec3f & force, const vec3f & torque, const vec3f & driveTorque); @virtual vtpo=0 vfid=24 @loc=static @len=466 @rva=2899584
	//_Data: this+0x190, Member, Type: class PhysicsEngine *, physicsEngine
	//_Data: this+0x198, Member, Type: float, steerLinkBaseLength
	//_Data: this+0x19C, Member, Type: float, steerTorque
	//_Data: this+0x1A0, Member, Type: class vec3f, baseCarSteerPosition
	//_Data: this+0x1AC, Member, Type: float, steerAngle
	//_Data: this+0x1B0, Member, Type: float, strutBaseLength
	//_Data: this+0x1B8, Member, Type: class IRigidBody *, strutBody
	//_Data: this+0x1C0, Member, Type: float, strutBodyLength
	//_Data: this+0x1C4, Member, Type: struct SusStrutDamageDef, damageData
	//_Data: this+0x1E0, Member, Type: class Car *, car
	//_Func: private void loadINI(int index); @loc=static @len=4706 @rva=2903776
	//_Func: public SuspensionStrut & operator=(const SuspensionStrut &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class SuspensionStrut : public ISuspension {
public:
	IRigidBody * carBody;
	IRigidBody * hub;
	vec3f basePosition;
	IJoint * joints[5];
	IJoint * bumpStopJoint;
	SStrutSuspensionData dataRelToWheel;
	SStrutSuspensionData dataRelToBody;
	Damper damper;
	SuspensionStatus status;
	int index;
	PhysicsEngine * physicsEngine;
	float steerLinkBaseLength;
	float steerTorque;
	vec3f baseCarSteerPosition;
	float steerAngle;
	float strutBaseLength;
	IRigidBody * strutBody;
	float strutBodyLength;
	SusStrutDamageDef damageData;
	Car * car;
	inline SuspensionStrut() { }
	inline SuspensionStrut(const SuspensionStrut& other) = default;
	inline SuspensionStrut& operator=(const SuspensionStrut& other) = default;
	inline void ctor(Car * car, int index) { typedef void (SuspensionStrut::*_fpt)(Car *, int); auto _f=xcast<_fpt>(_drva(2898128)); (this->*_f)(car, index); }
	virtual ~SuspensionStrut();
	virtual vec3f getBasePosition_vf10();
	inline vec3f getBasePosition_impl() { typedef vec3f (SuspensionStrut::*_fpt)(); auto _f=xcast<_fpt>(_drva(2901648)); return (this->*_f)(); }
	inline vec3f getBasePosition() { typedef vec3f (SuspensionStrut::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 10)); return (this->*_f)(); }
	virtual SuspensionStatus & getStatus_vf9();
	inline SuspensionStatus & getStatus_impl() { typedef SuspensionStatus & (SuspensionStrut::*_fpt)(); auto _f=xcast<_fpt>(_drva(2903392)); return (this->*_f)(); }
	inline SuspensionStatus & getStatus() { typedef SuspensionStatus & (SuspensionStrut::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 9)); return (this->*_f)(); }
	virtual void attach_vf8();
	inline void attach_impl() { typedef void (SuspensionStrut::*_fpt)(); auto _f=xcast<_fpt>(_drva(2900224)); return (this->*_f)(); }
	inline void attach() { typedef void (SuspensionStrut::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 8)); return (this->*_f)(); }
	inline void setPositions() { typedef void (SuspensionStrut::*_fpt)(); auto _f=xcast<_fpt>(_drva(2908688)); return (this->*_f)(); }
	virtual void step_vf22(float dt);
	inline void step_impl(float dt) { typedef void (SuspensionStrut::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2909696)); return (this->*_f)(dt); }
	inline void step(float dt) { typedef void (SuspensionStrut::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 22)); return (this->*_f)(dt); }
	virtual void addForceAtPos_vf3(const vec3f & force, const vec3f & pos, bool driven, bool addToSteerTorque);
	inline void addForceAtPos_impl(const vec3f & force, const vec3f & pos, bool driven, bool addToSteerTorque) { typedef void (SuspensionStrut::*_fpt)(const vec3f &, const vec3f &, bool, bool); auto _f=xcast<_fpt>(_drva(2899296)); return (this->*_f)(force, pos, driven, addToSteerTorque); }
	inline void addForceAtPos(const vec3f & force, const vec3f & pos, bool driven, bool addToSteerTorque) { typedef void (SuspensionStrut::*_fpt)(const vec3f &, const vec3f &, bool, bool); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(force, pos, driven, addToSteerTorque); }
	virtual void getSteerBasis_vf21(vec3f & center, vec3f & axis);
	inline void getSteerBasis_impl(vec3f & center, vec3f & axis) { typedef void (SuspensionStrut::*_fpt)(vec3f &, vec3f &); auto _f=xcast<_fpt>(_drva(2903408)); return (this->*_f)(center, axis); }
	inline void getSteerBasis(vec3f & center, vec3f & axis) { typedef void (SuspensionStrut::*_fpt)(vec3f &, vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 21)); return (this->*_f)(center, axis); }
	virtual mat44f getHubWorldMatrix_vf1();
	inline mat44f getHubWorldMatrix_impl() { typedef mat44f (SuspensionStrut::*_fpt)(); auto _f=xcast<_fpt>(_drva(2903120)); return (this->*_f)(); }
	inline mat44f getHubWorldMatrix() { typedef mat44f (SuspensionStrut::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(); }
	virtual vec3f getPointVelocity_vf2(const vec3f & p);
	inline vec3f getPointVelocity_impl(const vec3f & p) { typedef vec3f (SuspensionStrut::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2903360)); return (this->*_f)(p); }
	inline vec3f getPointVelocity(const vec3f & p) { typedef vec3f (SuspensionStrut::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)(p); }
	virtual void addTorque_vf4(const vec3f & torque);
	inline void addTorque_impl(const vec3f & torque) { typedef void (SuspensionStrut::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2900064)); return (this->*_f)(torque); }
	inline void addTorque(const vec3f & torque) { typedef void (SuspensionStrut::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 4)); return (this->*_f)(torque); }
	virtual void setSteerLengthOffset_vf5(float o);
	inline void setSteerLengthOffset_impl(float o) { typedef void (SuspensionStrut::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2909504)); return (this->*_f)(o); }
	inline void setSteerLengthOffset(float o) { typedef void (SuspensionStrut::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 5)); return (this->*_f)(o); }
	virtual float getSteerTorque_vf6();
	inline float getSteerTorque_impl() { typedef float (SuspensionStrut::*_fpt)(); auto _f=xcast<_fpt>(_drva(2903760)); return (this->*_f)(); }
	inline float getSteerTorque() { typedef float (SuspensionStrut::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 6)); return (this->*_f)(); }
	virtual vec3f getHubAngularVelocity_vf7();
	inline vec3f getHubAngularVelocity_impl() { typedef vec3f (SuspensionStrut::*_fpt)(); auto _f=xcast<_fpt>(_drva(2890688)); return (this->*_f)(); }
	inline vec3f getHubAngularVelocity() { typedef vec3f (SuspensionStrut::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 7)); return (this->*_f)(); }
	virtual float getK_vf11();
	inline float getK_impl() { typedef float (SuspensionStrut::*_fpt)(); auto _f=xcast<_fpt>(_drva(2890720)); return (this->*_f)(); }
	inline float getK() { typedef float (SuspensionStrut::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 11)); return (this->*_f)(); }
	virtual Damper * getDamper_vf12();
	inline Damper * getDamper_impl() { typedef Damper * (SuspensionStrut::*_fpt)(); auto _f=xcast<_fpt>(_drva(2901712)); return (this->*_f)(); }
	inline Damper * getDamper() { typedef Damper * (SuspensionStrut::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 12)); return (this->*_f)(); }
	virtual float getPackerRange_vf13();
	inline float getPackerRange_impl() { typedef float (SuspensionStrut::*_fpt)(); auto _f=xcast<_fpt>(_drva(2740064)); return (this->*_f)(); }
	inline float getPackerRange() { typedef float (SuspensionStrut::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 13)); return (this->*_f)(); }
	virtual std::vector<DebugLine,std::allocator<DebugLine> > getDebugLines_vf14(const mat44f & bodyMatrix, const mat44f & hubMatrix);
	inline std::vector<DebugLine,std::allocator<DebugLine> > getDebugLines_impl(const mat44f & bodyMatrix, const mat44f & hubMatrix) { typedef std::vector<DebugLine,std::allocator<DebugLine> > (SuspensionStrut::*_fpt)(const mat44f &, const mat44f &); auto _f=xcast<_fpt>(_drva(2901728)); return (this->*_f)(bodyMatrix, hubMatrix); }
	inline std::vector<DebugLine,std::allocator<DebugLine> > getDebugLines(const mat44f & bodyMatrix, const mat44f & hubMatrix) { typedef std::vector<DebugLine,std::allocator<DebugLine> > (SuspensionStrut::*_fpt)(const mat44f &, const mat44f &); auto _f=xcast<_fpt>(get_vfp(this, 14)); return (this->*_f)(bodyMatrix, hubMatrix); }
	virtual void setDamage_vf15(float amount);
	inline void setDamage_impl(float amount) { typedef void (SuspensionStrut::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2908512)); return (this->*_f)(amount); }
	inline void setDamage(float amount) { typedef void (SuspensionStrut::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 15)); return (this->*_f)(amount); }
	virtual float getDamage_vf17();
	inline float getDamage_impl() { typedef float (SuspensionStrut::*_fpt)(); auto _f=xcast<_fpt>(_drva(2901680)); return (this->*_f)(); }
	inline float getDamage() { typedef float (SuspensionStrut::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 17)); return (this->*_f)(); }
	virtual void resetDamage_vf16();
	inline void resetDamage_impl() { typedef void (SuspensionStrut::*_fpt)(); auto _f=xcast<_fpt>(_drva(2908496)); return (this->*_f)(); }
	inline void resetDamage() { typedef void (SuspensionStrut::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 16)); return (this->*_f)(); }
	virtual float getMass_vf18();
	inline float getMass_impl() { typedef float (SuspensionStrut::*_fpt)(); auto _f=xcast<_fpt>(_drva(2903344)); return (this->*_f)(); }
	inline float getMass() { typedef float (SuspensionStrut::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 18)); return (this->*_f)(); }
	virtual void stop_vf19();
	inline void stop_impl() { typedef void (SuspensionStrut::*_fpt)(); auto _f=xcast<_fpt>(_drva(2911008)); return (this->*_f)(); }
	inline void stop() { typedef void (SuspensionStrut::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 19)); return (this->*_f)(); }
	virtual vec3f getVelocity_vf20();
	inline vec3f getVelocity_impl() { typedef vec3f (SuspensionStrut::*_fpt)(); auto _f=xcast<_fpt>(_drva(2891120)); return (this->*_f)(); }
	inline vec3f getVelocity() { typedef vec3f (SuspensionStrut::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 20)); return (this->*_f)(); }
	virtual void setERPCFM_vf23(float erp, float cfm);
	inline void setERPCFM_impl(float erp, float cfm) { typedef void (SuspensionStrut::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2908592)); return (this->*_f)(erp, cfm); }
	inline void setERPCFM(float erp, float cfm) { typedef void (SuspensionStrut::*_fpt)(float, float); auto _f=xcast<_fpt>(get_vfp(this, 23)); return (this->*_f)(erp, cfm); }
	virtual void addLocalForceAndTorque_vf24(const vec3f & force, const vec3f & torque, const vec3f & driveTorque);
	inline void addLocalForceAndTorque_impl(const vec3f & force, const vec3f & torque, const vec3f & driveTorque) { typedef void (SuspensionStrut::*_fpt)(const vec3f &, const vec3f &, const vec3f &); auto _f=xcast<_fpt>(_drva(2899584)); return (this->*_f)(force, torque, driveTorque); }
	inline void addLocalForceAndTorque(const vec3f & force, const vec3f & torque, const vec3f & driveTorque) { typedef void (SuspensionStrut::*_fpt)(const vec3f &, const vec3f &, const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 24)); return (this->*_f)(force, torque, driveTorque); }
	inline void loadINI(int index) { typedef void (SuspensionStrut::*_fpt)(int); auto _f=xcast<_fpt>(_drva(2903776)); return (this->*_f)(index); }
	inline void _guard_obj() {
		static_assert((sizeof(SuspensionStrut)==488),"bad size");
		static_assert((offsetof(SuspensionStrut,carBody)==0x38),"bad off");
		static_assert((offsetof(SuspensionStrut,hub)==0x40),"bad off");
		static_assert((offsetof(SuspensionStrut,basePosition)==0x48),"bad off");
		static_assert((offsetof(SuspensionStrut,joints)==0x58),"bad off");
		static_assert((offsetof(SuspensionStrut,bumpStopJoint)==0x80),"bad off");
		static_assert((offsetof(SuspensionStrut,dataRelToWheel)==0x88),"bad off");
		static_assert((offsetof(SuspensionStrut,dataRelToBody)==0xF8),"bad off");
		static_assert((offsetof(SuspensionStrut,damper)==0x168),"bad off");
		static_assert((offsetof(SuspensionStrut,status)==0x180),"bad off");
		static_assert((offsetof(SuspensionStrut,index)==0x188),"bad off");
		static_assert((offsetof(SuspensionStrut,physicsEngine)==0x190),"bad off");
		static_assert((offsetof(SuspensionStrut,steerLinkBaseLength)==0x198),"bad off");
		static_assert((offsetof(SuspensionStrut,steerTorque)==0x19C),"bad off");
		static_assert((offsetof(SuspensionStrut,baseCarSteerPosition)==0x1A0),"bad off");
		static_assert((offsetof(SuspensionStrut,steerAngle)==0x1AC),"bad off");
		static_assert((offsetof(SuspensionStrut,strutBaseLength)==0x1B0),"bad off");
		static_assert((offsetof(SuspensionStrut,strutBody)==0x1B8),"bad off");
		static_assert((offsetof(SuspensionStrut,strutBodyLength)==0x1C0),"bad off");
		static_assert((offsetof(SuspensionStrut,damageData)==0x1C4),"bad off");
		static_assert((offsetof(SuspensionStrut,car)==0x1E0),"bad off");
	};
};

//UDT: class ksgui::Spinner @len=624 @vfcount=21
	//_Base: class ksgui::Control @off=0 @len=376
	//_Func: public void Spinner(const ksgui_Spinner &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void Spinner(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & iname, ksgui_GUI * igui, bool isDressed, bool mirrored); @loc=static @len=3253 @rva=2407104
	//_Func: public void ~Spinner(); @virtual vtpo=0 vfid=0 @loc=static @len=132 @rva=2410368
	//_Data: this+0x178, Member, Type: bool, homogeneousPressingDelay
	//_Data: this+0x17C, Member, Type: float, displayValueMult
	//_Data: this+0x180, Member, Type: int, minValue
	//_Data: this+0x184, Member, Type: int, maxValue
	//_Data: this+0x188, Member, Type: int, step
	//_Data: this+0x190, Member, Type: class Event<ksgui::OnSpinnerValueChanged>, evOnValueChanged
	//_Data: this+0x1A8, Member, Type: class ksgui::PopOver *, popOver
	//_Data: this+0x1B0, Member, Type: bool, displayPopover
	//_Data: this+0x1B1, Member, Type: bool, drawUnderline
	//_Data: this+0x1B2, Member, Type: bool, displayCentralValue
	//_Data: this+0x1B3, Member, Type: bool, displayLabel
	//_Data: this+0x1B8, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, units
	//_Data: this+0x1D8, Member, Type: float, textSize
	//_Data: this+0x1DC, Member, Type: bool, isReadOnly
	//_Func: public void setValue(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & itemName); @loc=static @len=292 @rva=2415920
	//_Func: public void setValue(int v); @loc=static @len=139 @rva=2416224
	//_Func: public void render(float dt); @virtual vtpo=0 vfid=3 @loc=static @len=2271 @rva=2411984
	//_Func: public int getValue(); @loc=static @len=7 @rva=2411712
	//_Func: public std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getItemAt(unsigned int index); @loc=static @len=68 @rva=3316640
	//_Func: public void setRepeatInterval(float i); @virtual vtpo=0 vfid=16 @loc=static @len=31 @rva=2415552
	//_Func: public void addItem(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * item); @loc=static @len=150 @rva=2411392
	//_Func: public void setFlatStyle(bool  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void setLabelText(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * text); @loc=static @len=106 @rva=2415296
	//_Func: public void setSize(float w, float h); @virtual vtpo=0 vfid=7 @loc=static @len=329 @rva=2415584
	//_Func: public void setPosition(float x, float y); @loc=static @len=142 @rva=2415408
	//_Func: public std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getCurrentItem(); @loc=static @len=147 @rva=2411552
	//_Func: public void setLabelMaxChar(int  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void timedIncrement(); @loc=optimized @len=0 @rva=0
	//_Func: public void timedDecrement(); @loc=optimized @len=0 @rva=0
	//_Func: public bool onMouseDown(const OnMouseDownEvent & message); @virtual vtpo=0 vfid=10 @loc=static @len=64 @rva=2411728
	//_Func: public void onMouseMove(const OnMouseMoveEvent & message); @virtual vtpo=0 vfid=12 @loc=static @len=181 @rva=2411792
	//_Func: public void setDrawArrows(bool draw); @loc=static @len=641 @rva=2414640
	//_Func: protected void scaleByMult(float value); @virtual vtpo=0 vfid=19 @loc=static @len=43 @rva=2414592
	//_Data: this+0x1E0, Member, Type: float, counter
	//_Data: this+0x1E4, Member, Type: float, pressionCounter
	//_Data: this+0x1E8, Member, Type: class ksgui::Control *, butPlus
	//_Data: this+0x1F0, Member, Type: class ksgui::Control *, butMinus
	//_Data: this+0x1F8, Member, Type: class ksgui::Control *, selectionSlider
	//_Data: this+0x200, Member, Type: class ksgui::Label *, label
	//_Data: this+0x208, Member, Type: class Texture, valueBack
	//_Data: this+0x230, Member, Type: bool, dressed
	//_Data: this+0x238, Member, Type: struct ksgui::OnControlClicked, lastOnControlClicked
	//_Data: this+0x248, Member, Type: int, value
	//_Data: this+0x250, Member, Type: class std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, items
	//_Data: this+0x268, Member, Type: bool, mirrored
	//_Data: this+0x26C, Member, Type: float, triangleWidth
	//_Func: private void drawArrow(ksgui_Control *  _arg0, ksgui_eArrowsDirection  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: private void resize(float value); @loc=static @len=325 @rva=2414256
	//_Func: public ksgui_Spinner & operator=(const ksgui_Spinner &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ksgui_Spinner : public ksgui_Control {
public:
	bool homogeneousPressingDelay;
	float displayValueMult;
	int minValue;
	int maxValue;
	int step;
	Event<ksgui_OnSpinnerValueChanged> evOnValueChanged;
	ksgui_PopOver * popOver;
	bool displayPopover;
	bool drawUnderline;
	bool displayCentralValue;
	bool displayLabel;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > units;
	float textSize;
	bool isReadOnly;
	float counter;
	float pressionCounter;
	ksgui_Control * butPlus;
	ksgui_Control * butMinus;
	ksgui_Control * selectionSlider;
	ksgui_Label * label;
	Texture valueBack;
	bool dressed;
	ksgui_OnControlClicked lastOnControlClicked;
	int value;
	std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > items;
	bool mirrored;
	float triangleWidth;
	inline ksgui_Spinner() { }
	inline ksgui_Spinner(const ksgui_Spinner& other) = default;
	inline ksgui_Spinner& operator=(const ksgui_Spinner& other) = default;
	inline void ctor(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & iname, ksgui_GUI * igui, bool isDressed, bool mirrored) { typedef void (ksgui_Spinner::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, ksgui_GUI *, bool, bool); auto _f=xcast<_fpt>(_drva(2407104)); (this->*_f)(iname, igui, isDressed, mirrored); }
	virtual ~ksgui_Spinner();
	inline void dtor() { typedef void (ksgui_Spinner::*_fpt)(); auto _f=xcast<_fpt>(_drva(2410368)); (this->*_f)(); }
	inline void setValue(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & itemName) { typedef void (ksgui_Spinner::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2415920)); return (this->*_f)(itemName); }
	inline void setValue(int v) { typedef void (ksgui_Spinner::*_fpt)(int); auto _f=xcast<_fpt>(_drva(2416224)); return (this->*_f)(v); }
	virtual void render_vf3(float dt);
	inline void render_impl(float dt) { typedef void (ksgui_Spinner::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2411984)); return (this->*_f)(dt); }
	inline void render(float dt) { typedef void (ksgui_Spinner::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(dt); }
	inline int getValue() { typedef int (ksgui_Spinner::*_fpt)(); auto _f=xcast<_fpt>(_drva(2411712)); return (this->*_f)(); }
	inline std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getItemAt(unsigned int index) { typedef std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > (ksgui_Spinner::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(3316640)); return (this->*_f)(index); }
	virtual void setRepeatInterval_vf16(float i);
	inline void setRepeatInterval_impl(float i) { typedef void (ksgui_Spinner::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2415552)); return (this->*_f)(i); }
	inline void setRepeatInterval(float i) { typedef void (ksgui_Spinner::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 16)); return (this->*_f)(i); }
	inline void addItem(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * item) { typedef void (ksgui_Spinner::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *); auto _f=xcast<_fpt>(_drva(2411392)); return (this->*_f)(item); }
	inline void setLabelText(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * text) { typedef void (ksgui_Spinner::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *); auto _f=xcast<_fpt>(_drva(2415296)); return (this->*_f)(text); }
	virtual void setSize_vf7(float w, float h);
	inline void setSize_impl(float w, float h) { typedef void (ksgui_Spinner::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2415584)); return (this->*_f)(w, h); }
	inline void setSize(float w, float h) { typedef void (ksgui_Spinner::*_fpt)(float, float); auto _f=xcast<_fpt>(get_vfp(this, 7)); return (this->*_f)(w, h); }
	inline void setPosition(float x, float y) { typedef void (ksgui_Spinner::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2415408)); return (this->*_f)(x, y); }
	inline std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getCurrentItem() { typedef std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > (ksgui_Spinner::*_fpt)(); auto _f=xcast<_fpt>(_drva(2411552)); return (this->*_f)(); }
	virtual bool onMouseDown_vf10(const OnMouseDownEvent & message);
	inline bool onMouseDown_impl(const OnMouseDownEvent & message) { typedef bool (ksgui_Spinner::*_fpt)(const OnMouseDownEvent &); auto _f=xcast<_fpt>(_drva(2411728)); return (this->*_f)(message); }
	inline bool onMouseDown(const OnMouseDownEvent & message) { typedef bool (ksgui_Spinner::*_fpt)(const OnMouseDownEvent &); auto _f=xcast<_fpt>(get_vfp(this, 10)); return (this->*_f)(message); }
	virtual void onMouseMove_vf12(const OnMouseMoveEvent & message);
	inline void onMouseMove_impl(const OnMouseMoveEvent & message) { typedef void (ksgui_Spinner::*_fpt)(const OnMouseMoveEvent &); auto _f=xcast<_fpt>(_drva(2411792)); return (this->*_f)(message); }
	inline void onMouseMove(const OnMouseMoveEvent & message) { typedef void (ksgui_Spinner::*_fpt)(const OnMouseMoveEvent &); auto _f=xcast<_fpt>(get_vfp(this, 12)); return (this->*_f)(message); }
	inline void setDrawArrows(bool draw) { typedef void (ksgui_Spinner::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(2414640)); return (this->*_f)(draw); }
	virtual void scaleByMult_vf19(float value);
	inline void scaleByMult_impl(float value) { typedef void (ksgui_Spinner::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2414592)); return (this->*_f)(value); }
	inline void scaleByMult(float value) { typedef void (ksgui_Spinner::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 19)); return (this->*_f)(value); }
	inline void resize(float value) { typedef void (ksgui_Spinner::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2414256)); return (this->*_f)(value); }
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_Spinner)==624),"bad size");
		static_assert((offsetof(ksgui_Spinner,homogeneousPressingDelay)==0x178),"bad off");
		static_assert((offsetof(ksgui_Spinner,displayValueMult)==0x17C),"bad off");
		static_assert((offsetof(ksgui_Spinner,minValue)==0x180),"bad off");
		static_assert((offsetof(ksgui_Spinner,maxValue)==0x184),"bad off");
		static_assert((offsetof(ksgui_Spinner,step)==0x188),"bad off");
		static_assert((offsetof(ksgui_Spinner,evOnValueChanged)==0x190),"bad off");
		static_assert((offsetof(ksgui_Spinner,popOver)==0x1A8),"bad off");
		static_assert((offsetof(ksgui_Spinner,displayPopover)==0x1B0),"bad off");
		static_assert((offsetof(ksgui_Spinner,drawUnderline)==0x1B1),"bad off");
		static_assert((offsetof(ksgui_Spinner,displayCentralValue)==0x1B2),"bad off");
		static_assert((offsetof(ksgui_Spinner,displayLabel)==0x1B3),"bad off");
		static_assert((offsetof(ksgui_Spinner,units)==0x1B8),"bad off");
		static_assert((offsetof(ksgui_Spinner,textSize)==0x1D8),"bad off");
		static_assert((offsetof(ksgui_Spinner,isReadOnly)==0x1DC),"bad off");
		static_assert((offsetof(ksgui_Spinner,counter)==0x1E0),"bad off");
		static_assert((offsetof(ksgui_Spinner,pressionCounter)==0x1E4),"bad off");
		static_assert((offsetof(ksgui_Spinner,butPlus)==0x1E8),"bad off");
		static_assert((offsetof(ksgui_Spinner,butMinus)==0x1F0),"bad off");
		static_assert((offsetof(ksgui_Spinner,selectionSlider)==0x1F8),"bad off");
		static_assert((offsetof(ksgui_Spinner,label)==0x200),"bad off");
		static_assert((offsetof(ksgui_Spinner,valueBack)==0x208),"bad off");
		static_assert((offsetof(ksgui_Spinner,dressed)==0x230),"bad off");
		static_assert((offsetof(ksgui_Spinner,lastOnControlClicked)==0x238),"bad off");
		static_assert((offsetof(ksgui_Spinner,value)==0x248),"bad off");
		static_assert((offsetof(ksgui_Spinner,items)==0x250),"bad off");
		static_assert((offsetof(ksgui_Spinner,mirrored)==0x268),"bad off");
		static_assert((offsetof(ksgui_Spinner,triangleWidth)==0x26C),"bad off");
	};
};

//UDT: class ksgui::Taskbar @len=616 @vfcount=21
	//_Base: class ksgui::Control @off=0 @len=376
	//_Func: public void Taskbar(const ksgui_Taskbar &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void Taskbar(ksgui_GUI * igui); @loc=static @len=2106 @rva=2460192
	//_Func: public void ~Taskbar(); @virtual vtpo=0 vfid=0 @loc=static @len=260 @rva=2462304
	//_Data: this+0x178, Member, Type: int, targetX
	//_Data: this+0x17C, Member, Type: bool, taskBarFullShowed
	//_Data: this+0x180, Member, Type: class Event<ksgui::OnControlClicked>, evAppOpened
	//_Data: this+0x198, Member, Type: class Event<ksgui::OnControlClicked>, evAppDismiss
	//_Data: this+0x1B0, Member, Type: class std::vector<ksgui::Form *,std::allocator<ksgui::Form *> >, forms
	//_Func: public void render(float dt); @virtual vtpo=0 vfid=3 @loc=static @len=599 @rva=2465872
	//_Func: public void addForm(ksgui_Form * form); @loc=static @len=467 @rva=2464784
	//_Func: public void shutdown(); @loc=optimized @len=0 @rva=0
	//_Func: public void onAppClicked(const ksgui_OnControlClicked &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void onMouseMove(const OnMouseMoveEvent & message); @virtual vtpo=0 vfid=12 @loc=static @len=70 @rva=2465648
	//_Func: public void mouseWheelMoved(const OnMouseWheelMovedEvent & message); @loc=static @len=186 @rva=2465456
	//_Func: public void selectVirtualDesktop(int id); @loc=static @len=170 @rva=2466480
	//_Func: public int getNumDekstops(); @loc=optimized @len=0 @rva=0
	//_Func: public short cycleDekstop(); @loc=static @len=177 @rva=2465264
	//_Func: public float getTargetFullShow(); @loc=optimized @len=0 @rva=0
	//_Func: public float getTargetOutOfSight(); @loc=optimized @len=0 @rva=0
	//_Func: public unsigned int getFormCount(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x1C8, Member, Type: class Event<int>, evOnDesktopChange
	//_Data: this+0x1E0, Member, Type: class vec4f, selectedColor
	//_Data: this+0x1F0, Member, Type: class vec4f, unselectedColor
	//_Data: this+0x200, Member, Type: class ksgui::Control *, topScroller
	//_Data: this+0x208, Member, Type: class ksgui::Control *, bottomScroller
	//_Data: this+0x210, Member, Type: class std::vector<ksgui::Control *,std::allocator<ksgui::Control *> >, desktops
	//_Data: this+0x228, Member, Type: float, targetOutOfSight
	//_Data: this+0x22C, Member, Type: float, targetFullShow
	//_Data: this+0x230, Member, Type: int, topAppIndex
	//_Data: this+0x238, Member, Type: class std::shared_ptr<Font>, appFont
	//_Data: this+0x248, Member, Type: class std::vector<ksgui::TaskBarIcon *,std::allocator<ksgui::TaskBarIcon *> >, icons
	//_Data: this+0x260, Member, Type: short, virtualDesktop
	//_Func: protected void setTopAppIndex(int  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: protected void updateAppIconsPosition(); @loc=static @len=309 @rva=2466656
	//_Func: protected ksgui_Control * addDesktop(int id, int x, int y); @loc=static @len=543 @rva=2464240
	//_Func: public ksgui_Taskbar & operator=(const ksgui_Taskbar &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ksgui_Taskbar : public ksgui_Control {
public:
	int targetX;
	bool taskBarFullShowed;
	Event<ksgui_OnControlClicked> evAppOpened;
	Event<ksgui_OnControlClicked> evAppDismiss;
	std::vector<ksgui_Form *,std::allocator<ksgui_Form *> > forms;
	Event<int> evOnDesktopChange;
	vec4f selectedColor;
	vec4f unselectedColor;
	ksgui_Control * topScroller;
	ksgui_Control * bottomScroller;
	std::vector<ksgui_Control *,std::allocator<ksgui_Control *> > desktops;
	float targetOutOfSight;
	float targetFullShow;
	int topAppIndex;
	std::shared_ptr<Font> appFont;
	std::vector<ksgui_TaskBarIcon *,std::allocator<ksgui_TaskBarIcon *> > icons;
	short virtualDesktop;
	inline ksgui_Taskbar() { }
	inline ksgui_Taskbar(const ksgui_Taskbar& other) = default;
	inline ksgui_Taskbar& operator=(const ksgui_Taskbar& other) = default;
	inline void ctor(ksgui_GUI * igui) { typedef void (ksgui_Taskbar::*_fpt)(ksgui_GUI *); auto _f=xcast<_fpt>(_drva(2460192)); (this->*_f)(igui); }
	virtual ~ksgui_Taskbar();
	inline void dtor() { typedef void (ksgui_Taskbar::*_fpt)(); auto _f=xcast<_fpt>(_drva(2462304)); (this->*_f)(); }
	virtual void render_vf3(float dt);
	inline void render_impl(float dt) { typedef void (ksgui_Taskbar::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2465872)); return (this->*_f)(dt); }
	inline void render(float dt) { typedef void (ksgui_Taskbar::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(dt); }
	inline void addForm(ksgui_Form * form) { typedef void (ksgui_Taskbar::*_fpt)(ksgui_Form *); auto _f=xcast<_fpt>(_drva(2464784)); return (this->*_f)(form); }
	virtual void onMouseMove_vf12(const OnMouseMoveEvent & message);
	inline void onMouseMove_impl(const OnMouseMoveEvent & message) { typedef void (ksgui_Taskbar::*_fpt)(const OnMouseMoveEvent &); auto _f=xcast<_fpt>(_drva(2465648)); return (this->*_f)(message); }
	inline void onMouseMove(const OnMouseMoveEvent & message) { typedef void (ksgui_Taskbar::*_fpt)(const OnMouseMoveEvent &); auto _f=xcast<_fpt>(get_vfp(this, 12)); return (this->*_f)(message); }
	inline void mouseWheelMoved(const OnMouseWheelMovedEvent & message) { typedef void (ksgui_Taskbar::*_fpt)(const OnMouseWheelMovedEvent &); auto _f=xcast<_fpt>(_drva(2465456)); return (this->*_f)(message); }
	inline void selectVirtualDesktop(int id) { typedef void (ksgui_Taskbar::*_fpt)(int); auto _f=xcast<_fpt>(_drva(2466480)); return (this->*_f)(id); }
	inline short cycleDekstop() { typedef short (ksgui_Taskbar::*_fpt)(); auto _f=xcast<_fpt>(_drva(2465264)); return (this->*_f)(); }
	inline void updateAppIconsPosition() { typedef void (ksgui_Taskbar::*_fpt)(); auto _f=xcast<_fpt>(_drva(2466656)); return (this->*_f)(); }
	inline ksgui_Control * addDesktop(int id, int x, int y) { typedef ksgui_Control * (ksgui_Taskbar::*_fpt)(int, int, int); auto _f=xcast<_fpt>(_drva(2464240)); return (this->*_f)(id, x, y); }
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_Taskbar)==616),"bad size");
		static_assert((offsetof(ksgui_Taskbar,targetX)==0x178),"bad off");
		static_assert((offsetof(ksgui_Taskbar,taskBarFullShowed)==0x17C),"bad off");
		static_assert((offsetof(ksgui_Taskbar,evAppOpened)==0x180),"bad off");
		static_assert((offsetof(ksgui_Taskbar,evAppDismiss)==0x198),"bad off");
		static_assert((offsetof(ksgui_Taskbar,forms)==0x1B0),"bad off");
		static_assert((offsetof(ksgui_Taskbar,evOnDesktopChange)==0x1C8),"bad off");
		static_assert((offsetof(ksgui_Taskbar,selectedColor)==0x1E0),"bad off");
		static_assert((offsetof(ksgui_Taskbar,unselectedColor)==0x1F0),"bad off");
		static_assert((offsetof(ksgui_Taskbar,topScroller)==0x200),"bad off");
		static_assert((offsetof(ksgui_Taskbar,bottomScroller)==0x208),"bad off");
		static_assert((offsetof(ksgui_Taskbar,desktops)==0x210),"bad off");
		static_assert((offsetof(ksgui_Taskbar,targetOutOfSight)==0x228),"bad off");
		static_assert((offsetof(ksgui_Taskbar,targetFullShow)==0x22C),"bad off");
		static_assert((offsetof(ksgui_Taskbar,topAppIndex)==0x230),"bad off");
		static_assert((offsetof(ksgui_Taskbar,appFont)==0x238),"bad off");
		static_assert((offsetof(ksgui_Taskbar,icons)==0x248),"bad off");
		static_assert((offsetof(ksgui_Taskbar,virtualDesktop)==0x260),"bad off");
	};
};

//UDT: class Suspension @len=528 @vfcount=25
	//_Base: class ISuspension @off=0 @len=56
	//_Func: public void Suspension(const Suspension &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void Suspension(Car * car, int index); @loc=static @len=1035 @rva=2885408
	//_Func: public void ~Suspension(); @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Data: this+0x38, Member, Type: class IRigidBody *, carBody
	//_Data: this+0x40, Member, Type: class IRigidBody *, hub
	//_Data: this+0x48, Member, Type: class vec3f, basePosition
	//_Data: this+0x58, Member, Type: class Car *, car
	//_Data: this+0x60, Member, Type: bool, useActiveActuator
	//_Data: this+0x68, Member, Type: class IJoint *[0x5], joints
	//_Data: this+0x90, Member, Type: class IJoint *, bumpStopJoint
	//_Data: this+0x98, Member, Type: struct SDWSuspensionData, dataRelToWheel
	//_Data: this+0x114, Member, Type: struct SDWSuspensionData, dataRelToBody
	//_Data: this+0x190, Member, Type: class Damper, damper
	//_Data: this+0x1A8, Member, Type: class ActiveActuator, activeActuator
	//_Data: this+0x1C0, Member, Type: struct SuspensionStatus, status
	//_Data: this+0x1C8, Member, Type: int, index
	//_Func: public vec3f getBasePosition(); @virtual vtpo=0 vfid=10 @loc=static @len=19 @rva=2901648
	//_Func: public SuspensionStatus & getStatus(); @virtual vtpo=0 vfid=9 @loc=static @len=8 @rva=2890736
	//_Func: public IRigidBody * getHub(); @loc=optimized @len=0 @rva=0
	//_Func: public void attach(); @virtual vtpo=0 vfid=8 @loc=static @len=1356 @rva=2887600
	//_Func: public void setPositions(); @loc=optimized @len=0 @rva=0
	//_Func: public void step(float dt); @virtual vtpo=0 vfid=22 @loc=static @len=1338 @rva=2896784
	//_Func: public mat44f getHubWorldMatrix(); @virtual vtpo=0 vfid=1 @loc=static @len=219 @rva=2903120
	//_Func: public vec3f getPointVelocity(const vec3f & p); @virtual vtpo=0 vfid=2 @loc=static @len=31 @rva=2903360
	//_Func: public void addForceAtPos(const vec3f & force, const vec3f & pos, bool driven, bool addToSteerTorque); @virtual vtpo=0 vfid=3 @loc=static @len=335 @rva=2886640
	//_Func: public void addTorque(const vec3f & torque); @virtual vtpo=0 vfid=4 @loc=static @len=152 @rva=2887440
	//_Func: public void setSteerLengthOffset(float o); @virtual vtpo=0 vfid=5 @loc=static @len=247 @rva=2896528
	//_Func: public void getSteerBasis(vec3f & centre, vec3f & axis); @virtual vtpo=0 vfid=21 @loc=static @len=340 @rva=2890752
	//_Func: public float getSteerTorque(); @virtual vtpo=0 vfid=6 @loc=static @len=9 @rva=2891104
	//_Func: public void setSteerTorque(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public vec3f getHubAngularVelocity(); @virtual vtpo=0 vfid=7 @loc=static @len=31 @rva=2890688
	//_Func: public float getK(); @virtual vtpo=0 vfid=11 @loc=static @len=6 @rva=2890720
	//_Func: public Damper * getDamper(); @virtual vtpo=0 vfid=12 @loc=static @len=8 @rva=2888992
	//_Func: public float getPackerRange(); @virtual vtpo=0 vfid=13 @loc=static @len=6 @rva=2740064
	//_Func: public std::vector<DebugLine,std::allocator<DebugLine> > getDebugLines(const mat44f & bodyMatrix, const mat44f & hubMatrix); @virtual vtpo=0 vfid=14 @loc=static @len=1671 @rva=2889008
	//_Func: public void setDamage(float amount); @virtual vtpo=0 vfid=15 @loc=static @len=79 @rva=2896352
	//_Func: public void resetDamage(); @virtual vtpo=0 vfid=16 @loc=static @len=11 @rva=2896336
	//_Func: public float getDamage(); @virtual vtpo=0 vfid=17 @loc=static @len=29 @rva=2888960
	//_Func: public float getMass(); @virtual vtpo=0 vfid=18 @loc=static @len=11 @rva=2903344
	//_Func: public void stop(); @virtual vtpo=0 vfid=19 @loc=static @len=19 @rva=2911008
	//_Func: public vec3f getVelocity(); @virtual vtpo=0 vfid=20 @loc=static @len=28 @rva=2891120
	//_Func: public void setERPCFM(float erp, float cfm); @virtual vtpo=0 vfid=23 @loc=static @len=93 @rva=2896432
	//_Func: public void addLocalForceAndTorque(const vec3f & force, const vec3f & torque, const vec3f & driveTorque); @virtual vtpo=0 vfid=24 @loc=static @len=463 @rva=2886976
	//_Data: this+0x1D0, Member, Type: class PhysicsEngine *, physicsEngine
	//_Data: this+0x1D8, Member, Type: float, steerLinkBaseLength
	//_Data: this+0x1DC, Member, Type: float, steerTorque
	//_Data: this+0x1E0, Member, Type: class vec3f, baseCarSteerPosition
	//_Data: this+0x1EC, Member, Type: float, steerAngle
	//_Data: this+0x1F0, Member, Type: struct SusDamageDef, damageData
	//_Func: protected void loadINI(int index); @loc=static @len=4949 @rva=2891152
	//_Func: protected void initActiveActuator(); @loc=optimized @len=0 @rva=0
	//_Func: public Suspension & operator=(const Suspension &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class Suspension : public ISuspension {
public:
	IRigidBody * carBody;
	IRigidBody * hub;
	vec3f basePosition;
	Car * car;
	bool useActiveActuator;
	IJoint * joints[5];
	IJoint * bumpStopJoint;
	SDWSuspensionData dataRelToWheel;
	SDWSuspensionData dataRelToBody;
	Damper damper;
	ActiveActuator activeActuator;
	SuspensionStatus status;
	int index;
	PhysicsEngine * physicsEngine;
	float steerLinkBaseLength;
	float steerTorque;
	vec3f baseCarSteerPosition;
	float steerAngle;
	SusDamageDef damageData;
	inline Suspension() { }
	inline Suspension(const Suspension& other) = default;
	inline Suspension& operator=(const Suspension& other) = default;
	inline void ctor(Car * car, int index) { typedef void (Suspension::*_fpt)(Car *, int); auto _f=xcast<_fpt>(_drva(2885408)); (this->*_f)(car, index); }
	virtual ~Suspension();
	virtual vec3f getBasePosition_vf10();
	inline vec3f getBasePosition_impl() { typedef vec3f (Suspension::*_fpt)(); auto _f=xcast<_fpt>(_drva(2901648)); return (this->*_f)(); }
	inline vec3f getBasePosition() { typedef vec3f (Suspension::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 10)); return (this->*_f)(); }
	virtual SuspensionStatus & getStatus_vf9();
	inline SuspensionStatus & getStatus_impl() { typedef SuspensionStatus & (Suspension::*_fpt)(); auto _f=xcast<_fpt>(_drva(2890736)); return (this->*_f)(); }
	inline SuspensionStatus & getStatus() { typedef SuspensionStatus & (Suspension::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 9)); return (this->*_f)(); }
	virtual void attach_vf8();
	inline void attach_impl() { typedef void (Suspension::*_fpt)(); auto _f=xcast<_fpt>(_drva(2887600)); return (this->*_f)(); }
	inline void attach() { typedef void (Suspension::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 8)); return (this->*_f)(); }
	virtual void step_vf22(float dt);
	inline void step_impl(float dt) { typedef void (Suspension::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2896784)); return (this->*_f)(dt); }
	inline void step(float dt) { typedef void (Suspension::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 22)); return (this->*_f)(dt); }
	virtual mat44f getHubWorldMatrix_vf1();
	inline mat44f getHubWorldMatrix_impl() { typedef mat44f (Suspension::*_fpt)(); auto _f=xcast<_fpt>(_drva(2903120)); return (this->*_f)(); }
	inline mat44f getHubWorldMatrix() { typedef mat44f (Suspension::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(); }
	virtual vec3f getPointVelocity_vf2(const vec3f & p);
	inline vec3f getPointVelocity_impl(const vec3f & p) { typedef vec3f (Suspension::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2903360)); return (this->*_f)(p); }
	inline vec3f getPointVelocity(const vec3f & p) { typedef vec3f (Suspension::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)(p); }
	virtual void addForceAtPos_vf3(const vec3f & force, const vec3f & pos, bool driven, bool addToSteerTorque);
	inline void addForceAtPos_impl(const vec3f & force, const vec3f & pos, bool driven, bool addToSteerTorque) { typedef void (Suspension::*_fpt)(const vec3f &, const vec3f &, bool, bool); auto _f=xcast<_fpt>(_drva(2886640)); return (this->*_f)(force, pos, driven, addToSteerTorque); }
	inline void addForceAtPos(const vec3f & force, const vec3f & pos, bool driven, bool addToSteerTorque) { typedef void (Suspension::*_fpt)(const vec3f &, const vec3f &, bool, bool); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(force, pos, driven, addToSteerTorque); }
	virtual void addTorque_vf4(const vec3f & torque);
	inline void addTorque_impl(const vec3f & torque) { typedef void (Suspension::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2887440)); return (this->*_f)(torque); }
	inline void addTorque(const vec3f & torque) { typedef void (Suspension::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 4)); return (this->*_f)(torque); }
	virtual void setSteerLengthOffset_vf5(float o);
	inline void setSteerLengthOffset_impl(float o) { typedef void (Suspension::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2896528)); return (this->*_f)(o); }
	inline void setSteerLengthOffset(float o) { typedef void (Suspension::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 5)); return (this->*_f)(o); }
	virtual void getSteerBasis_vf21(vec3f & centre, vec3f & axis);
	inline void getSteerBasis_impl(vec3f & centre, vec3f & axis) { typedef void (Suspension::*_fpt)(vec3f &, vec3f &); auto _f=xcast<_fpt>(_drva(2890752)); return (this->*_f)(centre, axis); }
	inline void getSteerBasis(vec3f & centre, vec3f & axis) { typedef void (Suspension::*_fpt)(vec3f &, vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 21)); return (this->*_f)(centre, axis); }
	virtual float getSteerTorque_vf6();
	inline float getSteerTorque_impl() { typedef float (Suspension::*_fpt)(); auto _f=xcast<_fpt>(_drva(2891104)); return (this->*_f)(); }
	inline float getSteerTorque() { typedef float (Suspension::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 6)); return (this->*_f)(); }
	virtual vec3f getHubAngularVelocity_vf7();
	inline vec3f getHubAngularVelocity_impl() { typedef vec3f (Suspension::*_fpt)(); auto _f=xcast<_fpt>(_drva(2890688)); return (this->*_f)(); }
	inline vec3f getHubAngularVelocity() { typedef vec3f (Suspension::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 7)); return (this->*_f)(); }
	virtual float getK_vf11();
	inline float getK_impl() { typedef float (Suspension::*_fpt)(); auto _f=xcast<_fpt>(_drva(2890720)); return (this->*_f)(); }
	inline float getK() { typedef float (Suspension::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 11)); return (this->*_f)(); }
	virtual Damper * getDamper_vf12();
	inline Damper * getDamper_impl() { typedef Damper * (Suspension::*_fpt)(); auto _f=xcast<_fpt>(_drva(2888992)); return (this->*_f)(); }
	inline Damper * getDamper() { typedef Damper * (Suspension::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 12)); return (this->*_f)(); }
	virtual float getPackerRange_vf13();
	inline float getPackerRange_impl() { typedef float (Suspension::*_fpt)(); auto _f=xcast<_fpt>(_drva(2740064)); return (this->*_f)(); }
	inline float getPackerRange() { typedef float (Suspension::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 13)); return (this->*_f)(); }
	virtual std::vector<DebugLine,std::allocator<DebugLine> > getDebugLines_vf14(const mat44f & bodyMatrix, const mat44f & hubMatrix);
	inline std::vector<DebugLine,std::allocator<DebugLine> > getDebugLines_impl(const mat44f & bodyMatrix, const mat44f & hubMatrix) { typedef std::vector<DebugLine,std::allocator<DebugLine> > (Suspension::*_fpt)(const mat44f &, const mat44f &); auto _f=xcast<_fpt>(_drva(2889008)); return (this->*_f)(bodyMatrix, hubMatrix); }
	inline std::vector<DebugLine,std::allocator<DebugLine> > getDebugLines(const mat44f & bodyMatrix, const mat44f & hubMatrix) { typedef std::vector<DebugLine,std::allocator<DebugLine> > (Suspension::*_fpt)(const mat44f &, const mat44f &); auto _f=xcast<_fpt>(get_vfp(this, 14)); return (this->*_f)(bodyMatrix, hubMatrix); }
	virtual void setDamage_vf15(float amount);
	inline void setDamage_impl(float amount) { typedef void (Suspension::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2896352)); return (this->*_f)(amount); }
	inline void setDamage(float amount) { typedef void (Suspension::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 15)); return (this->*_f)(amount); }
	virtual void resetDamage_vf16();
	inline void resetDamage_impl() { typedef void (Suspension::*_fpt)(); auto _f=xcast<_fpt>(_drva(2896336)); return (this->*_f)(); }
	inline void resetDamage() { typedef void (Suspension::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 16)); return (this->*_f)(); }
	virtual float getDamage_vf17();
	inline float getDamage_impl() { typedef float (Suspension::*_fpt)(); auto _f=xcast<_fpt>(_drva(2888960)); return (this->*_f)(); }
	inline float getDamage() { typedef float (Suspension::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 17)); return (this->*_f)(); }
	virtual float getMass_vf18();
	inline float getMass_impl() { typedef float (Suspension::*_fpt)(); auto _f=xcast<_fpt>(_drva(2903344)); return (this->*_f)(); }
	inline float getMass() { typedef float (Suspension::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 18)); return (this->*_f)(); }
	virtual void stop_vf19();
	inline void stop_impl() { typedef void (Suspension::*_fpt)(); auto _f=xcast<_fpt>(_drva(2911008)); return (this->*_f)(); }
	inline void stop() { typedef void (Suspension::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 19)); return (this->*_f)(); }
	virtual vec3f getVelocity_vf20();
	inline vec3f getVelocity_impl() { typedef vec3f (Suspension::*_fpt)(); auto _f=xcast<_fpt>(_drva(2891120)); return (this->*_f)(); }
	inline vec3f getVelocity() { typedef vec3f (Suspension::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 20)); return (this->*_f)(); }
	virtual void setERPCFM_vf23(float erp, float cfm);
	inline void setERPCFM_impl(float erp, float cfm) { typedef void (Suspension::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2896432)); return (this->*_f)(erp, cfm); }
	inline void setERPCFM(float erp, float cfm) { typedef void (Suspension::*_fpt)(float, float); auto _f=xcast<_fpt>(get_vfp(this, 23)); return (this->*_f)(erp, cfm); }
	virtual void addLocalForceAndTorque_vf24(const vec3f & force, const vec3f & torque, const vec3f & driveTorque);
	inline void addLocalForceAndTorque_impl(const vec3f & force, const vec3f & torque, const vec3f & driveTorque) { typedef void (Suspension::*_fpt)(const vec3f &, const vec3f &, const vec3f &); auto _f=xcast<_fpt>(_drva(2886976)); return (this->*_f)(force, torque, driveTorque); }
	inline void addLocalForceAndTorque(const vec3f & force, const vec3f & torque, const vec3f & driveTorque) { typedef void (Suspension::*_fpt)(const vec3f &, const vec3f &, const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 24)); return (this->*_f)(force, torque, driveTorque); }
	inline void loadINI(int index) { typedef void (Suspension::*_fpt)(int); auto _f=xcast<_fpt>(_drva(2891152)); return (this->*_f)(index); }
	inline void _guard_obj() {
		static_assert((sizeof(Suspension)==528),"bad size");
		static_assert((offsetof(Suspension,carBody)==0x38),"bad off");
		static_assert((offsetof(Suspension,hub)==0x40),"bad off");
		static_assert((offsetof(Suspension,basePosition)==0x48),"bad off");
		static_assert((offsetof(Suspension,car)==0x58),"bad off");
		static_assert((offsetof(Suspension,useActiveActuator)==0x60),"bad off");
		static_assert((offsetof(Suspension,joints)==0x68),"bad off");
		static_assert((offsetof(Suspension,bumpStopJoint)==0x90),"bad off");
		static_assert((offsetof(Suspension,dataRelToWheel)==0x98),"bad off");
		static_assert((offsetof(Suspension,dataRelToBody)==0x114),"bad off");
		static_assert((offsetof(Suspension,damper)==0x190),"bad off");
		static_assert((offsetof(Suspension,activeActuator)==0x1A8),"bad off");
		static_assert((offsetof(Suspension,status)==0x1C0),"bad off");
		static_assert((offsetof(Suspension,index)==0x1C8),"bad off");
		static_assert((offsetof(Suspension,physicsEngine)==0x1D0),"bad off");
		static_assert((offsetof(Suspension,steerLinkBaseLength)==0x1D8),"bad off");
		static_assert((offsetof(Suspension,steerTorque)==0x1DC),"bad off");
		static_assert((offsetof(Suspension,baseCarSteerPosition)==0x1E0),"bad off");
		static_assert((offsetof(Suspension,steerAngle)==0x1EC),"bad off");
		static_assert((offsetof(Suspension,damageData)==0x1F0),"bad off");
	};
};

//UDT: class GLRenderer @len=272 @vfcount=1
	//_VTable: 
	//_Func: public void ~GLRenderer(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=202 @rva=2089920
	//_Func: public void init(); @loc=optimized @len=0 @rva=0
	//_Func: public void begin(eGLPrimitiveType type, Shader * ishader); @loc=static @len=19 @rva=2091008
	//_Func: public void vertex3f(const vec3f & v); @loc=static @len=19 @rva=2096128
	//_Func: public void vertex3f(float x, float y, float z); @loc=static @len=878 @rva=2096160
	//_Func: public void vertex3fv(const float * v); @loc=static @len=19 @rva=2096128
	//_Func: public void end(); @loc=static @len=547 @rva=2091120
	//_Func: public void color3f(float r, float g, float b); @loc=static @len=23 @rva=2091040
	//_Func: public void color4fv(float *  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void color4f(const vec4f & v); @loc=static @len=8 @rva=2091072
	//_Func: public void color4f(float r, float g, float b, float a); @loc=static @len=27 @rva=2091088
	//_Func: public void texCoord2f(float u, float v); @loc=static @len=15 @rva=2096112
	//_Func: public void fullScreenQuad(Shader * ishader); @loc=static @len=129 @rva=2091680
	//_Func: public void quad(float x, float y, float width, float height, bool textured, Shader * shader); @loc=static @len=286 @rva=2094112
	//_Func: public void quadCentred(float x, float y, float width, float height, bool textured, Shader * shader); @loc=static @len=355 @rva=2094400
	//_Func: public void quadCentredRotated(float x, float y, float width, float height, float rotationRAD, bool textured, Shader * shader); @loc=static @len=650 @rva=2094768
	//_Func: public void spline(const Spline & spline); @loc=static @len=686 @rva=2095424
	//_Func: public unsigned int getMaxVertices(); @loc=optimized @len=0 @rva=0
	//_Func: public void GLRenderer(const GLRenderer &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: protected void GLRenderer(GraphicsManager * r, unsigned int maxVertices, bool withFullScreenQuad); @loc=static @len=977 @rva=2088928
	//_Data: this+0x8, Member, Type: class std::vector<std::pair<int,void *>,std::allocator<std::pair<int,void *> > >, buffers
	//_Data: this+0x20, Member, Type: int, currentIndex
	//_Data: this+0x28, Member, Type: class GraphicsManager *, graphics
	//_Data: this+0x30, Member, Type: enum eGLPrimitiveType, primitive
	//_Data: this+0x34, Member, Type: class vec4f, color
	//_Data: this+0x44, Member, Type: bool, useTexture
	//_Data: this+0x48, Member, Type: class vec2f, texCoord
	//_Data: this+0x50, Member, Type: class Shader *, shader
	//_Data: this+0x58, Member, Type: class IndexBuffer *, fullQuadIB
	//_Data: this+0x60, Member, Type: class VertexBuffer<MeshVertex> *, fullQuadVB
	//_Data: this+0x68, Member, Type: class Shader *, glShader
	//_Data: this+0x70, Member, Type: class Shader *, glShaderTex
	//_Data: this+0x78, Member, Type: unsigned int, tempCounter
	//_Data: this+0x7C, Member, Type: struct MeshVertex[0x3], tempVertices
	//_Data: this+0x100, Member, Type: struct MeshVertex *, tempBuffer
	//_Data: this+0x108, Member, Type: unsigned int, maxVertices
	//_Func: protected void initFullScreenQuad(); @loc=static @len=2281 @rva=2091824
	//_Func: public GLRenderer & operator=(const GLRenderer &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class GLRenderer {
public:
	std::vector<std::pair<int,void *>,std::allocator<std::pair<int,void *> > > buffers;
	int currentIndex;
	GraphicsManager * graphics;
	eGLPrimitiveType primitive;
	vec4f color;
	bool useTexture;
	vec2f texCoord;
	Shader * shader;
	IndexBuffer * fullQuadIB;
	VertexBuffer<MeshVertex> * fullQuadVB;
	Shader * glShader;
	Shader * glShaderTex;
	unsigned int tempCounter;
	MeshVertex tempVertices[3];
	MeshVertex * tempBuffer;
	unsigned int maxVertices;
	inline GLRenderer() { }
	inline GLRenderer(const GLRenderer& other) = default;
	inline GLRenderer& operator=(const GLRenderer& other) = default;
	virtual ~GLRenderer();
	inline void dtor() { typedef void (GLRenderer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2089920)); (this->*_f)(); }
	inline void begin(eGLPrimitiveType type, Shader * ishader) { typedef void (GLRenderer::*_fpt)(eGLPrimitiveType, Shader *); auto _f=xcast<_fpt>(_drva(2091008)); return (this->*_f)(type, ishader); }
	inline void vertex3f(const vec3f & v) { typedef void (GLRenderer::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2096128)); return (this->*_f)(v); }
	inline void vertex3f(float x, float y, float z) { typedef void (GLRenderer::*_fpt)(float, float, float); auto _f=xcast<_fpt>(_drva(2096160)); return (this->*_f)(x, y, z); }
	inline void vertex3fv(const float * v) { typedef void (GLRenderer::*_fpt)(const float *); auto _f=xcast<_fpt>(_drva(2096128)); return (this->*_f)(v); }
	inline void end() { typedef void (GLRenderer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2091120)); return (this->*_f)(); }
	inline void color3f(float r, float g, float b) { typedef void (GLRenderer::*_fpt)(float, float, float); auto _f=xcast<_fpt>(_drva(2091040)); return (this->*_f)(r, g, b); }
	inline void color4f(const vec4f & v) { typedef void (GLRenderer::*_fpt)(const vec4f &); auto _f=xcast<_fpt>(_drva(2091072)); return (this->*_f)(v); }
	inline void color4f(float r, float g, float b, float a) { typedef void (GLRenderer::*_fpt)(float, float, float, float); auto _f=xcast<_fpt>(_drva(2091088)); return (this->*_f)(r, g, b, a); }
	inline void texCoord2f(float u, float v) { typedef void (GLRenderer::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2096112)); return (this->*_f)(u, v); }
	inline void fullScreenQuad(Shader * ishader) { typedef void (GLRenderer::*_fpt)(Shader *); auto _f=xcast<_fpt>(_drva(2091680)); return (this->*_f)(ishader); }
	inline void quad(float x, float y, float width, float height, bool textured, Shader * shader) { typedef void (GLRenderer::*_fpt)(float, float, float, float, bool, Shader *); auto _f=xcast<_fpt>(_drva(2094112)); return (this->*_f)(x, y, width, height, textured, shader); }
	inline void quadCentred(float x, float y, float width, float height, bool textured, Shader * shader) { typedef void (GLRenderer::*_fpt)(float, float, float, float, bool, Shader *); auto _f=xcast<_fpt>(_drva(2094400)); return (this->*_f)(x, y, width, height, textured, shader); }
	inline void quadCentredRotated(float x, float y, float width, float height, float rotationRAD, bool textured, Shader * shader) { typedef void (GLRenderer::*_fpt)(float, float, float, float, float, bool, Shader *); auto _f=xcast<_fpt>(_drva(2094768)); return (this->*_f)(x, y, width, height, rotationRAD, textured, shader); }
	inline void spline(const Spline & spline) { typedef void (GLRenderer::*_fpt)(const Spline &); auto _f=xcast<_fpt>(_drva(2095424)); return (this->*_f)(spline); }
	inline void ctor(GraphicsManager * r, unsigned int maxVertices, bool withFullScreenQuad) { typedef void (GLRenderer::*_fpt)(GraphicsManager *, unsigned int, bool); auto _f=xcast<_fpt>(_drva(2088928)); (this->*_f)(r, maxVertices, withFullScreenQuad); }
	inline void initFullScreenQuad() { typedef void (GLRenderer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2091824)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(GLRenderer)==272),"bad size");
		static_assert((offsetof(GLRenderer,buffers)==0x8),"bad off");
		static_assert((offsetof(GLRenderer,currentIndex)==0x20),"bad off");
		static_assert((offsetof(GLRenderer,graphics)==0x28),"bad off");
		static_assert((offsetof(GLRenderer,primitive)==0x30),"bad off");
		static_assert((offsetof(GLRenderer,color)==0x34),"bad off");
		static_assert((offsetof(GLRenderer,useTexture)==0x44),"bad off");
		static_assert((offsetof(GLRenderer,texCoord)==0x48),"bad off");
		static_assert((offsetof(GLRenderer,shader)==0x50),"bad off");
		static_assert((offsetof(GLRenderer,fullQuadIB)==0x58),"bad off");
		static_assert((offsetof(GLRenderer,fullQuadVB)==0x60),"bad off");
		static_assert((offsetof(GLRenderer,glShader)==0x68),"bad off");
		static_assert((offsetof(GLRenderer,glShaderTex)==0x70),"bad off");
		static_assert((offsetof(GLRenderer,tempCounter)==0x78),"bad off");
		static_assert((offsetof(GLRenderer,tempVertices)==0x7C),"bad off");
		static_assert((offsetof(GLRenderer,tempBuffer)==0x100),"bad off");
		static_assert((offsetof(GLRenderer,maxVertices)==0x108),"bad off");
	};
};

//UDT: class ksgui::ListBox @len=536 @vfcount=21
	//_Base: class ksgui::Control @off=0 @len=376
	//_Func: public void ListBox(const ksgui_ListBox &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void ListBox(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, unsigned int rowNumber, unsigned int colNumber, ksgui_GUI * aGui, bool isDressed); @loc=static @len=2176 @rva=2392896
	//_Func: public void ~ListBox(); @virtual vtpo=0 vfid=0 @loc=static @len=222 @rva=2395296
	//_Data: this+0x178, Member, Type: bool, allowDeselection
	//_Data: this+0x179, Member, Type: bool, allowSelectionOnClick
	//_Data: this+0x17A, Member, Type: bool, drawUnderline
	//_Data: this+0x17B, Member, Type: bool, drawScrollbarPlaceholder
	//_Data: this+0x17C, Member, Type: enum ksgui::eListBoxSelectionMode, selectionMode
	//_Data: this+0x180, Member, Type: class Event<ksgui::OnListBoxItemClickedEvent>, evOnListBoxItemClicked
	//_Data: this+0x198, Member, Type: class Event<ksgui::OnListBoxItemClickedEvent>, evOnListBoxItemDeselected
	//_Func: public ksgui_ListBoxRowData & getItem(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void addItem(const ksgui_ListBoxRowData & item); @loc=static @len=255 @rva=2397680
	//_Func: public void clear(); @loc=static @len=182 @rva=2397936
	//_Func: public ksgui_ListBoxRowData * getSelectedItem(); @loc=static @len=42 @rva=2398592
	//_Data: this+0x1B0, Member, Type: class ksgui::ListBoxRow *, titleRow
	//_Data: this+0x1B8, Member, Type: class ksgui::ListBoxRow *, bottomRow
	//_Func: public void scrollToTop(); @loc=static @len=62 @rva=2400848
	//_Func: public void scrollToBottom(); @loc=optimized @len=0 @rva=0
	//_Func: public void scrollToCenterOnSelected(); @loc=static @len=131 @rva=2400704
	//_Func: public void scrollToIndex(int  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void setItemsFontSize(float size); @loc=static @len=110 @rva=2401696
	//_Func: public int getSelectedItemIndex(); @loc=optimized @len=0 @rva=0
	//_Func: public void render(float dt); @virtual vtpo=0 vfid=3 @loc=static @len=1016 @rva=2399280
	//_Func: public void setSize(float w, float h); @virtual vtpo=0 vfid=7 @loc=static @len=597 @rva=2401808
	//_Func: public void onMouseWheelMovedEvent(const OnMouseWheelMovedEvent & message); @virtual vtpo=0 vfid=13 @loc=static @len=138 @rva=2398640
	//_Func: public void selectItem(int itemIndex); @loc=static @len=291 @rva=2400912
	//_Func: public void selectItemByName(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & itemText); @loc=static @len=468 @rva=2401216
	//_Func: public int getItemIdFromName(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & aName); @loc=static @len=301 @rva=2398288
	//_Func: public ksgui_ListBoxRow * getCell(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public unsigned int getCellCount(); @loc=optimized @len=0 @rva=0
	//_Func: public unsigned int getItemsCount(); @loc=optimized @len=0 @rva=0
	//_Func: public void drawCellsBackgrounds(bool value); @loc=static @len=79 @rva=2398128
	//_Data: this+0x1C0, Member, Type: class std::vector<ksgui::ListBoxRowData,std::allocator<ksgui::ListBoxRowData> >, items
	//_Data: this+0x1D8, Member, Type: class std::vector<ksgui::ListBoxRow *,std::allocator<ksgui::ListBoxRow *> >, rows
	//_Data: this+0x1F0, Member, Type: unsigned int, columnNumber
	//_Data: this+0x1F8, Member, Type: class std::map<unsigned int,vec4f,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,vec4f> > >, category
	//_Data: this+0x208, Member, Type: int, selectedItemIndex
	//_Data: this+0x20C, Member, Type: int, pivot
	//_Data: this+0x210, Member, Type: class ksgui::ScrollBar *, scrollBar
	//_Func: private void scrollListBoxToItem(int itemId); @loc=static @len=398 @rva=2400304
	//_Func: private void onScrollBarValueChanged(const ksgui_OnScrollBarValueChanged &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: private int getItemIdFromRow(ksgui_ListBoxRow *  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public ksgui_ListBox & operator=(const ksgui_ListBox &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ksgui_ListBox : public ksgui_Control {
public:
	bool allowDeselection;
	bool allowSelectionOnClick;
	bool drawUnderline;
	bool drawScrollbarPlaceholder;
	ksgui_eListBoxSelectionMode selectionMode;
	Event<ksgui_OnListBoxItemClickedEvent> evOnListBoxItemClicked;
	Event<ksgui_OnListBoxItemClickedEvent> evOnListBoxItemDeselected;
	ksgui_ListBoxRow * titleRow;
	ksgui_ListBoxRow * bottomRow;
	std::vector<ksgui_ListBoxRowData,std::allocator<ksgui_ListBoxRowData> > items;
	std::vector<ksgui_ListBoxRow *,std::allocator<ksgui_ListBoxRow *> > rows;
	unsigned int columnNumber;
	std::map<unsigned int,vec4f,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,vec4f> > > category;
	int selectedItemIndex;
	int pivot;
	ksgui_ScrollBar * scrollBar;
	inline ksgui_ListBox() { }
	inline ksgui_ListBox(const ksgui_ListBox& other) = default;
	inline ksgui_ListBox& operator=(const ksgui_ListBox& other) = default;
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, unsigned int rowNumber, unsigned int colNumber, ksgui_GUI * aGui, bool isDressed) { typedef void (ksgui_ListBox::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, unsigned int, unsigned int, ksgui_GUI *, bool); auto _f=xcast<_fpt>(_drva(2392896)); (this->*_f)(name, rowNumber, colNumber, aGui, isDressed); }
	virtual ~ksgui_ListBox();
	inline void dtor() { typedef void (ksgui_ListBox::*_fpt)(); auto _f=xcast<_fpt>(_drva(2395296)); (this->*_f)(); }
	inline void addItem(const ksgui_ListBoxRowData & item) { typedef void (ksgui_ListBox::*_fpt)(const ksgui_ListBoxRowData &); auto _f=xcast<_fpt>(_drva(2397680)); return (this->*_f)(item); }
	inline void clear() { typedef void (ksgui_ListBox::*_fpt)(); auto _f=xcast<_fpt>(_drva(2397936)); return (this->*_f)(); }
	inline ksgui_ListBoxRowData * getSelectedItem() { typedef ksgui_ListBoxRowData * (ksgui_ListBox::*_fpt)(); auto _f=xcast<_fpt>(_drva(2398592)); return (this->*_f)(); }
	inline void scrollToTop() { typedef void (ksgui_ListBox::*_fpt)(); auto _f=xcast<_fpt>(_drva(2400848)); return (this->*_f)(); }
	inline void scrollToCenterOnSelected() { typedef void (ksgui_ListBox::*_fpt)(); auto _f=xcast<_fpt>(_drva(2400704)); return (this->*_f)(); }
	inline void setItemsFontSize(float size) { typedef void (ksgui_ListBox::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2401696)); return (this->*_f)(size); }
	virtual void render_vf3(float dt);
	inline void render_impl(float dt) { typedef void (ksgui_ListBox::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2399280)); return (this->*_f)(dt); }
	inline void render(float dt) { typedef void (ksgui_ListBox::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(dt); }
	virtual void setSize_vf7(float w, float h);
	inline void setSize_impl(float w, float h) { typedef void (ksgui_ListBox::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2401808)); return (this->*_f)(w, h); }
	inline void setSize(float w, float h) { typedef void (ksgui_ListBox::*_fpt)(float, float); auto _f=xcast<_fpt>(get_vfp(this, 7)); return (this->*_f)(w, h); }
	virtual void onMouseWheelMovedEvent_vf13(const OnMouseWheelMovedEvent & message);
	inline void onMouseWheelMovedEvent_impl(const OnMouseWheelMovedEvent & message) { typedef void (ksgui_ListBox::*_fpt)(const OnMouseWheelMovedEvent &); auto _f=xcast<_fpt>(_drva(2398640)); return (this->*_f)(message); }
	inline void onMouseWheelMovedEvent(const OnMouseWheelMovedEvent & message) { typedef void (ksgui_ListBox::*_fpt)(const OnMouseWheelMovedEvent &); auto _f=xcast<_fpt>(get_vfp(this, 13)); return (this->*_f)(message); }
	inline void selectItem(int itemIndex) { typedef void (ksgui_ListBox::*_fpt)(int); auto _f=xcast<_fpt>(_drva(2400912)); return (this->*_f)(itemIndex); }
	inline void selectItemByName(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & itemText) { typedef void (ksgui_ListBox::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2401216)); return (this->*_f)(itemText); }
	inline int getItemIdFromName(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & aName) { typedef int (ksgui_ListBox::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2398288)); return (this->*_f)(aName); }
	inline void drawCellsBackgrounds(bool value) { typedef void (ksgui_ListBox::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(2398128)); return (this->*_f)(value); }
	inline void scrollListBoxToItem(int itemId) { typedef void (ksgui_ListBox::*_fpt)(int); auto _f=xcast<_fpt>(_drva(2400304)); return (this->*_f)(itemId); }
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_ListBox)==536),"bad size");
		static_assert((offsetof(ksgui_ListBox,allowDeselection)==0x178),"bad off");
		static_assert((offsetof(ksgui_ListBox,allowSelectionOnClick)==0x179),"bad off");
		static_assert((offsetof(ksgui_ListBox,drawUnderline)==0x17A),"bad off");
		static_assert((offsetof(ksgui_ListBox,drawScrollbarPlaceholder)==0x17B),"bad off");
		static_assert((offsetof(ksgui_ListBox,selectionMode)==0x17C),"bad off");
		static_assert((offsetof(ksgui_ListBox,evOnListBoxItemClicked)==0x180),"bad off");
		static_assert((offsetof(ksgui_ListBox,evOnListBoxItemDeselected)==0x198),"bad off");
		static_assert((offsetof(ksgui_ListBox,titleRow)==0x1B0),"bad off");
		static_assert((offsetof(ksgui_ListBox,bottomRow)==0x1B8),"bad off");
		static_assert((offsetof(ksgui_ListBox,items)==0x1C0),"bad off");
		static_assert((offsetof(ksgui_ListBox,rows)==0x1D8),"bad off");
		static_assert((offsetof(ksgui_ListBox,columnNumber)==0x1F0),"bad off");
		static_assert((offsetof(ksgui_ListBox,category)==0x1F8),"bad off");
		static_assert((offsetof(ksgui_ListBox,selectedItemIndex)==0x208),"bad off");
		static_assert((offsetof(ksgui_ListBox,pivot)==0x20C),"bad off");
		static_assert((offsetof(ksgui_ListBox,scrollBar)==0x210),"bad off");
	};
};

//UDT: class Material @len=176
	//_Func: public void Material(const Material &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void Material(const Material * mat); @loc=static @len=399 @rva=2136640
	//_Func: public void Material(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & iname, GraphicsManager * graphics); @loc=static @len=196 @rva=2136432
	//_Func: public void ~Material(); @loc=static @len=462 @rva=2137440
	//_Data: this+0x0, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, name
	//_Data: this+0x20, Member, Type: class Shader *, shader
	//_Data: this+0x28, Member, Type: bool, doubleFace
	//_Data: this+0x29, Member, Type: bool, wireFrame
	//_Data: this+0x30, Member, Type: class GraphicsManager *, graphics
	//_Data: this+0x38, Member, Type: class std::vector<MaterialVar *,std::allocator<MaterialVar *> >, vars
	//_Data: this+0x50, Member, Type: class std::vector<MaterialResource,std::allocator<MaterialResource> >, resources
	//_Data: this+0x68, Member, Type: class std::vector<CBuffer,std::allocator<CBuffer> >, cBuffers
	//_Data: this+0x80, Member, Type: class std::vector<ShaderVariable *,std::allocator<ShaderVariable *> >, shaderVars
	//_Data: this+0x98, Member, Type: int, guid
	//_Data: this+0x9C, Member, Type: enum DepthMode, depthMode
	//_Data: this+0xA0, Member, Type: enum BlendMode, blendMode
	//_Data: this+0xA4, Member, Type: enum CullMode, cullMode
	//_Data: this+0xA8, Member, Type: bool, doubleFaceShadow
	//_Func: public void apply(RenderContext * rc); @loc=static @len=195 @rva=2139872
	//_Func: public void setShader(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name); @loc=static @len=62 @rva=2144000
	//_Func: public void setVar(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name, const vec4f & value); @loc=static @len=148 @rva=2144528
	//_Func: public void setVar(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name, const vec3f & value); @loc=static @len=160 @rva=2144368
	//_Func: public void setVar(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name, float value); @loc=static @len=168 @rva=2144688
	//_Func: public MaterialVar * getVar(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & vname); @loc=static @len=254 @rva=2140976
	//_Func: public void setTexture(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & rname, const Texture & tex); @loc=static @len=304 @rva=2144064
	//_Func: public MaterialResource * getResource(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public int getResourceIndex(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name); @loc=static @len=235 @rva=2140736
	//_Func: public void setDoubleFace(); @loc=optimized @len=0 @rva=0
	//_Data: static, [0151D0F4][0003:0000A0F4], Static Member, Type: int, guidCount
	//_Func: protected void resetVars(); @loc=static @len=166 @rva=2143552
	//_Func: protected void applySM(); @loc=optimized @len=0 @rva=0
	//_Func: protected void initShaderVars(bool updateOptions); @loc=static @len=2312 @rva=2141232
	//_Func: protected void createCBuffers(); @loc=static @len=245 @rva=2140480
	//_Func: protected CBuffer * getBufferFromSlot(int  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public Material & operator=(const Material &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class Material {
public:
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > name;
	Shader * shader;
	bool doubleFace;
	bool wireFrame;
	GraphicsManager * graphics;
	std::vector<MaterialVar *,std::allocator<MaterialVar *> > vars;
	std::vector<MaterialResource,std::allocator<MaterialResource> > resources;
	std::vector<CBuffer,std::allocator<CBuffer> > cBuffers;
	std::vector<ShaderVariable *,std::allocator<ShaderVariable *> > shaderVars;
	int guid;
	DepthMode depthMode;
	BlendMode blendMode;
	CullMode cullMode;
	bool doubleFaceShadow;
	inline Material() { }
	inline Material(const Material& other) = default;
	inline Material& operator=(const Material& other) = default;
	inline void ctor(const Material * mat) { typedef void (Material::*_fpt)(const Material *); auto _f=xcast<_fpt>(_drva(2136640)); (this->*_f)(mat); }
	inline void ctor(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & iname, GraphicsManager * graphics) { typedef void (Material::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, GraphicsManager *); auto _f=xcast<_fpt>(_drva(2136432)); (this->*_f)(iname, graphics); }
	inline void dtor() { typedef void (Material::*_fpt)(); auto _f=xcast<_fpt>(_drva(2137440)); (this->*_f)(); }
	inline void apply(RenderContext * rc) { typedef void (Material::*_fpt)(RenderContext *); auto _f=xcast<_fpt>(_drva(2139872)); return (this->*_f)(rc); }
	inline void setShader(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name) { typedef void (Material::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2144000)); return (this->*_f)(name); }
	inline void setVar(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name, const vec4f & value) { typedef void (Material::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, const vec4f &); auto _f=xcast<_fpt>(_drva(2144528)); return (this->*_f)(name, value); }
	inline void setVar(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name, const vec3f & value) { typedef void (Material::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, const vec3f &); auto _f=xcast<_fpt>(_drva(2144368)); return (this->*_f)(name, value); }
	inline void setVar(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name, float value) { typedef void (Material::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, float); auto _f=xcast<_fpt>(_drva(2144688)); return (this->*_f)(name, value); }
	inline MaterialVar * getVar(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & vname) { typedef MaterialVar * (Material::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2140976)); return (this->*_f)(vname); }
	inline void setTexture(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & rname, const Texture & tex) { typedef void (Material::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, const Texture &); auto _f=xcast<_fpt>(_drva(2144064)); return (this->*_f)(rname, tex); }
	inline int getResourceIndex(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name) { typedef int (Material::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2140736)); return (this->*_f)(name); }
	inline void resetVars() { typedef void (Material::*_fpt)(); auto _f=xcast<_fpt>(_drva(2143552)); return (this->*_f)(); }
	inline void initShaderVars(bool updateOptions) { typedef void (Material::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(2141232)); return (this->*_f)(updateOptions); }
	inline void createCBuffers() { typedef void (Material::*_fpt)(); auto _f=xcast<_fpt>(_drva(2140480)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(Material)==176),"bad size");
		static_assert((offsetof(Material,name)==0x0),"bad off");
		static_assert((offsetof(Material,shader)==0x20),"bad off");
		static_assert((offsetof(Material,doubleFace)==0x28),"bad off");
		static_assert((offsetof(Material,wireFrame)==0x29),"bad off");
		static_assert((offsetof(Material,graphics)==0x30),"bad off");
		static_assert((offsetof(Material,vars)==0x38),"bad off");
		static_assert((offsetof(Material,resources)==0x50),"bad off");
		static_assert((offsetof(Material,cBuffers)==0x68),"bad off");
		static_assert((offsetof(Material,shaderVars)==0x80),"bad off");
		static_assert((offsetof(Material,guid)==0x98),"bad off");
		static_assert((offsetof(Material,depthMode)==0x9C),"bad off");
		static_assert((offsetof(Material,blendMode)==0xA0),"bad off");
		static_assert((offsetof(Material,cullMode)==0xA4),"bad off");
		static_assert((offsetof(Material,doubleFaceShadow)==0xA8),"bad off");
	};
};

//UDT: class RenderWindow @len=240 @vfcount=1
	//_VTable: 
	//_Func: public void RenderWindow(const RenderWindow &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void RenderWindow(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, VideoSettings & videoSettings); @loc=static @len=403 @rva=2086464
	//_Func: public void ~RenderWindow(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=121 @rva=2086880
	//_Data: this+0x8, Member, Type: void *, hWnd
	//_Data: this+0x10, Member, Type: class Event<OnMouseDownEvent>, evOnMouseDown
	//_Data: this+0x28, Member, Type: class Event<OnMouseWheelMovedEvent>, evOnMouseWheelMoved
	//_Data: this+0x40, Member, Type: class Event<OnMouseUpEvent>, evOnMouseUp
	//_Data: this+0x58, Member, Type: class Event<OnMouseMoveEvent>, evOnMouseMove
	//_Data: this+0x70, Member, Type: class Event<OnWindowResizeEvent>, evOnWindowResize
	//_Data: this+0x88, Member, Type: class Event<OnKeyCharEvent>, evOnKeyChar
	//_Data: this+0xA0, Member, Type: class Event<OnKeyEvent>, evOnKeyDown
	//_Data: this+0xB8, Member, Type: class Event<OnWindowClosedEvent>, evOnWindowClosed
	//_Data: this+0xD0, Member, Type: class Event<OnKeyEvent>, evOnKeyUp
	//_Data: this+0xE8, Member, Type: bool, disableEventsWithMouseHidden
	//_Func: public bool step(); @loc=static @len=23 @rva=2088352
	//_Func: public bool hasFocus(); @loc=static @len=23 @rva=2087216
	//_Func: public void setFocus(); @loc=static @len=9 @rva=2088336
	//_Func: public RenderWindow & operator=(const RenderWindow &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class RenderWindow {
public:
	void * hWnd;
	Event<OnMouseDownEvent> evOnMouseDown;
	Event<OnMouseWheelMovedEvent> evOnMouseWheelMoved;
	Event<OnMouseUpEvent> evOnMouseUp;
	Event<OnMouseMoveEvent> evOnMouseMove;
	Event<OnWindowResizeEvent> evOnWindowResize;
	Event<OnKeyCharEvent> evOnKeyChar;
	Event<OnKeyEvent> evOnKeyDown;
	Event<OnWindowClosedEvent> evOnWindowClosed;
	Event<OnKeyEvent> evOnKeyUp;
	bool disableEventsWithMouseHidden;
	inline RenderWindow() { }
	inline RenderWindow(const RenderWindow& other) = default;
	inline RenderWindow& operator=(const RenderWindow& other) = default;
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, VideoSettings & videoSettings) { typedef void (RenderWindow::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, VideoSettings &); auto _f=xcast<_fpt>(_drva(2086464)); (this->*_f)(name, videoSettings); }
	virtual ~RenderWindow();
	inline void dtor() { typedef void (RenderWindow::*_fpt)(); auto _f=xcast<_fpt>(_drva(2086880)); (this->*_f)(); }
	inline bool step() { typedef bool (RenderWindow::*_fpt)(); auto _f=xcast<_fpt>(_drva(2088352)); return (this->*_f)(); }
	inline bool hasFocus() { typedef bool (RenderWindow::*_fpt)(); auto _f=xcast<_fpt>(_drva(2087216)); return (this->*_f)(); }
	inline void setFocus() { typedef void (RenderWindow::*_fpt)(); auto _f=xcast<_fpt>(_drva(2088336)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(RenderWindow)==240),"bad size");
		static_assert((offsetof(RenderWindow,hWnd)==0x8),"bad off");
		static_assert((offsetof(RenderWindow,evOnMouseDown)==0x10),"bad off");
		static_assert((offsetof(RenderWindow,evOnMouseWheelMoved)==0x28),"bad off");
		static_assert((offsetof(RenderWindow,evOnMouseUp)==0x40),"bad off");
		static_assert((offsetof(RenderWindow,evOnMouseMove)==0x58),"bad off");
		static_assert((offsetof(RenderWindow,evOnWindowResize)==0x70),"bad off");
		static_assert((offsetof(RenderWindow,evOnKeyChar)==0x88),"bad off");
		static_assert((offsetof(RenderWindow,evOnKeyDown)==0xA0),"bad off");
		static_assert((offsetof(RenderWindow,evOnWindowClosed)==0xB8),"bad off");
		static_assert((offsetof(RenderWindow,evOnKeyUp)==0xD0),"bad off");
		static_assert((offsetof(RenderWindow,disableEventsWithMouseHidden)==0xE8),"bad off");
	};
};

//UDT: class PhysicsCore @len=168 @vfcount=21
	//_Base: class IPhysicsCore @off=0 @len=8
	//_Func: public void PhysicsCore(const PhysicsCore &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void PhysicsCore(); @loc=static @len=392 @rva=2931328
	//_Func: public void ~PhysicsCore(); @virtual vtpo=0 vfid=20 @loc=static @len=558 @rva=2931744
	//_Data: this+0x8, Member, Type: struct dxWorld *, id
	//_Data: this+0x10, Member, Type: struct dxSpace *, spaceStatic
	//_Data: this+0x18, Member, Type: struct dxSpace *, spaceDynamic
	//_Data: this+0x20, Member, Type: struct CoreCPUTimes, coreCPUTimes
	//_Func: public void resetCollisions(); @virtual vtpo=0 vfid=0 @loc=static @len=32 @rva=2938224
	//_Func: public void initMultithreading(); @virtual vtpo=0 vfid=1 @loc=static @len=8 @rva=2935904
	//_Func: public void step(float dt); @virtual vtpo=0 vfid=2 @loc=static @len=73 @rva=2938512
	//_Func: public IRigidBody * createRigidBody(); @virtual vtpo=0 vfid=3 @loc=static @len=60 @rva=2933680
	//_Func: public void release(); @virtual vtpo=0 vfid=4 @loc=static @len=21 @rva=2937952
	//_Func: public IJoint * createDistanceJoint(IRigidBody * rb1, IRigidBody * rb2, const vec3f & p1, const vec3f & p2); @virtual vtpo=0 vfid=5 @loc=static @len=258 @rva=2933136
	//_Func: public void reseatDistanceJointLocal(IJoint * joint, const vec3f & p1, const vec3f & p2); @virtual vtpo=0 vfid=10 @loc=static @len=227 @rva=2937984
	//_Func: public void reseatDistanceJointLength(IJoint * joint, float newLength); @virtual vtpo=0 vfid=11 @loc=static @len=3 @rva=96368
	//_Func: public IJoint * createBumpJoint(IRigidBody * rb1, IRigidBody * rb2, const vec3f & p1, float rangeUp, float rangeDn); @virtual vtpo=0 vfid=6 @loc=static @len=3 @rva=3776688
	//_Func: public IJoint * createSliderJoint(IRigidBody * rb1, IRigidBody * rb2, const vec3f & axis); @virtual vtpo=0 vfid=13 @loc=static @len=315 @rva=2933744
	//_Func: public void setSliderAxis(IJoint * joint, const vec3f & axis, const vec3f & anchor); @virtual vtpo=0 vfid=14 @loc=static @len=26 @rva=2938480
	//_Func: public ICollisionObject * createCollisionMesh(float * vertices, unsigned int numVertices, unsigned short * indices, int indexCount, const mat44f & worldMatrix, IRigidBody * body, unsigned long group, unsigned long mask, unsigned int space_id); @virtual vtpo=0 vfid=7 @loc=static @len=159 @rva=2932976
	//_Func: public RayCastHit rayCast(const vec3f & pos, const vec3f & dir, dxGeom * rayc); @loc=static @len=301 @rva=2936944
	//_Func: public RayCastHit rayCast(const vec3f & pos, const vec3f & dir, float length); @virtual vtpo=0 vfid=8 @loc=static @len=97 @rva=2937248
	//_Func: public void setCollisionCallback(ICollisionCallback * callback); @virtual vtpo=0 vfid=9 @loc=static @len=5 @rva=2938256
	//_Func: public void setRigidBodyIterations(int count); @virtual vtpo=0 vfid=12 @loc=static @len=3 @rva=96368
	//_Func: public void onCollision(dContactGeom * contacts, int numContacts, dxGeom * g0, dxGeom * g1); @loc=static @len=706 @rva=2936224
	//_Func: public IJoint * createBallJoint(IRigidBody * rb1, IRigidBody * rb2, const vec3f & pos); @virtual vtpo=0 vfid=15 @loc=static @len=222 @rva=2932752
	//_Func: public IJoint * createFixedJoint(IRigidBody * rb1, IRigidBody * rb2); @virtual vtpo=0 vfid=16 @loc=static @len=188 @rva=2933408
	//_Func: public IRayCaster * createRayCaster(float length); @virtual vtpo=0 vfid=17 @loc=static @len=76 @rva=2933600
	//_Func: public CoreCPUTimes getCoreCPUTimes(); @virtual vtpo=0 vfid=18 @loc=static @len=21 @rva=2935040
	//_Func: public void setNoCollisionSteps(int steps); @virtual vtpo=0 vfid=19 @loc=static @len=4 @rva=2938464
	//_Func: public dxSpace * getStaticSubSpace(unsigned int index); @loc=static @len=408 @rva=2935488
	//_Func: public dxSpace * getDynamicSubSpace(unsigned int index); @loc=static @len=408 @rva=2935072
	//_Func: public void setERPCFM(float  _arg0, float  _arg1); @loc=optimized @len=0 @rva=0
	//_Data: this+0x38, Member, Type: struct dxJointGroup *, contactGroup
	//_Data: this+0x40, Member, Type: struct dxJointGroup *, contactGroupDynamic
	//_Data: this+0x48, Member, Type: struct dxJointGroup *, currentContactGroup
	//_Data: this+0x50, Member, Type: struct dxGeom *, ray
	//_Data: this+0x58, Member, Type: class ICollisionCallback *, collisionCallback
	//_Data: this+0x60, Member, Type: int, noCollisionCounter
	//_Data: this+0x68, Member, Type: class std::map<unsigned int,dxSpace *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,dxSpace *> > >, staticSubSpaces
	//_Data: this+0x78, Member, Type: class std::map<unsigned int,dxSpace *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,dxSpace *> > >, dynamicSubSpaces
	//_Data: this+0x88, Member, Type: struct dxThreadingImplementation *, threading
	//_Data: this+0x90, Member, Type: struct dxThreadingThreadPool *, pool
	//_Data: this+0x98, Member, Type: double, totRayTime
	//_Data: this+0xA0, Member, Type: unsigned int, currentFrame
	//_Func: private void collisionStep(float dt); @loc=static @len=128 @rva=2932624
	//_Func: public PhysicsCore & operator=(const PhysicsCore &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=20 @loc=optimized @len=0 @rva=0
//UDT;

class PhysicsCore : public IPhysicsCore {
public:
	dxWorld * id;
	dxSpace * spaceStatic;
	dxSpace * spaceDynamic;
	CoreCPUTimes coreCPUTimes;
	dxJointGroup * contactGroup;
	dxJointGroup * contactGroupDynamic;
	dxJointGroup * currentContactGroup;
	dxGeom * ray;
	ICollisionCallback * collisionCallback;
	int noCollisionCounter;
	std::map<unsigned int,dxSpace *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,dxSpace *> > > staticSubSpaces;
	std::map<unsigned int,dxSpace *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,dxSpace *> > > dynamicSubSpaces;
	dxThreadingImplementation * threading;
	dxThreadingThreadPool * pool;
	double totRayTime;
	unsigned int currentFrame;
	inline PhysicsCore() { }
	inline PhysicsCore(const PhysicsCore& other) = default;
	inline PhysicsCore& operator=(const PhysicsCore& other) = default;
	inline void ctor() { typedef void (PhysicsCore::*_fpt)(); auto _f=xcast<_fpt>(_drva(2931328)); (this->*_f)(); }
	virtual ~PhysicsCore();
	inline void dtor() { typedef void (PhysicsCore::*_fpt)(); auto _f=xcast<_fpt>(_drva(2931744)); (this->*_f)(); }
	virtual void resetCollisions_vf0();
	inline void resetCollisions_impl() { typedef void (PhysicsCore::*_fpt)(); auto _f=xcast<_fpt>(_drva(2938224)); return (this->*_f)(); }
	inline void resetCollisions() { typedef void (PhysicsCore::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 0)); return (this->*_f)(); }
	virtual void initMultithreading_vf1();
	inline void initMultithreading_impl() { typedef void (PhysicsCore::*_fpt)(); auto _f=xcast<_fpt>(_drva(2935904)); return (this->*_f)(); }
	inline void initMultithreading() { typedef void (PhysicsCore::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(); }
	virtual void step_vf2(float dt);
	inline void step_impl(float dt) { typedef void (PhysicsCore::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2938512)); return (this->*_f)(dt); }
	inline void step(float dt) { typedef void (PhysicsCore::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)(dt); }
	virtual IRigidBody * createRigidBody_vf3();
	inline IRigidBody * createRigidBody_impl() { typedef IRigidBody * (PhysicsCore::*_fpt)(); auto _f=xcast<_fpt>(_drva(2933680)); return (this->*_f)(); }
	inline IRigidBody * createRigidBody() { typedef IRigidBody * (PhysicsCore::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(); }
	virtual void release_vf4();
	inline void release_impl() { typedef void (PhysicsCore::*_fpt)(); auto _f=xcast<_fpt>(_drva(2937952)); return (this->*_f)(); }
	inline void release() { typedef void (PhysicsCore::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 4)); return (this->*_f)(); }
	virtual IJoint * createDistanceJoint_vf5(IRigidBody * rb1, IRigidBody * rb2, const vec3f & p1, const vec3f & p2);
	inline IJoint * createDistanceJoint_impl(IRigidBody * rb1, IRigidBody * rb2, const vec3f & p1, const vec3f & p2) { typedef IJoint * (PhysicsCore::*_fpt)(IRigidBody *, IRigidBody *, const vec3f &, const vec3f &); auto _f=xcast<_fpt>(_drva(2933136)); return (this->*_f)(rb1, rb2, p1, p2); }
	inline IJoint * createDistanceJoint(IRigidBody * rb1, IRigidBody * rb2, const vec3f & p1, const vec3f & p2) { typedef IJoint * (PhysicsCore::*_fpt)(IRigidBody *, IRigidBody *, const vec3f &, const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 5)); return (this->*_f)(rb1, rb2, p1, p2); }
	virtual void reseatDistanceJointLocal_vf10(IJoint * joint, const vec3f & p1, const vec3f & p2);
	inline void reseatDistanceJointLocal_impl(IJoint * joint, const vec3f & p1, const vec3f & p2) { typedef void (PhysicsCore::*_fpt)(IJoint *, const vec3f &, const vec3f &); auto _f=xcast<_fpt>(_drva(2937984)); return (this->*_f)(joint, p1, p2); }
	inline void reseatDistanceJointLocal(IJoint * joint, const vec3f & p1, const vec3f & p2) { typedef void (PhysicsCore::*_fpt)(IJoint *, const vec3f &, const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 10)); return (this->*_f)(joint, p1, p2); }
	virtual void reseatDistanceJointLength_vf11(IJoint * joint, float newLength);
	inline void reseatDistanceJointLength_impl(IJoint * joint, float newLength) { typedef void (PhysicsCore::*_fpt)(IJoint *, float); auto _f=xcast<_fpt>(_drva(96368)); return (this->*_f)(joint, newLength); }
	inline void reseatDistanceJointLength(IJoint * joint, float newLength) { typedef void (PhysicsCore::*_fpt)(IJoint *, float); auto _f=xcast<_fpt>(get_vfp(this, 11)); return (this->*_f)(joint, newLength); }
	virtual IJoint * createBumpJoint_vf6(IRigidBody * rb1, IRigidBody * rb2, const vec3f & p1, float rangeUp, float rangeDn);
	inline IJoint * createBumpJoint_impl(IRigidBody * rb1, IRigidBody * rb2, const vec3f & p1, float rangeUp, float rangeDn) { typedef IJoint * (PhysicsCore::*_fpt)(IRigidBody *, IRigidBody *, const vec3f &, float, float); auto _f=xcast<_fpt>(_drva(3776688)); return (this->*_f)(rb1, rb2, p1, rangeUp, rangeDn); }
	inline IJoint * createBumpJoint(IRigidBody * rb1, IRigidBody * rb2, const vec3f & p1, float rangeUp, float rangeDn) { typedef IJoint * (PhysicsCore::*_fpt)(IRigidBody *, IRigidBody *, const vec3f &, float, float); auto _f=xcast<_fpt>(get_vfp(this, 6)); return (this->*_f)(rb1, rb2, p1, rangeUp, rangeDn); }
	virtual IJoint * createSliderJoint_vf13(IRigidBody * rb1, IRigidBody * rb2, const vec3f & axis);
	inline IJoint * createSliderJoint_impl(IRigidBody * rb1, IRigidBody * rb2, const vec3f & axis) { typedef IJoint * (PhysicsCore::*_fpt)(IRigidBody *, IRigidBody *, const vec3f &); auto _f=xcast<_fpt>(_drva(2933744)); return (this->*_f)(rb1, rb2, axis); }
	inline IJoint * createSliderJoint(IRigidBody * rb1, IRigidBody * rb2, const vec3f & axis) { typedef IJoint * (PhysicsCore::*_fpt)(IRigidBody *, IRigidBody *, const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 13)); return (this->*_f)(rb1, rb2, axis); }
	virtual void setSliderAxis_vf14(IJoint * joint, const vec3f & axis, const vec3f & anchor);
	inline void setSliderAxis_impl(IJoint * joint, const vec3f & axis, const vec3f & anchor) { typedef void (PhysicsCore::*_fpt)(IJoint *, const vec3f &, const vec3f &); auto _f=xcast<_fpt>(_drva(2938480)); return (this->*_f)(joint, axis, anchor); }
	inline void setSliderAxis(IJoint * joint, const vec3f & axis, const vec3f & anchor) { typedef void (PhysicsCore::*_fpt)(IJoint *, const vec3f &, const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 14)); return (this->*_f)(joint, axis, anchor); }
	virtual ICollisionObject * createCollisionMesh_vf7(float * vertices, unsigned int numVertices, unsigned short * indices, int indexCount, const mat44f & worldMatrix, IRigidBody * body, unsigned long group, unsigned long mask, unsigned int space_id);
	inline ICollisionObject * createCollisionMesh_impl(float * vertices, unsigned int numVertices, unsigned short * indices, int indexCount, const mat44f & worldMatrix, IRigidBody * body, unsigned long group, unsigned long mask, unsigned int space_id) { typedef ICollisionObject * (PhysicsCore::*_fpt)(float *, unsigned int, unsigned short *, int, const mat44f &, IRigidBody *, unsigned long, unsigned long, unsigned int); auto _f=xcast<_fpt>(_drva(2932976)); return (this->*_f)(vertices, numVertices, indices, indexCount, worldMatrix, body, group, mask, space_id); }
	inline ICollisionObject * createCollisionMesh(float * vertices, unsigned int numVertices, unsigned short * indices, int indexCount, const mat44f & worldMatrix, IRigidBody * body, unsigned long group, unsigned long mask, unsigned int space_id) { typedef ICollisionObject * (PhysicsCore::*_fpt)(float *, unsigned int, unsigned short *, int, const mat44f &, IRigidBody *, unsigned long, unsigned long, unsigned int); auto _f=xcast<_fpt>(get_vfp(this, 7)); return (this->*_f)(vertices, numVertices, indices, indexCount, worldMatrix, body, group, mask, space_id); }
	inline RayCastHit rayCast(const vec3f & pos, const vec3f & dir, dxGeom * rayc) { typedef RayCastHit (PhysicsCore::*_fpt)(const vec3f &, const vec3f &, dxGeom *); auto _f=xcast<_fpt>(_drva(2936944)); return (this->*_f)(pos, dir, rayc); }
	virtual RayCastHit rayCast_vf8(const vec3f & pos, const vec3f & dir, float length);
	inline RayCastHit rayCast_impl(const vec3f & pos, const vec3f & dir, float length) { typedef RayCastHit (PhysicsCore::*_fpt)(const vec3f &, const vec3f &, float); auto _f=xcast<_fpt>(_drva(2937248)); return (this->*_f)(pos, dir, length); }
	inline RayCastHit rayCast(const vec3f & pos, const vec3f & dir, float length) { typedef RayCastHit (PhysicsCore::*_fpt)(const vec3f &, const vec3f &, float); auto _f=xcast<_fpt>(get_vfp(this, 8)); return (this->*_f)(pos, dir, length); }
	virtual void setCollisionCallback_vf9(ICollisionCallback * callback);
	inline void setCollisionCallback_impl(ICollisionCallback * callback) { typedef void (PhysicsCore::*_fpt)(ICollisionCallback *); auto _f=xcast<_fpt>(_drva(2938256)); return (this->*_f)(callback); }
	inline void setCollisionCallback(ICollisionCallback * callback) { typedef void (PhysicsCore::*_fpt)(ICollisionCallback *); auto _f=xcast<_fpt>(get_vfp(this, 9)); return (this->*_f)(callback); }
	virtual void setRigidBodyIterations_vf12(int count);
	inline void setRigidBodyIterations_impl(int count) { typedef void (PhysicsCore::*_fpt)(int); auto _f=xcast<_fpt>(_drva(96368)); return (this->*_f)(count); }
	inline void setRigidBodyIterations(int count) { typedef void (PhysicsCore::*_fpt)(int); auto _f=xcast<_fpt>(get_vfp(this, 12)); return (this->*_f)(count); }
	inline void onCollision(dContactGeom * contacts, int numContacts, dxGeom * g0, dxGeom * g1) { typedef void (PhysicsCore::*_fpt)(dContactGeom *, int, dxGeom *, dxGeom *); auto _f=xcast<_fpt>(_drva(2936224)); return (this->*_f)(contacts, numContacts, g0, g1); }
	virtual IJoint * createBallJoint_vf15(IRigidBody * rb1, IRigidBody * rb2, const vec3f & pos);
	inline IJoint * createBallJoint_impl(IRigidBody * rb1, IRigidBody * rb2, const vec3f & pos) { typedef IJoint * (PhysicsCore::*_fpt)(IRigidBody *, IRigidBody *, const vec3f &); auto _f=xcast<_fpt>(_drva(2932752)); return (this->*_f)(rb1, rb2, pos); }
	inline IJoint * createBallJoint(IRigidBody * rb1, IRigidBody * rb2, const vec3f & pos) { typedef IJoint * (PhysicsCore::*_fpt)(IRigidBody *, IRigidBody *, const vec3f &); auto _f=xcast<_fpt>(get_vfp(this, 15)); return (this->*_f)(rb1, rb2, pos); }
	virtual IJoint * createFixedJoint_vf16(IRigidBody * rb1, IRigidBody * rb2);
	inline IJoint * createFixedJoint_impl(IRigidBody * rb1, IRigidBody * rb2) { typedef IJoint * (PhysicsCore::*_fpt)(IRigidBody *, IRigidBody *); auto _f=xcast<_fpt>(_drva(2933408)); return (this->*_f)(rb1, rb2); }
	inline IJoint * createFixedJoint(IRigidBody * rb1, IRigidBody * rb2) { typedef IJoint * (PhysicsCore::*_fpt)(IRigidBody *, IRigidBody *); auto _f=xcast<_fpt>(get_vfp(this, 16)); return (this->*_f)(rb1, rb2); }
	virtual IRayCaster * createRayCaster_vf17(float length);
	inline IRayCaster * createRayCaster_impl(float length) { typedef IRayCaster * (PhysicsCore::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2933600)); return (this->*_f)(length); }
	inline IRayCaster * createRayCaster(float length) { typedef IRayCaster * (PhysicsCore::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 17)); return (this->*_f)(length); }
	virtual CoreCPUTimes getCoreCPUTimes_vf18();
	inline CoreCPUTimes getCoreCPUTimes_impl() { typedef CoreCPUTimes (PhysicsCore::*_fpt)(); auto _f=xcast<_fpt>(_drva(2935040)); return (this->*_f)(); }
	inline CoreCPUTimes getCoreCPUTimes() { typedef CoreCPUTimes (PhysicsCore::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 18)); return (this->*_f)(); }
	virtual void setNoCollisionSteps_vf19(int steps);
	inline void setNoCollisionSteps_impl(int steps) { typedef void (PhysicsCore::*_fpt)(int); auto _f=xcast<_fpt>(_drva(2938464)); return (this->*_f)(steps); }
	inline void setNoCollisionSteps(int steps) { typedef void (PhysicsCore::*_fpt)(int); auto _f=xcast<_fpt>(get_vfp(this, 19)); return (this->*_f)(steps); }
	inline dxSpace * getStaticSubSpace(unsigned int index) { typedef dxSpace * (PhysicsCore::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(2935488)); return (this->*_f)(index); }
	inline dxSpace * getDynamicSubSpace(unsigned int index) { typedef dxSpace * (PhysicsCore::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(2935072)); return (this->*_f)(index); }
	inline void collisionStep(float dt) { typedef void (PhysicsCore::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2932624)); return (this->*_f)(dt); }
	inline void _guard_obj() {
		static_assert((sizeof(PhysicsCore)==168),"bad size");
		static_assert((offsetof(PhysicsCore,id)==0x8),"bad off");
		static_assert((offsetof(PhysicsCore,spaceStatic)==0x10),"bad off");
		static_assert((offsetof(PhysicsCore,spaceDynamic)==0x18),"bad off");
		static_assert((offsetof(PhysicsCore,coreCPUTimes)==0x20),"bad off");
		static_assert((offsetof(PhysicsCore,contactGroup)==0x38),"bad off");
		static_assert((offsetof(PhysicsCore,contactGroupDynamic)==0x40),"bad off");
		static_assert((offsetof(PhysicsCore,currentContactGroup)==0x48),"bad off");
		static_assert((offsetof(PhysicsCore,ray)==0x50),"bad off");
		static_assert((offsetof(PhysicsCore,collisionCallback)==0x58),"bad off");
		static_assert((offsetof(PhysicsCore,noCollisionCounter)==0x60),"bad off");
		static_assert((offsetof(PhysicsCore,staticSubSpaces)==0x68),"bad off");
		static_assert((offsetof(PhysicsCore,dynamicSubSpaces)==0x78),"bad off");
		static_assert((offsetof(PhysicsCore,threading)==0x88),"bad off");
		static_assert((offsetof(PhysicsCore,pool)==0x90),"bad off");
		static_assert((offsetof(PhysicsCore,totRayTime)==0x98),"bad off");
		static_assert((offsetof(PhysicsCore,currentFrame)==0xA0),"bad off");
	};
};

//UDT: class ACCameraManager @len=408 @vfcount=6
	//_Base: class GameObject @off=0 @len=88
	//_Func: public void ACCameraManager(const ACCameraManager &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void ACCameraManager(Sim * isim, CameraForward * icamera); @loc=static @len=4217 @rva=201328
	//_Func: public void ~ACCameraManager(); @virtual vtpo=0 vfid=0 @loc=static @len=1045 @rva=205584
	//_Data: this+0x58, Member, Type: class Event<int>, evOnCameraSelectedIndex
	//_Data: this+0x70, Member, Type: class Event<bool>, evOnCameraUpdateDone
	//_Data: this+0x88, Member, Type: class CameraOnBoard *, cameraOnBoard
	//_Data: this+0x90, Member, Type: class CameraMouseControl *, mouseControl
	//_Data: this+0x98, Member, Type: class CinematicFreeCamera *, cinematicMouseControl
	//_Data: this+0xA0, Member, Type: class CameraTrack *, cameraTrack
	//_Data: this+0xA8, Member, Type: class CameraHelicopter *, cameraHelicopter
	//_Data: this+0xB0, Member, Type: class CameraOnBoardFree *, cameraOnBoardFree
	//_Data: this+0xB8, Member, Type: class CameraCarManager *, cameraCar
	//_Data: this+0xC0, Member, Type: class CameraDrivableManager *, cameraDrivable
	//_Data: this+0xC8, Member, Type: class CameraModeStart *, cameraStart
	//_Data: this+0xD0, Member, Type: class ImageGeneratorCamera *, imageGeneratorCamera
	//_Func: public void update(float deltaT); @virtual vtpo=0 vfid=1 @loc=static @len=444 @rva=214496
	//_Func: public void setMode(CameraMode imode, bool force, bool pIsRandom); @loc=static @len=536 @rva=213200
	//_Func: public bool isCameraOnBoard(CarAvatar * car); @loc=static @len=111 @rva=210672
	//_Func: public CameraMode getMode(); @loc=static @len=7 @rva=377008
	//_Func: public bool isVirtualMirrorOn(); @loc=static @len=14 @rva=210784
	//_Func: public bool isDrivingCamera(CarAvatar *  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public bool isCockpitAudioOccluded(CarAvatar *  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public int getCurrentGlobalCameraIndex(); @loc=optimized @len=0 @rva=0
	//_Func: public void onCameraChanged(const ACCamera &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void loadPreviousSessionUserCamera(); @loc=static @len=364 @rva=210912
	//_Func: public void fadeIn(FadeModeDef aFadeMode); @loc=static @len=63 @rva=210576
	//_Func: public void registerToFadeInEvent(std::function<void __cdecl(bool const &)> * f, void * sender); @loc=static @len=309 @rva=212192
	//_Func: public void setKeyboardInputEnabled(bool value); @loc=static @len=7 @rva=673008
	//_Func: public void setCameraCarIndex(int index); @loc=static @len=22 @rva=212912
	//_Func: public void setDrivableCarIndex(int index); @loc=static @len=254 @rva=212944
	//_Func: public unsigned int onFadeInFinishedListenersCount(); @loc=static @len=45 @rva=553136
	//_Func: public bool isRandom(); @loc=optimized @len=0 @rva=0
	//_Func: public void setRandom(bool  _arg0); @loc=optimized @len=0 @rva=0
	//_Data: this+0xD8, Member, Type: bool, isKeyboardCameraControlEnabled
	//_Data: this+0xDC, Member, Type: int, currentGlobalCameraIndex
	//_Data: this+0xE0, Member, Type: float, randomCameraTime
	//_Data: this+0xE4, Member, Type: float, randomOldCameraTime
	//_Data: this+0xE8, Member, Type: float, randomCameraMinTime
	//_Data: this+0xEC, Member, Type: float, randomCameraMaxTime
	//_Data: this+0xF0, Member, Type: class std::vector<int,std::allocator<int> >, randomCameraProbabilities
	//_Data: this+0x108, Member, Type: bool, randomMode
	//_Data: this+0x10C, Member, Type: enum CameraMode, lastRandomCamera
	//_Data: this+0x110, Member, Type: class Sim *, sim
	//_Data: this+0x118, Member, Type: class CameraForward *, camera
	//_Data: this+0x120, Member, Type: enum CameraMode, mode
	//_Data: this+0x124, Member, Type: enum CameraMode, lastDrivingMode
	//_Data: this+0x128, Member, Type: struct FadeModeDef, fadeMode
	//_Data: this+0x140, Member, Type: class Texture, fadeTexture
	//_Data: this+0x168, Member, Type: class vec3f, fadeColor
	//_Data: this+0x178, Member, Type: class Event<bool>, evOnFadeInFinished
	//_Data: this+0x190, Member, Type: struct PersistanceCameraModeDef, persistanceCameraMode
	//_Func: protected void stepCameraRandom(int lastCarIndex); @loc=static @len=600 @rva=213760
	//_Func: protected void setAudioDistanceScale(); @loc=static @len=396 @rva=212512
	//_Func: public ACCameraManager & operator=(const ACCameraManager &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ACCameraManager : public GameObject {
public:
	Event<int> evOnCameraSelectedIndex;
	Event<bool> evOnCameraUpdateDone;
	CameraOnBoard * cameraOnBoard;
	CameraMouseControl * mouseControl;
	CinematicFreeCamera * cinematicMouseControl;
	CameraTrack * cameraTrack;
	CameraHelicopter * cameraHelicopter;
	CameraOnBoardFree * cameraOnBoardFree;
	CameraCarManager * cameraCar;
	CameraDrivableManager * cameraDrivable;
	CameraModeStart * cameraStart;
	ImageGeneratorCamera * imageGeneratorCamera;
	bool isKeyboardCameraControlEnabled;
	int currentGlobalCameraIndex;
	float randomCameraTime;
	float randomOldCameraTime;
	float randomCameraMinTime;
	float randomCameraMaxTime;
	std::vector<int,std::allocator<int> > randomCameraProbabilities;
	bool randomMode;
	CameraMode lastRandomCamera;
	Sim * sim;
	CameraForward * camera;
	CameraMode mode;
	CameraMode lastDrivingMode;
	FadeModeDef fadeMode;
	Texture fadeTexture;
	vec3f fadeColor;
	Event<bool> evOnFadeInFinished;
	PersistanceCameraModeDef persistanceCameraMode;
	inline ACCameraManager() { }
	inline ACCameraManager(const ACCameraManager& other) = default;
	inline ACCameraManager& operator=(const ACCameraManager& other) = default;
	inline void ctor(Sim * isim, CameraForward * icamera) { typedef void (ACCameraManager::*_fpt)(Sim *, CameraForward *); auto _f=xcast<_fpt>(_drva(201328)); (this->*_f)(isim, icamera); }
	virtual ~ACCameraManager();
	inline void dtor() { typedef void (ACCameraManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(205584)); (this->*_f)(); }
	virtual void update_vf1(float deltaT);
	inline void update_impl(float deltaT) { typedef void (ACCameraManager::*_fpt)(float); auto _f=xcast<_fpt>(_drva(214496)); return (this->*_f)(deltaT); }
	inline void update(float deltaT) { typedef void (ACCameraManager::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(deltaT); }
	inline void setMode(CameraMode imode, bool force, bool pIsRandom) { typedef void (ACCameraManager::*_fpt)(CameraMode, bool, bool); auto _f=xcast<_fpt>(_drva(213200)); return (this->*_f)(imode, force, pIsRandom); }
	inline bool isCameraOnBoard(CarAvatar * car) { typedef bool (ACCameraManager::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(210672)); return (this->*_f)(car); }
	inline CameraMode getMode() { typedef CameraMode (ACCameraManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(377008)); return (this->*_f)(); }
	inline bool isVirtualMirrorOn() { typedef bool (ACCameraManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(210784)); return (this->*_f)(); }
	inline void loadPreviousSessionUserCamera() { typedef void (ACCameraManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(210912)); return (this->*_f)(); }
	inline void fadeIn(FadeModeDef aFadeMode) { typedef void (ACCameraManager::*_fpt)(FadeModeDef); auto _f=xcast<_fpt>(_drva(210576)); return (this->*_f)(aFadeMode); }
	inline void registerToFadeInEvent(std::function<void __cdecl(bool const &)> * f, void * sender) { typedef void (ACCameraManager::*_fpt)(std::function<void __cdecl(bool const &)> *, void *); auto _f=xcast<_fpt>(_drva(212192)); return (this->*_f)(f, sender); }
	inline void setKeyboardInputEnabled(bool value) { typedef void (ACCameraManager::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(673008)); return (this->*_f)(value); }
	inline void setCameraCarIndex(int index) { typedef void (ACCameraManager::*_fpt)(int); auto _f=xcast<_fpt>(_drva(212912)); return (this->*_f)(index); }
	inline void setDrivableCarIndex(int index) { typedef void (ACCameraManager::*_fpt)(int); auto _f=xcast<_fpt>(_drva(212944)); return (this->*_f)(index); }
	inline unsigned int onFadeInFinishedListenersCount() { typedef unsigned int (ACCameraManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(553136)); return (this->*_f)(); }
	inline void stepCameraRandom(int lastCarIndex) { typedef void (ACCameraManager::*_fpt)(int); auto _f=xcast<_fpt>(_drva(213760)); return (this->*_f)(lastCarIndex); }
	inline void setAudioDistanceScale() { typedef void (ACCameraManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(212512)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(ACCameraManager)==408),"bad size");
		static_assert((offsetof(ACCameraManager,evOnCameraSelectedIndex)==0x58),"bad off");
		static_assert((offsetof(ACCameraManager,evOnCameraUpdateDone)==0x70),"bad off");
		static_assert((offsetof(ACCameraManager,cameraOnBoard)==0x88),"bad off");
		static_assert((offsetof(ACCameraManager,mouseControl)==0x90),"bad off");
		static_assert((offsetof(ACCameraManager,cinematicMouseControl)==0x98),"bad off");
		static_assert((offsetof(ACCameraManager,cameraTrack)==0xA0),"bad off");
		static_assert((offsetof(ACCameraManager,cameraHelicopter)==0xA8),"bad off");
		static_assert((offsetof(ACCameraManager,cameraOnBoardFree)==0xB0),"bad off");
		static_assert((offsetof(ACCameraManager,cameraCar)==0xB8),"bad off");
		static_assert((offsetof(ACCameraManager,cameraDrivable)==0xC0),"bad off");
		static_assert((offsetof(ACCameraManager,cameraStart)==0xC8),"bad off");
		static_assert((offsetof(ACCameraManager,imageGeneratorCamera)==0xD0),"bad off");
		static_assert((offsetof(ACCameraManager,isKeyboardCameraControlEnabled)==0xD8),"bad off");
		static_assert((offsetof(ACCameraManager,currentGlobalCameraIndex)==0xDC),"bad off");
		static_assert((offsetof(ACCameraManager,randomCameraTime)==0xE0),"bad off");
		static_assert((offsetof(ACCameraManager,randomOldCameraTime)==0xE4),"bad off");
		static_assert((offsetof(ACCameraManager,randomCameraMinTime)==0xE8),"bad off");
		static_assert((offsetof(ACCameraManager,randomCameraMaxTime)==0xEC),"bad off");
		static_assert((offsetof(ACCameraManager,randomCameraProbabilities)==0xF0),"bad off");
		static_assert((offsetof(ACCameraManager,randomMode)==0x108),"bad off");
		static_assert((offsetof(ACCameraManager,lastRandomCamera)==0x10C),"bad off");
		static_assert((offsetof(ACCameraManager,sim)==0x110),"bad off");
		static_assert((offsetof(ACCameraManager,camera)==0x118),"bad off");
		static_assert((offsetof(ACCameraManager,mode)==0x120),"bad off");
		static_assert((offsetof(ACCameraManager,lastDrivingMode)==0x124),"bad off");
		static_assert((offsetof(ACCameraManager,fadeMode)==0x128),"bad off");
		static_assert((offsetof(ACCameraManager,fadeTexture)==0x140),"bad off");
		static_assert((offsetof(ACCameraManager,fadeColor)==0x168),"bad off");
		static_assert((offsetof(ACCameraManager,evOnFadeInFinished)==0x178),"bad off");
		static_assert((offsetof(ACCameraManager,persistanceCameraMode)==0x190),"bad off");
	};
};

//UDT: class PhysicsEngine @len=632 @vfcount=2
	//_Base: class ICollisionCallback @off=0 @len=8
	//_Func: public void PhysicsEngine(const PhysicsEngine &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void PhysicsEngine(); @loc=static @len=2107 @rva=2499632
	//_Func: public void ~PhysicsEngine(); @virtual vtpo=0 vfid=0 @loc=static @len=334 @rva=2501872
	//_Data: this+0x8, Member, Type: class std::vector<Car *,std::allocator<Car *> >, cars
	//_Data: this+0x20, Member, Type: double, physicsTime
	//_Data: this+0x28, Member, Type: bool, validated
	//_Data: this+0x30, Member, Type: class Concurrency::concurrent_queue<ACPhysicsEvent,std::allocator<ACPhysicsEvent> >, eventQueue
	//_Data: this+0x58, Member, Type: class Event<OnFlagEvent>, evOnFlagEvent
	//_Data: this+0x70, Member, Type: class Event<double>, evOnStepCompleted
	//_Data: this+0x88, Member, Type: class Event<double>, evOnPreStep
	//_Data: this+0xA0, Member, Type: class Event<SessionInfo>, evOnNewSessionPhysics
	//_Data: this+0xB8, Member, Type: bool, allowTyreBlankets
	//_Data: this+0xC0, Member, Type: double, lockGearboxAtStartTimeMS
	//_Data: this+0xC8, Member, Type: float, fuelConsumptionRate
	//_Data: this+0xCC, Member, Type: float, tyreConsumptionRate
	//_Data: this+0xD0, Member, Type: int, allowedTyresOut
	//_Data: this+0xD4, Member, Type: enum PenaltyMode, penaltyMode
	//_Data: this+0xD8, Member, Type: struct PenaltyRules, penaltyRules
	//_Data: this+0xE0, Member, Type: class std::vector<SlipStream *,std::allocator<SlipStream *> >, slipStreams
	//_Data: this+0xF8, Member, Type: double, gameTime
	//_Data: this+0x100, Member, Type: float, ambientTemperature
	//_Data: this+0x104, Member, Type: float, roadTemperature
	//_Data: this+0x108, Member, Type: float, mechanicalDamageRate
	//_Data: this+0x110, Member, Type: struct PhysicsCPUTimes, physicsCPUTimes
	//_Data: this+0x138, Member, Type: const float, flatSpotFFGain
	//_Data: this+0x13C, Member, Type: struct SteerMzLowSpeedReduction, mzLowSpeedReduction
	//_Data: this+0x144, Member, Type: bool, isEngineStallEnabled
	//_Data: this+0x148, Member, Type: float, gyroWheelGain
	//_Data: this+0x14C, Member, Type: float, spinTorqueGain
	//_Data: static, [0155A770][0003:00047770], Static Member, Type: bool, isTestMode
	//_Data: static, [0155A771][0003:00047771], Static Member, Type: bool, autoDrive
	//_Data: static, [0155A774][0003:00047774], Static Member, Type: enum TestMode, testMode
	//_Data: this+0x150, Member, Type: float, damperMinValue
	//_Data: this+0x154, Member, Type: float, damperGain
	//_Data: this+0x158, Member, Type: struct Wind, wind
	//_Func: public void setWind(Speed speed, float directionDEG); @loc=static @len=433 @rva=2508192
	//_Func: public void setCurrentSessionStartTime(double st); @loc=static @len=9 @rva=2508176
	//_Func: public SessionInfo getCurrentSession(); @loc=optimized @len=0 @rva=0
	//_Func: public Track * getTrack(); @loc=optimized @len=0 @rva=0
	//_Func: public void setTrack(Track *  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void removeCar(Car * c); @loc=static @len=73 @rva=2507328
	//_Func: public void step(float dt, double currentTime, double gt); @loc=static @len=2996 @rva=2508640
	//_Func: public void stepPaused(); @loc=static @len=87 @rva=2511648
	//_Func: public IPhysicsCore * getCore(); @loc=static @len=8 @rva=2505344
	//_Func: public void onCollisionCallBack(void * userData0, void * shape0, void * userData1, void * shape1, vec3f normal, vec3f pos, float depth); @virtual vtpo=0 vfid=1 @loc=static @len=398 @rva=2506784
	//_Func: public bool hasSessionStarted(double lag); @loc=static @len=17 @rva=2505840
	//_Func: public void addDebugLine(const DebugLine &  _arg0, int  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public void addDebugString(DebugString &  _arg0, int  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public void setDebugVisualizer(IDebugVisualizer *  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public double getOddTimeOffset(); @loc=static @len=35 @rva=2505360
	//_Func: public void addAdditionalPhysicsProvider(ICarPhysicsStateProvider * p); @loc=static @len=31 @rva=2505216
	//_Func: public void setSessionInfo(const SessionInfo & info); @loc=static @len=34 @rva=2508128
	//_Func: public void setSessionStartTimeMS(double new_start_time); @loc=static @len=9 @rva=2508176
	//_Func: public void addLegalTyre(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & short_name); @loc=static @len=64 @rva=2505248
	//_Func: public bool isTyreLegal(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & short_name); @loc=static @len=234 @rva=2506544
	//_Func: public float getAirDensity(); @loc=static @len=29 @rva=2505312
	//_Func: public void writeTestResult(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & result); @loc=static @len=837 @rva=2512176
	//_Func: public void getPhysicsStates(std::vector<CarPhysicsState,std::allocator<CarPhysicsState> > & states, std::vector<std::vector<WingState,std::allocator<WingState> >,std::allocator<std::vector<WingState,std::allocator<WingState> > > > & wingStates); @loc=static @len=419 @rva=2505408
	//_Func: public void setDynamicTempData(DynamicTempData & data); @loc=static @len=96 @rva=1315344
	//_Data: this+0x170, Member, Type: struct SessionInfo, sessionInfo
	//_Data: this+0x190, Member, Type: class IPhysicsCore *, core
	//_Data: this+0x198, Member, Type: class Track *, track
	//_Data: this+0x1A0, Member, Type: class IDebugVisualizer *, debugVisualizer
	//_Data: this+0x1A8, Member, Type: unsigned int, stepCounter
	//_Data: this+0x1B0, Member, Type: class std::vector<ICarPhysicsStateProvider *,std::allocator<ICarPhysicsStateProvider *> >, additionalPhysicsProviders
	//_Data: this+0x1C8, Member, Type: class std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, legalTyreList
	//_Data: this+0x1E0, Member, Type: class std::unique_ptr<ThreadPool,std::default_delete<ThreadPool> >, pool
	//_Data: this+0x1E8, Member, Type: struct DynamicTempData, dynamicTemp
	//_Func: protected void validate(); @loc=optimized @len=0 @rva=0
	//_Func: protected void loadConfiguration(); @loc=optimized @len=0 @rva=0
	//_Func: protected void initLowSpeedFF(); @loc=static @len=670 @rva=2505872
	//_Func: protected void stepTemperatureCurve(); @loc=optimized @len=0 @rva=0
	//_Func: protected void stepWind(float dt); @loc=static @len=391 @rva=2511744
	//_Func: public PhysicsEngine & operator=(const PhysicsEngine &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class PhysicsEngine : public ICollisionCallback {
public:
	std::vector<Car *,std::allocator<Car *> > cars;
	double physicsTime;
	bool validated;
	Concurrency::concurrent_queue<ACPhysicsEvent,std::allocator<ACPhysicsEvent> > eventQueue;
	Event<OnFlagEvent> evOnFlagEvent;
	Event<double> evOnStepCompleted;
	Event<double> evOnPreStep;
	Event<SessionInfo> evOnNewSessionPhysics;
	bool allowTyreBlankets;
	double lockGearboxAtStartTimeMS;
	float fuelConsumptionRate;
	float tyreConsumptionRate;
	int allowedTyresOut;
	PenaltyMode penaltyMode;
	PenaltyRules penaltyRules;
	std::vector<SlipStream *,std::allocator<SlipStream *> > slipStreams;
	double gameTime;
	float ambientTemperature;
	float roadTemperature;
	float mechanicalDamageRate;
	PhysicsCPUTimes physicsCPUTimes;
	float flatSpotFFGain;
	SteerMzLowSpeedReduction mzLowSpeedReduction;
	bool isEngineStallEnabled;
	float gyroWheelGain;
	float spinTorqueGain;
	float damperMinValue;
	float damperGain;
	Wind wind;
	SessionInfo sessionInfo;
	IPhysicsCore * core;
	Track * track;
	IDebugVisualizer * debugVisualizer;
	unsigned int stepCounter;
	std::vector<ICarPhysicsStateProvider *,std::allocator<ICarPhysicsStateProvider *> > additionalPhysicsProviders;
	std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > legalTyreList;
	std::unique_ptr<ThreadPool,std::default_delete<ThreadPool> > pool;
	DynamicTempData dynamicTemp;
	inline PhysicsEngine() { }
	inline PhysicsEngine(const PhysicsEngine& other) = default;
	inline PhysicsEngine& operator=(const PhysicsEngine& other) = default;
	inline void ctor() { typedef void (PhysicsEngine::*_fpt)(); auto _f=xcast<_fpt>(_drva(2499632)); (this->*_f)(); }
	virtual ~PhysicsEngine();
	inline void dtor() { typedef void (PhysicsEngine::*_fpt)(); auto _f=xcast<_fpt>(_drva(2501872)); (this->*_f)(); }
	inline void setWind(Speed speed, float directionDEG) { typedef void (PhysicsEngine::*_fpt)(Speed, float); auto _f=xcast<_fpt>(_drva(2508192)); return (this->*_f)(speed, directionDEG); }
	inline void setCurrentSessionStartTime(double st) { typedef void (PhysicsEngine::*_fpt)(double); auto _f=xcast<_fpt>(_drva(2508176)); return (this->*_f)(st); }
	inline void removeCar(Car * c) { typedef void (PhysicsEngine::*_fpt)(Car *); auto _f=xcast<_fpt>(_drva(2507328)); return (this->*_f)(c); }
	inline void step(float dt, double currentTime, double gt) { typedef void (PhysicsEngine::*_fpt)(float, double, double); auto _f=xcast<_fpt>(_drva(2508640)); return (this->*_f)(dt, currentTime, gt); }
	inline void stepPaused() { typedef void (PhysicsEngine::*_fpt)(); auto _f=xcast<_fpt>(_drva(2511648)); return (this->*_f)(); }
	inline IPhysicsCore * getCore() { typedef IPhysicsCore * (PhysicsEngine::*_fpt)(); auto _f=xcast<_fpt>(_drva(2505344)); return (this->*_f)(); }
	virtual void onCollisionCallBack_vf1(void * userData0, void * shape0, void * userData1, void * shape1, vec3f normal, vec3f pos, float depth);
	inline void onCollisionCallBack_impl(void * userData0, void * shape0, void * userData1, void * shape1, vec3f normal, vec3f pos, float depth) { typedef void (PhysicsEngine::*_fpt)(void *, void *, void *, void *, vec3f, vec3f, float); auto _f=xcast<_fpt>(_drva(2506784)); return (this->*_f)(userData0, shape0, userData1, shape1, normal, pos, depth); }
	inline void onCollisionCallBack(void * userData0, void * shape0, void * userData1, void * shape1, vec3f normal, vec3f pos, float depth) { typedef void (PhysicsEngine::*_fpt)(void *, void *, void *, void *, vec3f, vec3f, float); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(userData0, shape0, userData1, shape1, normal, pos, depth); }
	inline bool hasSessionStarted(double lag) { typedef bool (PhysicsEngine::*_fpt)(double); auto _f=xcast<_fpt>(_drva(2505840)); return (this->*_f)(lag); }
	inline double getOddTimeOffset() { typedef double (PhysicsEngine::*_fpt)(); auto _f=xcast<_fpt>(_drva(2505360)); return (this->*_f)(); }
	inline void addAdditionalPhysicsProvider(ICarPhysicsStateProvider * p) { typedef void (PhysicsEngine::*_fpt)(ICarPhysicsStateProvider *); auto _f=xcast<_fpt>(_drva(2505216)); return (this->*_f)(p); }
	inline void setSessionInfo(const SessionInfo & info) { typedef void (PhysicsEngine::*_fpt)(const SessionInfo &); auto _f=xcast<_fpt>(_drva(2508128)); return (this->*_f)(info); }
	inline void setSessionStartTimeMS(double new_start_time) { typedef void (PhysicsEngine::*_fpt)(double); auto _f=xcast<_fpt>(_drva(2508176)); return (this->*_f)(new_start_time); }
	inline void addLegalTyre(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & short_name) { typedef void (PhysicsEngine::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2505248)); return (this->*_f)(short_name); }
	inline bool isTyreLegal(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & short_name) { typedef bool (PhysicsEngine::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2506544)); return (this->*_f)(short_name); }
	inline float getAirDensity() { typedef float (PhysicsEngine::*_fpt)(); auto _f=xcast<_fpt>(_drva(2505312)); return (this->*_f)(); }
	inline void writeTestResult(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & result) { typedef void (PhysicsEngine::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2512176)); return (this->*_f)(result); }
	inline void getPhysicsStates(std::vector<CarPhysicsState,std::allocator<CarPhysicsState> > & states, std::vector<std::vector<WingState,std::allocator<WingState> >,std::allocator<std::vector<WingState,std::allocator<WingState> > > > & wingStates) { typedef void (PhysicsEngine::*_fpt)(std::vector<CarPhysicsState,std::allocator<CarPhysicsState> > &, std::vector<std::vector<WingState,std::allocator<WingState> >,std::allocator<std::vector<WingState,std::allocator<WingState> > > > &); auto _f=xcast<_fpt>(_drva(2505408)); return (this->*_f)(states, wingStates); }
	inline void setDynamicTempData(DynamicTempData & data) { typedef void (PhysicsEngine::*_fpt)(DynamicTempData &); auto _f=xcast<_fpt>(_drva(1315344)); return (this->*_f)(data); }
	inline void initLowSpeedFF() { typedef void (PhysicsEngine::*_fpt)(); auto _f=xcast<_fpt>(_drva(2505872)); return (this->*_f)(); }
	inline void stepWind(float dt) { typedef void (PhysicsEngine::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2511744)); return (this->*_f)(dt); }
	inline void _guard_obj() {
		static_assert((sizeof(PhysicsEngine)==632),"bad size");
		static_assert((offsetof(PhysicsEngine,cars)==0x8),"bad off");
		static_assert((offsetof(PhysicsEngine,physicsTime)==0x20),"bad off");
		static_assert((offsetof(PhysicsEngine,validated)==0x28),"bad off");
		static_assert((offsetof(PhysicsEngine,eventQueue)==0x30),"bad off");
		static_assert((offsetof(PhysicsEngine,evOnFlagEvent)==0x58),"bad off");
		static_assert((offsetof(PhysicsEngine,evOnStepCompleted)==0x70),"bad off");
		static_assert((offsetof(PhysicsEngine,evOnPreStep)==0x88),"bad off");
		static_assert((offsetof(PhysicsEngine,evOnNewSessionPhysics)==0xA0),"bad off");
		static_assert((offsetof(PhysicsEngine,allowTyreBlankets)==0xB8),"bad off");
		static_assert((offsetof(PhysicsEngine,lockGearboxAtStartTimeMS)==0xC0),"bad off");
		static_assert((offsetof(PhysicsEngine,fuelConsumptionRate)==0xC8),"bad off");
		static_assert((offsetof(PhysicsEngine,tyreConsumptionRate)==0xCC),"bad off");
		static_assert((offsetof(PhysicsEngine,allowedTyresOut)==0xD0),"bad off");
		static_assert((offsetof(PhysicsEngine,penaltyMode)==0xD4),"bad off");
		static_assert((offsetof(PhysicsEngine,penaltyRules)==0xD8),"bad off");
		static_assert((offsetof(PhysicsEngine,slipStreams)==0xE0),"bad off");
		static_assert((offsetof(PhysicsEngine,gameTime)==0xF8),"bad off");
		static_assert((offsetof(PhysicsEngine,ambientTemperature)==0x100),"bad off");
		static_assert((offsetof(PhysicsEngine,roadTemperature)==0x104),"bad off");
		static_assert((offsetof(PhysicsEngine,mechanicalDamageRate)==0x108),"bad off");
		static_assert((offsetof(PhysicsEngine,physicsCPUTimes)==0x110),"bad off");
		static_assert((offsetof(PhysicsEngine,flatSpotFFGain)==0x138),"bad off");
		static_assert((offsetof(PhysicsEngine,mzLowSpeedReduction)==0x13C),"bad off");
		static_assert((offsetof(PhysicsEngine,isEngineStallEnabled)==0x144),"bad off");
		static_assert((offsetof(PhysicsEngine,gyroWheelGain)==0x148),"bad off");
		static_assert((offsetof(PhysicsEngine,spinTorqueGain)==0x14C),"bad off");
		static_assert((offsetof(PhysicsEngine,damperMinValue)==0x150),"bad off");
		static_assert((offsetof(PhysicsEngine,damperGain)==0x154),"bad off");
		static_assert((offsetof(PhysicsEngine,wind)==0x158),"bad off");
		static_assert((offsetof(PhysicsEngine,sessionInfo)==0x170),"bad off");
		static_assert((offsetof(PhysicsEngine,core)==0x190),"bad off");
		static_assert((offsetof(PhysicsEngine,track)==0x198),"bad off");
		static_assert((offsetof(PhysicsEngine,debugVisualizer)==0x1A0),"bad off");
		static_assert((offsetof(PhysicsEngine,stepCounter)==0x1A8),"bad off");
		static_assert((offsetof(PhysicsEngine,additionalPhysicsProviders)==0x1B0),"bad off");
		static_assert((offsetof(PhysicsEngine,legalTyreList)==0x1C8),"bad off");
		static_assert((offsetof(PhysicsEngine,pool)==0x1E0),"bad off");
		static_assert((offsetof(PhysicsEngine,dynamicTemp)==0x1E8),"bad off");
	};
};

//UDT: struct SteerBrake @len=48
	//_Data: this+0x0, Member, Type: bool, isActive
	//_Data: this+0x8, Member, Type: class DynamicController, controller
	//_Func: public void SteerBrake(const SteerBrake &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void SteerBrake(); @loc=optimized @len=0 @rva=0
	//_Func: public void ~SteerBrake(); @loc=static @len=9 @rva=2549856
	//_Func: public SteerBrake & operator=(const SteerBrake &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct SteerBrake {
public:
	bool isActive;
	DynamicController controller;
	inline SteerBrake() { }
	inline SteerBrake(const SteerBrake& other) = default;
	inline SteerBrake& operator=(const SteerBrake& other) = default;
	inline void dtor() { typedef void (SteerBrake::*_fpt)(); auto _f=xcast<_fpt>(_drva(2549856)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(SteerBrake)==48),"bad size");
		static_assert((offsetof(SteerBrake,isActive)==0x0),"bad off");
		static_assert((offsetof(SteerBrake,controller)==0x8),"bad off");
	};
};

//UDT: struct DrivetrainControllers @len=32
	//_Data: this+0x0, Member, Type: class std::unique_ptr<DynamicController,std::default_delete<DynamicController> >, awdFrontShare
	//_Data: this+0x8, Member, Type: class std::unique_ptr<DynamicController,std::default_delete<DynamicController> >, awdCenterLock
	//_Data: this+0x10, Member, Type: class std::unique_ptr<DynamicController,std::default_delete<DynamicController> >, singleDiffLock
	//_Data: this+0x18, Member, Type: class std::unique_ptr<DynamicController,std::default_delete<DynamicController> >, awd2
	//_Func: public void DrivetrainControllers(const DrivetrainControllers &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void DrivetrainControllers(); @loc=optimized @len=0 @rva=0
	//_Func: public void ~DrivetrainControllers(); @loc=static @len=123 @rva=2515184
	//_Func: public DrivetrainControllers & operator=(const DrivetrainControllers &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct DrivetrainControllers {
public:
	std::unique_ptr<DynamicController,std::default_delete<DynamicController> > awdFrontShare;
	std::unique_ptr<DynamicController,std::default_delete<DynamicController> > awdCenterLock;
	std::unique_ptr<DynamicController,std::default_delete<DynamicController> > singleDiffLock;
	std::unique_ptr<DynamicController,std::default_delete<DynamicController> > awd2;
	inline DrivetrainControllers() { }
	inline DrivetrainControllers(const DrivetrainControllers& other) = default;
	inline DrivetrainControllers& operator=(const DrivetrainControllers& other) = default;
	inline void dtor() { typedef void (DrivetrainControllers::*_fpt)(); auto _f=xcast<_fpt>(_drva(2515184)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(DrivetrainControllers)==32),"bad size");
		static_assert((offsetof(DrivetrainControllers,awdFrontShare)==0x0),"bad off");
		static_assert((offsetof(DrivetrainControllers,awdCenterLock)==0x8),"bad off");
		static_assert((offsetof(DrivetrainControllers,singleDiffLock)==0x10),"bad off");
		static_assert((offsetof(DrivetrainControllers,awd2)==0x18),"bad off");
	};
};

//UDT: struct TurboDynamicController @len=56
	//_Data: this+0x0, Member, Type: class Turbo *, turbo
	//_Data: this+0x8, Member, Type: class DynamicController, controller
	//_Data: this+0x30, Member, Type: bool, isWastegate
	//_Func: public void TurboDynamicController(const TurboDynamicController &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void TurboDynamicController(); @loc=static @len=38 @rva=2643056
	//_Func: public void ~TurboDynamicController(); @loc=static @len=9 @rva=2549856
	//_Func: public TurboDynamicController & operator=(const TurboDynamicController &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct TurboDynamicController {
public:
	Turbo * turbo;
	DynamicController controller;
	bool isWastegate;
	inline TurboDynamicController() { }
	inline TurboDynamicController(const TurboDynamicController& other) = default;
	inline TurboDynamicController& operator=(const TurboDynamicController& other) = default;
	inline void ctor() { typedef void (TurboDynamicController::*_fpt)(); auto _f=xcast<_fpt>(_drva(2643056)); (this->*_f)(); }
	inline void dtor() { typedef void (TurboDynamicController::*_fpt)(); auto _f=xcast<_fpt>(_drva(2549856)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(TurboDynamicController)==56),"bad size");
		static_assert((offsetof(TurboDynamicController,turbo)==0x0),"bad off");
		static_assert((offsetof(TurboDynamicController,controller)==0x8),"bad off");
		static_assert((offsetof(TurboDynamicController,isWastegate)==0x30),"bad off");
	};
};

//UDT: struct ERSPowerController @len=72
	//_Data: this+0x0, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, name
	//_Data: this+0x20, Member, Type: class DynamicController, ctrl
	//_Func: public void ERSPowerController(const ERSPowerController & __that); @loc=static @len=102 @rva=2692640
	//_Func: public void ERSPowerController(); @loc=optimized @len=0 @rva=0
	//_Func: public void ~ERSPowerController(); @loc=static @len=70 @rva=2693104
	//_Func: public ERSPowerController & operator=(const ERSPowerController &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct ERSPowerController {
public:
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > name;
	DynamicController ctrl;
	inline ERSPowerController() { }
	inline ERSPowerController(const ERSPowerController& other) = default;
	inline ERSPowerController& operator=(const ERSPowerController& other) = default;
	inline void ctor(const ERSPowerController & __that) { typedef void (ERSPowerController::*_fpt)(const ERSPowerController &); auto _f=xcast<_fpt>(_drva(2692640)); (this->*_f)(__that); }
	inline void dtor() { typedef void (ERSPowerController::*_fpt)(); auto _f=xcast<_fpt>(_drva(2693104)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(ERSPowerController)==72),"bad size");
		static_assert((offsetof(ERSPowerController,name)==0x0),"bad off");
		static_assert((offsetof(ERSPowerController,ctrl)==0x20),"bad off");
	};
};

//UDT: struct SteeringSystem @len=64
	//_Func: public void ~SteeringSystem(); @loc=static @len=9 @rva=2864640
	//_Data: this+0x0, Member, Type: float, linearRatio
	//_Func: public void init(Car * car); @loc=static @len=221 @rva=2851024
	//_Func: public void step(float dt); @loc=static @len=164 @rva=2851248
	//_Data: this+0x8, Member, Type: class Car *, car
	//_Data: this+0x10, Member, Type: bool, has4ws
	//_Data: this+0x18, Member, Type: class DynamicController, ctrl4ws
	//_Func: public void SteeringSystem(const SteeringSystem &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void SteeringSystem(); @loc=optimized @len=0 @rva=0
	//_Func: public SteeringSystem & operator=(const SteeringSystem &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct SteeringSystem {
public:
	float linearRatio;
	Car * car;
	bool has4ws;
	DynamicController ctrl4ws;
	inline SteeringSystem() { }
	inline SteeringSystem(const SteeringSystem& other) = default;
	inline SteeringSystem& operator=(const SteeringSystem& other) = default;
	inline void dtor() { typedef void (SteeringSystem::*_fpt)(); auto _f=xcast<_fpt>(_drva(2864640)); (this->*_f)(); }
	inline void init(Car * car) { typedef void (SteeringSystem::*_fpt)(Car *); auto _f=xcast<_fpt>(_drva(2851024)); return (this->*_f)(car); }
	inline void step(float dt) { typedef void (SteeringSystem::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2851248)); return (this->*_f)(dt); }
	inline void _guard_obj() {
		static_assert((sizeof(SteeringSystem)==64),"bad size");
		static_assert((offsetof(SteeringSystem,linearRatio)==0x0),"bad off");
		static_assert((offsetof(SteeringSystem,car)==0x8),"bad off");
		static_assert((offsetof(SteeringSystem,has4ws)==0x10),"bad off");
		static_assert((offsetof(SteeringSystem,ctrl4ws)==0x18),"bad off");
	};
};

//UDT: class MaterialFilter @len=16 @vfcount=2
	//_VTable: 
	//_Func: public void MaterialFilter(const MaterialFilter &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void MaterialFilter(); @loc=static @len=22 @rva=2202928
	//_Func: public void ~MaterialFilter(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=11 @rva=2202960
	//_Func: public void apply(const std::shared_ptr<Material> & material, RenderContext * rc); @intro @virtual vtpo=0 vfid=1 @loc=static @len=51 @rva=2203024
	//_Func: public void resetMaterialCache(); @loc=static @len=9 @rva=2203088
	//_Data: this+0x8, Member, Type: class Material *, lastMaterial
	//_Func: public MaterialFilter & operator=(const MaterialFilter &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class MaterialFilter {
public:
	Material * lastMaterial;
	inline MaterialFilter() { }
	inline MaterialFilter(const MaterialFilter& other) = default;
	inline MaterialFilter& operator=(const MaterialFilter& other) = default;
	inline void ctor() { typedef void (MaterialFilter::*_fpt)(); auto _f=xcast<_fpt>(_drva(2202928)); (this->*_f)(); }
	virtual ~MaterialFilter();
	inline void dtor() { typedef void (MaterialFilter::*_fpt)(); auto _f=xcast<_fpt>(_drva(2202960)); (this->*_f)(); }
	virtual void apply_vf1(const std::shared_ptr<Material> & material, RenderContext * rc);
	inline void apply_impl(const std::shared_ptr<Material> & material, RenderContext * rc) { typedef void (MaterialFilter::*_fpt)(const std::shared_ptr<Material> &, RenderContext *); auto _f=xcast<_fpt>(_drva(2203024)); return (this->*_f)(material, rc); }
	inline void apply(const std::shared_ptr<Material> & material, RenderContext * rc) { typedef void (MaterialFilter::*_fpt)(const std::shared_ptr<Material> &, RenderContext *); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(material, rc); }
	inline void resetMaterialCache() { typedef void (MaterialFilter::*_fpt)(); auto _f=xcast<_fpt>(_drva(2203088)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(MaterialFilter)==16),"bad size");
		static_assert((offsetof(MaterialFilter,lastMaterial)==0x8),"bad off");
	};
};

//UDT: struct AntirollBar @len=72
	//_Func: public void ~AntirollBar(); @loc=static @len=9 @rva=2864640
	//_Data: this+0x0, Member, Type: class IRigidBody *, carBody
	//_Data: this+0x8, Member, Type: class ISuspension *[0x2], hubs
	//_Data: this+0x18, Member, Type: class DynamicController, ctrl
	//_Data: this+0x40, Member, Type: float, k
	//_Func: public void init(IRigidBody * cb, ISuspension * * sus); @loc=static @len=26 @rva=2864656
	//_Func: public void step(float dt); @loc=static @len=699 @rva=2864704
	//_Func: public void AntirollBar(const AntirollBar &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void AntirollBar(); @loc=static @len=41 @rva=2538800
	//_Func: public AntirollBar & operator=(const AntirollBar &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct AntirollBar {
public:
	IRigidBody * carBody;
	ISuspension * hubs[2];
	DynamicController ctrl;
	float k;
	inline AntirollBar() { }
	inline AntirollBar(const AntirollBar& other) = default;
	inline AntirollBar& operator=(const AntirollBar& other) = default;
	inline void dtor() { typedef void (AntirollBar::*_fpt)(); auto _f=xcast<_fpt>(_drva(2864640)); (this->*_f)(); }
	inline void init(IRigidBody * cb, ISuspension * * sus) { typedef void (AntirollBar::*_fpt)(IRigidBody *, ISuspension * *); auto _f=xcast<_fpt>(_drva(2864656)); return (this->*_f)(cb, sus); }
	inline void step(float dt) { typedef void (AntirollBar::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2864704)); return (this->*_f)(dt); }
	inline void ctor() { typedef void (AntirollBar::*_fpt)(); auto _f=xcast<_fpt>(_drva(2538800)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(AntirollBar)==72),"bad size");
		static_assert((offsetof(AntirollBar,carBody)==0x0),"bad off");
		static_assert((offsetof(AntirollBar,hubs)==0x8),"bad off");
		static_assert((offsetof(AntirollBar,ctrl)==0x18),"bad off");
		static_assert((offsetof(AntirollBar,k)==0x40),"bad off");
	};
};

//UDT: class DIControlButton @len=80 @vfcount=3
	//_Base: class DIControlInput @off=0 @len=72
	//_Func: public void DIControlButton(const DIControlButton &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void DIControlButton(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * iname, DirectInput * di); @loc=static @len=184 @rva=531264
	//_Func: public void ~DIControlButton(); @virtual vtpo=0 vfid=0 @loc=static @len=15 @rva=531456
	//_Func: public void load(INIReader & reader, bool loadRange); @virtual vtpo=0 vfid=1 @loc=static @len=558 @rva=531648
	//_Func: public float getValue(bool useRange); @virtual vtpo=0 vfid=2 @loc=static @len=35 @rva=531600
	//_Func: public float getKeyboardValue(bool isKeyboardEnabled); @loc=static @len=51 @rva=531536
	//_Data: this+0x48, Member, Type: bool, combineWithKeyboard
	//_Data: this+0x4C, Member, Type: int, keyboardKey
	//_Func: public DIControlButton & operator=(const DIControlButton &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class DIControlButton : public DIControlInput {
public:
	bool combineWithKeyboard;
	int keyboardKey;
	inline DIControlButton() { }
	inline DIControlButton(const DIControlButton& other) = default;
	inline DIControlButton& operator=(const DIControlButton& other) = default;
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * iname, DirectInput * di) { typedef void (DIControlButton::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, DirectInput *); auto _f=xcast<_fpt>(_drva(531264)); (this->*_f)(iname, di); }
	virtual ~DIControlButton();
	inline void dtor() { typedef void (DIControlButton::*_fpt)(); auto _f=xcast<_fpt>(_drva(531456)); (this->*_f)(); }
	virtual void load_vf1(INIReader & reader, bool loadRange);
	inline void load_impl(INIReader & reader, bool loadRange) { typedef void (DIControlButton::*_fpt)(INIReader &, bool); auto _f=xcast<_fpt>(_drva(531648)); return (this->*_f)(reader, loadRange); }
	inline void load(INIReader & reader, bool loadRange) { typedef void (DIControlButton::*_fpt)(INIReader &, bool); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(reader, loadRange); }
	virtual float getValue_vf2(bool useRange);
	inline float getValue_impl(bool useRange) { typedef float (DIControlButton::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(531600)); return (this->*_f)(useRange); }
	inline float getValue(bool useRange) { typedef float (DIControlButton::*_fpt)(bool); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)(useRange); }
	inline float getKeyboardValue(bool isKeyboardEnabled) { typedef float (DIControlButton::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(531536)); return (this->*_f)(isKeyboardEnabled); }
	inline void _guard_obj() {
		static_assert((sizeof(DIControlButton)==80),"bad size");
		static_assert((offsetof(DIControlButton,combineWithKeyboard)==0x48),"bad off");
		static_assert((offsetof(DIControlButton,keyboardKey)==0x4C),"bad off");
	};
};

//UDT: class KeyboardManager @len=48 @vfcount=1
	//_VTable: 
	//_Func: public void KeyboardManager(const KeyboardManager &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void KeyboardManager(RenderWindow & arenderWindow); @loc=static @len=69 @rva=2372096
	//_Func: public void ~KeyboardManager(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=62 @rva=2372176
	//_Func: public void registerEventHandlers(); @loc=static @len=127 @rva=2375440
	//_Func: public void onKeyDownEvent(const OnKeyEvent & message); @loc=static @len=124 @rva=2374432
	//_Func: public void onKeyPressEvent(const OnKeyCharEvent & message); @loc=static @len=126 @rva=2374560
	//_Func: public void addGodListener(IKeyEventListener * l); @loc=static @len=28 @rva=2373984
	//_Func: public void removeListener(IKeyEventListener *  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void clearListeners(); @loc=optimized @len=0 @rva=0
	//_Func: public void getFocus(IKeyEventListener * l); @loc=static @len=5 @rva=2944432
	//_Func: public void releaseFocus(IKeyEventListener * l); @loc=static @len=15 @rva=2375568
	//_Data: this+0x8, Member, Type: class RenderWindow &, renderWindow
	//_Data: this+0x10, Member, Type: class std::vector<IKeyEventListener *,std::allocator<IKeyEventListener *> >, listeners
	//_Data: this+0x28, Member, Type: class IKeyEventListener *, focusListener
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class KeyboardManager {
public:
	RenderWindow & renderWindow;
	std::vector<IKeyEventListener *,std::allocator<IKeyEventListener *> > listeners;
	IKeyEventListener * focusListener;
	inline KeyboardManager() : renderWindow(*((RenderWindow*)NULL)) { }
	inline KeyboardManager(const KeyboardManager& other) = default;
	inline KeyboardManager& operator=(const KeyboardManager& other) = default;
	inline void ctor(RenderWindow & arenderWindow) { typedef void (KeyboardManager::*_fpt)(RenderWindow &); auto _f=xcast<_fpt>(_drva(2372096)); (this->*_f)(arenderWindow); }
	virtual ~KeyboardManager();
	inline void dtor() { typedef void (KeyboardManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2372176)); (this->*_f)(); }
	inline void registerEventHandlers() { typedef void (KeyboardManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2375440)); return (this->*_f)(); }
	inline void onKeyDownEvent(const OnKeyEvent & message) { typedef void (KeyboardManager::*_fpt)(const OnKeyEvent &); auto _f=xcast<_fpt>(_drva(2374432)); return (this->*_f)(message); }
	inline void onKeyPressEvent(const OnKeyCharEvent & message) { typedef void (KeyboardManager::*_fpt)(const OnKeyCharEvent &); auto _f=xcast<_fpt>(_drva(2374560)); return (this->*_f)(message); }
	inline void addGodListener(IKeyEventListener * l) { typedef void (KeyboardManager::*_fpt)(IKeyEventListener *); auto _f=xcast<_fpt>(_drva(2373984)); return (this->*_f)(l); }
	inline void getFocus(IKeyEventListener * l) { typedef void (KeyboardManager::*_fpt)(IKeyEventListener *); auto _f=xcast<_fpt>(_drva(2944432)); return (this->*_f)(l); }
	inline void releaseFocus(IKeyEventListener * l) { typedef void (KeyboardManager::*_fpt)(IKeyEventListener *); auto _f=xcast<_fpt>(_drva(2375568)); return (this->*_f)(l); }
	inline void _guard_obj() {
		static_assert((sizeof(KeyboardManager)==48),"bad size");
		static_assert((offsetof(KeyboardManager,listeners)==0x10),"bad off");
		static_assert((offsetof(KeyboardManager,focusListener)==0x28),"bad off");
	};
};

//UDT: class DIControlAxis @len=80 @vfcount=3
	//_Base: class DIControlInput @off=0 @len=72
	//_Func: public void DIControlAxis(const DIControlAxis &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void DIControlAxis(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * iname, DirectInput * di); @loc=static @len=177 @rva=530432
	//_Func: public void ~DIControlAxis(); @virtual vtpo=0 vfid=0 @loc=static @len=15 @rva=530624
	//_Func: public void load(INIReader & reader, bool loadRange); @virtual vtpo=0 vfid=1 @loc=static @len=423 @rva=530832
	//_Func: public float getValue(bool useRange); @virtual vtpo=0 vfid=2 @loc=static @len=120 @rva=530704
	//_Data: this+0x48, Member, Type: bool, hasMoved
	//_Func: public DIControlAxis & operator=(const DIControlAxis &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class DIControlAxis : public DIControlInput {
public:
	bool hasMoved;
	inline DIControlAxis() { }
	inline DIControlAxis(const DIControlAxis& other) = default;
	inline DIControlAxis& operator=(const DIControlAxis& other) = default;
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * iname, DirectInput * di) { typedef void (DIControlAxis::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, DirectInput *); auto _f=xcast<_fpt>(_drva(530432)); (this->*_f)(iname, di); }
	virtual ~DIControlAxis();
	inline void dtor() { typedef void (DIControlAxis::*_fpt)(); auto _f=xcast<_fpt>(_drva(530624)); (this->*_f)(); }
	virtual void load_vf1(INIReader & reader, bool loadRange);
	inline void load_impl(INIReader & reader, bool loadRange) { typedef void (DIControlAxis::*_fpt)(INIReader &, bool); auto _f=xcast<_fpt>(_drva(530832)); return (this->*_f)(reader, loadRange); }
	inline void load(INIReader & reader, bool loadRange) { typedef void (DIControlAxis::*_fpt)(INIReader &, bool); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(reader, loadRange); }
	virtual float getValue_vf2(bool useRange);
	inline float getValue_impl(bool useRange) { typedef float (DIControlAxis::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(530704)); return (this->*_f)(useRange); }
	inline float getValue(bool useRange) { typedef float (DIControlAxis::*_fpt)(bool); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)(useRange); }
	inline void _guard_obj() {
		static_assert((sizeof(DIControlAxis)==80),"bad size");
		static_assert((offsetof(DIControlAxis,hasMoved)==0x48),"bad off");
	};
};

//UDT: class PhysicsCarStateProvider @len=16 @vfcount=3
	//_Base: class ICarPhysicsStateProvider @off=0 @len=8
	//_Func: public void PhysicsCarStateProvider(const PhysicsCarStateProvider &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void PhysicsCarStateProvider(Car * car); @loc=static @len=18 @rva=1190384
	//_Func: public void ~PhysicsCarStateProvider(); @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
	//_Func: public void getPhysicsState(CarPhysicsState & physicsState); @virtual vtpo=0 vfid=1 @loc=static @len=9 @rva=1190464
	//_Func: public void getWingState(std::vector<WingState,std::allocator<WingState> > & wingStatus); @virtual vtpo=0 vfid=2 @loc=static @len=9 @rva=1190480
	//_Func: public mat44f getBodyMatrix(); @loc=optimized @len=0 @rva=0
	//_Func: public mat44f getSuspensionMatrix(int  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public mat44f getTyreMatrix(int  _arg0); @loc=optimized @len=0 @rva=0
	//_Data: this+0x8, Member, Type: class Car *, car
	//_Func: public PhysicsCarStateProvider & operator=(const PhysicsCarStateProvider &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class PhysicsCarStateProvider : public ICarPhysicsStateProvider {
public:
	Car * car;
	inline PhysicsCarStateProvider() { }
	inline PhysicsCarStateProvider(const PhysicsCarStateProvider& other) = default;
	inline PhysicsCarStateProvider& operator=(const PhysicsCarStateProvider& other) = default;
	inline void ctor(Car * car) { typedef void (PhysicsCarStateProvider::*_fpt)(Car *); auto _f=xcast<_fpt>(_drva(1190384)); (this->*_f)(car); }
	virtual ~PhysicsCarStateProvider();
	virtual void getPhysicsState_vf1(CarPhysicsState & physicsState);
	inline void getPhysicsState_impl(CarPhysicsState & physicsState) { typedef void (PhysicsCarStateProvider::*_fpt)(CarPhysicsState &); auto _f=xcast<_fpt>(_drva(1190464)); return (this->*_f)(physicsState); }
	inline void getPhysicsState(CarPhysicsState & physicsState) { typedef void (PhysicsCarStateProvider::*_fpt)(CarPhysicsState &); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(physicsState); }
	virtual void getWingState_vf2(std::vector<WingState,std::allocator<WingState> > & wingStatus);
	inline void getWingState_impl(std::vector<WingState,std::allocator<WingState> > & wingStatus) { typedef void (PhysicsCarStateProvider::*_fpt)(std::vector<WingState,std::allocator<WingState> > &); auto _f=xcast<_fpt>(_drva(1190480)); return (this->*_f)(wingStatus); }
	inline void getWingState(std::vector<WingState,std::allocator<WingState> > & wingStatus) { typedef void (PhysicsCarStateProvider::*_fpt)(std::vector<WingState,std::allocator<WingState> > &); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)(wingStatus); }
	inline void _guard_obj() {
		static_assert((sizeof(PhysicsCarStateProvider)==16),"bad size");
		static_assert((offsetof(PhysicsCarStateProvider,car)==0x8),"bad off");
	};
};

//UDT: class Kers @len=248 @vfcount=2
	//_Base: class ITorqueGenerator @off=0 @len=8
	//_Func: public void ~Kers(); @virtual vtpo=0 vfid=0 @loc=static @len=71 @rva=2847200
	//_Data: this+0x8, Member, Type: enum KersAttachment, attachment
	//_Func: public void init(Car * car); @loc=static @len=2718 @rva=2847584
	//_Func: public void step(float dt); @loc=static @len=694 @rva=2850320
	//_Func: public float getOutputTorque(); @virtual vtpo=0 vfid=1 @loc=static @len=166 @rva=2847408
	//_Func: public float getInput(); @loc=optimized @len=0 @rva=0
	//_Func: public bool isPresent(); @loc=static @len=5 @rva=888160
	//_Func: public float getCharge(); @loc=optimized @len=0 @rva=0
	//_Func: public void reset(); @loc=static @len=15 @rva=2850304
	//_Func: public float getCurrentJ(); @loc=optimized @len=0 @rva=0
	//_Func: public float getMaxJ(); @loc=optimized @len=0 @rva=0
	//_Func: public float getDischargeTimeS(); @loc=static @len=22 @rva=2847376
	//_Data: this+0x10, Member, Type: class Car *, car
	//_Data: this+0x18, Member, Type: bool, present
	//_Data: this+0x1C, Member, Type: float, input
	//_Data: this+0x20, Member, Type: float, brakeForMaxCharge
	//_Data: this+0x24, Member, Type: float, charge
	//_Data: this+0x28, Member, Type: float, chargeK
	//_Data: this+0x2C, Member, Type: float, dischargeK
	//_Data: this+0x30, Member, Type: float, angularVelocity
	//_Data: this+0x34, Member, Type: float, negativeInputChargeK
	//_Data: this+0x38, Member, Type: bool, hasButtonOverride
	//_Data: this+0x3C, Member, Type: float, currentJ
	//_Data: this+0x40, Member, Type: float, maxJ
	//_Data: this+0x48, Member, Type: class Curve, torqueLUT
	//_Data: this+0xC8, Member, Type: class DynamicController, controller
	//_Data: this+0xF0, Member, Type: bool, hasController
	//_Func: public void Kers(const Kers &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void Kers(); @loc=optimized @len=0 @rva=0
	//_Func: public Kers & operator=(const Kers &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class Kers : public ITorqueGenerator {
public:
	KersAttachment attachment;
	Car * car;
	bool present;
	float input;
	float brakeForMaxCharge;
	float charge;
	float chargeK;
	float dischargeK;
	float angularVelocity;
	float negativeInputChargeK;
	bool hasButtonOverride;
	float currentJ;
	float maxJ;
	Curve torqueLUT;
	DynamicController controller;
	bool hasController;
	inline Kers() { }
	inline Kers(const Kers& other) = default;
	inline Kers& operator=(const Kers& other) = default;
	virtual ~Kers();
	inline void dtor() { typedef void (Kers::*_fpt)(); auto _f=xcast<_fpt>(_drva(2847200)); (this->*_f)(); }
	inline void init(Car * car) { typedef void (Kers::*_fpt)(Car *); auto _f=xcast<_fpt>(_drva(2847584)); return (this->*_f)(car); }
	inline void step(float dt) { typedef void (Kers::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2850320)); return (this->*_f)(dt); }
	virtual float getOutputTorque_vf1();
	inline float getOutputTorque_impl() { typedef float (Kers::*_fpt)(); auto _f=xcast<_fpt>(_drva(2847408)); return (this->*_f)(); }
	inline float getOutputTorque() { typedef float (Kers::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(); }
	inline bool isPresent() { typedef bool (Kers::*_fpt)(); auto _f=xcast<_fpt>(_drva(888160)); return (this->*_f)(); }
	inline void reset() { typedef void (Kers::*_fpt)(); auto _f=xcast<_fpt>(_drva(2850304)); return (this->*_f)(); }
	inline float getDischargeTimeS() { typedef float (Kers::*_fpt)(); auto _f=xcast<_fpt>(_drva(2847376)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(Kers)==248),"bad size");
		static_assert((offsetof(Kers,attachment)==0x8),"bad off");
		static_assert((offsetof(Kers,car)==0x10),"bad off");
		static_assert((offsetof(Kers,present)==0x18),"bad off");
		static_assert((offsetof(Kers,input)==0x1C),"bad off");
		static_assert((offsetof(Kers,brakeForMaxCharge)==0x20),"bad off");
		static_assert((offsetof(Kers,charge)==0x24),"bad off");
		static_assert((offsetof(Kers,chargeK)==0x28),"bad off");
		static_assert((offsetof(Kers,dischargeK)==0x2C),"bad off");
		static_assert((offsetof(Kers,angularVelocity)==0x30),"bad off");
		static_assert((offsetof(Kers,negativeInputChargeK)==0x34),"bad off");
		static_assert((offsetof(Kers,hasButtonOverride)==0x38),"bad off");
		static_assert((offsetof(Kers,currentJ)==0x3C),"bad off");
		static_assert((offsetof(Kers,maxJ)==0x40),"bad off");
		static_assert((offsetof(Kers,torqueLUT)==0x48),"bad off");
		static_assert((offsetof(Kers,controller)==0xC8),"bad off");
		static_assert((offsetof(Kers,hasController)==0xF0),"bad off");
	};
};

//UDT: class ksgui::Graph @len=440 @vfcount=21
	//_Base: class ksgui::Control @off=0 @len=376
	//_Func: public void Graph(const ksgui_Graph &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void Graph(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * iname, ksgui_GUI * igui); @loc=static @len=193 @rva=2388336
	//_Func: public void ~Graph(); @virtual vtpo=0 vfid=0 @loc=static @len=163 @rva=2388544
	//_Data: this+0x178, Member, Type: float, minY
	//_Data: this+0x17C, Member, Type: float, maxY
	//_Data: this+0x180, Member, Type: unsigned int, maxValuesCount
	//_Data: this+0x184, Member, Type: bool, autoAdjustMaxValue
	//_Func: public void render(float dt); @virtual vtpo=0 vfid=3 @loc=static @len=690 @rva=2390240
	//_Func: public void addSerie(vec3f color); @loc=static @len=221 @rva=2389536
	//_Func: public void addValue(unsigned int serieIndex, float v); @loc=static @len=92 @rva=2389760
	//_Func: public void clearSerie(unsigned int serieIndex); @loc=static @len=66 @rva=2389856
	//_Func: public void addReferenceAxis(const ksgui_GraphReferenceAxis & axis); @loc=static @len=12 @rva=2389520
	//_Func: public int getSeriesCount(); @loc=static @len=19 @rva=2389936
	//_Func: public int getSeriesValuesCount(int  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public float getValuesAtPercentage(int serieIndex, float perc); @loc=static @len=68 @rva=2389968
	//_Func: public float getValuesAt(int  _arg0, int  _arg1); @loc=optimized @len=0 @rva=0
	//_Data: this+0x188, Member, Type: class std::vector<ksgui::ValueSerie *,std::allocator<ksgui::ValueSerie *> >, series
	//_Data: this+0x1A0, Member, Type: class std::vector<ksgui::GraphReferenceAxis,std::allocator<ksgui::GraphReferenceAxis> >, axes
	//_Data: static, [0155A6E0][0003:000476E0], Static Member, Type: class GLRenderer *, localGL
	//_Func: protected void checkMaxValuesCount(); @loc=optimized @len=0 @rva=0
	//_Func: protected void renderAxes(GLRenderer & gl); @loc=static @len=111 @rva=2390944
	//_Func: public ksgui_Graph & operator=(const ksgui_Graph &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ksgui_Graph : public ksgui_Control {
public:
	float minY;
	float maxY;
	unsigned int maxValuesCount;
	bool autoAdjustMaxValue;
	std::vector<ksgui_ValueSerie *,std::allocator<ksgui_ValueSerie *> > series;
	std::vector<ksgui_GraphReferenceAxis,std::allocator<ksgui_GraphReferenceAxis> > axes;
	inline ksgui_Graph() { }
	inline ksgui_Graph(const ksgui_Graph& other) = default;
	inline ksgui_Graph& operator=(const ksgui_Graph& other) = default;
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * iname, ksgui_GUI * igui) { typedef void (ksgui_Graph::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, ksgui_GUI *); auto _f=xcast<_fpt>(_drva(2388336)); (this->*_f)(iname, igui); }
	virtual ~ksgui_Graph();
	inline void dtor() { typedef void (ksgui_Graph::*_fpt)(); auto _f=xcast<_fpt>(_drva(2388544)); (this->*_f)(); }
	virtual void render_vf3(float dt);
	inline void render_impl(float dt) { typedef void (ksgui_Graph::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2390240)); return (this->*_f)(dt); }
	inline void render(float dt) { typedef void (ksgui_Graph::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(dt); }
	inline void addSerie(vec3f color) { typedef void (ksgui_Graph::*_fpt)(vec3f); auto _f=xcast<_fpt>(_drva(2389536)); return (this->*_f)(color); }
	inline void addValue(unsigned int serieIndex, float v) { typedef void (ksgui_Graph::*_fpt)(unsigned int, float); auto _f=xcast<_fpt>(_drva(2389760)); return (this->*_f)(serieIndex, v); }
	inline void clearSerie(unsigned int serieIndex) { typedef void (ksgui_Graph::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(2389856)); return (this->*_f)(serieIndex); }
	inline void addReferenceAxis(const ksgui_GraphReferenceAxis & axis) { typedef void (ksgui_Graph::*_fpt)(const ksgui_GraphReferenceAxis &); auto _f=xcast<_fpt>(_drva(2389520)); return (this->*_f)(axis); }
	inline int getSeriesCount() { typedef int (ksgui_Graph::*_fpt)(); auto _f=xcast<_fpt>(_drva(2389936)); return (this->*_f)(); }
	inline float getValuesAtPercentage(int serieIndex, float perc) { typedef float (ksgui_Graph::*_fpt)(int, float); auto _f=xcast<_fpt>(_drva(2389968)); return (this->*_f)(serieIndex, perc); }
	inline void renderAxes(GLRenderer & gl) { typedef void (ksgui_Graph::*_fpt)(GLRenderer &); auto _f=xcast<_fpt>(_drva(2390944)); return (this->*_f)(gl); }
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_Graph)==440),"bad size");
		static_assert((offsetof(ksgui_Graph,minY)==0x178),"bad off");
		static_assert((offsetof(ksgui_Graph,maxY)==0x17C),"bad off");
		static_assert((offsetof(ksgui_Graph,maxValuesCount)==0x180),"bad off");
		static_assert((offsetof(ksgui_Graph,autoAdjustMaxValue)==0x184),"bad off");
		static_assert((offsetof(ksgui_Graph,series)==0x188),"bad off");
		static_assert((offsetof(ksgui_Graph,axes)==0x1A0),"bad off");
	};
};

//UDT: class AISpline @len=224 @vfcount=1
	//_VTable: 
	//_Func: public void AISpline(const AISpline &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void AISpline(); @loc=static @len=137 @rva=2772336
	//_Func: public void ~AISpline(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=156 @rva=2772480
	//_Data: this+0x8, Member, Type: unsigned int, lapTime
	//_Data: this+0x10, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, filename
	//_Data: this+0x30, Member, Type: int, version
	//_Data: this+0x38, Member, Type: class std::vector<AIStraightData,std::allocator<AIStraightData> >, straights
	//_Func: public InterpolatingSpline & getBaseSpline(); @loc=static @len=5 @rva=460272
	//_Func: public void addPoint(const vec3f & point, const AISplinePayload & payload); @loc=static @len=88 @rva=2773712
	//_Func: public unsigned int pointsCount(); @loc=static @len=9 @rva=2791152
	//_Func: public vec3f getLastPoint(); @loc=static @len=54 @rva=2782192
	//_Func: public void clear(); @loc=static @len=40 @rva=2779984
	//_Func: public vec3f nextPoint(const vec3f &  _arg0, float  _arg1, int &  _arg2); @loc=optimized @len=0 @rva=0
	//_Func: public vec3f nextPoint(unsigned int  _arg0, float  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public AISplinePayload payloadAtSplineIndex(unsigned int index); @loc=static @len=314 @rva=2790832
	//_Func: public AISplinePayload payloadAtPosition(float pos); @loc=static @len=1287 @rva=2789536
	//_Func: public void setPayloadAtSplineIndex(unsigned int index, AISplinePayload pl); @loc=static @len=118 @rva=2792816
	//_Func: public void save(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * filen); @loc=static @len=1181 @rva=2791632
	//_Func: public void load(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & a_filename); @loc=static @len=48 @rva=2786192
	//_Func: public void loadFast(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & a_filename); @loc=static @len=492 @rva=2786240
	//_Func: public void buildSides(IRayTrackCollisionProvider * track); @loc=static @len=2014 @rva=2774576
	//_Func: public void calculateRadius(int range); @loc=static @len=1524 @rva=2778144
	//_Func: public void closeSmooth(); @loc=static @len=36 @rva=2780032
	//_Func: public void adjustPayloadEndpoint(int numberOfPoints); @loc=static @len=749 @rva=2773808
	//_Func: public void printPayloads(); @loc=optimized @len=0 @rva=0
	//_Func: public void buildGrid(); @loc=static @len=9 @rva=2774560
	//_Func: public unsigned int getPayloadsCount(); @loc=optimized @len=0 @rva=0
	//_Func: public void cleanSpline(); @loc=static @len=304 @rva=2779680
	//_Func: public void calculateNormals(IRayTrackCollisionProvider * track); @loc=static @len=1549 @rva=2776592
	//_Func: public vec3f getLanePoint(float  _arg0, float  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public vec3f getPointWithOffset(float pos, float lateralOffset, float carHalfWidth); @loc=static @len=913 @rva=2782560
	//_Func: public vec3f getPointWithOffset(float pos, float lateralOffset, float carHalfWidth, const AISplinePayload & pl); @loc=static @len=281 @rva=2783488
	//_Func: public float getCornerRadiusAt(float normalizedPosition, float distance, float lateralOffset, float carWidth); @loc=static @len=573 @rva=2780080
	//_Func: public float getCornerRadiusAtLane(float  _arg0, float  _arg1, float  _arg2); @loc=optimized @len=0 @rva=0
	//_Func: public void getSlimPayloadAt(float pos, AISplineSlimPayload & pl); @loc=static @len=441 @rva=2783984
	//_Func: public float getDistToCornerFwd(float thresholdRadius, float normalizedSplinePosition, float resolution); @loc=static @len=758 @rva=2780656
	//_Func: public float getDistToCornerRev(float thresholdRadius, float normalizedSplinePosition, float resolution); @loc=static @len=758 @rva=2781424
	//_Func: public void initPitlane(IRayTrackCollisionProvider * track); @loc=static @len=442 @rva=2785136
	//_Func: public bool isRadiusOpening(float  _arg0, float  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public void getSidesAtPos(float pos, float * sides, bool use_blend); @loc=static @len=205 @rva=2783776
	//_Func: public float getStraightFactor(); @loc=static @len=261 @rva=2784864
	//_Func: public int isInStraight(float normalizedPos); @loc=static @len=152 @rva=2786032
	//_Data: this+0x50, Member, Type: class InterpolatingSpline, spline
	//_Data: this+0xC0, Member, Type: class std::vector<AISplinePayload,std::allocator<AISplinePayload> >, payloads
	//_Data: this+0xD8, Member, Type: float, straightFactor
	//_Func: protected void loadVersion6(std::basic_ifstream<char,std::char_traits<char> > & in); @loc=static @len=1473 @rva=2786736
	//_Func: protected void loadVersion7(std::basic_ifstream<char,std::char_traits<char> > & in); @loc=static @len=1306 @rva=2788224
	//_Func: protected void getPayloadIndices(float pos, unsigned int * i0, unsigned int * i1, float * blend); @loc=static @len=302 @rva=2782256
	//_Func: protected void initStraights(float radiusThreshold); @loc=static @len=444 @rva=2785584
	//_Func: protected bool getStraightDataFromIndex(int index, AIStraightData & data, float radiusThreshold); @loc=static @len=430 @rva=2784432
	//_Func: public AISpline & operator=(const AISpline & __that); @loc=static @len=208 @rva=2705440
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class AISpline {
public:
	unsigned int lapTime;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > filename;
	int version;
	std::vector<AIStraightData,std::allocator<AIStraightData> > straights;
	InterpolatingSpline spline;
	std::vector<AISplinePayload,std::allocator<AISplinePayload> > payloads;
	float straightFactor;
	inline AISpline() { }
	inline AISpline(const AISpline& other) = default;
	inline AISpline& operator=(const AISpline& other) = default;
	inline void ctor() { typedef void (AISpline::*_fpt)(); auto _f=xcast<_fpt>(_drva(2772336)); (this->*_f)(); }
	virtual ~AISpline();
	inline void dtor() { typedef void (AISpline::*_fpt)(); auto _f=xcast<_fpt>(_drva(2772480)); (this->*_f)(); }
	inline InterpolatingSpline & getBaseSpline() { typedef InterpolatingSpline & (AISpline::*_fpt)(); auto _f=xcast<_fpt>(_drva(460272)); return (this->*_f)(); }
	inline void addPoint(const vec3f & point, const AISplinePayload & payload) { typedef void (AISpline::*_fpt)(const vec3f &, const AISplinePayload &); auto _f=xcast<_fpt>(_drva(2773712)); return (this->*_f)(point, payload); }
	inline unsigned int pointsCount() { typedef unsigned int (AISpline::*_fpt)(); auto _f=xcast<_fpt>(_drva(2791152)); return (this->*_f)(); }
	inline vec3f getLastPoint() { typedef vec3f (AISpline::*_fpt)(); auto _f=xcast<_fpt>(_drva(2782192)); return (this->*_f)(); }
	inline void clear() { typedef void (AISpline::*_fpt)(); auto _f=xcast<_fpt>(_drva(2779984)); return (this->*_f)(); }
	inline AISplinePayload payloadAtSplineIndex(unsigned int index) { typedef AISplinePayload (AISpline::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(2790832)); return (this->*_f)(index); }
	inline AISplinePayload payloadAtPosition(float pos) { typedef AISplinePayload (AISpline::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2789536)); return (this->*_f)(pos); }
	inline void setPayloadAtSplineIndex(unsigned int index, AISplinePayload pl) { typedef void (AISpline::*_fpt)(unsigned int, AISplinePayload); auto _f=xcast<_fpt>(_drva(2792816)); return (this->*_f)(index, pl); }
	inline void save(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * filen) { typedef void (AISpline::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *); auto _f=xcast<_fpt>(_drva(2791632)); return (this->*_f)(filen); }
	inline void load(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & a_filename) { typedef void (AISpline::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2786192)); return (this->*_f)(a_filename); }
	inline void loadFast(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & a_filename) { typedef void (AISpline::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2786240)); return (this->*_f)(a_filename); }
	inline void buildSides(IRayTrackCollisionProvider * track) { typedef void (AISpline::*_fpt)(IRayTrackCollisionProvider *); auto _f=xcast<_fpt>(_drva(2774576)); return (this->*_f)(track); }
	inline void calculateRadius(int range) { typedef void (AISpline::*_fpt)(int); auto _f=xcast<_fpt>(_drva(2778144)); return (this->*_f)(range); }
	inline void closeSmooth() { typedef void (AISpline::*_fpt)(); auto _f=xcast<_fpt>(_drva(2780032)); return (this->*_f)(); }
	inline void adjustPayloadEndpoint(int numberOfPoints) { typedef void (AISpline::*_fpt)(int); auto _f=xcast<_fpt>(_drva(2773808)); return (this->*_f)(numberOfPoints); }
	inline void buildGrid() { typedef void (AISpline::*_fpt)(); auto _f=xcast<_fpt>(_drva(2774560)); return (this->*_f)(); }
	inline void cleanSpline() { typedef void (AISpline::*_fpt)(); auto _f=xcast<_fpt>(_drva(2779680)); return (this->*_f)(); }
	inline void calculateNormals(IRayTrackCollisionProvider * track) { typedef void (AISpline::*_fpt)(IRayTrackCollisionProvider *); auto _f=xcast<_fpt>(_drva(2776592)); return (this->*_f)(track); }
	inline vec3f getPointWithOffset(float pos, float lateralOffset, float carHalfWidth) { typedef vec3f (AISpline::*_fpt)(float, float, float); auto _f=xcast<_fpt>(_drva(2782560)); return (this->*_f)(pos, lateralOffset, carHalfWidth); }
	inline vec3f getPointWithOffset(float pos, float lateralOffset, float carHalfWidth, const AISplinePayload & pl) { typedef vec3f (AISpline::*_fpt)(float, float, float, const AISplinePayload &); auto _f=xcast<_fpt>(_drva(2783488)); return (this->*_f)(pos, lateralOffset, carHalfWidth, pl); }
	inline float getCornerRadiusAt(float normalizedPosition, float distance, float lateralOffset, float carWidth) { typedef float (AISpline::*_fpt)(float, float, float, float); auto _f=xcast<_fpt>(_drva(2780080)); return (this->*_f)(normalizedPosition, distance, lateralOffset, carWidth); }
	inline void getSlimPayloadAt(float pos, AISplineSlimPayload & pl) { typedef void (AISpline::*_fpt)(float, AISplineSlimPayload &); auto _f=xcast<_fpt>(_drva(2783984)); return (this->*_f)(pos, pl); }
	inline float getDistToCornerFwd(float thresholdRadius, float normalizedSplinePosition, float resolution) { typedef float (AISpline::*_fpt)(float, float, float); auto _f=xcast<_fpt>(_drva(2780656)); return (this->*_f)(thresholdRadius, normalizedSplinePosition, resolution); }
	inline float getDistToCornerRev(float thresholdRadius, float normalizedSplinePosition, float resolution) { typedef float (AISpline::*_fpt)(float, float, float); auto _f=xcast<_fpt>(_drva(2781424)); return (this->*_f)(thresholdRadius, normalizedSplinePosition, resolution); }
	inline void initPitlane(IRayTrackCollisionProvider * track) { typedef void (AISpline::*_fpt)(IRayTrackCollisionProvider *); auto _f=xcast<_fpt>(_drva(2785136)); return (this->*_f)(track); }
	inline void getSidesAtPos(float pos, float * sides, bool use_blend) { typedef void (AISpline::*_fpt)(float, float *, bool); auto _f=xcast<_fpt>(_drva(2783776)); return (this->*_f)(pos, sides, use_blend); }
	inline float getStraightFactor() { typedef float (AISpline::*_fpt)(); auto _f=xcast<_fpt>(_drva(2784864)); return (this->*_f)(); }
	inline int isInStraight(float normalizedPos) { typedef int (AISpline::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2786032)); return (this->*_f)(normalizedPos); }
	inline void loadVersion6(std::basic_ifstream<char,std::char_traits<char> > & in) { typedef void (AISpline::*_fpt)(std::basic_ifstream<char,std::char_traits<char> > &); auto _f=xcast<_fpt>(_drva(2786736)); return (this->*_f)(in); }
	inline void loadVersion7(std::basic_ifstream<char,std::char_traits<char> > & in) { typedef void (AISpline::*_fpt)(std::basic_ifstream<char,std::char_traits<char> > &); auto _f=xcast<_fpt>(_drva(2788224)); return (this->*_f)(in); }
	inline void getPayloadIndices(float pos, unsigned int * i0, unsigned int * i1, float * blend) { typedef void (AISpline::*_fpt)(float, unsigned int *, unsigned int *, float *); auto _f=xcast<_fpt>(_drva(2782256)); return (this->*_f)(pos, i0, i1, blend); }
	inline void initStraights(float radiusThreshold) { typedef void (AISpline::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2785584)); return (this->*_f)(radiusThreshold); }
	inline bool getStraightDataFromIndex(int index, AIStraightData & data, float radiusThreshold) { typedef bool (AISpline::*_fpt)(int, AIStraightData &, float); auto _f=xcast<_fpt>(_drva(2784432)); return (this->*_f)(index, data, radiusThreshold); }
	inline void _guard_obj() {
		static_assert((sizeof(AISpline)==224),"bad size");
		static_assert((offsetof(AISpline,lapTime)==0x8),"bad off");
		static_assert((offsetof(AISpline,filename)==0x10),"bad off");
		static_assert((offsetof(AISpline,version)==0x30),"bad off");
		static_assert((offsetof(AISpline,straights)==0x38),"bad off");
		static_assert((offsetof(AISpline,spline)==0x50),"bad off");
		static_assert((offsetof(AISpline,payloads)==0xC0),"bad off");
		static_assert((offsetof(AISpline,straightFactor)==0xD8),"bad off");
	};
};

//UDT: class Camera @len=528 @vfcount=5
	//_VTable: 
	//_Func: public void Camera(const Camera &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void Camera(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & iname, GraphicsManager * rm); @loc=static @len=521 @rva=2157120
	//_Func: public void ~Camera(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=85 @rva=2157648
	//_Data: this+0x8, Member, Type: float, fov
	//_Data: this+0xC, Member, Type: class mat44f, matrix
	//_Data: this+0x50, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, name
	//_Data: this+0x70, Member, Type: float, nearPlane
	//_Data: this+0x74, Member, Type: float, farPlane
	//_Data: this+0x78, Member, Type: enum eCameraClearMode, clearMode
	//_Data: this+0x7C, Member, Type: enum eAxisRendering, axisRenderingMode
	//_Data: this+0x80, Member, Type: class vec4f, clearColor
	//_Data: this+0x90, Member, Type: float, clearDepth
	//_Data: this+0x98, Member, Type: class SkyBox *, skyBox
	//_Data: this+0xA0, Member, Type: class BoundingFrustum, frustum
	//_Data: this+0x188, Member, Type: class Node *, axis3d
	//_Data: this+0x190, Member, Type: class RenderTarget *, renderTarget
	//_Data: this+0x198, Member, Type: bool, solveTransparentBuffer
	//_Data: this+0x19C, Member, Type: float, exposure
	//_Data: this+0x1A0, Member, Type: float, minExposure
	//_Data: this+0x1A4, Member, Type: float, maxExposure
	//_Data: this+0x1A8, Member, Type: float, aspectRatio
	//_Data: this+0x1AC, Member, Type: float, maxLayer
	//_Data: this+0x1B0, Member, Type: float, dofFactor
	//_Data: this+0x1B4, Member, Type: float, dofFocus
	//_Data: this+0x1B8, Member, Type: float, dofRange
	//_Data: this+0x1BC, Member, Type: bool, isMirror
	//_Data: this+0x1BD, Member, Type: bool, renderAudio
	//_Data: this+0x1C0, Member, Type: float, lodMultiplier
	//_Data: this+0x1C4, Member, Type: bool, isCubeMapCamera
	//_Func: public void render(Node * root, float dt); @intro @virtual vtpo=0 vfid=1 @loc=static @len=500 @rva=2158944
	//_Func: public void setClearColor(float r, float g, float b, float a); @loc=static @len=49 @rva=2161632
	//_Func: public void moveForward(float d); @loc=static @len=75 @rva=2158752
	//_Func: public void moveRight(float d); @loc=static @len=58 @rva=2158832
	//_Func: public void rotatePitch(float rads); @loc=static @len=170 @rva=2161280
	//_Func: public void rotateHeading(float rads); @loc=static @len=176 @rva=2160960
	//_Func: public void rotateRoll(float rads); @loc=static @len=170 @rva=2161456
	//_Func: public void rotateOnAxis(const vec3f & axis, float rads); @loc=static @len=140 @rva=2161136
	//_Func: public void renderCamera(); @loc=static @len=334 @rva=2160080
	//_Func: public void renderCameraCustomPerspective(float left, float right, float top, float bottom); @loc=static @len=540 @rva=2160416
	//_Func: public mat44f getPerspectiveMatrix(); @intro @virtual vtpo=0 vfid=2 @loc=static @len=237 @rva=2158336
	//_Func: public mat44f getViewMatrix(); @intro @virtual vtpo=0 vfid=3 @loc=static @len=174 @rva=2158576
	//_Func: public void moveUpWorld(float d); @loc=static @len=35 @rva=2158896
	//_Func: public mat44f getFinalWorldMatrix(); @intro @virtual vtpo=0 vfid=4 @loc=static @len=35 @rva=2158288
	//_Data: this+0x1C8, Member, Type: class GraphicsManager *, graphics
	//_Data: this+0x1D0, Member, Type: class mat44f, virtualScreenPassOrgMatrix
	//_Func: protected void clearBuffers(); @loc=static @len=98 @rva=2158176
	//_Func: protected void renderAxis(bool useZBuffer); @loc=static @len=615 @rva=2159456
	//_Func: public Camera & operator=(const Camera &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class Camera {
public:
	float fov;
	mat44f matrix;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > name;
	float nearPlane;
	float farPlane;
	eCameraClearMode clearMode;
	eAxisRendering axisRenderingMode;
	vec4f clearColor;
	float clearDepth;
	SkyBox * skyBox;
	BoundingFrustum frustum;
	Node * axis3d;
	RenderTarget * renderTarget;
	bool solveTransparentBuffer;
	float exposure;
	float minExposure;
	float maxExposure;
	float aspectRatio;
	float maxLayer;
	float dofFactor;
	float dofFocus;
	float dofRange;
	bool isMirror;
	bool renderAudio;
	float lodMultiplier;
	bool isCubeMapCamera;
	GraphicsManager * graphics;
	mat44f virtualScreenPassOrgMatrix;
	inline Camera() { }
	inline Camera(const Camera& other) = default;
	inline Camera& operator=(const Camera& other) = default;
	inline void ctor(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & iname, GraphicsManager * rm) { typedef void (Camera::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, GraphicsManager *); auto _f=xcast<_fpt>(_drva(2157120)); (this->*_f)(iname, rm); }
	virtual ~Camera();
	inline void dtor() { typedef void (Camera::*_fpt)(); auto _f=xcast<_fpt>(_drva(2157648)); (this->*_f)(); }
	virtual void render_vf1(Node * root, float dt);
	inline void render_impl(Node * root, float dt) { typedef void (Camera::*_fpt)(Node *, float); auto _f=xcast<_fpt>(_drva(2158944)); return (this->*_f)(root, dt); }
	inline void render(Node * root, float dt) { typedef void (Camera::*_fpt)(Node *, float); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(root, dt); }
	inline void setClearColor(float r, float g, float b, float a) { typedef void (Camera::*_fpt)(float, float, float, float); auto _f=xcast<_fpt>(_drva(2161632)); return (this->*_f)(r, g, b, a); }
	inline void moveForward(float d) { typedef void (Camera::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2158752)); return (this->*_f)(d); }
	inline void moveRight(float d) { typedef void (Camera::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2158832)); return (this->*_f)(d); }
	inline void rotatePitch(float rads) { typedef void (Camera::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2161280)); return (this->*_f)(rads); }
	inline void rotateHeading(float rads) { typedef void (Camera::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2160960)); return (this->*_f)(rads); }
	inline void rotateRoll(float rads) { typedef void (Camera::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2161456)); return (this->*_f)(rads); }
	inline void rotateOnAxis(const vec3f & axis, float rads) { typedef void (Camera::*_fpt)(const vec3f &, float); auto _f=xcast<_fpt>(_drva(2161136)); return (this->*_f)(axis, rads); }
	inline void renderCamera() { typedef void (Camera::*_fpt)(); auto _f=xcast<_fpt>(_drva(2160080)); return (this->*_f)(); }
	inline void renderCameraCustomPerspective(float left, float right, float top, float bottom) { typedef void (Camera::*_fpt)(float, float, float, float); auto _f=xcast<_fpt>(_drva(2160416)); return (this->*_f)(left, right, top, bottom); }
	virtual mat44f getPerspectiveMatrix_vf2();
	inline mat44f getPerspectiveMatrix_impl() { typedef mat44f (Camera::*_fpt)(); auto _f=xcast<_fpt>(_drva(2158336)); return (this->*_f)(); }
	inline mat44f getPerspectiveMatrix() { typedef mat44f (Camera::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)(); }
	virtual mat44f getViewMatrix_vf3();
	inline mat44f getViewMatrix_impl() { typedef mat44f (Camera::*_fpt)(); auto _f=xcast<_fpt>(_drva(2158576)); return (this->*_f)(); }
	inline mat44f getViewMatrix() { typedef mat44f (Camera::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(); }
	inline void moveUpWorld(float d) { typedef void (Camera::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2158896)); return (this->*_f)(d); }
	virtual mat44f getFinalWorldMatrix_vf4();
	inline mat44f getFinalWorldMatrix_impl() { typedef mat44f (Camera::*_fpt)(); auto _f=xcast<_fpt>(_drva(2158288)); return (this->*_f)(); }
	inline mat44f getFinalWorldMatrix() { typedef mat44f (Camera::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 4)); return (this->*_f)(); }
	inline void clearBuffers() { typedef void (Camera::*_fpt)(); auto _f=xcast<_fpt>(_drva(2158176)); return (this->*_f)(); }
	inline void renderAxis(bool useZBuffer) { typedef void (Camera::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(2159456)); return (this->*_f)(useZBuffer); }
	inline void _guard_obj() {
		static_assert((sizeof(Camera)==528),"bad size");
		static_assert((offsetof(Camera,fov)==0x8),"bad off");
		static_assert((offsetof(Camera,matrix)==0xC),"bad off");
		static_assert((offsetof(Camera,name)==0x50),"bad off");
		static_assert((offsetof(Camera,nearPlane)==0x70),"bad off");
		static_assert((offsetof(Camera,farPlane)==0x74),"bad off");
		static_assert((offsetof(Camera,clearMode)==0x78),"bad off");
		static_assert((offsetof(Camera,axisRenderingMode)==0x7C),"bad off");
		static_assert((offsetof(Camera,clearColor)==0x80),"bad off");
		static_assert((offsetof(Camera,clearDepth)==0x90),"bad off");
		static_assert((offsetof(Camera,skyBox)==0x98),"bad off");
		static_assert((offsetof(Camera,frustum)==0xA0),"bad off");
		static_assert((offsetof(Camera,axis3d)==0x188),"bad off");
		static_assert((offsetof(Camera,renderTarget)==0x190),"bad off");
		static_assert((offsetof(Camera,solveTransparentBuffer)==0x198),"bad off");
		static_assert((offsetof(Camera,exposure)==0x19C),"bad off");
		static_assert((offsetof(Camera,minExposure)==0x1A0),"bad off");
		static_assert((offsetof(Camera,maxExposure)==0x1A4),"bad off");
		static_assert((offsetof(Camera,aspectRatio)==0x1A8),"bad off");
		static_assert((offsetof(Camera,maxLayer)==0x1AC),"bad off");
		static_assert((offsetof(Camera,dofFactor)==0x1B0),"bad off");
		static_assert((offsetof(Camera,dofFocus)==0x1B4),"bad off");
		static_assert((offsetof(Camera,dofRange)==0x1B8),"bad off");
		static_assert((offsetof(Camera,isMirror)==0x1BC),"bad off");
		static_assert((offsetof(Camera,renderAudio)==0x1BD),"bad off");
		static_assert((offsetof(Camera,lodMultiplier)==0x1C0),"bad off");
		static_assert((offsetof(Camera,isCubeMapCamera)==0x1C4),"bad off");
		static_assert((offsetof(Camera,graphics)==0x1C8),"bad off");
		static_assert((offsetof(Camera,virtualScreenPassOrgMatrix)==0x1D0),"bad off");
	};
};

//UDT: class RaceEngineer @len=24 @vfcount=1
	//_VTable: 
	//_Func: public void RaceEngineer(const RaceEngineer &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void RaceEngineer(Car * icar); @loc=static @len=25 @rva=2595824
	//_Func: public void ~RaceEngineer(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=11 @rva=2595856
	//_Func: public float getCompoundDY(const TyreCompoundDef & def, float load); @pure @loc=static @len=45 @rva=2604016
	//_Func: public float projectCarForwardForceAtGas(float gas); @loc=static @len=196 @rva=2608160
	//_Func: public AccelerationProfile getAccelerationProfile(); @loc=static @len=445 @rva=2602320
	//_Func: public Car * getCar(); @loc=static @len=5 @rva=100256
	//_Func: public float getBetaRAD(); @loc=static @len=132 @rva=2603664
	//_Func: public float getUndersteerFactor(); @loc=optimized @len=0 @rva=0
	//_Func: public float getFrontCasterRAD(); @loc=static @len=19 @rva=2604352
	//_Func: public float getCasterRAD(ISuspension * isus); @loc=static @len=204 @rva=2603808
	//_Func: public void getToeInRAD(float *  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public float getFrontNaturalFrequencyHZ(); @loc=static @len=229 @rva=2604832
	//_Func: public float getRearNaturalFrequencyHZ(); @loc=static @len=231 @rva=2607344
	//_Func: public float getNaturalFrequencyHZ(float  _arg0, float  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public float getWeightDistribution(); @loc=static @len=136 @rva=2608016
	//_Func: public float getDampingRatio(float  _arg0, float  _arg1, float  _arg2); @loc=optimized @len=0 @rva=0
	//_Func: public std::tuple<float,float> getFrontDampingRatio(); @loc=static @len=443 @rva=2604384
	//_Func: public std::tuple<float,float> getRearDampingRatio(); @loc=static @len=539 @rva=2606800
	//_Func: public float evalLateralGrip(float speed, float mass, float aeroModifier, float * in_loads, float current_lift_kg); @loc=static @len=823 @rva=2598160
	//_Func: public float getPointGroundHeight(const vec3f & p); @loc=static @len=371 @rva=2606416
	//_Func: public float getPointFrontShare(vec3f & p); @loc=static @len=127 @rva=2606288
	//_Func: public float projectWingLift(Wing *  _arg0, float  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public float projectWingDrag(Wing *  _arg0, float  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public float projectWingsLift(float speed); @loc=static @len=180 @rva=2608576
	//_Func: public float projectWingsDrag(float speed); @loc=static @len=200 @rva=2608368
	//_Func: public int getIdealGear(float  _arg0, int  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public float getLookAheadBraking(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public float getTorqueToGripRatio(); @loc=static @len=277 @rva=2607712
	//_Func: public Tyre * getLeftDrivenTyre(); @loc=static @len=33 @rva=2605504
	//_Func: public Tyre * getRightDrivenTyre(); @loc=static @len=33 @rva=2607664
	//_Func: public float getFrontTrack(); @loc=static @len=66 @rva=2605072
	//_Func: public float getRearTrack(); @loc=static @len=67 @rva=2607584
	//_Func: public float getDynamicIndex(); @loc=static @len=216 @rva=2604128
	//_Func: public float getTractionMaxSlipRatio(); @loc=optimized @len=0 @rva=0
	//_Func: public float getOptimalBrake(); @loc=static @len=427 @rva=2605856
	//_Func: public float getDrivingTyresSlip(); @loc=static @len=56 @rva=2604064
	//_Func: public float getMaxBrakingForce(); @loc=static @len=78 @rva=2605552
	//_Func: public float getBaseCarHeight(); @loc=static @len=136 @rva=2603520
	//_Func: public Speed getMaxSpeedFromGear(unsigned int relativeCarIndex); @loc=static @len=221 @rva=2605632
	//_Func: public float evalAvailableBrake(float speed, float latg, float weight); @loc=static @len=415 @rva=2596688
	//_Func: public float evalFrontRideHeight(); @loc=static @len=365 @rva=2597104
	//_Func: public float evalRearRideHeight(); @loc=static @len=372 @rva=2598992
	//_Func: public float evalRideHeight(int index); @loc=static @len=13 @rva=2599376
	//_Func: public float projectFrontWeight(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public float getFrontWheelbase(); @loc=optimized @len=0 @rva=0
	//_Func: public float evaluateFuelPerLapFromTrackSpline(); @loc=static @len=1846 @rva=2600032
	//_Func: public int findTyreCompound(FindTyreCompoundLogic logic); @loc=static @len=421 @rva=2601888
	//_Func: public WheelValues evalTyreLoad(float speedMS, float latg, float longg); @loc=static @len=625 @rva=2599392
	//_Func: public float getWheelbase(); @loc=optimized @len=0 @rva=0
	//_Func: public KPI getKPI_RAD(int index); @loc=static @len=347 @rva=2605152
	//_Func: public float getCurrentLateralGrip(float  _arg0, const float *  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public bool shouldChangeUp(); @loc=optimized @len=0 @rva=0
	//_Func: public float getAntiSquat(); @loc=static @len=745 @rva=2602768
	//_Data: this+0x8, Member, Type: class Car *, car
	//_Data: this+0x10, Member, Type: float, fuelPerLapEvaluated
	//_Data: static, [0155A888][0003:00047888], Static Member, Type: class std::unique_ptr<AISpline,std::default_delete<AISpline> >, trackSpline
	//_Func: protected float evalLateralGFromLoads(float speed, float aeroRatio, float mass, const float * loads); @loc=static @len=680 @rva=2597472
	//_Func: public RaceEngineer & operator=(const RaceEngineer &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class RaceEngineer {
public:
	Car * car;
	float fuelPerLapEvaluated;
	inline RaceEngineer() { }
	inline RaceEngineer(const RaceEngineer& other) = default;
	inline RaceEngineer& operator=(const RaceEngineer& other) = default;
	inline void ctor(Car * icar) { typedef void (RaceEngineer::*_fpt)(Car *); auto _f=xcast<_fpt>(_drva(2595824)); (this->*_f)(icar); }
	virtual ~RaceEngineer();
	inline void dtor() { typedef void (RaceEngineer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2595856)); (this->*_f)(); }
	inline static float getCompoundDY(const TyreCompoundDef & def, float load) { typedef float (*_fpt)(const TyreCompoundDef &, float); auto _f=(_fpt)_drva(2604016); return _f(def, load); }
	inline float projectCarForwardForceAtGas(float gas) { typedef float (RaceEngineer::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2608160)); return (this->*_f)(gas); }
	inline AccelerationProfile getAccelerationProfile() { typedef AccelerationProfile (RaceEngineer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2602320)); return (this->*_f)(); }
	inline Car * getCar() { typedef Car * (RaceEngineer::*_fpt)(); auto _f=xcast<_fpt>(_drva(100256)); return (this->*_f)(); }
	inline float getBetaRAD() { typedef float (RaceEngineer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2603664)); return (this->*_f)(); }
	inline float getFrontCasterRAD() { typedef float (RaceEngineer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2604352)); return (this->*_f)(); }
	inline float getCasterRAD(ISuspension * isus) { typedef float (RaceEngineer::*_fpt)(ISuspension *); auto _f=xcast<_fpt>(_drva(2603808)); return (this->*_f)(isus); }
	inline float getFrontNaturalFrequencyHZ() { typedef float (RaceEngineer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2604832)); return (this->*_f)(); }
	inline float getRearNaturalFrequencyHZ() { typedef float (RaceEngineer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2607344)); return (this->*_f)(); }
	inline float getWeightDistribution() { typedef float (RaceEngineer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2608016)); return (this->*_f)(); }
	inline std::tuple<float,float> getFrontDampingRatio() { typedef std::tuple<float,float> (RaceEngineer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2604384)); return (this->*_f)(); }
	inline std::tuple<float,float> getRearDampingRatio() { typedef std::tuple<float,float> (RaceEngineer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2606800)); return (this->*_f)(); }
	inline float evalLateralGrip(float speed, float mass, float aeroModifier, float * in_loads, float current_lift_kg) { typedef float (RaceEngineer::*_fpt)(float, float, float, float *, float); auto _f=xcast<_fpt>(_drva(2598160)); return (this->*_f)(speed, mass, aeroModifier, in_loads, current_lift_kg); }
	inline float getPointGroundHeight(const vec3f & p) { typedef float (RaceEngineer::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2606416)); return (this->*_f)(p); }
	inline float getPointFrontShare(vec3f & p) { typedef float (RaceEngineer::*_fpt)(vec3f &); auto _f=xcast<_fpt>(_drva(2606288)); return (this->*_f)(p); }
	inline float projectWingsLift(float speed) { typedef float (RaceEngineer::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2608576)); return (this->*_f)(speed); }
	inline float projectWingsDrag(float speed) { typedef float (RaceEngineer::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2608368)); return (this->*_f)(speed); }
	inline float getTorqueToGripRatio() { typedef float (RaceEngineer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2607712)); return (this->*_f)(); }
	inline Tyre * getLeftDrivenTyre() { typedef Tyre * (RaceEngineer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2605504)); return (this->*_f)(); }
	inline Tyre * getRightDrivenTyre() { typedef Tyre * (RaceEngineer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2607664)); return (this->*_f)(); }
	inline float getFrontTrack() { typedef float (RaceEngineer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2605072)); return (this->*_f)(); }
	inline float getRearTrack() { typedef float (RaceEngineer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2607584)); return (this->*_f)(); }
	inline float getDynamicIndex() { typedef float (RaceEngineer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2604128)); return (this->*_f)(); }
	inline float getOptimalBrake() { typedef float (RaceEngineer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2605856)); return (this->*_f)(); }
	inline float getDrivingTyresSlip() { typedef float (RaceEngineer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2604064)); return (this->*_f)(); }
	inline float getMaxBrakingForce() { typedef float (RaceEngineer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2605552)); return (this->*_f)(); }
	inline float getBaseCarHeight() { typedef float (RaceEngineer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2603520)); return (this->*_f)(); }
	inline Speed getMaxSpeedFromGear(unsigned int relativeCarIndex) { typedef Speed (RaceEngineer::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(2605632)); return (this->*_f)(relativeCarIndex); }
	inline float evalAvailableBrake(float speed, float latg, float weight) { typedef float (RaceEngineer::*_fpt)(float, float, float); auto _f=xcast<_fpt>(_drva(2596688)); return (this->*_f)(speed, latg, weight); }
	inline float evalFrontRideHeight() { typedef float (RaceEngineer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2597104)); return (this->*_f)(); }
	inline float evalRearRideHeight() { typedef float (RaceEngineer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2598992)); return (this->*_f)(); }
	inline float evalRideHeight(int index) { typedef float (RaceEngineer::*_fpt)(int); auto _f=xcast<_fpt>(_drva(2599376)); return (this->*_f)(index); }
	inline float evaluateFuelPerLapFromTrackSpline() { typedef float (RaceEngineer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2600032)); return (this->*_f)(); }
	inline int findTyreCompound(FindTyreCompoundLogic logic) { typedef int (RaceEngineer::*_fpt)(FindTyreCompoundLogic); auto _f=xcast<_fpt>(_drva(2601888)); return (this->*_f)(logic); }
	inline WheelValues evalTyreLoad(float speedMS, float latg, float longg) { typedef WheelValues (RaceEngineer::*_fpt)(float, float, float); auto _f=xcast<_fpt>(_drva(2599392)); return (this->*_f)(speedMS, latg, longg); }
	inline KPI getKPI_RAD(int index) { typedef KPI (RaceEngineer::*_fpt)(int); auto _f=xcast<_fpt>(_drva(2605152)); return (this->*_f)(index); }
	inline float getAntiSquat() { typedef float (RaceEngineer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2602768)); return (this->*_f)(); }
	inline float evalLateralGFromLoads(float speed, float aeroRatio, float mass, const float * loads) { typedef float (RaceEngineer::*_fpt)(float, float, float, const float *); auto _f=xcast<_fpt>(_drva(2597472)); return (this->*_f)(speed, aeroRatio, mass, loads); }
	inline void _guard_obj() {
		static_assert((sizeof(RaceEngineer)==24),"bad size");
		static_assert((offsetof(RaceEngineer,car)==0x8),"bad off");
		static_assert((offsetof(RaceEngineer,fuelPerLapEvaluated)==0x10),"bad off");
	};
};

//UDT: struct Tyre @len=2136
	//_Func: public void ~Tyre(); @loc=static @len=262 @rva=2609952
	//_Data: this+0x0, Member, Type: struct TyreInputs, inputs
	//_Data: this+0xC, Member, Type: struct TyreData, data
	//_Data: this+0x58, Member, Type: struct TyreModelData, modelData
	//_Data: this+0x2E8, Member, Type: struct TyreStatus, status
	//_Data: this+0x3A0, Member, Type: class ISuspension *, hub
	//_Data: this+0x3A8, Member, Type: class mat44f, worldRotation
	//_Data: this+0x3E8, Member, Type: class vec3f, unmodifiedContactPoint
	//_Data: this+0x3F4, Member, Type: class vec3f, contactPoint
	//_Data: this+0x400, Member, Type: class vec3f, contactNormal
	//_Data: this+0x410, Member, Type: struct SurfaceDef *, surfaceDef
	//_Data: this+0x418, Member, Type: bool, debugOutput
	//_Data: this+0x41C, Member, Type: float, absOverride
	//_Data: this+0x420, Member, Type: struct TyreThermalModel, thermalModel
	//_Data: this+0x500, Member, Type: class std::vector<TyreCompoundDef,std::allocator<TyreCompoundDef> >, compoundDefs
	//_Data: this+0x518, Member, Type: class std::function<void __cdecl(void)>, onStepCompleted
	//_Data: this+0x538, Member, Type: float, aiMult
	//_Data: this+0x540, Member, Type: class BrushSlipProvider, slipProvider
	//_Data: this+0x578, Member, Type: struct TyreExternalInputs, externalInputs
	//_Data: this+0x588, Member, Type: class vec3f, roadRight
	//_Data: this+0x594, Member, Type: class vec3f, roadHeading
	//_Data: this+0x5A0, Member, Type: bool, useLoadForVKM
	//_Data: this+0x5A1, Member, Type: bool, driven
	//_Func: public float loadSensLinearD(float d0, float d1, float load); @pure @loc=static @len=20 @rva=2634368
	//_Func: public float loadSensExpD(float exp, float mult, float load); @pure @loc=static @len=62 @rva=2634304
	//_Func: public void init(ISuspension * ihub, IRayTrackCollisionProvider * rcp, std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * dataPath, int index, int carID, Car * car); @loc=static @len=422 @rva=2623056
	//_Func: public void step(float dt); @loc=static @len=3011 @rva=2635776
	//_Func: public mat44f getFinalTyreRotation(); @loc=static @len=152 @rva=2622864
	//_Func: public void stepRotationMatrix(float dt); @loc=static @len=284 @rva=2640768
	//_Func: public void reset(); @loc=static @len=350 @rva=2634624
	//_Func: public vec3f getRoadRight(); @loc=optimized @len=0 @rva=0
	//_Func: public vec3f getRoadHeading(); @loc=optimized @len=0 @rva=0
	//_Func: public vec3f getWorldPosition(); @loc=static @len=25 @rva=2623024
	//_Func: public float getDYWithExp(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public float getDXWithExp(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public float getDY(float load); @loc=static @len=385 @rva=2622416
	//_Func: public float getDX(float load); @loc=static @len=393 @rva=2622016
	//_Func: public bool setCompound(int cindex); @loc=static @len=786 @rva=2634976
	//_Func: public int getCompound(); @loc=optimized @len=0 @rva=0
	//_Func: public float getDynamicK(); @loc=static @len=41 @rva=2622816
	//_Func: public float getFxFyRatio(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public float getCorrectedD(float d, float * wear_mult); @loc=static @len=169 @rva=2621840
	//_Func: public float getLiveRadius(); @loc=optimized @len=0 @rva=0
	//_Func: public float getCamberedDy(float camberRAD, float dy); @loc=static @len=174 @rva=2621568
	//_Data: this+0x5A8, Member, Type: class IRayTrackCollisionProvider *, rayCollisionProvider
	//_Data: this+0x5B0, Member, Type: float, oldAngularVelocity
	//_Data: this+0x5B4, Member, Type: float, totalSlideVelocity
	//_Data: this+0x5B8, Member, Type: class mat44f, localWheelRotation
	//_Data: this+0x5F8, Member, Type: class vec3f, worldPosition
	//_Data: this+0x604, Member, Type: float, slidingVelocityY
	//_Data: this+0x608, Member, Type: float, slidingVelocityX
	//_Data: this+0x60C, Member, Type: float, roadVelocityX
	//_Data: this+0x610, Member, Type: float, roadVelocityY
	//_Data: this+0x614, Member, Type: float, totalHubVelocity
	//_Data: this+0x618, Member, Type: float, rSlidingVelocityX
	//_Data: this+0x61C, Member, Type: float, rSlidingVelocityY
	//_Data: this+0x620, Member, Type: class IRayCaster *, rayCaster
	//_Data: this+0x628, Member, Type: int, index
	//_Data: this+0x630, Member, Type: class SinSignalGenerator, shakeGenerator
	//_Data: this+0x640, Member, Type: class Car *, car
	//_Data: this+0x648, Member, Type: int, currentCompoundIndex
	//_Data: this+0x64C, Member, Type: bool, tyreBlanketsOn
	//_Data: this+0x650, Member, Type: const float, flatSpotK
	//_Data: this+0x658, Member, Type: class ITyreModel *, tyreModel
	//_Data: this+0x660, Member, Type: class SCTM, scTM
	//_Data: this+0x848, Member, Type: float, explosionTemperature
	//_Data: this+0x84C, Member, Type: float, blanketTemperature
	//_Data: this+0x850, Member, Type: float, pressureTemperatureGain
	//_Data: this+0x854, Member, Type: float, localMX
	//_Func: protected void addGroundContact(const vec3f & pos, const vec3f & normal); @loc=static @len=634 @rva=2611584
	//_Func: protected void addTyreForces(const vec3f & pos, const vec3f & normal, SurfaceDef * surfaceDef, float dt); @loc=static @len=3000 @rva=2613664
	//_Func: protected void addTyreForcesV10(const vec3f & pos, const vec3f & normal, SurfaceDef * surfaceDef, float dt); @loc=static @len=2554 @rva=2616672
	//_Func: protected void updateAngularSpeed(float dt); @loc=static @len=206 @rva=2641824
	//_Func: protected void updateLockedState(float dt); @loc=static @len=119 @rva=2642032
	//_Func: protected void stepRelaxationLength(float svx, float svy, float hubVelocity, float dt); @loc=static @len=320 @rva=2640448
	//_Func: protected void stepDirtyLevel(float dt, float hubSpeed); @loc=static @len=293 @rva=2638800
	//_Func: protected void stepThermalModel(float dt); @loc=static @len=609 @rva=2641056
	//_Func: protected float similarityF(float  _arg0, float  _arg1, float  _arg2, float  _arg3, float  _arg4); @loc=optimized @len=0 @rva=0
	//_Func: protected void initCompounds(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & dataPath, int index); @loc=static @len=10809 @rva=2623488
	//_Func: protected void stepGrainBlister(float dt, float hubVelocity); @loc=static @len=937 @rva=2639360
	//_Func: protected void stepPuncture(float dt, float hubSpeed); @loc=static @len=142 @rva=2640304
	//_Func: protected void stepTyreBlankets(float dt); @loc=static @len=132 @rva=2641680
	//_Func: protected void stepFlatSpot(float dt, float hubVelocity); @loc=static @len=243 @rva=2639104
	//_Func: protected bool generateCompoundNames(); @loc=static @len=2260 @rva=2619296
	//_Func: protected void rayCast(const vec3f &  _arg0, const vec3f &  _arg1, RayCastResult *  _arg2); @loc=optimized @len=0 @rva=0
	//_Func: protected void addTyreForceToHub(const vec3f & pos, const vec3f & force); @loc=static @len=1439 @rva=2612224
	//_Func: public void Tyre(const Tyre &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void Tyre(); @loc=static @len=639 @rva=2546640
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct Tyre {
public:
	TyreInputs inputs;
	TyreData data;
	TyreModelData modelData;
	TyreStatus status;
	ISuspension * hub;
	mat44f worldRotation;
	vec3f unmodifiedContactPoint;
	vec3f contactPoint;
	vec3f contactNormal;
	SurfaceDef * surfaceDef;
	bool debugOutput;
	float absOverride;
	TyreThermalModel thermalModel;
	std::vector<TyreCompoundDef,std::allocator<TyreCompoundDef> > compoundDefs;
	std::function<void __cdecl(void)> onStepCompleted;
	float aiMult;
	BrushSlipProvider slipProvider;
	TyreExternalInputs externalInputs;
	vec3f roadRight;
	vec3f roadHeading;
	bool useLoadForVKM;
	bool driven;
	IRayTrackCollisionProvider * rayCollisionProvider;
	float oldAngularVelocity;
	float totalSlideVelocity;
	mat44f localWheelRotation;
	vec3f worldPosition;
	float slidingVelocityY;
	float slidingVelocityX;
	float roadVelocityX;
	float roadVelocityY;
	float totalHubVelocity;
	float rSlidingVelocityX;
	float rSlidingVelocityY;
	IRayCaster * rayCaster;
	int index;
	SinSignalGenerator shakeGenerator;
	Car * car;
	int currentCompoundIndex;
	bool tyreBlanketsOn;
	float flatSpotK;
	ITyreModel * tyreModel;
	SCTM scTM;
	float explosionTemperature;
	float blanketTemperature;
	float pressureTemperatureGain;
	float localMX;
	inline Tyre() { }
	inline Tyre(const Tyre& other) = default;
	inline Tyre& operator=(const Tyre& other) = default;
	inline void dtor() { typedef void (Tyre::*_fpt)(); auto _f=xcast<_fpt>(_drva(2609952)); (this->*_f)(); }
	inline static float loadSensLinearD(float d0, float d1, float load) { typedef float (*_fpt)(float, float, float); auto _f=(_fpt)_drva(2634368); return _f(d0, d1, load); }
	inline static float loadSensExpD(float exp, float mult, float load) { typedef float (*_fpt)(float, float, float); auto _f=(_fpt)_drva(2634304); return _f(exp, mult, load); }
	inline void init(ISuspension * ihub, IRayTrackCollisionProvider * rcp, std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * dataPath, int index, int carID, Car * car) { typedef void (Tyre::*_fpt)(ISuspension *, IRayTrackCollisionProvider *, std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, int, int, Car *); auto _f=xcast<_fpt>(_drva(2623056)); return (this->*_f)(ihub, rcp, dataPath, index, carID, car); }
	inline void step(float dt) { typedef void (Tyre::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2635776)); return (this->*_f)(dt); }
	inline mat44f getFinalTyreRotation() { typedef mat44f (Tyre::*_fpt)(); auto _f=xcast<_fpt>(_drva(2622864)); return (this->*_f)(); }
	inline void stepRotationMatrix(float dt) { typedef void (Tyre::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2640768)); return (this->*_f)(dt); }
	inline void reset() { typedef void (Tyre::*_fpt)(); auto _f=xcast<_fpt>(_drva(2634624)); return (this->*_f)(); }
	inline vec3f getWorldPosition() { typedef vec3f (Tyre::*_fpt)(); auto _f=xcast<_fpt>(_drva(2623024)); return (this->*_f)(); }
	inline float getDY(float load) { typedef float (Tyre::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2622416)); return (this->*_f)(load); }
	inline float getDX(float load) { typedef float (Tyre::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2622016)); return (this->*_f)(load); }
	inline bool setCompound(int cindex) { typedef bool (Tyre::*_fpt)(int); auto _f=xcast<_fpt>(_drva(2634976)); return (this->*_f)(cindex); }
	inline float getDynamicK() { typedef float (Tyre::*_fpt)(); auto _f=xcast<_fpt>(_drva(2622816)); return (this->*_f)(); }
	inline float getCorrectedD(float d, float * wear_mult) { typedef float (Tyre::*_fpt)(float, float *); auto _f=xcast<_fpt>(_drva(2621840)); return (this->*_f)(d, wear_mult); }
	inline float getCamberedDy(float camberRAD, float dy) { typedef float (Tyre::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2621568)); return (this->*_f)(camberRAD, dy); }
	inline void addGroundContact(const vec3f & pos, const vec3f & normal) { typedef void (Tyre::*_fpt)(const vec3f &, const vec3f &); auto _f=xcast<_fpt>(_drva(2611584)); return (this->*_f)(pos, normal); }
	inline void addTyreForces(const vec3f & pos, const vec3f & normal, SurfaceDef * surfaceDef, float dt) { typedef void (Tyre::*_fpt)(const vec3f &, const vec3f &, SurfaceDef *, float); auto _f=xcast<_fpt>(_drva(2613664)); return (this->*_f)(pos, normal, surfaceDef, dt); }
	inline void addTyreForcesV10(const vec3f & pos, const vec3f & normal, SurfaceDef * surfaceDef, float dt) { typedef void (Tyre::*_fpt)(const vec3f &, const vec3f &, SurfaceDef *, float); auto _f=xcast<_fpt>(_drva(2616672)); return (this->*_f)(pos, normal, surfaceDef, dt); }
	inline void updateAngularSpeed(float dt) { typedef void (Tyre::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2641824)); return (this->*_f)(dt); }
	inline void updateLockedState(float dt) { typedef void (Tyre::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2642032)); return (this->*_f)(dt); }
	inline void stepRelaxationLength(float svx, float svy, float hubVelocity, float dt) { typedef void (Tyre::*_fpt)(float, float, float, float); auto _f=xcast<_fpt>(_drva(2640448)); return (this->*_f)(svx, svy, hubVelocity, dt); }
	inline void stepDirtyLevel(float dt, float hubSpeed) { typedef void (Tyre::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2638800)); return (this->*_f)(dt, hubSpeed); }
	inline void stepThermalModel(float dt) { typedef void (Tyre::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2641056)); return (this->*_f)(dt); }
	inline void initCompounds(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & dataPath, int index) { typedef void (Tyre::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, int); auto _f=xcast<_fpt>(_drva(2623488)); return (this->*_f)(dataPath, index); }
	inline void stepGrainBlister(float dt, float hubVelocity) { typedef void (Tyre::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2639360)); return (this->*_f)(dt, hubVelocity); }
	inline void stepPuncture(float dt, float hubSpeed) { typedef void (Tyre::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2640304)); return (this->*_f)(dt, hubSpeed); }
	inline void stepTyreBlankets(float dt) { typedef void (Tyre::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2641680)); return (this->*_f)(dt); }
	inline void stepFlatSpot(float dt, float hubVelocity) { typedef void (Tyre::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2639104)); return (this->*_f)(dt, hubVelocity); }
	inline bool generateCompoundNames() { typedef bool (Tyre::*_fpt)(); auto _f=xcast<_fpt>(_drva(2619296)); return (this->*_f)(); }
	inline void addTyreForceToHub(const vec3f & pos, const vec3f & force) { typedef void (Tyre::*_fpt)(const vec3f &, const vec3f &); auto _f=xcast<_fpt>(_drva(2612224)); return (this->*_f)(pos, force); }
	inline void ctor() { typedef void (Tyre::*_fpt)(); auto _f=xcast<_fpt>(_drva(2546640)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(Tyre)==2136),"bad size");
		static_assert((offsetof(Tyre,inputs)==0x0),"bad off");
		static_assert((offsetof(Tyre,data)==0xC),"bad off");
		static_assert((offsetof(Tyre,modelData)==0x58),"bad off");
		static_assert((offsetof(Tyre,status)==0x2E8),"bad off");
		static_assert((offsetof(Tyre,hub)==0x3A0),"bad off");
		static_assert((offsetof(Tyre,worldRotation)==0x3A8),"bad off");
		static_assert((offsetof(Tyre,unmodifiedContactPoint)==0x3E8),"bad off");
		static_assert((offsetof(Tyre,contactPoint)==0x3F4),"bad off");
		static_assert((offsetof(Tyre,contactNormal)==0x400),"bad off");
		static_assert((offsetof(Tyre,surfaceDef)==0x410),"bad off");
		static_assert((offsetof(Tyre,debugOutput)==0x418),"bad off");
		static_assert((offsetof(Tyre,absOverride)==0x41C),"bad off");
		static_assert((offsetof(Tyre,thermalModel)==0x420),"bad off");
		static_assert((offsetof(Tyre,compoundDefs)==0x500),"bad off");
		static_assert((offsetof(Tyre,onStepCompleted)==0x518),"bad off");
		static_assert((offsetof(Tyre,aiMult)==0x538),"bad off");
		static_assert((offsetof(Tyre,slipProvider)==0x540),"bad off");
		static_assert((offsetof(Tyre,externalInputs)==0x578),"bad off");
		static_assert((offsetof(Tyre,roadRight)==0x588),"bad off");
		static_assert((offsetof(Tyre,roadHeading)==0x594),"bad off");
		static_assert((offsetof(Tyre,useLoadForVKM)==0x5A0),"bad off");
		static_assert((offsetof(Tyre,driven)==0x5A1),"bad off");
		static_assert((offsetof(Tyre,rayCollisionProvider)==0x5A8),"bad off");
		static_assert((offsetof(Tyre,oldAngularVelocity)==0x5B0),"bad off");
		static_assert((offsetof(Tyre,totalSlideVelocity)==0x5B4),"bad off");
		static_assert((offsetof(Tyre,localWheelRotation)==0x5B8),"bad off");
		static_assert((offsetof(Tyre,worldPosition)==0x5F8),"bad off");
		static_assert((offsetof(Tyre,slidingVelocityY)==0x604),"bad off");
		static_assert((offsetof(Tyre,slidingVelocityX)==0x608),"bad off");
		static_assert((offsetof(Tyre,roadVelocityX)==0x60C),"bad off");
		static_assert((offsetof(Tyre,roadVelocityY)==0x610),"bad off");
		static_assert((offsetof(Tyre,totalHubVelocity)==0x614),"bad off");
		static_assert((offsetof(Tyre,rSlidingVelocityX)==0x618),"bad off");
		static_assert((offsetof(Tyre,rSlidingVelocityY)==0x61C),"bad off");
		static_assert((offsetof(Tyre,rayCaster)==0x620),"bad off");
		static_assert((offsetof(Tyre,index)==0x628),"bad off");
		static_assert((offsetof(Tyre,shakeGenerator)==0x630),"bad off");
		static_assert((offsetof(Tyre,car)==0x640),"bad off");
		static_assert((offsetof(Tyre,currentCompoundIndex)==0x648),"bad off");
		static_assert((offsetof(Tyre,tyreBlanketsOn)==0x64C),"bad off");
		static_assert((offsetof(Tyre,flatSpotK)==0x650),"bad off");
		static_assert((offsetof(Tyre,tyreModel)==0x658),"bad off");
		static_assert((offsetof(Tyre,scTM)==0x660),"bad off");
		static_assert((offsetof(Tyre,explosionTemperature)==0x848),"bad off");
		static_assert((offsetof(Tyre,blanketTemperature)==0x84C),"bad off");
		static_assert((offsetof(Tyre,pressureTemperatureGain)==0x850),"bad off");
		static_assert((offsetof(Tyre,localMX)==0x854),"bad off");
	};
};

//UDT: class RaceManager @len=536 @vfcount=6
	//_Base: class GameObject @off=0 @len=88
	//_Func: public void RaceManager(const RaceManager &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void RaceManager(Sim * isim); @loc=static @len=1059 @rva=1256880
	//_Func: public void ~RaceManager(); @virtual vtpo=0 vfid=0 @loc=static @len=545 @rva=1258224
	//_Data: this+0x58, Member, Type: class Event<OnRaceInitEvent>, evOnRaceInit
	//_Data: this+0x70, Member, Type: class Event<OnSessionEndEvent>, evOnSessionEnd
	//_Data: this+0x88, Member, Type: class Event<OnLapCompletedEvent>, evOnLapCompleted
	//_Data: static, [01559B00][0003:00046B00], Static Member, Type: int, carsToBeLoaded
	//_Func: public bool arePenaltiesEnabled(); @loc=optimized @len=0 @rva=0
	//_Func: public bool isOfficialSpecialEvent(); @loc=static @len=8 @rva=1680464
	//_Func: public bool isSetupFixed(); @loc=optimized @len=0 @rva=0
	//_Func: public void update(float deltaT); @virtual vtpo=0 vfid=1 @loc=static @len=4342 @rva=1316176
	//_Func: public void startRace(float millisecondsToStart); @loc=static @len=220 @rva=1315952
	//_Func: public bool isRaceOver(unsigned int carIndex); @loc=static @len=222 @rva=1305312
	//_Func: public void renderHUD(float dt); @virtual vtpo=0 vfid=3 @loc=static @len=2450 @rva=1309024
	//_Func: public void shutdown(); @virtual vtpo=0 vfid=5 @loc=static @len=33 @rva=1315616
	//_Func: public void setPauseMode(bool  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public bool skipCurrentSession(); @loc=static @len=274 @rva=1315664
	//_Func: public int getCurrentSessionIndex(); @loc=static @len=34 @rva=1278672
	//_Func: public SessionType getCurrentSessionType(); @loc=static @len=126 @rva=1278720
	//_Func: public Session getCurrentSession(); @loc=static @len=170 @rva=1278496
	//_Func: public Session getSessionInfo(int sessionIndex); @loc=static @len=236 @rva=1285488
	//_Func: public void restartCurrentSession(); @loc=static @len=239 @rva=1314048
	//_Func: public bool loadSessions(); @loc=static @len=1734 @rva=1305776
	//_Func: public bool hasSessionStarted(); @loc=static @len=151 @rva=1286512
	//_Func: public double getTimeToSessionStart(); @loc=static @len=142 @rva=1286304
	//_Func: public double getSessionOverTime(); @loc=optimized @len=0 @rva=0
	//_Func: public unsigned int getSessionCount(); @loc=static @len=68 @rva=1285280
	//_Func: public double getSessionTimeLeft(); @loc=static @len=125 @rva=1285728
	//_Func: public bool hasExtraLap(); @loc=static @len=30 @rva=1286480
	//_Func: public unsigned short getPitWindowStart(); @loc=static @len=30 @rva=1281376
	//_Func: public unsigned short getPitWindowEnd(); @loc=static @len=30 @rva=1281344
	//_Func: public std::vector<LeaderboardEntry,std::allocator<LeaderboardEntry> > getLeaderboard(); @loc=static @len=210 @rva=1280688
	//_Func: public std::vector<LeaderboardEntry,std::allocator<LeaderboardEntry> > getLeaderboardFromSession(int sessionID); @loc=static @len=140 @rva=1280912
	//_Func: public int getCarLeaderboardPosition(CarAvatar * car); @loc=static @len=168 @rva=1277664
	//_Func: public int getCarRealTimePosition(CarAvatar * car); @loc=static @len=279 @rva=1277840
	//_Func: public int getSessionTotalTime(unsigned int carIndex); @loc=static @len=289 @rva=1285856
	//_Func: public Lap getLastLap(CarAvatar * car); @loc=static @len=526 @rva=1279936
	//_Func: public unsigned int getBestLap(); @loc=static @len=46 @rva=1277568
	//_Func: public Lap getBestLap(CarAvatar * car); @loc=static @len=636 @rva=1276928
	//_Func: public unsigned int getLapCount(CarAvatar * car); @loc=static @len=319 @rva=1279344
	//_Func: public unsigned int getSplit(CarAvatar * car, const int & sector); @loc=static @len=46 @rva=1286256
	//_Func: public int getSplit(CarAvatar * car); @loc=static @len=89 @rva=1286160
	//_Func: public Lap getCurrentLap(CarAvatar * car); @loc=static @len=360 @rva=1278128
	//_Func: public std::vector<Lap,std::allocator<Lap> > getLaps(CarAvatar * car, bool readReplayModeIfActive); @loc=static @len=268 @rva=1279664
	//_Func: public int getInstanceBestLap(CarAvatar * car); @loc=static @len=319 @rva=1278976
	//_Func: public unsigned int getLastSplit(CarAvatar * car, const int & sector); @loc=static @len=46 @rva=1280464
	//_Func: public unsigned int getBestSplit(const int & sector, const bool & isGlobal, CarAvatar * car); @loc=static @len=46 @rva=1277616
	//_Func: public bool isBestSplit(const int & sector, const int & t, const bool & isGlobal, CarAvatar * car); @loc=static @len=52 @rva=1305248
	//_Func: public unsigned int getLeaderLapCount(); @loc=static @len=173 @rva=1280512
	//_Func: public OnSessionEndEvent getSessionHistory(const int & sessionID); @loc=static @len=114 @rva=1285360
	//_Func: public double getTimetoWait(); @loc=static @len=27 @rva=1286448
	//_Func: public std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getPracticeQualifyText(); @loc=static @len=969 @rva=1281408
	//_Func: public std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getRaceText(); @loc=static @len=2886 @rva=1282384
	//_Func: public bool getHasCompletedFlag(CarAvatar * car); @loc=static @len=112 @rva=1278864
	//_Func: public int getInvertedGridPositions(); @loc=static @len=29 @rva=1279312
	//_Func: public void checkMandatoryPit(int carIndex, float entry, float exit); @loc=static @len=419 @rva=1271856
	//_Func: public void setMandatoryPit(int  _arg0, bool  _arg1); @loc=optimized @len=0 @rva=0
	//_Data: this+0xA0, Member, Type: bool, penaltiesEnabled
	//_Data: this+0xA1, Member, Type: bool, officialSpecialEvent
	//_Data: this+0xA2, Member, Type: bool, fixedSetup
	//_Data: this+0xA3, Member, Type: bool, pauseMode
	//_Data: this+0xA4, Member, Type: int, currentSessionIndex
	//_Data: this+0xA8, Member, Type: float, overTimeMult
	//_Data: this+0xAC, Member, Type: bool, timeRaceEnded
	//_Data: this+0xAD, Member, Type: bool, isTimedLastLap
	//_Data: this+0xAE, Member, Type: bool, hasAdditionalLap
	//_Data: this+0xB0, Member, Type: float, pitWindowStartTime
	//_Data: this+0xB4, Member, Type: float, pitWindowEndTime
	//_Data: this+0xB8, Member, Type: struct WindSettings, windSettings
	//_Data: this+0xC0, Member, Type: struct MultiplayerStatus, multiplayerStatus
	//_Data: this+0xE0, Member, Type: bool, leaderLastLap
	//_Data: this+0xE8, Member, Type: class Session, currentSession
	//_Data: this+0x158, Member, Type: class Trigger, debugTrigger
	//_Data: this+0x168, Member, Type: class Sim *, sim
	//_Data: this+0x170, Member, Type: class RaceTimingServices *, raceTimingServices
	//_Data: this+0x178, Member, Type: class std::shared_ptr<Font>, font
	//_Data: this+0x188, Member, Type: class std::vector<Session,std::allocator<Session> >, sessions
	//_Data: this+0x1A0, Member, Type: class std::vector<RealTimeCarDesc,std::allocator<RealTimeCarDesc> >, carsRealTimePosition
	//_Data: this+0x1B8, Member, Type: class std::vector<RaceStatusCarDesc,std::allocator<RaceStatusCarDesc> >, carsRaceStatus
	//_Data: this+0x1D0, Member, Type: class std::vector<LeaderboardEntry,std::allocator<LeaderboardEntry> >, mpCacheLeaderboard
	//_Data: this+0x1E8, Member, Type: class std::vector<std::vector<LeaderboardEntry,std::allocator<LeaderboardEntry> >,std::allocator<std::vector<LeaderboardEntry,std::allocator<LeaderboardEntry> > > >, leaderboardHistory
	//_Data: this+0x200, Member, Type: class std::vector<OnSessionEndEvent,std::allocator<OnSessionEndEvent> >, sessionHistoryList
	//_Func: protected std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > getModelSkins(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & model); @loc=static @len=288 @rva=1281056
	//_Func: protected void initLighting(INIReaderDocuments & ini); @loc=static @len=749 @rva=1287120
	//_Func: protected void initGhostcar(INIReaderDocuments & ini); @loc=static @len=443 @rva=1286672
	//_Func: protected bool initOnline(INIReaderDocuments & ini); @loc=static @len=5810 @rva=1298784
	//_Func: protected bool initOffline(INIReaderDocuments & anIniReader); @loc=static @len=10903 @rva=1287872
	//_Func: protected bool initReplay(INIReaderDocuments & r); @loc=static @len=636 @rva=1304608
	//_Func: protected void updateCarsRealTimePositions(float dt); @loc=static @len=358 @rva=1321136
	//_Func: protected void finalizeCurrentSession(); @loc=static @len=4085 @rva=1272624
	//_Func: protected void moveToNextSession(); @loc=optimized @len=0 @rva=0
	//_Func: protected void updateCarsEndRace(float dt); @loc=static @len=601 @rva=1320528
	//_Func: protected void setCurrentSession(unsigned int index); @loc=static @len=1044 @rva=1314288
	//_Func: protected void onLapCompleted(const OnLapCompletedEvent & message); @loc=static @len=367 @rva=1307520
	//_Func: protected void updateAIFuel(); @loc=optimized @len=0 @rva=0
	//_Func: protected void resetInvalidStateCarsToPits(float dt); @loc=static @len=693 @rva=1311552
	//_Func: protected void resetCurrentLaps(); @loc=static @len=61 @rva=1311488
	//_Func: protected void resetMandatoryPit(); @loc=static @len=262 @rva=1312256
	//_Func: protected Session convertRemoteSession(const RemoteSession & rs); @loc=static @len=214 @rva=1272400
	//_Func: protected bool isSkinAvailable(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & model, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & skin); @loc=static @len=236 @rva=1305536
	//_Func: protected void setHasCompletedFlag(CarAvatar * car, bool value); @loc=static @len=143 @rva=1315440
	//_Func: protected void generateWind(); @loc=static @len=69 @rva=1276832
	//_Func: public RaceManager & operator=(const RaceManager &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class RaceManager : public GameObject {
public:
	Event<OnRaceInitEvent> evOnRaceInit;
	Event<OnSessionEndEvent> evOnSessionEnd;
	Event<OnLapCompletedEvent> evOnLapCompleted;
	bool penaltiesEnabled;
	bool officialSpecialEvent;
	bool fixedSetup;
	bool pauseMode;
	int currentSessionIndex;
	float overTimeMult;
	bool timeRaceEnded;
	bool isTimedLastLap;
	bool hasAdditionalLap;
	float pitWindowStartTime;
	float pitWindowEndTime;
	WindSettings windSettings;
	MultiplayerStatus multiplayerStatus;
	bool leaderLastLap;
	Session currentSession;
	Trigger debugTrigger;
	Sim * sim;
	RaceTimingServices * raceTimingServices;
	std::shared_ptr<Font> font;
	std::vector<Session,std::allocator<Session> > sessions;
	std::vector<RealTimeCarDesc,std::allocator<RealTimeCarDesc> > carsRealTimePosition;
	std::vector<RaceStatusCarDesc,std::allocator<RaceStatusCarDesc> > carsRaceStatus;
	std::vector<LeaderboardEntry,std::allocator<LeaderboardEntry> > mpCacheLeaderboard;
	std::vector<std::vector<LeaderboardEntry,std::allocator<LeaderboardEntry> >,std::allocator<std::vector<LeaderboardEntry,std::allocator<LeaderboardEntry> > > > leaderboardHistory;
	std::vector<OnSessionEndEvent,std::allocator<OnSessionEndEvent> > sessionHistoryList;
	inline RaceManager() { }
	inline RaceManager(const RaceManager& other) = default;
	inline RaceManager& operator=(const RaceManager& other) = default;
	inline void ctor(Sim * isim) { typedef void (RaceManager::*_fpt)(Sim *); auto _f=xcast<_fpt>(_drva(1256880)); (this->*_f)(isim); }
	virtual ~RaceManager();
	inline void dtor() { typedef void (RaceManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1258224)); (this->*_f)(); }
	inline bool isOfficialSpecialEvent() { typedef bool (RaceManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1680464)); return (this->*_f)(); }
	virtual void update_vf1(float deltaT);
	inline void update_impl(float deltaT) { typedef void (RaceManager::*_fpt)(float); auto _f=xcast<_fpt>(_drva(1316176)); return (this->*_f)(deltaT); }
	inline void update(float deltaT) { typedef void (RaceManager::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(deltaT); }
	inline void startRace(float millisecondsToStart) { typedef void (RaceManager::*_fpt)(float); auto _f=xcast<_fpt>(_drva(1315952)); return (this->*_f)(millisecondsToStart); }
	inline bool isRaceOver(unsigned int carIndex) { typedef bool (RaceManager::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(1305312)); return (this->*_f)(carIndex); }
	virtual void renderHUD_vf3(float dt);
	inline void renderHUD_impl(float dt) { typedef void (RaceManager::*_fpt)(float); auto _f=xcast<_fpt>(_drva(1309024)); return (this->*_f)(dt); }
	inline void renderHUD(float dt) { typedef void (RaceManager::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(dt); }
	virtual void shutdown_vf5();
	inline void shutdown_impl() { typedef void (RaceManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1315616)); return (this->*_f)(); }
	inline void shutdown() { typedef void (RaceManager::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 5)); return (this->*_f)(); }
	inline bool skipCurrentSession() { typedef bool (RaceManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1315664)); return (this->*_f)(); }
	inline int getCurrentSessionIndex() { typedef int (RaceManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1278672)); return (this->*_f)(); }
	inline SessionType getCurrentSessionType() { typedef SessionType (RaceManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1278720)); return (this->*_f)(); }
	inline Session getCurrentSession() { typedef Session (RaceManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1278496)); return (this->*_f)(); }
	inline Session getSessionInfo(int sessionIndex) { typedef Session (RaceManager::*_fpt)(int); auto _f=xcast<_fpt>(_drva(1285488)); return (this->*_f)(sessionIndex); }
	inline void restartCurrentSession() { typedef void (RaceManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1314048)); return (this->*_f)(); }
	inline bool loadSessions() { typedef bool (RaceManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1305776)); return (this->*_f)(); }
	inline bool hasSessionStarted() { typedef bool (RaceManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1286512)); return (this->*_f)(); }
	inline double getTimeToSessionStart() { typedef double (RaceManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1286304)); return (this->*_f)(); }
	inline unsigned int getSessionCount() { typedef unsigned int (RaceManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1285280)); return (this->*_f)(); }
	inline double getSessionTimeLeft() { typedef double (RaceManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1285728)); return (this->*_f)(); }
	inline bool hasExtraLap() { typedef bool (RaceManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1286480)); return (this->*_f)(); }
	inline unsigned short getPitWindowStart() { typedef unsigned short (RaceManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1281376)); return (this->*_f)(); }
	inline unsigned short getPitWindowEnd() { typedef unsigned short (RaceManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1281344)); return (this->*_f)(); }
	inline std::vector<LeaderboardEntry,std::allocator<LeaderboardEntry> > getLeaderboard() { typedef std::vector<LeaderboardEntry,std::allocator<LeaderboardEntry> > (RaceManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1280688)); return (this->*_f)(); }
	inline std::vector<LeaderboardEntry,std::allocator<LeaderboardEntry> > getLeaderboardFromSession(int sessionID) { typedef std::vector<LeaderboardEntry,std::allocator<LeaderboardEntry> > (RaceManager::*_fpt)(int); auto _f=xcast<_fpt>(_drva(1280912)); return (this->*_f)(sessionID); }
	inline int getCarLeaderboardPosition(CarAvatar * car) { typedef int (RaceManager::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(1277664)); return (this->*_f)(car); }
	inline int getCarRealTimePosition(CarAvatar * car) { typedef int (RaceManager::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(1277840)); return (this->*_f)(car); }
	inline int getSessionTotalTime(unsigned int carIndex) { typedef int (RaceManager::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(1285856)); return (this->*_f)(carIndex); }
	inline Lap getLastLap(CarAvatar * car) { typedef Lap (RaceManager::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(1279936)); return (this->*_f)(car); }
	inline unsigned int getBestLap() { typedef unsigned int (RaceManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1277568)); return (this->*_f)(); }
	inline Lap getBestLap(CarAvatar * car) { typedef Lap (RaceManager::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(1276928)); return (this->*_f)(car); }
	inline unsigned int getLapCount(CarAvatar * car) { typedef unsigned int (RaceManager::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(1279344)); return (this->*_f)(car); }
	inline unsigned int getSplit(CarAvatar * car, const int & sector) { typedef unsigned int (RaceManager::*_fpt)(CarAvatar *, const int &); auto _f=xcast<_fpt>(_drva(1286256)); return (this->*_f)(car, sector); }
	inline int getSplit(CarAvatar * car) { typedef int (RaceManager::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(1286160)); return (this->*_f)(car); }
	inline Lap getCurrentLap(CarAvatar * car) { typedef Lap (RaceManager::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(1278128)); return (this->*_f)(car); }
	inline std::vector<Lap,std::allocator<Lap> > getLaps(CarAvatar * car, bool readReplayModeIfActive) { typedef std::vector<Lap,std::allocator<Lap> > (RaceManager::*_fpt)(CarAvatar *, bool); auto _f=xcast<_fpt>(_drva(1279664)); return (this->*_f)(car, readReplayModeIfActive); }
	inline int getInstanceBestLap(CarAvatar * car) { typedef int (RaceManager::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(1278976)); return (this->*_f)(car); }
	inline unsigned int getLastSplit(CarAvatar * car, const int & sector) { typedef unsigned int (RaceManager::*_fpt)(CarAvatar *, const int &); auto _f=xcast<_fpt>(_drva(1280464)); return (this->*_f)(car, sector); }
	inline unsigned int getBestSplit(const int & sector, const bool & isGlobal, CarAvatar * car) { typedef unsigned int (RaceManager::*_fpt)(const int &, const bool &, CarAvatar *); auto _f=xcast<_fpt>(_drva(1277616)); return (this->*_f)(sector, isGlobal, car); }
	inline bool isBestSplit(const int & sector, const int & t, const bool & isGlobal, CarAvatar * car) { typedef bool (RaceManager::*_fpt)(const int &, const int &, const bool &, CarAvatar *); auto _f=xcast<_fpt>(_drva(1305248)); return (this->*_f)(sector, t, isGlobal, car); }
	inline unsigned int getLeaderLapCount() { typedef unsigned int (RaceManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1280512)); return (this->*_f)(); }
	inline OnSessionEndEvent getSessionHistory(const int & sessionID) { typedef OnSessionEndEvent (RaceManager::*_fpt)(const int &); auto _f=xcast<_fpt>(_drva(1285360)); return (this->*_f)(sessionID); }
	inline double getTimetoWait() { typedef double (RaceManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1286448)); return (this->*_f)(); }
	inline std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getPracticeQualifyText() { typedef std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > (RaceManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1281408)); return (this->*_f)(); }
	inline std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getRaceText() { typedef std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > (RaceManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1282384)); return (this->*_f)(); }
	inline bool getHasCompletedFlag(CarAvatar * car) { typedef bool (RaceManager::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(1278864)); return (this->*_f)(car); }
	inline int getInvertedGridPositions() { typedef int (RaceManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1279312)); return (this->*_f)(); }
	inline void checkMandatoryPit(int carIndex, float entry, float exit) { typedef void (RaceManager::*_fpt)(int, float, float); auto _f=xcast<_fpt>(_drva(1271856)); return (this->*_f)(carIndex, entry, exit); }
	inline std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > getModelSkins(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & model) { typedef std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > (RaceManager::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(1281056)); return (this->*_f)(model); }
	inline void initLighting(INIReaderDocuments & ini) { typedef void (RaceManager::*_fpt)(INIReaderDocuments &); auto _f=xcast<_fpt>(_drva(1287120)); return (this->*_f)(ini); }
	inline void initGhostcar(INIReaderDocuments & ini) { typedef void (RaceManager::*_fpt)(INIReaderDocuments &); auto _f=xcast<_fpt>(_drva(1286672)); return (this->*_f)(ini); }
	inline bool initOnline(INIReaderDocuments & ini) { typedef bool (RaceManager::*_fpt)(INIReaderDocuments &); auto _f=xcast<_fpt>(_drva(1298784)); return (this->*_f)(ini); }
	inline bool initOffline(INIReaderDocuments & anIniReader) { typedef bool (RaceManager::*_fpt)(INIReaderDocuments &); auto _f=xcast<_fpt>(_drva(1287872)); return (this->*_f)(anIniReader); }
	inline bool initReplay(INIReaderDocuments & r) { typedef bool (RaceManager::*_fpt)(INIReaderDocuments &); auto _f=xcast<_fpt>(_drva(1304608)); return (this->*_f)(r); }
	inline void updateCarsRealTimePositions(float dt) { typedef void (RaceManager::*_fpt)(float); auto _f=xcast<_fpt>(_drva(1321136)); return (this->*_f)(dt); }
	inline void finalizeCurrentSession() { typedef void (RaceManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1272624)); return (this->*_f)(); }
	inline void updateCarsEndRace(float dt) { typedef void (RaceManager::*_fpt)(float); auto _f=xcast<_fpt>(_drva(1320528)); return (this->*_f)(dt); }
	inline void setCurrentSession(unsigned int index) { typedef void (RaceManager::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(1314288)); return (this->*_f)(index); }
	inline void onLapCompleted(const OnLapCompletedEvent & message) { typedef void (RaceManager::*_fpt)(const OnLapCompletedEvent &); auto _f=xcast<_fpt>(_drva(1307520)); return (this->*_f)(message); }
	inline void resetInvalidStateCarsToPits(float dt) { typedef void (RaceManager::*_fpt)(float); auto _f=xcast<_fpt>(_drva(1311552)); return (this->*_f)(dt); }
	inline void resetCurrentLaps() { typedef void (RaceManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1311488)); return (this->*_f)(); }
	inline void resetMandatoryPit() { typedef void (RaceManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1312256)); return (this->*_f)(); }
	inline Session convertRemoteSession(const RemoteSession & rs) { typedef Session (RaceManager::*_fpt)(const RemoteSession &); auto _f=xcast<_fpt>(_drva(1272400)); return (this->*_f)(rs); }
	inline bool isSkinAvailable(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & model, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & skin) { typedef bool (RaceManager::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(1305536)); return (this->*_f)(model, skin); }
	inline void setHasCompletedFlag(CarAvatar * car, bool value) { typedef void (RaceManager::*_fpt)(CarAvatar *, bool); auto _f=xcast<_fpt>(_drva(1315440)); return (this->*_f)(car, value); }
	inline void generateWind() { typedef void (RaceManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1276832)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(RaceManager)==536),"bad size");
		static_assert((offsetof(RaceManager,evOnRaceInit)==0x58),"bad off");
		static_assert((offsetof(RaceManager,evOnSessionEnd)==0x70),"bad off");
		static_assert((offsetof(RaceManager,evOnLapCompleted)==0x88),"bad off");
		static_assert((offsetof(RaceManager,penaltiesEnabled)==0xA0),"bad off");
		static_assert((offsetof(RaceManager,officialSpecialEvent)==0xA1),"bad off");
		static_assert((offsetof(RaceManager,fixedSetup)==0xA2),"bad off");
		static_assert((offsetof(RaceManager,pauseMode)==0xA3),"bad off");
		static_assert((offsetof(RaceManager,currentSessionIndex)==0xA4),"bad off");
		static_assert((offsetof(RaceManager,overTimeMult)==0xA8),"bad off");
		static_assert((offsetof(RaceManager,timeRaceEnded)==0xAC),"bad off");
		static_assert((offsetof(RaceManager,isTimedLastLap)==0xAD),"bad off");
		static_assert((offsetof(RaceManager,hasAdditionalLap)==0xAE),"bad off");
		static_assert((offsetof(RaceManager,pitWindowStartTime)==0xB0),"bad off");
		static_assert((offsetof(RaceManager,pitWindowEndTime)==0xB4),"bad off");
		static_assert((offsetof(RaceManager,windSettings)==0xB8),"bad off");
		static_assert((offsetof(RaceManager,multiplayerStatus)==0xC0),"bad off");
		static_assert((offsetof(RaceManager,leaderLastLap)==0xE0),"bad off");
		static_assert((offsetof(RaceManager,currentSession)==0xE8),"bad off");
		static_assert((offsetof(RaceManager,debugTrigger)==0x158),"bad off");
		static_assert((offsetof(RaceManager,sim)==0x168),"bad off");
		static_assert((offsetof(RaceManager,raceTimingServices)==0x170),"bad off");
		static_assert((offsetof(RaceManager,font)==0x178),"bad off");
		static_assert((offsetof(RaceManager,sessions)==0x188),"bad off");
		static_assert((offsetof(RaceManager,carsRealTimePosition)==0x1A0),"bad off");
		static_assert((offsetof(RaceManager,carsRaceStatus)==0x1B8),"bad off");
		static_assert((offsetof(RaceManager,mpCacheLeaderboard)==0x1D0),"bad off");
		static_assert((offsetof(RaceManager,leaderboardHistory)==0x1E8),"bad off");
		static_assert((offsetof(RaceManager,sessionHistoryList)==0x200),"bad off");
	};
};

//UDT: class ksgui::GUI @len=400 @vfcount=3
	//_Base: class IKeyEventListener @off=0 @len=8
	//_Tag 11
	//_Func: public void GUI(const ksgui_GUI &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void GUI(GraphicsManager * graphics, std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * aapplicationName, KeyboardManager * keyManager); @loc=static @len=2038 @rva=2431680
	//_Func: public void ~GUI(); @intro @virtual vtpo=0 vfid=2 @loc=static @len=424 @rva=2433760
	//_Data: this+0x8, Member, Type: bool, isActive
	//_Data: this+0x10, Member, Type: class GraphicsManager *, graphics
	//_Data: this+0x18, Member, Type: class std::shared_ptr<Font>, font
	//_Data: this+0x28, Member, Type: class INIReader, skinReader
	//_Data: this+0x90, Member, Type: int, version
	//_Data: this+0x98, Member, Type: class ksgui::Taskbar *, taskbar
	//_Data: this+0xA0, Member, Type: class std::vector<ksgui::Control *,std::allocator<ksgui::Control *> >, controls
	//_Data: this+0xB8, Member, Type: bool, isPointerVisible
	//_Func: public void preRender3D(float dt); @loc=static @len=305 @rva=2443200
	//_Func: public void render3D(float dt); @loc=static @len=777 @rva=2443520
	//_Func: public void render(float dt); @loc=static @len=21 @rva=2444304
	//_Func: public void addControl(ksgui_Control * c); @loc=static @len=95 @rva=2436688
	//_Func: public vec4f getSkinColor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * key, std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * value); @loc=static @len=171 @rva=2440800
	//_Func: public void setCapturedForm(ksgui_Form * form, int wx, int wy); @loc=static @len=58 @rva=2447040
	//_Func: public void serializeForms(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * filename); @loc=static @len=1651 @rva=2444640
	//_Func: public void deserializeForm(ksgui_Form * form); @loc=static @len=1027 @rva=2437008
	//_Func: public void attachToRenderWindowEvents(RenderWindow & window); @loc=static @len=214 @rva=2436784
	//_Func: public void setAudioEngine(AudioEngine * engine); @loc=static @len=8 @rva=2447024
	//_Func: public void playClick(); @loc=static @len=3 @rva=96368
	//_Func: public void setAllowFormSerialization(bool  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void init3DMode(unsigned int width, unsigned int height, Node * referenceFrame, Camera * camera, vec3f posOffset); @loc=static @len=351 @rva=2440976
	//_Func: public void onMouseUp(const OnMouseUpEvent & message); @loc=static @len=339 @rva=2442688
	//_Func: public void onMouseMove(const OnMouseMoveEvent & message); @loc=static @len=662 @rva=2442016
	//_Func: public void onMouseDown(const OnMouseDownEvent & message); @loc=static @len=141 @rva=2441872
	//_Func: public void onMouseWheelMoved(const OnMouseWheelMovedEvent & message); @loc=static @len=145 @rva=2443040
	//_Func: public void onKeyChar(unsigned int key); @virtual vtpo=0 vfid=1 @loc=static @len=72 @rva=2441696
	//_Func: public void onKeyDown(const OnKeyEvent & message); @virtual vtpo=0 vfid=0 @loc=static @len=85 @rva=2441776
	//_Func: public void renderVPointer(); @loc=static @len=296 @rva=2444336
	//_Data: this+0xB9, Member, Type: bool, allowFormSerialization
	//_Data: this+0xC0, Member, Type: class AudioEngine *, audioEngine
	//_Data: this+0xC8, Member, Type: class ksgui::Form *, capturedForm
	//_Data: this+0xD0, Member, Type: class vec2f, capturedPos
	//_Data: this+0xD8, Member, Type: class vec2f, oldGoodPos
	//_Data: this+0xE0, Member, Type: bool, moveApp
	//_Data: this+0xE1, Member, Type: bool, renderDrawingArea
	//_Data: this+0xE2, Member, Type: bool, allowOverlappingForms
	//_Data: this+0xE8, Member, Type: class ksgui::EventReplicator<OnMouseDownEvent>, onMouseDownReplicator
	//_Data: this+0xF8, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, applicationName
	//_Data: this+0x118, Member, Type: class RenderTarget *, renderTarget
	//_Data: this+0x120, Member, Type: class Camera *, camera
	//_Data: this+0x128, Member, Type: class Node *, referenceFrameForOrientation
	//_Data: this+0x130, Member, Type: class Texture, txPointer
	//_Data: this+0x158, Member, Type: class vec2f, mousePos
	//_Data: this+0x160, Member, Type: float, mouseSpeed
	//_Data: this+0x164, Member, Type: class vec2f, oldMousePos
	//_Data: this+0x16C, Member, Type: class vec3f, positionOffset3D
	//_Data: this+0x178, Member, Type: int, virtualDesktop
	//_Data: this+0x180, Member, Type: class std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,ksgui::GUI::FormData,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,ksgui::GUI::FormData> > >, formDataMap
	//_Func: protected void doRender2D(float dt); @loc=static @len=325 @rva=2439632
	//_Func: protected void deserializeOldForm(ksgui_Form * form); @loc=static @len=306 @rva=2439312
	//_Func: protected void deserializeFormDesktop(ksgui_Form * form, int idDesktop); @loc=static @len=1257 @rva=2438048
	//_Func: protected void serializeMemoryForm(ksgui_Form * form); @loc=static @len=719 @rva=2446304
	//_Func: protected void fromForm(ksgui_GUI_FormData &  _arg0, ksgui_Form *  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: protected void fromIni(ksgui_GUI_FormData & data, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section); @loc=static @len=826 @rva=2439968
	//_Func: protected void fromMemory(ksgui_GUI_FormData &  _arg0, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public ksgui_GUI & operator=(const ksgui_GUI &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=2 @loc=optimized @len=0 @rva=0
//UDT;

class ksgui_GUI : public IKeyEventListener {
public:
	bool isActive;
	GraphicsManager * graphics;
	std::shared_ptr<Font> font;
	INIReader skinReader;
	int version;
	ksgui_Taskbar * taskbar;
	std::vector<ksgui_Control *,std::allocator<ksgui_Control *> > controls;
	bool isPointerVisible;
	bool allowFormSerialization;
	AudioEngine * audioEngine;
	ksgui_Form * capturedForm;
	vec2f capturedPos;
	vec2f oldGoodPos;
	bool moveApp;
	bool renderDrawingArea;
	bool allowOverlappingForms;
	ksgui_EventReplicator<OnMouseDownEvent> onMouseDownReplicator;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > applicationName;
	RenderTarget * renderTarget;
	Camera * camera;
	Node * referenceFrameForOrientation;
	Texture txPointer;
	vec2f mousePos;
	float mouseSpeed;
	vec2f oldMousePos;
	vec3f positionOffset3D;
	int virtualDesktop;
	std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,ksgui_GUI_FormData,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,ksgui_GUI_FormData> > > formDataMap;
	inline ksgui_GUI() { }
	inline ksgui_GUI(const ksgui_GUI& other) = default;
	inline ksgui_GUI& operator=(const ksgui_GUI& other) = default;
	inline void ctor(GraphicsManager * graphics, std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * aapplicationName, KeyboardManager * keyManager) { typedef void (ksgui_GUI::*_fpt)(GraphicsManager *, std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, KeyboardManager *); auto _f=xcast<_fpt>(_drva(2431680)); (this->*_f)(graphics, aapplicationName, keyManager); }
	virtual ~ksgui_GUI();
	inline void dtor() { typedef void (ksgui_GUI::*_fpt)(); auto _f=xcast<_fpt>(_drva(2433760)); (this->*_f)(); }
	inline void preRender3D(float dt) { typedef void (ksgui_GUI::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2443200)); return (this->*_f)(dt); }
	inline void render3D(float dt) { typedef void (ksgui_GUI::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2443520)); return (this->*_f)(dt); }
	inline void render(float dt) { typedef void (ksgui_GUI::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2444304)); return (this->*_f)(dt); }
	inline void addControl(ksgui_Control * c) { typedef void (ksgui_GUI::*_fpt)(ksgui_Control *); auto _f=xcast<_fpt>(_drva(2436688)); return (this->*_f)(c); }
	inline vec4f getSkinColor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * key, std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * value) { typedef vec4f (ksgui_GUI::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *); auto _f=xcast<_fpt>(_drva(2440800)); return (this->*_f)(key, value); }
	inline void setCapturedForm(ksgui_Form * form, int wx, int wy) { typedef void (ksgui_GUI::*_fpt)(ksgui_Form *, int, int); auto _f=xcast<_fpt>(_drva(2447040)); return (this->*_f)(form, wx, wy); }
	inline void serializeForms(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * filename) { typedef void (ksgui_GUI::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *); auto _f=xcast<_fpt>(_drva(2444640)); return (this->*_f)(filename); }
	inline void deserializeForm(ksgui_Form * form) { typedef void (ksgui_GUI::*_fpt)(ksgui_Form *); auto _f=xcast<_fpt>(_drva(2437008)); return (this->*_f)(form); }
	inline void attachToRenderWindowEvents(RenderWindow & window) { typedef void (ksgui_GUI::*_fpt)(RenderWindow &); auto _f=xcast<_fpt>(_drva(2436784)); return (this->*_f)(window); }
	inline void setAudioEngine(AudioEngine * engine) { typedef void (ksgui_GUI::*_fpt)(AudioEngine *); auto _f=xcast<_fpt>(_drva(2447024)); return (this->*_f)(engine); }
	inline void playClick() { typedef void (ksgui_GUI::*_fpt)(); auto _f=xcast<_fpt>(_drva(96368)); return (this->*_f)(); }
	inline void init3DMode(unsigned int width, unsigned int height, Node * referenceFrame, Camera * camera, vec3f posOffset) { typedef void (ksgui_GUI::*_fpt)(unsigned int, unsigned int, Node *, Camera *, vec3f); auto _f=xcast<_fpt>(_drva(2440976)); return (this->*_f)(width, height, referenceFrame, camera, posOffset); }
	inline void onMouseUp(const OnMouseUpEvent & message) { typedef void (ksgui_GUI::*_fpt)(const OnMouseUpEvent &); auto _f=xcast<_fpt>(_drva(2442688)); return (this->*_f)(message); }
	inline void onMouseMove(const OnMouseMoveEvent & message) { typedef void (ksgui_GUI::*_fpt)(const OnMouseMoveEvent &); auto _f=xcast<_fpt>(_drva(2442016)); return (this->*_f)(message); }
	inline void onMouseDown(const OnMouseDownEvent & message) { typedef void (ksgui_GUI::*_fpt)(const OnMouseDownEvent &); auto _f=xcast<_fpt>(_drva(2441872)); return (this->*_f)(message); }
	inline void onMouseWheelMoved(const OnMouseWheelMovedEvent & message) { typedef void (ksgui_GUI::*_fpt)(const OnMouseWheelMovedEvent &); auto _f=xcast<_fpt>(_drva(2443040)); return (this->*_f)(message); }
	virtual void onKeyChar_vf1(unsigned int key);
	inline void onKeyChar_impl(unsigned int key) { typedef void (ksgui_GUI::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(2441696)); return (this->*_f)(key); }
	inline void onKeyChar(unsigned int key) { typedef void (ksgui_GUI::*_fpt)(unsigned int); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(key); }
	virtual void onKeyDown_vf0(const OnKeyEvent & message);
	inline void onKeyDown_impl(const OnKeyEvent & message) { typedef void (ksgui_GUI::*_fpt)(const OnKeyEvent &); auto _f=xcast<_fpt>(_drva(2441776)); return (this->*_f)(message); }
	inline void onKeyDown(const OnKeyEvent & message) { typedef void (ksgui_GUI::*_fpt)(const OnKeyEvent &); auto _f=xcast<_fpt>(get_vfp(this, 0)); return (this->*_f)(message); }
	inline void renderVPointer() { typedef void (ksgui_GUI::*_fpt)(); auto _f=xcast<_fpt>(_drva(2444336)); return (this->*_f)(); }
	inline void doRender2D(float dt) { typedef void (ksgui_GUI::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2439632)); return (this->*_f)(dt); }
	inline void deserializeOldForm(ksgui_Form * form) { typedef void (ksgui_GUI::*_fpt)(ksgui_Form *); auto _f=xcast<_fpt>(_drva(2439312)); return (this->*_f)(form); }
	inline void deserializeFormDesktop(ksgui_Form * form, int idDesktop) { typedef void (ksgui_GUI::*_fpt)(ksgui_Form *, int); auto _f=xcast<_fpt>(_drva(2438048)); return (this->*_f)(form, idDesktop); }
	inline void serializeMemoryForm(ksgui_Form * form) { typedef void (ksgui_GUI::*_fpt)(ksgui_Form *); auto _f=xcast<_fpt>(_drva(2446304)); return (this->*_f)(form); }
	inline void fromIni(ksgui_GUI_FormData & data, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section) { typedef void (ksgui_GUI::*_fpt)(ksgui_GUI_FormData &, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2439968)); return (this->*_f)(data, section); }
	inline void _guard_obj() {
		static_assert((sizeof(ksgui_GUI)==400),"bad size");
		static_assert((offsetof(ksgui_GUI,isActive)==0x8),"bad off");
		static_assert((offsetof(ksgui_GUI,graphics)==0x10),"bad off");
		static_assert((offsetof(ksgui_GUI,font)==0x18),"bad off");
		static_assert((offsetof(ksgui_GUI,skinReader)==0x28),"bad off");
		static_assert((offsetof(ksgui_GUI,version)==0x90),"bad off");
		static_assert((offsetof(ksgui_GUI,taskbar)==0x98),"bad off");
		static_assert((offsetof(ksgui_GUI,controls)==0xA0),"bad off");
		static_assert((offsetof(ksgui_GUI,isPointerVisible)==0xB8),"bad off");
		static_assert((offsetof(ksgui_GUI,allowFormSerialization)==0xB9),"bad off");
		static_assert((offsetof(ksgui_GUI,audioEngine)==0xC0),"bad off");
		static_assert((offsetof(ksgui_GUI,capturedForm)==0xC8),"bad off");
		static_assert((offsetof(ksgui_GUI,capturedPos)==0xD0),"bad off");
		static_assert((offsetof(ksgui_GUI,oldGoodPos)==0xD8),"bad off");
		static_assert((offsetof(ksgui_GUI,moveApp)==0xE0),"bad off");
		static_assert((offsetof(ksgui_GUI,renderDrawingArea)==0xE1),"bad off");
		static_assert((offsetof(ksgui_GUI,allowOverlappingForms)==0xE2),"bad off");
		static_assert((offsetof(ksgui_GUI,onMouseDownReplicator)==0xE8),"bad off");
		static_assert((offsetof(ksgui_GUI,applicationName)==0xF8),"bad off");
		static_assert((offsetof(ksgui_GUI,renderTarget)==0x118),"bad off");
		static_assert((offsetof(ksgui_GUI,camera)==0x120),"bad off");
		static_assert((offsetof(ksgui_GUI,referenceFrameForOrientation)==0x128),"bad off");
		static_assert((offsetof(ksgui_GUI,txPointer)==0x130),"bad off");
		static_assert((offsetof(ksgui_GUI,mousePos)==0x158),"bad off");
		static_assert((offsetof(ksgui_GUI,mouseSpeed)==0x160),"bad off");
		static_assert((offsetof(ksgui_GUI,oldMousePos)==0x164),"bad off");
		static_assert((offsetof(ksgui_GUI,positionOffset3D)==0x16C),"bad off");
		static_assert((offsetof(ksgui_GUI,virtualDesktop)==0x178),"bad off");
		static_assert((offsetof(ksgui_GUI,formDataMap)==0x180),"bad off");
	};
};

//UDT: class NetCarStateProvider @len=5560 @multibase=2
	//_Base: class GameObject @off=0 @len=88
	//_Base: class ICarPhysicsStateProvider @off=88 @len=8
	//_Func: public void NetCarStateProvider(const NetCarStateProvider &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void NetCarStateProvider(const NetCarStateProviderDef & def); @loc=static @len=4691 @rva=1141872
	//_Func: public void ~NetCarStateProvider(); @virtual vtpo=0 vfid=0 @loc=static @len=521 @rva=1147072
	//_Data: this+0x60, Member, Type: class Event<OnSectorSplitEvent>, evOnSectorSplit
	//_Data: this+0x78, Member, Type: unsigned char, sessionID
	//_Data: this+0x80, Member, Type: struct DriverInfo, driverInfo
	//_Data: this+0x100, Member, Type: class vec3f, errorVector
	//_Data: this+0x10C, Member, Type: int, guid
	//_Data: this+0x110, Member, Type: int, ping
	//_Data: this+0x114, Member, Type: unsigned int, lastLap
	//_Data: this+0x118, Member, Type: unsigned int, bestLap
	//_Data: this+0x120, Member, Type: class std::vector<unsigned int,std::allocator<unsigned int> >, currentSplits
	//_Data: this+0x138, Member, Type: class std::vector<unsigned int,std::allocator<unsigned int> >, personalBestSplits
	//_Data: this+0x150, Member, Type: double, lastUpdateTime
	//_Data: this+0x158, Member, Type: double, lastTime
	//_Data: this+0x160, Member, Type: class std::vector<Lap,std::allocator<Lap> >, laps
	//_Data: this+0x178, Member, Type: struct NetCarPushToPass, p2p
	//_Data: this+0x18C, Member, Type: bool, hasEverReceivedAPacket
	//_Data: this+0x190, Member, Type: float, ballastKG
	//_Data: this+0x194, Member, Type: float, restrictor
	//_Data: this+0x198, Member, Type: float, hasCollisionInThisStep
	//_Func: public void update(float dt); @virtual vtpo=0 vfid=1 @loc=static @len=82 @rva=1169744
	//_Func: public void getPhysicsState(CarPhysicsState & physicsState); @virtual vtpo=88 vfid=1 @loc=static @len=239 @rva=1151520
	//_Func: public void getWingState(std::vector<WingState,std::allocator<WingState> > & ws); @virtual vtpo=88 vfid=2 @loc=static @len=18 @rva=1153600
	//_Func: public void onRemoteStateReceived(NetCarState & s); @loc=static @len=1814 @rva=1159648
	//_Func: public void setCarAvatar(CarAvatar * av); @loc=static @len=91 @rva=1162368
	//_Func: public CarAvatar * getCarAvatar(); @loc=optimized @len=0 @rva=0
	//_Func: public NetCarQoS getQos(); @loc=optimized @len=0 @rva=0
	//_Func: public void resetQos(); @loc=optimized @len=0 @rva=0
	//_Func: public void setDisconnected(); @loc=optimized @len=0 @rva=0
	//_Func: public IRigidBody * getBody(); @loc=optimized @len=0 @rva=0
	//_Func: public void resetDamage(); @loc=static @len=64 @rva=1162048
	//_Func: public void setDamageZoneLevel(float * zones); @loc=static @len=20 @rva=1162464
	//_Func: public void activateP2P(); @loc=static @len=24 @rva=1150672
	//_Tag 17
	//_Data: this+0x19C, Member, Type: struct NetCarQoS, qos
	//_Data: this+0x1A8, Member, Type: class ACClient *, client
	//_Data: this+0x1B0, Member, Type: class mat44f, bodyMatrix
	//_Data: this+0x1F0, Member, Type: class mat44f[0x4], wheelMatrix
	//_Data: this+0x2F0, Member, Type: class mat44f[0x4], suspMatrix
	//_Data: this+0x3F0, Member, Type: struct NetCarState[0x3], netStates
	//_Data: this+0x588, Member, Type: class vec3f, lastScreenPos
	//_Data: this+0x594, Member, Type: class mat44f[0x4], wheelBasePosLS
	//_Data: this+0x698, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, unixName
	//_Data: this+0x6B8, Member, Type: class IRayTrackCollisionProvider *, rayCastProvider
	//_Data: this+0x6C0, Member, Type: class vec3f, lastVelocity
	//_Data: this+0x6CC, Member, Type: class vec3f, instantVelocity
	//_Data: this+0x6D8, Member, Type: class vec3f, currentVelocity
	//_Data: this+0x6E8, Member, Type: struct CarPhysicsState, state
	//_Data: this+0x1258, Member, Type: class std::vector<WingState,std::allocator<WingState> >, wingStates
	//_Data: this+0x1270, Member, Type: class std::vector<std::vector<std::unique_ptr<DynamicWingController,std::default_delete<DynamicWingController> >,std::allocator<std::unique_ptr<DynamicWingController,std::default_delete<DynamicWingController> > > >,std::allocator<std::vector<std::unique_ptr<DynamicWingController,std::default_delete<DynamicWingController> >,std::allocator<std::unique_ptr<DynamicWingController,std::default_delete<DynamicWingController> > > > > >, wingControllerLists
	//_Data: this+0x1288, Member, Type: class std::unique_ptr<Node,std::default_delete<Node> >, colliderModel
	//_Data: this+0x1290, Member, Type: class mat44f, pitPosition
	//_Data: this+0x12D0, Member, Type: struct SlipStream, slipStream
	//_Data: this+0x1338, Member, Type: struct DriverInfo, oldDriverInfo
	//_Data: this+0x13B8, Member, Type: bool, isDisconnected
	//_Data: this+0x13BC, Member, Type: float, lastStepSpeedkmh
	//_Data: this+0x13C0, Member, Type: float, lastStepGas
	//_Data: this+0x13C8, Member, Type: class std::vector<DRSWingSetting,std::allocator<DRSWingSetting> >, drsWingSettings
	//_Data: this+0x13E0, Member, Type: class vec3f, smoothVelocity
	//_Data: this+0x13F0, Member, Type: class Concurrency::concurrent_queue<NetCarState,std::allocator<NetCarState> >, incomingStateQueue
	//_Data: this+0x1418, Member, Type: class std::vector<CarPhysicsState,std::allocator<CarPhysicsState> >, stateCache
	//_Data: this+0x1430, Member, Type: double, lastIntegrationTime
	//_Data: this+0x1438, Member, Type: float[0x4], tyreRadius
	//_Data: this+0x1448, Member, Type: class vec3f, graphicsOffset
	//_Data: this+0x1454, Member, Type: float, graphicsPitchRotation
	//_Data: this+0x1458, Member, Type: class mat44f[0x4], tyreLocalRotation
	//_Data: this+0x1558, Member, Type: class CarAvatar *, avatar
	//_Data: this+0x1560, Member, Type: class IRigidBody *, body
	//_Data: this+0x1568, Member, Type: class vec3f, lastDistanceV
	//_Data: this+0x1574, Member, Type: class vec3f, lastAxis
	//_Data: this+0x1580, Member, Type: struct SplineLocationData, splineLocationData
	//_Data: this+0x1588, Member, Type: double, lastSliceTimeStamp
	//_Data: this+0x1590, Member, Type: float, currentAOA
	//_Data: this+0x1594, Member, Type: float, carVerticalOffset
	//_Data: this+0x1598, Member, Type: bool, useLog
	//_Tag 11
	//_Data: this+0x15A0, Member, Type: struct NetCarStateProvider::LagDebug, lagDebug
	//_Func: private bool isLagging(double  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: private mat44f getTyreMatrix(int  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: private mat44f getSmoothBodyMatrix(double physics_time, CarPhysicsState & state); @loc=static @len=1825 @rva=1151760
	//_Func: private vec3f getNetStateLocalVel(int  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: private vec3f getNetStateVelocity(int  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: private vec3f getNetStateAcceleration(int  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: private vec3f projectNetStatePos(int ti, double t); @loc=static @len=334 @rva=1161472
	//_Func: private double getCorrectionDeltaTime(double  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: private void getNetStateAngularVelocity(int  _arg0, mat44f &  _arg1, mat44f &  _arg2, vec3f &  _arg3, float &  _arg4); @loc=optimized @len=0 @rva=0
	//_Func: private void initPhysicsValues(); @loc=static @len=2715 @rva=1155040
	//_Func: private void step(double physics_time); @loc=static @len=4695 @rva=1162496
	//_Func: private void stepLagging(double physics_time); @loc=static @len=2030 @rva=1167200
	//_Func: private void debugLag(bool isLagging, double physics_time); @loc=static @len=207 @rva=1151312
	//_Func: private void initWings(); @loc=static @len=1884 @rva=1157760
	//_Func: private void stepWings(); @loc=static @len=389 @rva=1169344
	//_Func: private void initP2P(); @loc=static @len=675 @rva=1154352
	//_Func: private void stepP2P(); @loc=static @len=99 @rva=1169232
	//_Func: private void initDRS(); @loc=static @len=706 @rva=1153632
	//_Func: public NetCarStateProvider & operator=(const NetCarStateProvider &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class NetCarStateProvider : public GameObject, public ICarPhysicsStateProvider {
public:
	Event<OnSectorSplitEvent> evOnSectorSplit;
	unsigned char sessionID;
	DriverInfo driverInfo;
	vec3f errorVector;
	int guid;
	int ping;
	unsigned int lastLap;
	unsigned int bestLap;
	std::vector<unsigned int,std::allocator<unsigned int> > currentSplits;
	std::vector<unsigned int,std::allocator<unsigned int> > personalBestSplits;
	double lastUpdateTime;
	double lastTime;
	std::vector<Lap,std::allocator<Lap> > laps;
	NetCarPushToPass p2p;
	bool hasEverReceivedAPacket;
	float ballastKG;
	float restrictor;
	float hasCollisionInThisStep;
	NetCarQoS qos;
	ACClient * client;
	mat44f bodyMatrix;
	mat44f wheelMatrix[4];
	mat44f suspMatrix[4];
	NetCarState netStates[3];
	vec3f lastScreenPos;
	mat44f wheelBasePosLS[4];
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > unixName;
	IRayTrackCollisionProvider * rayCastProvider;
	vec3f lastVelocity;
	vec3f instantVelocity;
	vec3f currentVelocity;
	CarPhysicsState state;
	std::vector<WingState,std::allocator<WingState> > wingStates;
	std::vector<std::vector<std::unique_ptr<DynamicWingController,std::default_delete<DynamicWingController> >,std::allocator<std::unique_ptr<DynamicWingController,std::default_delete<DynamicWingController> > > >,std::allocator<std::vector<std::unique_ptr<DynamicWingController,std::default_delete<DynamicWingController> >,std::allocator<std::unique_ptr<DynamicWingController,std::default_delete<DynamicWingController> > > > > > wingControllerLists;
	std::unique_ptr<Node,std::default_delete<Node> > colliderModel;
	mat44f pitPosition;
	SlipStream slipStream;
	DriverInfo oldDriverInfo;
	bool isDisconnected;
	float lastStepSpeedkmh;
	float lastStepGas;
	std::vector<DRSWingSetting,std::allocator<DRSWingSetting> > drsWingSettings;
	vec3f smoothVelocity;
	Concurrency::concurrent_queue<NetCarState,std::allocator<NetCarState> > incomingStateQueue;
	std::vector<CarPhysicsState,std::allocator<CarPhysicsState> > stateCache;
	double lastIntegrationTime;
	float tyreRadius[4];
	vec3f graphicsOffset;
	float graphicsPitchRotation;
	mat44f tyreLocalRotation[4];
	CarAvatar * avatar;
	IRigidBody * body;
	vec3f lastDistanceV;
	vec3f lastAxis;
	SplineLocationData splineLocationData;
	double lastSliceTimeStamp;
	float currentAOA;
	float carVerticalOffset;
	bool useLog;
	NetCarStateProvider_LagDebug lagDebug;
	inline NetCarStateProvider() { }
	inline NetCarStateProvider(const NetCarStateProvider& other) = default;
	inline NetCarStateProvider& operator=(const NetCarStateProvider& other) = default;
	inline void ctor(const NetCarStateProviderDef & def) { typedef void (NetCarStateProvider::*_fpt)(const NetCarStateProviderDef &); auto _f=xcast<_fpt>(_drva(1141872)); (this->*_f)(def); }
	virtual ~NetCarStateProvider();
	inline void dtor() { typedef void (NetCarStateProvider::*_fpt)(); auto _f=xcast<_fpt>(_drva(1147072)); (this->*_f)(); }
	virtual void update_vf1(float dt);
	inline void update_impl(float dt) { typedef void (NetCarStateProvider::*_fpt)(float); auto _f=xcast<_fpt>(_drva(1169744)); return (this->*_f)(dt); }
	inline void update(float dt) { typedef void (NetCarStateProvider::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(dt); }
	virtual void getPhysicsState_vf1(CarPhysicsState & physicsState);
	inline void getPhysicsState_impl(CarPhysicsState & physicsState) { typedef void (NetCarStateProvider::*_fpt)(CarPhysicsState &); auto _f=xcast<_fpt>(_drva(1151520)); return (this->*_f)(physicsState); }
	inline void getPhysicsState(CarPhysicsState & physicsState) { typedef void (NetCarStateProvider::*_fpt)(CarPhysicsState &); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(physicsState); }
	virtual void getWingState_vf2(std::vector<WingState,std::allocator<WingState> > & ws);
	inline void getWingState_impl(std::vector<WingState,std::allocator<WingState> > & ws) { typedef void (NetCarStateProvider::*_fpt)(std::vector<WingState,std::allocator<WingState> > &); auto _f=xcast<_fpt>(_drva(1153600)); return (this->*_f)(ws); }
	inline void getWingState(std::vector<WingState,std::allocator<WingState> > & ws) { typedef void (NetCarStateProvider::*_fpt)(std::vector<WingState,std::allocator<WingState> > &); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)(ws); }
	inline void onRemoteStateReceived(NetCarState & s) { typedef void (NetCarStateProvider::*_fpt)(NetCarState &); auto _f=xcast<_fpt>(_drva(1159648)); return (this->*_f)(s); }
	inline void setCarAvatar(CarAvatar * av) { typedef void (NetCarStateProvider::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(1162368)); return (this->*_f)(av); }
	inline void resetDamage() { typedef void (NetCarStateProvider::*_fpt)(); auto _f=xcast<_fpt>(_drva(1162048)); return (this->*_f)(); }
	inline void setDamageZoneLevel(float * zones) { typedef void (NetCarStateProvider::*_fpt)(float *); auto _f=xcast<_fpt>(_drva(1162464)); return (this->*_f)(zones); }
	inline void activateP2P() { typedef void (NetCarStateProvider::*_fpt)(); auto _f=xcast<_fpt>(_drva(1150672)); return (this->*_f)(); }
	inline mat44f getSmoothBodyMatrix(double physics_time, CarPhysicsState & state) { typedef mat44f (NetCarStateProvider::*_fpt)(double, CarPhysicsState &); auto _f=xcast<_fpt>(_drva(1151760)); return (this->*_f)(physics_time, state); }
	inline vec3f projectNetStatePos(int ti, double t) { typedef vec3f (NetCarStateProvider::*_fpt)(int, double); auto _f=xcast<_fpt>(_drva(1161472)); return (this->*_f)(ti, t); }
	inline void initPhysicsValues() { typedef void (NetCarStateProvider::*_fpt)(); auto _f=xcast<_fpt>(_drva(1155040)); return (this->*_f)(); }
	inline void step(double physics_time) { typedef void (NetCarStateProvider::*_fpt)(double); auto _f=xcast<_fpt>(_drva(1162496)); return (this->*_f)(physics_time); }
	inline void stepLagging(double physics_time) { typedef void (NetCarStateProvider::*_fpt)(double); auto _f=xcast<_fpt>(_drva(1167200)); return (this->*_f)(physics_time); }
	inline void debugLag(bool isLagging, double physics_time) { typedef void (NetCarStateProvider::*_fpt)(bool, double); auto _f=xcast<_fpt>(_drva(1151312)); return (this->*_f)(isLagging, physics_time); }
	inline void initWings() { typedef void (NetCarStateProvider::*_fpt)(); auto _f=xcast<_fpt>(_drva(1157760)); return (this->*_f)(); }
	inline void stepWings() { typedef void (NetCarStateProvider::*_fpt)(); auto _f=xcast<_fpt>(_drva(1169344)); return (this->*_f)(); }
	inline void initP2P() { typedef void (NetCarStateProvider::*_fpt)(); auto _f=xcast<_fpt>(_drva(1154352)); return (this->*_f)(); }
	inline void stepP2P() { typedef void (NetCarStateProvider::*_fpt)(); auto _f=xcast<_fpt>(_drva(1169232)); return (this->*_f)(); }
	inline void initDRS() { typedef void (NetCarStateProvider::*_fpt)(); auto _f=xcast<_fpt>(_drva(1153632)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(NetCarStateProvider)==5560),"bad size");
		static_assert((offsetof(NetCarStateProvider,evOnSectorSplit)==0x60),"bad off");
		static_assert((offsetof(NetCarStateProvider,sessionID)==0x78),"bad off");
		static_assert((offsetof(NetCarStateProvider,driverInfo)==0x80),"bad off");
		static_assert((offsetof(NetCarStateProvider,errorVector)==0x100),"bad off");
		static_assert((offsetof(NetCarStateProvider,guid)==0x10C),"bad off");
		static_assert((offsetof(NetCarStateProvider,ping)==0x110),"bad off");
		static_assert((offsetof(NetCarStateProvider,lastLap)==0x114),"bad off");
		static_assert((offsetof(NetCarStateProvider,bestLap)==0x118),"bad off");
		static_assert((offsetof(NetCarStateProvider,currentSplits)==0x120),"bad off");
		static_assert((offsetof(NetCarStateProvider,personalBestSplits)==0x138),"bad off");
		static_assert((offsetof(NetCarStateProvider,lastUpdateTime)==0x150),"bad off");
		static_assert((offsetof(NetCarStateProvider,lastTime)==0x158),"bad off");
		static_assert((offsetof(NetCarStateProvider,laps)==0x160),"bad off");
		static_assert((offsetof(NetCarStateProvider,p2p)==0x178),"bad off");
		static_assert((offsetof(NetCarStateProvider,hasEverReceivedAPacket)==0x18C),"bad off");
		static_assert((offsetof(NetCarStateProvider,ballastKG)==0x190),"bad off");
		static_assert((offsetof(NetCarStateProvider,restrictor)==0x194),"bad off");
		static_assert((offsetof(NetCarStateProvider,hasCollisionInThisStep)==0x198),"bad off");
		static_assert((offsetof(NetCarStateProvider,qos)==0x19C),"bad off");
		static_assert((offsetof(NetCarStateProvider,client)==0x1A8),"bad off");
		static_assert((offsetof(NetCarStateProvider,bodyMatrix)==0x1B0),"bad off");
		static_assert((offsetof(NetCarStateProvider,wheelMatrix)==0x1F0),"bad off");
		static_assert((offsetof(NetCarStateProvider,suspMatrix)==0x2F0),"bad off");
		static_assert((offsetof(NetCarStateProvider,netStates)==0x3F0),"bad off");
		static_assert((offsetof(NetCarStateProvider,lastScreenPos)==0x588),"bad off");
		static_assert((offsetof(NetCarStateProvider,wheelBasePosLS)==0x594),"bad off");
		static_assert((offsetof(NetCarStateProvider,unixName)==0x698),"bad off");
		static_assert((offsetof(NetCarStateProvider,rayCastProvider)==0x6B8),"bad off");
		static_assert((offsetof(NetCarStateProvider,lastVelocity)==0x6C0),"bad off");
		static_assert((offsetof(NetCarStateProvider,instantVelocity)==0x6CC),"bad off");
		static_assert((offsetof(NetCarStateProvider,currentVelocity)==0x6D8),"bad off");
		static_assert((offsetof(NetCarStateProvider,state)==0x6E8),"bad off");
		static_assert((offsetof(NetCarStateProvider,wingStates)==0x1258),"bad off");
		static_assert((offsetof(NetCarStateProvider,wingControllerLists)==0x1270),"bad off");
		static_assert((offsetof(NetCarStateProvider,colliderModel)==0x1288),"bad off");
		static_assert((offsetof(NetCarStateProvider,pitPosition)==0x1290),"bad off");
		static_assert((offsetof(NetCarStateProvider,slipStream)==0x12D0),"bad off");
		static_assert((offsetof(NetCarStateProvider,oldDriverInfo)==0x1338),"bad off");
		static_assert((offsetof(NetCarStateProvider,isDisconnected)==0x13B8),"bad off");
		static_assert((offsetof(NetCarStateProvider,lastStepSpeedkmh)==0x13BC),"bad off");
		static_assert((offsetof(NetCarStateProvider,lastStepGas)==0x13C0),"bad off");
		static_assert((offsetof(NetCarStateProvider,drsWingSettings)==0x13C8),"bad off");
		static_assert((offsetof(NetCarStateProvider,smoothVelocity)==0x13E0),"bad off");
		static_assert((offsetof(NetCarStateProvider,incomingStateQueue)==0x13F0),"bad off");
		static_assert((offsetof(NetCarStateProvider,stateCache)==0x1418),"bad off");
		static_assert((offsetof(NetCarStateProvider,lastIntegrationTime)==0x1430),"bad off");
		static_assert((offsetof(NetCarStateProvider,tyreRadius)==0x1438),"bad off");
		static_assert((offsetof(NetCarStateProvider,graphicsOffset)==0x1448),"bad off");
		static_assert((offsetof(NetCarStateProvider,graphicsPitchRotation)==0x1454),"bad off");
		static_assert((offsetof(NetCarStateProvider,tyreLocalRotation)==0x1458),"bad off");
		static_assert((offsetof(NetCarStateProvider,avatar)==0x1558),"bad off");
		static_assert((offsetof(NetCarStateProvider,body)==0x1560),"bad off");
		static_assert((offsetof(NetCarStateProvider,lastDistanceV)==0x1568),"bad off");
		static_assert((offsetof(NetCarStateProvider,lastAxis)==0x1574),"bad off");
		static_assert((offsetof(NetCarStateProvider,splineLocationData)==0x1580),"bad off");
		static_assert((offsetof(NetCarStateProvider,lastSliceTimeStamp)==0x1588),"bad off");
		static_assert((offsetof(NetCarStateProvider,currentAOA)==0x1590),"bad off");
		static_assert((offsetof(NetCarStateProvider,carVerticalOffset)==0x1594),"bad off");
		static_assert((offsetof(NetCarStateProvider,useLog)==0x1598),"bad off");
		static_assert((offsetof(NetCarStateProvider,lagDebug)==0x15A0),"bad off");
	};
};

//UDT: class GraphicsManager @len=1248 @vfcount=1
	//_VTable: 
	//_Func: public void GraphicsManager(const GraphicsManager &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void GraphicsManager(const VideoSettings & ivideoSettings); @loc=static @len=1912 @rva=2102816
	//_Func: public void ~GraphicsManager(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=610 @rva=2105552
	//_Data: this+0x8, Member, Type: bool, useCustomSunDirection
	//_Data: this+0xC, Member, Type: float, exposureMultiplier
	//_Data: this+0x10, Member, Type: struct VideoSettings, videoSettings
	//_Data: this+0x60, Member, Type: struct RenderStats, stats
	//_Data: this+0x74, Member, Type: struct LightingSettings, lightingSettings
	//_Data: this+0x128, Member, Type: struct RendererFlags, renderFlags
	//_Data: this+0x130, Member, Type: bool, suspendViewportUpdateOnSetRenderTarget
	//_Data: this+0x138, Member, Type: class GPUProfiler *, gpuProfiler
	//_Data: this+0x140, Member, Type: class PvsProcessor *, pvsProcessor
	//_Data: this+0x148, Member, Type: class CubeMap *, currentCubeMap
	//_Data: this+0x150, Member, Type: class Event<OnWindowResize>, evWindowResize
	//_Data: this+0x168, Member, Type: class Event<OnWindowResize>, evWindowPreResize
	//_Data: this+0x180, Member, Type: class std::unique_ptr<ResourceStore,std::default_delete<ResourceStore> >, resourceStore
	//_Func: public SamplerStates & getSampleStates(); @loc=optimized @len=0 @rva=0
	//_Func: public std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > getErrorStrings(); @loc=static @len=41 @rva=2107968
	//_Func: public void addErrorString(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void beginMainRenderPass(); @loc=static @len=5 @rva=2106736
	//_Func: public void endMainRenderPass(); @loc=static @len=5 @rva=2107456
	//_Func: public GLRenderer & getGL(); @loc=static @len=8 @rva=148688
	//_Func: public GLRenderer * createGLRenderer(unsigned int maxVertices); @loc=static @len=220 @rva=2107152
	//_Func: public void clearRenderTarget(const vec4f & color); @loc=static @len=8 @rva=2106944
	//_Func: public void clearRenderTargetDepth(float value); @loc=static @len=8 @rva=2106960
	//_Func: public void beginScene(); @loc=static @len=177 @rva=2106752
	//_Func: public void endScene(); @loc=static @len=148 @rva=2107472
	//_Func: public void setViewport(int left, int top, int width, int height); @loc=static @len=170 @rva=2117616
	//_Func: public void drawPrimitive(unsigned int indicesCount, unsigned int baseIndex, unsigned int baseVertex, unsigned int numVertices); @loc=static @len=68 @rva=2107376
	//_Func: public void render(Node *  _arg0, RenderContext *  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public void compile(Node * root); @loc=static @len=36 @rva=2107104
	//_Func: public void setScreenSpaceMode(); @loc=static @len=275 @rva=2115808
	//_Func: public void onResize(int width, int height); @loc=static @len=215 @rva=2114352
	//_Func: public void updateLightingSetttings(); @loc=static @len=1752 @rva=2118032
	//_Func: public void loadLightingSettings(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & filename); @loc=static @len=4184 @rva=2110032
	//_Func: public void loadLightingSettings(); @loc=static @len=127 @rva=2114224
	//_Func: public void setOverrideNoMS(bool  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void resetRenderStates(); @loc=static @len=147 @rva=2114624
	//_Func: public bool setMaximumFrameLatency(int  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void overrideSamplerState(SamplerState sampler); @loc=static @len=43 @rva=2114576
	//_Func: public Shader * getShader(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name); @loc=static @len=46 @rva=2108512
	//_Func: public void setShader(Shader * sh); @loc=static @len=51 @rva=2116096
	//_Func: public std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > getShaders(); @loc=optimized @len=0 @rva=0
	//_Func: public void initShaders(); @loc=optimized @len=0 @rva=0
	//_Func: public void setBlendMode(BlendMode mode); @loc=static @len=47 @rva=2114784
	//_Func: public void commitShaderChanges(); @loc=static @len=62 @rva=2107040
	//_Func: public void setDepthMode(DepthMode mode); @loc=static @len=164 @rva=2114944
	//_Func: public void setCullMode(CullMode mode); @loc=static @len=66 @rva=2114832
	//_Func: public void setShadowMapBias(float b0, float b1, float b2); @loc=static @len=169 @rva=2116160
	//_Func: public vec3f getShadowMapBias(); @loc=static @len=48 @rva=2108560
	//_Func: public void setProjectionMatrix(const mat44f & matrix); @loc=static @len=256 @rva=2115168
	//_Func: public void setViewMatrix(const mat44f & matrix, Camera * camera); @loc=static @len=747 @rva=2116864
	//_Func: public void setWorldMatrix(const mat44f & matrix); @loc=static @len=239 @rva=2117792
	//_Func: public mat44f getWorldMatrix(); @loc=static @len=47 @rva=2108656
	//_Func: public mat44f getProjectionMatrix(); @loc=static @len=47 @rva=2108464
	//_Func: public mat44f getViewMatrix(); @loc=static @len=47 @rva=2108608
	//_Func: public void setVB(IVertexBuffer * vb); @loc=static @len=8 @rva=2116848
	//_Func: public void setIB(IndexBuffer * ib); @loc=static @len=9 @rva=2115152
	//_Func: public CBuffer * getCBuffer(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name); @loc=static @len=332 @rva=2107632
	//_Func: public void setRenderTarget(RenderTarget * rt); @loc=static @len=148 @rva=2115424
	//_Func: public void setTextureRT(unsigned int slot, RenderTarget * rt); @loc=static @len=19 @rva=2116816
	//_Func: public void setDepthTextureRT(unsigned int slot, RenderTarget * rt); @loc=static @len=19 @rva=2115120
	//_Func: public void setScreenRenderTargets(); @loc=static @len=88 @rva=2115712
	//_Func: public void setTexture(int slot, const Texture & tex); @loc=static @len=96 @rva=2116720
	//_Func: public void setShadowMapTexture(int level, RenderTarget * rt); @loc=static @len=116 @rva=2116592
	//_Func: public void setShadowMapMatrix(int level, const mat44f & matrix); @loc=static @len=244 @rva=2116336
	//_Func: public void setCustomSunDirection(vec3f sunDirection); @loc=static @len=22 @rva=2114912
	//_Func: public void setSamplerState(); @loc=static @len=113 @rva=2115584
	//_Func: public void clearTextureSlot(int slot); @loc=static @len=50 @rva=2106976
	//_Func: public vec3f getLDRColor(const vec3f & c); @loc=static @len=308 @rva=2108016
	//_Func: public float getLDRScale(const vec3f & c); @loc=static @len=119 @rva=2108336
	//_Data: this+0x188, Member, Type: struct RenderState, state
	//_Data: this+0x380, Member, Type: class GLRenderer *, gl
	//_Data: this+0x388, Member, Type: class vec3f, customSunDirection
	//_Data: this+0x398, Member, Type: class std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, errorStrings
	//_Data: this+0x3B0, Member, Type: class std::vector<GLRenderer *,std::allocator<GLRenderer *> >, glRenderers
	//_Data: this+0x3C8, Member, Type: int, multiSampleQuality
	//_Data: this+0x3D0, Member, Type: struct SamplerStates, samplerStates
	//_Data: this+0x408, Member, Type: struct SystemCBuffers, sysBuffers
	//_Data: this+0x4A8, Member, Type: class std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,CBuffer *,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,CBuffer *> > >, cBuffersMap
	//_Data: this+0x4B8, Member, Type: class ShaderManager, shaderManager
	//_Func: protected void initRenderFlags(); @loc=static @len=529 @rva=2109280
	//_Func: protected void initSamplerStates(); @loc=static @len=194 @rva=2109824
	//_Func: protected void initCBuffers(); @loc=static @len=563 @rva=2108704
	//_Func: public GraphicsManager & operator=(const GraphicsManager &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class GraphicsManager {
public:
	bool useCustomSunDirection;
	float exposureMultiplier;
	VideoSettings videoSettings;
	RenderStats stats;
	LightingSettings lightingSettings;
	RendererFlags renderFlags;
	bool suspendViewportUpdateOnSetRenderTarget;
	GPUProfiler * gpuProfiler;
	PvsProcessor * pvsProcessor;
	CubeMap * currentCubeMap;
	Event<OnWindowResize> evWindowResize;
	Event<OnWindowResize> evWindowPreResize;
	std::unique_ptr<ResourceStore,std::default_delete<ResourceStore> > resourceStore;
	RenderState state;
	GLRenderer * gl;
	vec3f customSunDirection;
	std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > errorStrings;
	std::vector<GLRenderer *,std::allocator<GLRenderer *> > glRenderers;
	int multiSampleQuality;
	SamplerStates samplerStates;
	SystemCBuffers sysBuffers;
	std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,CBuffer *,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,CBuffer *> > > cBuffersMap;
	ShaderManager shaderManager;
	inline GraphicsManager() { }
	inline GraphicsManager(const GraphicsManager& other) = default;
	inline GraphicsManager& operator=(const GraphicsManager& other) = default;
	inline void ctor(const VideoSettings & ivideoSettings) { typedef void (GraphicsManager::*_fpt)(const VideoSettings &); auto _f=xcast<_fpt>(_drva(2102816)); (this->*_f)(ivideoSettings); }
	virtual ~GraphicsManager();
	inline void dtor() { typedef void (GraphicsManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2105552)); (this->*_f)(); }
	inline std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > getErrorStrings() { typedef std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > (GraphicsManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2107968)); return (this->*_f)(); }
	inline void beginMainRenderPass() { typedef void (GraphicsManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2106736)); return (this->*_f)(); }
	inline void endMainRenderPass() { typedef void (GraphicsManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2107456)); return (this->*_f)(); }
	inline GLRenderer & getGL() { typedef GLRenderer & (GraphicsManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(148688)); return (this->*_f)(); }
	inline GLRenderer * createGLRenderer(unsigned int maxVertices) { typedef GLRenderer * (GraphicsManager::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(2107152)); return (this->*_f)(maxVertices); }
	inline void clearRenderTarget(const vec4f & color) { typedef void (GraphicsManager::*_fpt)(const vec4f &); auto _f=xcast<_fpt>(_drva(2106944)); return (this->*_f)(color); }
	inline void clearRenderTargetDepth(float value) { typedef void (GraphicsManager::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2106960)); return (this->*_f)(value); }
	inline void beginScene() { typedef void (GraphicsManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2106752)); return (this->*_f)(); }
	inline void endScene() { typedef void (GraphicsManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2107472)); return (this->*_f)(); }
	inline void setViewport(int left, int top, int width, int height) { typedef void (GraphicsManager::*_fpt)(int, int, int, int); auto _f=xcast<_fpt>(_drva(2117616)); return (this->*_f)(left, top, width, height); }
	inline void drawPrimitive(unsigned int indicesCount, unsigned int baseIndex, unsigned int baseVertex, unsigned int numVertices) { typedef void (GraphicsManager::*_fpt)(unsigned int, unsigned int, unsigned int, unsigned int); auto _f=xcast<_fpt>(_drva(2107376)); return (this->*_f)(indicesCount, baseIndex, baseVertex, numVertices); }
	inline void compile(Node * root) { typedef void (GraphicsManager::*_fpt)(Node *); auto _f=xcast<_fpt>(_drva(2107104)); return (this->*_f)(root); }
	inline void setScreenSpaceMode() { typedef void (GraphicsManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2115808)); return (this->*_f)(); }
	inline void onResize(int width, int height) { typedef void (GraphicsManager::*_fpt)(int, int); auto _f=xcast<_fpt>(_drva(2114352)); return (this->*_f)(width, height); }
	inline void updateLightingSetttings() { typedef void (GraphicsManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2118032)); return (this->*_f)(); }
	inline void loadLightingSettings(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & filename) { typedef void (GraphicsManager::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2110032)); return (this->*_f)(filename); }
	inline void loadLightingSettings() { typedef void (GraphicsManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2114224)); return (this->*_f)(); }
	inline void resetRenderStates() { typedef void (GraphicsManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2114624)); return (this->*_f)(); }
	inline void overrideSamplerState(SamplerState sampler) { typedef void (GraphicsManager::*_fpt)(SamplerState); auto _f=xcast<_fpt>(_drva(2114576)); return (this->*_f)(sampler); }
	inline Shader * getShader(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name) { typedef Shader * (GraphicsManager::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2108512)); return (this->*_f)(name); }
	inline void setShader(Shader * sh) { typedef void (GraphicsManager::*_fpt)(Shader *); auto _f=xcast<_fpt>(_drva(2116096)); return (this->*_f)(sh); }
	inline void setBlendMode(BlendMode mode) { typedef void (GraphicsManager::*_fpt)(BlendMode); auto _f=xcast<_fpt>(_drva(2114784)); return (this->*_f)(mode); }
	inline void commitShaderChanges() { typedef void (GraphicsManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2107040)); return (this->*_f)(); }
	inline void setDepthMode(DepthMode mode) { typedef void (GraphicsManager::*_fpt)(DepthMode); auto _f=xcast<_fpt>(_drva(2114944)); return (this->*_f)(mode); }
	inline void setCullMode(CullMode mode) { typedef void (GraphicsManager::*_fpt)(CullMode); auto _f=xcast<_fpt>(_drva(2114832)); return (this->*_f)(mode); }
	inline void setShadowMapBias(float b0, float b1, float b2) { typedef void (GraphicsManager::*_fpt)(float, float, float); auto _f=xcast<_fpt>(_drva(2116160)); return (this->*_f)(b0, b1, b2); }
	inline vec3f getShadowMapBias() { typedef vec3f (GraphicsManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2108560)); return (this->*_f)(); }
	inline void setProjectionMatrix(const mat44f & matrix) { typedef void (GraphicsManager::*_fpt)(const mat44f &); auto _f=xcast<_fpt>(_drva(2115168)); return (this->*_f)(matrix); }
	inline void setViewMatrix(const mat44f & matrix, Camera * camera) { typedef void (GraphicsManager::*_fpt)(const mat44f &, Camera *); auto _f=xcast<_fpt>(_drva(2116864)); return (this->*_f)(matrix, camera); }
	inline void setWorldMatrix(const mat44f & matrix) { typedef void (GraphicsManager::*_fpt)(const mat44f &); auto _f=xcast<_fpt>(_drva(2117792)); return (this->*_f)(matrix); }
	inline mat44f getWorldMatrix() { typedef mat44f (GraphicsManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2108656)); return (this->*_f)(); }
	inline mat44f getProjectionMatrix() { typedef mat44f (GraphicsManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2108464)); return (this->*_f)(); }
	inline mat44f getViewMatrix() { typedef mat44f (GraphicsManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2108608)); return (this->*_f)(); }
	inline void setVB(IVertexBuffer * vb) { typedef void (GraphicsManager::*_fpt)(IVertexBuffer *); auto _f=xcast<_fpt>(_drva(2116848)); return (this->*_f)(vb); }
	inline void setIB(IndexBuffer * ib) { typedef void (GraphicsManager::*_fpt)(IndexBuffer *); auto _f=xcast<_fpt>(_drva(2115152)); return (this->*_f)(ib); }
	inline CBuffer * getCBuffer(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name) { typedef CBuffer * (GraphicsManager::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2107632)); return (this->*_f)(name); }
	inline void setRenderTarget(RenderTarget * rt) { typedef void (GraphicsManager::*_fpt)(RenderTarget *); auto _f=xcast<_fpt>(_drva(2115424)); return (this->*_f)(rt); }
	inline void setTextureRT(unsigned int slot, RenderTarget * rt) { typedef void (GraphicsManager::*_fpt)(unsigned int, RenderTarget *); auto _f=xcast<_fpt>(_drva(2116816)); return (this->*_f)(slot, rt); }
	inline void setDepthTextureRT(unsigned int slot, RenderTarget * rt) { typedef void (GraphicsManager::*_fpt)(unsigned int, RenderTarget *); auto _f=xcast<_fpt>(_drva(2115120)); return (this->*_f)(slot, rt); }
	inline void setScreenRenderTargets() { typedef void (GraphicsManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2115712)); return (this->*_f)(); }
	inline void setTexture(int slot, const Texture & tex) { typedef void (GraphicsManager::*_fpt)(int, const Texture &); auto _f=xcast<_fpt>(_drva(2116720)); return (this->*_f)(slot, tex); }
	inline void setShadowMapTexture(int level, RenderTarget * rt) { typedef void (GraphicsManager::*_fpt)(int, RenderTarget *); auto _f=xcast<_fpt>(_drva(2116592)); return (this->*_f)(level, rt); }
	inline void setShadowMapMatrix(int level, const mat44f & matrix) { typedef void (GraphicsManager::*_fpt)(int, const mat44f &); auto _f=xcast<_fpt>(_drva(2116336)); return (this->*_f)(level, matrix); }
	inline void setCustomSunDirection(vec3f sunDirection) { typedef void (GraphicsManager::*_fpt)(vec3f); auto _f=xcast<_fpt>(_drva(2114912)); return (this->*_f)(sunDirection); }
	inline void setSamplerState() { typedef void (GraphicsManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2115584)); return (this->*_f)(); }
	inline void clearTextureSlot(int slot) { typedef void (GraphicsManager::*_fpt)(int); auto _f=xcast<_fpt>(_drva(2106976)); return (this->*_f)(slot); }
	inline vec3f getLDRColor(const vec3f & c) { typedef vec3f (GraphicsManager::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2108016)); return (this->*_f)(c); }
	inline float getLDRScale(const vec3f & c) { typedef float (GraphicsManager::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2108336)); return (this->*_f)(c); }
	inline void initRenderFlags() { typedef void (GraphicsManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2109280)); return (this->*_f)(); }
	inline void initSamplerStates() { typedef void (GraphicsManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2109824)); return (this->*_f)(); }
	inline void initCBuffers() { typedef void (GraphicsManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2108704)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(GraphicsManager)==1248),"bad size");
		static_assert((offsetof(GraphicsManager,useCustomSunDirection)==0x8),"bad off");
		static_assert((offsetof(GraphicsManager,exposureMultiplier)==0xC),"bad off");
		static_assert((offsetof(GraphicsManager,videoSettings)==0x10),"bad off");
		static_assert((offsetof(GraphicsManager,stats)==0x60),"bad off");
		static_assert((offsetof(GraphicsManager,lightingSettings)==0x74),"bad off");
		static_assert((offsetof(GraphicsManager,renderFlags)==0x128),"bad off");
		static_assert((offsetof(GraphicsManager,suspendViewportUpdateOnSetRenderTarget)==0x130),"bad off");
		static_assert((offsetof(GraphicsManager,gpuProfiler)==0x138),"bad off");
		static_assert((offsetof(GraphicsManager,pvsProcessor)==0x140),"bad off");
		static_assert((offsetof(GraphicsManager,currentCubeMap)==0x148),"bad off");
		static_assert((offsetof(GraphicsManager,evWindowResize)==0x150),"bad off");
		static_assert((offsetof(GraphicsManager,evWindowPreResize)==0x168),"bad off");
		static_assert((offsetof(GraphicsManager,resourceStore)==0x180),"bad off");
		static_assert((offsetof(GraphicsManager,state)==0x188),"bad off");
		static_assert((offsetof(GraphicsManager,gl)==0x380),"bad off");
		static_assert((offsetof(GraphicsManager,customSunDirection)==0x388),"bad off");
		static_assert((offsetof(GraphicsManager,errorStrings)==0x398),"bad off");
		static_assert((offsetof(GraphicsManager,glRenderers)==0x3B0),"bad off");
		static_assert((offsetof(GraphicsManager,multiSampleQuality)==0x3C8),"bad off");
		static_assert((offsetof(GraphicsManager,samplerStates)==0x3D0),"bad off");
		static_assert((offsetof(GraphicsManager,sysBuffers)==0x408),"bad off");
		static_assert((offsetof(GraphicsManager,cBuffersMap)==0x4A8),"bad off");
		static_assert((offsetof(GraphicsManager,shaderManager)==0x4B8),"bad off");
	};
};

//UDT: class ACClient @len=67608 @vfcount=6
	//_Base: class GameObject @off=0 @len=88
	//_Func: public void ACClient(const ACClient &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void ACClient(Sim * isim); @loc=static @len=3257 @rva=238272
	//_Func: public void ~ACClient(); @virtual vtpo=0 vfid=0 @loc=static @len=1088 @rva=244880
	//_Data: this+0x58, Member, Type: class Event<OnChatMessageEvent>, evOnChatMessage
	//_Data: this+0x70, Member, Type: class Event<RemoteSession>, evOnOnlineNewSession
	//_Data: this+0x88, Member, Type: class Event<RemoteSessionResume>, evOnOnlineEndSession
	//_Data: this+0xA0, Member, Type: class Event<OnLapCompletedEvent>, evOnLapCompleted
	//_Data: this+0xB8, Member, Type: class Event<ReceivedVoteDef>, evOnVoteReceived
	//_Data: this+0xD0, Member, Type: class Event<bool>, evOnVoteNotPassed
	//_Data: this+0xE8, Member, Type: class Event<bool>, evOnMandatoryPitDone
	//_Data: this+0x100, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, serverName
	//_Data: this+0x120, Member, Type: float, remoteSpring
	//_Data: this+0x124, Member, Type: float, remoteDamper
	//_Data: this+0x128, Member, Type: float, remoteFactor
	//_Data: this+0x130, Member, Type: struct DriverInfo, driverInfo
	//_Data: this+0x1B0, Member, Type: struct ServerInfo, serverInfo
	//_Data: this+0x1F8, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, guid
	//_Data: this+0x218, Member, Type: struct ClientRules, rules
	//_Data: this+0x21C, Member, Type: struct ServerDrivingAssists, serverDrivingAssists
	//_Data: this+0x228, Member, Type: bool, isTVMode
	//_Data: this+0x230, Member, Type: double, handshakeServerTimeS
	//_Data: this+0x238, Member, Type: class std::vector<unsigned char,std::allocator<unsigned char> >, playerCarMD5
	//_Func: public void renderHUD(float dt); @virtual vtpo=0 vfid=3 @loc=static @len=723 @rva=333392
	//_Func: public ClientHandshakeResult handshakeTCP(); @loc=static @len=8613 @rva=297808
	//_Func: public bool getRemoteCarList(std::vector<ClientRemoteCarDef,std::allocator<ClientRemoteCarDef> > & remoteCars); @loc=static @len=4972 @rva=290688
	//_Func: public void beginUpdateMode(); @loc=static @len=284 @rva=280288
	//_Func: public void sendChat(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & message); @loc=static @len=263 @rva=338576
	//_Func: public void sendVote(VoteType aVote, bool aVoteValue, int targetAvatarGUID); @loc=static @len=253 @rva=338848
	//_Func: public bool hasVoted(); @loc=static @len=12 @rva=306432
	//_Func: public CarAvatar * getCurrentVotingTarget(); @loc=static @len=12 @rva=287824
	//_Func: public float getVotingTimeLeft(); @loc=static @len=13 @rva=296512
	//_Func: public VoteType getCurrentVoteType(); @loc=static @len=11 @rva=287808
	//_Func: public float getVotingMaxTime(); @loc=static @len=13 @rva=296496
	//_Func: public void addNetCar(NetCarStateProvider * nc); @loc=static @len=31 @rva=279232
	//_Func: public NetCarStateProvider * getNetCarFromSessionID(unsigned char id); @loc=static @len=44 @rva=290528
	//_Func: public void update(float deltaT); @virtual vtpo=0 vfid=1 @loc=static @len=1323 @rva=342832
	//_Func: public double getPhysicsTime(); @loc=static @len=20 @rva=290576
	//_Func: public bool isAllowedToSendChatMessage(); @loc=static @len=29 @rva=307616
	//_Func: public int getPing(CarAvatar * anAvatar); @loc=static @len=75 @rva=290608
	//_Func: public int getQOS(); @loc=optimized @len=0 @rva=0
	//_Func: public RemoteSession getCurrentSession(); @loc=static @len=41 @rva=287648
	//_Func: public const RemoteSessionResult & getCurrentSessionResults(); @loc=static @len=8 @rva=287792
	//_Func: public CarAvatar * getCarAvatarFromSessionID(unsigned char sesid); @loc=static @len=107 @rva=286720
	//_Func: public int getSessionIDFromCarAvatar(CarAvatar * anAvatar); @loc=static @len=78 @rva=295696
	//_Func: public int getSessionCount(); @loc=static @len=19 @rva=295664
	//_Func: public int getCurrentSessionIndex(); @loc=static @len=88 @rva=287696
	//_Func: public RemoteSession getSessionInfo(int index); @loc=static @len=152 @rva=295936
	//_Func: public void shutdown(); @virtual vtpo=0 vfid=5 @loc=static @len=120 @rva=339248
	//_Func: public double getSessionTimeLeft(); @loc=static @len=57 @rva=296096
	//_Func: public double getSessionOverTime(); @loc=optimized @len=0 @rva=0
	//_Func: public int getFinishPosition(); @loc=optimized @len=0 @rva=0
	//_Func: public int getHandshakeCarPosition(); @loc=static @len=7 @rva=1278848
	//_Func: public unsigned int getCarPosition(CarAvatar * car); @loc=static @len=189 @rva=287168
	//_Func: public unsigned int getBestLap(); @loc=optimized @len=0 @rva=0
	//_Func: public unsigned int getBestLap(CarAvatar * car); @loc=static @len=108 @rva=286272
	//_Func: public unsigned int getInstanceBestLap(CarAvatar * car); @loc=static @len=108 @rva=287856
	//_Func: public Lap getLastLap(CarAvatar * car); @loc=static @len=325 @rva=290000
	//_Func: public unsigned int getLapCount(CarAvatar * car); @loc=static @len=177 @rva=287968
	//_Func: public void getLaps(CarAvatar * car, std::vector<Lap,std::allocator<Lap> > & laps); @loc=static @len=1834 @rva=288160
	//_Func: public bool isBestSplit(const int & sector, const int & t, const bool & isGlobal, CarAvatar * car); @loc=static @len=202 @rva=307648
	//_Func: public unsigned int getBestSplit(const int & sector, const bool & isGlobal, CarAvatar * car); @loc=static @len=322 @rva=286384
	//_Func: public unsigned int getLastSplit(CarAvatar * car, const int & sector); @loc=static @len=178 @rva=290336
	//_Func: public unsigned int getSplit(CarAvatar * car, const int & sector); @loc=static @len=274 @rva=296160
	//_Func: public void addSplitToBest(std::vector<unsigned int,std::allocator<unsigned int> > & splits, std::vector<unsigned int,std::allocator<unsigned int> > & personalSplits, const unsigned int & sector, const unsigned int & time, const unsigned int & cuts); @loc=static @len=397 @rva=279264
	//_Func: public void storeSplitToLap(std::vector<unsigned int,std::allocator<unsigned int> > & splits, std::vector<unsigned int,std::allocator<unsigned int> > & personalSplits, std::vector<Lap,std::allocator<Lap> > & laps, const unsigned int & laptime, const unsigned int & cuts); @loc=static @len=407 @rva=339488
	//_Func: public Lap getCurrentLap(CarAvatar * car); @loc=static @len=273 @rva=287360
	//_Func: public void resetCurrentLaps(); @loc=static @len=769 @rva=334128
	//_Func: public double getSendInterval(); @loc=optimized @len=0 @rva=0
	//_Func: public NetCarStateProvider * getNetCarFromBody(IRigidBody *  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public std::vector<unsigned char,std::allocator<unsigned char> > getCarMD5(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & unix_name); @loc=static @len=322 @rva=286832
	//_Func: public double getTimetoWait(); @loc=static @len=9 @rva=296448
	//_Func: public bool getHasExtraLap(); @loc=optimized @len=0 @rva=0
	//_Func: public bool getIsLastLap(); @loc=optimized @len=0 @rva=0
	//_Func: public bool getHasLeaderFinished(); @loc=optimized @len=0 @rva=0
	//_Func: public bool getHasPlayerFinished(); @loc=optimized @len=0 @rva=0
	//_Func: public unsigned int getPitWindowStart(); @loc=optimized @len=0 @rva=0
	//_Func: public unsigned int getPitWindowEnd(); @loc=optimized @len=0 @rva=0
	//_Func: public void setInvertedGridPositions(int pos); @loc=static @len=7 @rva=1315584
	//_Func: public int getInvertedGridPositions(); @loc=static @len=7 @rva=1279296
	//_Func: public void askForP2Pvalue(); @loc=static @len=169 @rva=279664
	//_Data: this+0x250, Member, Type: bool, debugStartingLights
	//_Data: this+0x251, Member, Type: bool, isAssociated
	//_Tag 11
	//_Data: this+0x258, Member, Type: struct ACClient::ClientSessionTransition, transitionInfo
	//_Data: this+0x330, Member, Type: struct RemoteSessionResult, sessionResultsGT
	//_Data: this+0x3A0, Member, Type: class UDPSocket, sok
	//_Tag 17
	//_Data: this+0x3D8, Member, Type: class std::vector<std::vector<unsigned char,std::allocator<unsigned char> >,std::allocator<std::vector<unsigned char,std::allocator<unsigned char> > > >, checksumResults
	//_Data: this+0x3F0, Member, Type: class Sim *, sim
	//_Data: this+0x3F8, Member, Type: class Car *, car
	//_Data: this+0x400, Member, Type: class ACClientVotingManager *, votingManager
	//_Data: this+0x408, Member, Type: class CarAvatar *, avatar
	//_Data: this+0x410, Member, Type: double, lastSendTime
	//_Data: this+0x418, Member, Type: double, sendInterval
	//_Data: this+0x420, Member, Type: double, lastChatMessage
	//_Data: this+0x428, Member, Type: double, lastSpectatorPulse
	//_Data: this+0x430, Member, Type: class IPAddress, serverIP
	//_Data: this+0x440, Member, Type: unsigned char, sessionID
	//_Data: this+0x448, Member, Type: class std::vector<NetCarStateProvider *,std::allocator<NetCarStateProvider *> >, netCars
	//_Data: this+0x460, Member, Type: unsigned char, pakSequenceIndex
	//_Data: this+0x464, Member, Type: int, handshakeCarPosition
	//_Data: this+0x468, Member, Type: class WrongWayIndicator *, wrongWayIndicator
	//_Data: this+0x470, Member, Type: int, numWrongWayInfractions
	//_Data: this+0x478, Member, Type: class TCPSocket, tcpSock
	//_Data: this+0x104F0, Member, Type: struct RemoteSession, currentSession
	//_Data: this+0x10530, Member, Type: int, finishPosition
	//_Data: this+0x10538, Member, Type: class Font *, font
	//_Data: this+0x10540, Member, Type: class std::vector<RemoteSession,std::allocator<RemoteSession> >, sessions
	//_Data: this+0x10558, Member, Type: struct DisconnectCountdown, dcCountdown
	//_Data: this+0x10580, Member, Type: double, lastSessionCheckTime
	//_Data: this+0x10588, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, welcomeMessage
	//_Data: this+0x105A8, Member, Type: struct DamageReportDef, damageReport
	//_Data: this+0x105C8, Member, Type: bool, isFlashingCache
	//_Data: this+0x105CC, Member, Type: struct WreckerProtection, wreckerProtection
	//_Data: this+0x105DC, Member, Type: unsigned int, resultScreenTime
	//_Data: this+0x105E0, Member, Type: unsigned int, raceOverTime
	//_Data: this+0x105E4, Member, Type: bool, isGasPenaltyDisabled
	//_Data: this+0x105E8, Member, Type: unsigned int, pitWindowStart
	//_Data: this+0x105EC, Member, Type: unsigned int, pitWindowEnd
	//_Data: this+0x105F0, Member, Type: bool, hasLeaderFinished
	//_Data: this+0x105F1, Member, Type: bool, hasPlayerFinished
	//_Data: this+0x105F8, Member, Type: double, raceClosingTime
	//_Data: this+0x10600, Member, Type: bool, isResultScreenOn
	//_Data: this+0x10601, Member, Type: bool, hasExtraLap
	//_Data: this+0x10602, Member, Type: bool, isLastLap
	//_Data: this+0x10603, Member, Type: bool, ignoreResultTeleport
	//_Data: this+0x10604, Member, Type: int, invertedGridPositions
	//_Data: this+0x10608, Member, Type: class std::vector<unsigned int,std::allocator<unsigned int> >, localCarCurrentSplits
	//_Data: this+0x10620, Member, Type: class std::vector<unsigned int,std::allocator<unsigned int> >, localCarBestSplits
	//_Data: this+0x10638, Member, Type: class std::vector<unsigned int,std::allocator<unsigned int> >, bestSplits
	//_Data: this+0x10650, Member, Type: unsigned int, globalBestlap
	//_Data: this+0x10658, Member, Type: class std::vector<Lap,std::allocator<Lap> >, localCarLaps
	//_Data: this+0x10670, Member, Type: unsigned int, localCarBestLap
	//_Data: this+0x10674, Member, Type: unsigned int, instanceLocalCarBestLap
	//_Data: this+0x10678, Member, Type: struct Lap, localCarLastLap
	//_Data: this+0x106C0, Member, Type: bool, useLog
	//_Data: this+0x106C1, Member, Type: bool, playerIsSpectator
	//_Data: this+0x106C8, Member, Type: class std::basic_ofstream<wchar_t,std::char_traits<wchar_t> >, log
	//_Data: this+0x107D0, Member, Type: struct ClientQOSData, qos
	//_Tag 11
	//_Data: this+0x107E8, Member, Type: struct ACClient::ClientEndSession, endSession
	//_Data: this+0x107F8, Member, Type: class std::vector<ClientCollisionEvent,std::allocator<ClientCollisionEvent> >, clientColissionEvents
	//_Data: this+0x10810, Member, Type: double, lastClientEventSendTime
	//_Func: private void sendCarPosition(); @loc=static @len=2142 @rva=336432
	//_Func: private void onMessage(const UDPMessage & msg); @loc=static @len=3695 @rva=309712
	//_Func: private void onLapCompleted(const OnLapCompletedEvent & ev); @loc=static @len=410 @rva=309296
	//_Func: private void onNewSession(UDPPacket & pak, bool isHandShake); @loc=static @len=3369 @rva=320672
	//_Func: private void onRemoteLapCompleted(UDPPacket & pak); @loc=static @len=2377 @rva=324720
	//_Func: private void onRemoteSectorSplit(UDPPacket & pak); @loc=static @len=300 @rva=327104
	//_Func: private void onPhysicsStep(double pt); @loc=static @len=667 @rva=324048
	//_Func: private void receiveFromSocket(); @loc=optimized @len=0 @rva=0
	//_Func: private void logMessage(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & message); @loc=static @len=203 @rva=307872
	//_Func: private int getNumberOfActiveCars(); @loc=optimized @len=0 @rva=0
	//_Func: private unsigned char getSessionIdFromCarAvatarID(int carAvatarID); @loc=static @len=149 @rva=295776
	//_Func: private void updateQOS(double pt); @loc=static @len=324 @rva=344528
	//_Func: private void associate(); @loc=static @len=147 @rva=280128
	//_Func: private void onMessageTCP(const UDPMessage & msg); @loc=static @len=7258 @rva=313408
	//_Func: private bool handleLocalAdminMessages(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * msg); @loc=static @len=1241 @rva=296560
	//_Func: private void onTyreCompoundChanged(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & shortName); @loc=static @len=136 @rva=328656
	//_Func: private void onCollisionEvent(const OnCollisionEvent &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: private void addCollisionEvent(NetCarStateProvider * netCar, float speed, const vec3f & worldPos, const vec3f & relPos); @loc=static @len=388 @rva=277152
	//_Func: private void onWelcomeMessageReceived(UDPPacket & pak); @loc=static @len=144 @rva=328800
	//_Func: private void onSetupReceived(UDPPacket & pak); @loc=static @len=820 @rva=327824
	//_Func: private void onDRSZoneReceived(UDPPacket & pak); @loc=static @len=771 @rva=308512
	//_Func: private void onRemoteSunAngleReceived(float angle); @loc=static @len=117 @rva=327408
	//_Func: private void updateDamageReport(); @loc=static @len=360 @rva=344160
	//_Func: private void onSectorSplit(const OnSectorSplitEvent & ev); @loc=static @len=282 @rva=327536
	//_Func: private void onCollisionWithCar(); @loc=static @len=428 @rva=308080
	//_Func: public ACClient & operator=(const ACClient &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ACClient : public GameObject {
public:
	Event<OnChatMessageEvent> evOnChatMessage;
	Event<RemoteSession> evOnOnlineNewSession;
	Event<RemoteSessionResume> evOnOnlineEndSession;
	Event<OnLapCompletedEvent> evOnLapCompleted;
	Event<ReceivedVoteDef> evOnVoteReceived;
	Event<bool> evOnVoteNotPassed;
	Event<bool> evOnMandatoryPitDone;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > serverName;
	float remoteSpring;
	float remoteDamper;
	float remoteFactor;
	DriverInfo driverInfo;
	ServerInfo serverInfo;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > guid;
	ClientRules rules;
	ServerDrivingAssists serverDrivingAssists;
	bool isTVMode;
	double handshakeServerTimeS;
	std::vector<unsigned char,std::allocator<unsigned char> > playerCarMD5;
	bool debugStartingLights;
	bool isAssociated;
	ACClient_ClientSessionTransition transitionInfo;
	RemoteSessionResult sessionResultsGT;
	UDPSocket sok;
	std::vector<std::vector<unsigned char,std::allocator<unsigned char> >,std::allocator<std::vector<unsigned char,std::allocator<unsigned char> > > > checksumResults;
	Sim * sim;
	Car * car;
	ACClientVotingManager * votingManager;
	CarAvatar * avatar;
	double lastSendTime;
	double sendInterval;
	double lastChatMessage;
	double lastSpectatorPulse;
	IPAddress serverIP;
	unsigned char sessionID;
	std::vector<NetCarStateProvider *,std::allocator<NetCarStateProvider *> > netCars;
	unsigned char pakSequenceIndex;
	int handshakeCarPosition;
	WrongWayIndicator * wrongWayIndicator;
	int numWrongWayInfractions;
	TCPSocket tcpSock;
	RemoteSession currentSession;
	int finishPosition;
	Font * font;
	std::vector<RemoteSession,std::allocator<RemoteSession> > sessions;
	DisconnectCountdown dcCountdown;
	double lastSessionCheckTime;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > welcomeMessage;
	DamageReportDef damageReport;
	bool isFlashingCache;
	WreckerProtection wreckerProtection;
	unsigned int resultScreenTime;
	unsigned int raceOverTime;
	bool isGasPenaltyDisabled;
	unsigned int pitWindowStart;
	unsigned int pitWindowEnd;
	bool hasLeaderFinished;
	bool hasPlayerFinished;
	double raceClosingTime;
	bool isResultScreenOn;
	bool hasExtraLap;
	bool isLastLap;
	bool ignoreResultTeleport;
	int invertedGridPositions;
	std::vector<unsigned int,std::allocator<unsigned int> > localCarCurrentSplits;
	std::vector<unsigned int,std::allocator<unsigned int> > localCarBestSplits;
	std::vector<unsigned int,std::allocator<unsigned int> > bestSplits;
	unsigned int globalBestlap;
	std::vector<Lap,std::allocator<Lap> > localCarLaps;
	unsigned int localCarBestLap;
	unsigned int instanceLocalCarBestLap;
	Lap localCarLastLap;
	bool useLog;
	bool playerIsSpectator;
	std::basic_ofstream<wchar_t,std::char_traits<wchar_t> > log;
	ClientQOSData qos;
	ACClient_ClientEndSession endSession;
	std::vector<ClientCollisionEvent,std::allocator<ClientCollisionEvent> > clientColissionEvents;
	double lastClientEventSendTime;
	inline ACClient() { }
	inline ACClient(const ACClient& other) = default;
	inline ACClient& operator=(const ACClient& other) = default;
	inline void ctor(Sim * isim) { typedef void (ACClient::*_fpt)(Sim *); auto _f=xcast<_fpt>(_drva(238272)); (this->*_f)(isim); }
	virtual ~ACClient();
	inline void dtor() { typedef void (ACClient::*_fpt)(); auto _f=xcast<_fpt>(_drva(244880)); (this->*_f)(); }
	virtual void renderHUD_vf3(float dt);
	inline void renderHUD_impl(float dt) { typedef void (ACClient::*_fpt)(float); auto _f=xcast<_fpt>(_drva(333392)); return (this->*_f)(dt); }
	inline void renderHUD(float dt) { typedef void (ACClient::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(dt); }
	inline ClientHandshakeResult handshakeTCP() { typedef ClientHandshakeResult (ACClient::*_fpt)(); auto _f=xcast<_fpt>(_drva(297808)); return (this->*_f)(); }
	inline bool getRemoteCarList(std::vector<ClientRemoteCarDef,std::allocator<ClientRemoteCarDef> > & remoteCars) { typedef bool (ACClient::*_fpt)(std::vector<ClientRemoteCarDef,std::allocator<ClientRemoteCarDef> > &); auto _f=xcast<_fpt>(_drva(290688)); return (this->*_f)(remoteCars); }
	inline void beginUpdateMode() { typedef void (ACClient::*_fpt)(); auto _f=xcast<_fpt>(_drva(280288)); return (this->*_f)(); }
	inline void sendChat(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & message) { typedef void (ACClient::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(338576)); return (this->*_f)(message); }
	inline void sendVote(VoteType aVote, bool aVoteValue, int targetAvatarGUID) { typedef void (ACClient::*_fpt)(VoteType, bool, int); auto _f=xcast<_fpt>(_drva(338848)); return (this->*_f)(aVote, aVoteValue, targetAvatarGUID); }
	inline bool hasVoted() { typedef bool (ACClient::*_fpt)(); auto _f=xcast<_fpt>(_drva(306432)); return (this->*_f)(); }
	inline CarAvatar * getCurrentVotingTarget() { typedef CarAvatar * (ACClient::*_fpt)(); auto _f=xcast<_fpt>(_drva(287824)); return (this->*_f)(); }
	inline float getVotingTimeLeft() { typedef float (ACClient::*_fpt)(); auto _f=xcast<_fpt>(_drva(296512)); return (this->*_f)(); }
	inline VoteType getCurrentVoteType() { typedef VoteType (ACClient::*_fpt)(); auto _f=xcast<_fpt>(_drva(287808)); return (this->*_f)(); }
	inline float getVotingMaxTime() { typedef float (ACClient::*_fpt)(); auto _f=xcast<_fpt>(_drva(296496)); return (this->*_f)(); }
	inline void addNetCar(NetCarStateProvider * nc) { typedef void (ACClient::*_fpt)(NetCarStateProvider *); auto _f=xcast<_fpt>(_drva(279232)); return (this->*_f)(nc); }
	inline NetCarStateProvider * getNetCarFromSessionID(unsigned char id) { typedef NetCarStateProvider * (ACClient::*_fpt)(unsigned char); auto _f=xcast<_fpt>(_drva(290528)); return (this->*_f)(id); }
	virtual void update_vf1(float deltaT);
	inline void update_impl(float deltaT) { typedef void (ACClient::*_fpt)(float); auto _f=xcast<_fpt>(_drva(342832)); return (this->*_f)(deltaT); }
	inline void update(float deltaT) { typedef void (ACClient::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(deltaT); }
	inline double getPhysicsTime() { typedef double (ACClient::*_fpt)(); auto _f=xcast<_fpt>(_drva(290576)); return (this->*_f)(); }
	inline bool isAllowedToSendChatMessage() { typedef bool (ACClient::*_fpt)(); auto _f=xcast<_fpt>(_drva(307616)); return (this->*_f)(); }
	inline int getPing(CarAvatar * anAvatar) { typedef int (ACClient::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(290608)); return (this->*_f)(anAvatar); }
	inline RemoteSession getCurrentSession() { typedef RemoteSession (ACClient::*_fpt)(); auto _f=xcast<_fpt>(_drva(287648)); return (this->*_f)(); }
	inline const RemoteSessionResult & getCurrentSessionResults() { typedef const RemoteSessionResult & (ACClient::*_fpt)(); auto _f=xcast<_fpt>(_drva(287792)); return (this->*_f)(); }
	inline CarAvatar * getCarAvatarFromSessionID(unsigned char sesid) { typedef CarAvatar * (ACClient::*_fpt)(unsigned char); auto _f=xcast<_fpt>(_drva(286720)); return (this->*_f)(sesid); }
	inline int getSessionIDFromCarAvatar(CarAvatar * anAvatar) { typedef int (ACClient::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(295696)); return (this->*_f)(anAvatar); }
	inline int getSessionCount() { typedef int (ACClient::*_fpt)(); auto _f=xcast<_fpt>(_drva(295664)); return (this->*_f)(); }
	inline int getCurrentSessionIndex() { typedef int (ACClient::*_fpt)(); auto _f=xcast<_fpt>(_drva(287696)); return (this->*_f)(); }
	inline RemoteSession getSessionInfo(int index) { typedef RemoteSession (ACClient::*_fpt)(int); auto _f=xcast<_fpt>(_drva(295936)); return (this->*_f)(index); }
	virtual void shutdown_vf5();
	inline void shutdown_impl() { typedef void (ACClient::*_fpt)(); auto _f=xcast<_fpt>(_drva(339248)); return (this->*_f)(); }
	inline void shutdown() { typedef void (ACClient::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 5)); return (this->*_f)(); }
	inline double getSessionTimeLeft() { typedef double (ACClient::*_fpt)(); auto _f=xcast<_fpt>(_drva(296096)); return (this->*_f)(); }
	inline int getHandshakeCarPosition() { typedef int (ACClient::*_fpt)(); auto _f=xcast<_fpt>(_drva(1278848)); return (this->*_f)(); }
	inline unsigned int getCarPosition(CarAvatar * car) { typedef unsigned int (ACClient::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(287168)); return (this->*_f)(car); }
	inline unsigned int getBestLap(CarAvatar * car) { typedef unsigned int (ACClient::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(286272)); return (this->*_f)(car); }
	inline unsigned int getInstanceBestLap(CarAvatar * car) { typedef unsigned int (ACClient::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(287856)); return (this->*_f)(car); }
	inline Lap getLastLap(CarAvatar * car) { typedef Lap (ACClient::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(290000)); return (this->*_f)(car); }
	inline unsigned int getLapCount(CarAvatar * car) { typedef unsigned int (ACClient::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(287968)); return (this->*_f)(car); }
	inline void getLaps(CarAvatar * car, std::vector<Lap,std::allocator<Lap> > & laps) { typedef void (ACClient::*_fpt)(CarAvatar *, std::vector<Lap,std::allocator<Lap> > &); auto _f=xcast<_fpt>(_drva(288160)); return (this->*_f)(car, laps); }
	inline bool isBestSplit(const int & sector, const int & t, const bool & isGlobal, CarAvatar * car) { typedef bool (ACClient::*_fpt)(const int &, const int &, const bool &, CarAvatar *); auto _f=xcast<_fpt>(_drva(307648)); return (this->*_f)(sector, t, isGlobal, car); }
	inline unsigned int getBestSplit(const int & sector, const bool & isGlobal, CarAvatar * car) { typedef unsigned int (ACClient::*_fpt)(const int &, const bool &, CarAvatar *); auto _f=xcast<_fpt>(_drva(286384)); return (this->*_f)(sector, isGlobal, car); }
	inline unsigned int getLastSplit(CarAvatar * car, const int & sector) { typedef unsigned int (ACClient::*_fpt)(CarAvatar *, const int &); auto _f=xcast<_fpt>(_drva(290336)); return (this->*_f)(car, sector); }
	inline unsigned int getSplit(CarAvatar * car, const int & sector) { typedef unsigned int (ACClient::*_fpt)(CarAvatar *, const int &); auto _f=xcast<_fpt>(_drva(296160)); return (this->*_f)(car, sector); }
	inline void addSplitToBest(std::vector<unsigned int,std::allocator<unsigned int> > & splits, std::vector<unsigned int,std::allocator<unsigned int> > & personalSplits, const unsigned int & sector, const unsigned int & time, const unsigned int & cuts) { typedef void (ACClient::*_fpt)(std::vector<unsigned int,std::allocator<unsigned int> > &, std::vector<unsigned int,std::allocator<unsigned int> > &, const unsigned int &, const unsigned int &, const unsigned int &); auto _f=xcast<_fpt>(_drva(279264)); return (this->*_f)(splits, personalSplits, sector, time, cuts); }
	inline void storeSplitToLap(std::vector<unsigned int,std::allocator<unsigned int> > & splits, std::vector<unsigned int,std::allocator<unsigned int> > & personalSplits, std::vector<Lap,std::allocator<Lap> > & laps, const unsigned int & laptime, const unsigned int & cuts) { typedef void (ACClient::*_fpt)(std::vector<unsigned int,std::allocator<unsigned int> > &, std::vector<unsigned int,std::allocator<unsigned int> > &, std::vector<Lap,std::allocator<Lap> > &, const unsigned int &, const unsigned int &); auto _f=xcast<_fpt>(_drva(339488)); return (this->*_f)(splits, personalSplits, laps, laptime, cuts); }
	inline Lap getCurrentLap(CarAvatar * car) { typedef Lap (ACClient::*_fpt)(CarAvatar *); auto _f=xcast<_fpt>(_drva(287360)); return (this->*_f)(car); }
	inline void resetCurrentLaps() { typedef void (ACClient::*_fpt)(); auto _f=xcast<_fpt>(_drva(334128)); return (this->*_f)(); }
	inline std::vector<unsigned char,std::allocator<unsigned char> > getCarMD5(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & unix_name) { typedef std::vector<unsigned char,std::allocator<unsigned char> > (ACClient::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(286832)); return (this->*_f)(unix_name); }
	inline double getTimetoWait() { typedef double (ACClient::*_fpt)(); auto _f=xcast<_fpt>(_drva(296448)); return (this->*_f)(); }
	inline void setInvertedGridPositions(int pos) { typedef void (ACClient::*_fpt)(int); auto _f=xcast<_fpt>(_drva(1315584)); return (this->*_f)(pos); }
	inline int getInvertedGridPositions() { typedef int (ACClient::*_fpt)(); auto _f=xcast<_fpt>(_drva(1279296)); return (this->*_f)(); }
	inline void askForP2Pvalue() { typedef void (ACClient::*_fpt)(); auto _f=xcast<_fpt>(_drva(279664)); return (this->*_f)(); }
	inline void sendCarPosition() { typedef void (ACClient::*_fpt)(); auto _f=xcast<_fpt>(_drva(336432)); return (this->*_f)(); }
	inline void onMessage(const UDPMessage & msg) { typedef void (ACClient::*_fpt)(const UDPMessage &); auto _f=xcast<_fpt>(_drva(309712)); return (this->*_f)(msg); }
	inline void onLapCompleted(const OnLapCompletedEvent & ev) { typedef void (ACClient::*_fpt)(const OnLapCompletedEvent &); auto _f=xcast<_fpt>(_drva(309296)); return (this->*_f)(ev); }
	inline void onNewSession(UDPPacket & pak, bool isHandShake) { typedef void (ACClient::*_fpt)(UDPPacket &, bool); auto _f=xcast<_fpt>(_drva(320672)); return (this->*_f)(pak, isHandShake); }
	inline void onRemoteLapCompleted(UDPPacket & pak) { typedef void (ACClient::*_fpt)(UDPPacket &); auto _f=xcast<_fpt>(_drva(324720)); return (this->*_f)(pak); }
	inline void onRemoteSectorSplit(UDPPacket & pak) { typedef void (ACClient::*_fpt)(UDPPacket &); auto _f=xcast<_fpt>(_drva(327104)); return (this->*_f)(pak); }
	inline void onPhysicsStep(double pt) { typedef void (ACClient::*_fpt)(double); auto _f=xcast<_fpt>(_drva(324048)); return (this->*_f)(pt); }
	inline void logMessage(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & message) { typedef void (ACClient::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(307872)); return (this->*_f)(message); }
	inline unsigned char getSessionIdFromCarAvatarID(int carAvatarID) { typedef unsigned char (ACClient::*_fpt)(int); auto _f=xcast<_fpt>(_drva(295776)); return (this->*_f)(carAvatarID); }
	inline void updateQOS(double pt) { typedef void (ACClient::*_fpt)(double); auto _f=xcast<_fpt>(_drva(344528)); return (this->*_f)(pt); }
	inline void associate() { typedef void (ACClient::*_fpt)(); auto _f=xcast<_fpt>(_drva(280128)); return (this->*_f)(); }
	inline void onMessageTCP(const UDPMessage & msg) { typedef void (ACClient::*_fpt)(const UDPMessage &); auto _f=xcast<_fpt>(_drva(313408)); return (this->*_f)(msg); }
	inline bool handleLocalAdminMessages(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * msg) { typedef bool (ACClient::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *); auto _f=xcast<_fpt>(_drva(296560)); return (this->*_f)(msg); }
	inline void onTyreCompoundChanged(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & shortName) { typedef void (ACClient::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(328656)); return (this->*_f)(shortName); }
	inline void addCollisionEvent(NetCarStateProvider * netCar, float speed, const vec3f & worldPos, const vec3f & relPos) { typedef void (ACClient::*_fpt)(NetCarStateProvider *, float, const vec3f &, const vec3f &); auto _f=xcast<_fpt>(_drva(277152)); return (this->*_f)(netCar, speed, worldPos, relPos); }
	inline void onWelcomeMessageReceived(UDPPacket & pak) { typedef void (ACClient::*_fpt)(UDPPacket &); auto _f=xcast<_fpt>(_drva(328800)); return (this->*_f)(pak); }
	inline void onSetupReceived(UDPPacket & pak) { typedef void (ACClient::*_fpt)(UDPPacket &); auto _f=xcast<_fpt>(_drva(327824)); return (this->*_f)(pak); }
	inline void onDRSZoneReceived(UDPPacket & pak) { typedef void (ACClient::*_fpt)(UDPPacket &); auto _f=xcast<_fpt>(_drva(308512)); return (this->*_f)(pak); }
	inline void onRemoteSunAngleReceived(float angle) { typedef void (ACClient::*_fpt)(float); auto _f=xcast<_fpt>(_drva(327408)); return (this->*_f)(angle); }
	inline void updateDamageReport() { typedef void (ACClient::*_fpt)(); auto _f=xcast<_fpt>(_drva(344160)); return (this->*_f)(); }
	inline void onSectorSplit(const OnSectorSplitEvent & ev) { typedef void (ACClient::*_fpt)(const OnSectorSplitEvent &); auto _f=xcast<_fpt>(_drva(327536)); return (this->*_f)(ev); }
	inline void onCollisionWithCar() { typedef void (ACClient::*_fpt)(); auto _f=xcast<_fpt>(_drva(308080)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(ACClient)==67608),"bad size");
		static_assert((offsetof(ACClient,evOnChatMessage)==0x58),"bad off");
		static_assert((offsetof(ACClient,evOnOnlineNewSession)==0x70),"bad off");
		static_assert((offsetof(ACClient,evOnOnlineEndSession)==0x88),"bad off");
		static_assert((offsetof(ACClient,evOnLapCompleted)==0xA0),"bad off");
		static_assert((offsetof(ACClient,evOnVoteReceived)==0xB8),"bad off");
		static_assert((offsetof(ACClient,evOnVoteNotPassed)==0xD0),"bad off");
		static_assert((offsetof(ACClient,evOnMandatoryPitDone)==0xE8),"bad off");
		static_assert((offsetof(ACClient,serverName)==0x100),"bad off");
		static_assert((offsetof(ACClient,remoteSpring)==0x120),"bad off");
		static_assert((offsetof(ACClient,remoteDamper)==0x124),"bad off");
		static_assert((offsetof(ACClient,remoteFactor)==0x128),"bad off");
		static_assert((offsetof(ACClient,driverInfo)==0x130),"bad off");
		static_assert((offsetof(ACClient,serverInfo)==0x1B0),"bad off");
		static_assert((offsetof(ACClient,guid)==0x1F8),"bad off");
		static_assert((offsetof(ACClient,rules)==0x218),"bad off");
		static_assert((offsetof(ACClient,serverDrivingAssists)==0x21C),"bad off");
		static_assert((offsetof(ACClient,isTVMode)==0x228),"bad off");
		static_assert((offsetof(ACClient,handshakeServerTimeS)==0x230),"bad off");
		static_assert((offsetof(ACClient,playerCarMD5)==0x238),"bad off");
		static_assert((offsetof(ACClient,debugStartingLights)==0x250),"bad off");
		static_assert((offsetof(ACClient,isAssociated)==0x251),"bad off");
		static_assert((offsetof(ACClient,transitionInfo)==0x258),"bad off");
		static_assert((offsetof(ACClient,sessionResultsGT)==0x330),"bad off");
		static_assert((offsetof(ACClient,sok)==0x3A0),"bad off");
		static_assert((offsetof(ACClient,checksumResults)==0x3D8),"bad off");
		static_assert((offsetof(ACClient,sim)==0x3F0),"bad off");
		static_assert((offsetof(ACClient,car)==0x3F8),"bad off");
		static_assert((offsetof(ACClient,votingManager)==0x400),"bad off");
		static_assert((offsetof(ACClient,avatar)==0x408),"bad off");
		static_assert((offsetof(ACClient,lastSendTime)==0x410),"bad off");
		static_assert((offsetof(ACClient,sendInterval)==0x418),"bad off");
		static_assert((offsetof(ACClient,lastChatMessage)==0x420),"bad off");
		static_assert((offsetof(ACClient,lastSpectatorPulse)==0x428),"bad off");
		static_assert((offsetof(ACClient,serverIP)==0x430),"bad off");
		static_assert((offsetof(ACClient,sessionID)==0x440),"bad off");
		static_assert((offsetof(ACClient,netCars)==0x448),"bad off");
		static_assert((offsetof(ACClient,pakSequenceIndex)==0x460),"bad off");
		static_assert((offsetof(ACClient,handshakeCarPosition)==0x464),"bad off");
		static_assert((offsetof(ACClient,wrongWayIndicator)==0x468),"bad off");
		static_assert((offsetof(ACClient,numWrongWayInfractions)==0x470),"bad off");
		static_assert((offsetof(ACClient,tcpSock)==0x478),"bad off");
		static_assert((offsetof(ACClient,currentSession)==0x104F0),"bad off");
		static_assert((offsetof(ACClient,finishPosition)==0x10530),"bad off");
		static_assert((offsetof(ACClient,font)==0x10538),"bad off");
		static_assert((offsetof(ACClient,sessions)==0x10540),"bad off");
		static_assert((offsetof(ACClient,dcCountdown)==0x10558),"bad off");
		static_assert((offsetof(ACClient,lastSessionCheckTime)==0x10580),"bad off");
		static_assert((offsetof(ACClient,welcomeMessage)==0x10588),"bad off");
		static_assert((offsetof(ACClient,damageReport)==0x105A8),"bad off");
		static_assert((offsetof(ACClient,isFlashingCache)==0x105C8),"bad off");
		static_assert((offsetof(ACClient,wreckerProtection)==0x105CC),"bad off");
		static_assert((offsetof(ACClient,resultScreenTime)==0x105DC),"bad off");
		static_assert((offsetof(ACClient,raceOverTime)==0x105E0),"bad off");
		static_assert((offsetof(ACClient,isGasPenaltyDisabled)==0x105E4),"bad off");
		static_assert((offsetof(ACClient,pitWindowStart)==0x105E8),"bad off");
		static_assert((offsetof(ACClient,pitWindowEnd)==0x105EC),"bad off");
		static_assert((offsetof(ACClient,hasLeaderFinished)==0x105F0),"bad off");
		static_assert((offsetof(ACClient,hasPlayerFinished)==0x105F1),"bad off");
		static_assert((offsetof(ACClient,raceClosingTime)==0x105F8),"bad off");
		static_assert((offsetof(ACClient,isResultScreenOn)==0x10600),"bad off");
		static_assert((offsetof(ACClient,hasExtraLap)==0x10601),"bad off");
		static_assert((offsetof(ACClient,isLastLap)==0x10602),"bad off");
		static_assert((offsetof(ACClient,ignoreResultTeleport)==0x10603),"bad off");
		static_assert((offsetof(ACClient,invertedGridPositions)==0x10604),"bad off");
		static_assert((offsetof(ACClient,localCarCurrentSplits)==0x10608),"bad off");
		static_assert((offsetof(ACClient,localCarBestSplits)==0x10620),"bad off");
		static_assert((offsetof(ACClient,bestSplits)==0x10638),"bad off");
		static_assert((offsetof(ACClient,globalBestlap)==0x10650),"bad off");
		static_assert((offsetof(ACClient,localCarLaps)==0x10658),"bad off");
		static_assert((offsetof(ACClient,localCarBestLap)==0x10670),"bad off");
		static_assert((offsetof(ACClient,instanceLocalCarBestLap)==0x10674),"bad off");
		static_assert((offsetof(ACClient,localCarLastLap)==0x10678),"bad off");
		static_assert((offsetof(ACClient,useLog)==0x106C0),"bad off");
		static_assert((offsetof(ACClient,playerIsSpectator)==0x106C1),"bad off");
		static_assert((offsetof(ACClient,log)==0x106C8),"bad off");
		static_assert((offsetof(ACClient,qos)==0x107D0),"bad off");
		static_assert((offsetof(ACClient,endSession)==0x107E8),"bad off");
		static_assert((offsetof(ACClient,clientColissionEvents)==0x107F8),"bad off");
		static_assert((offsetof(ACClient,lastClientEventSendTime)==0x10810),"bad off");
	};
};

//UDT: class Sim @len=720 @multibase=2
	//_Base: class GameObject @off=0 @len=88
	//_Base: class IKeyEventListener @off=88 @len=8
	//_Func: public void Sim(const Sim &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void Sim(Game * igame); @loc=static @len=13670 @rva=1646704
	//_Func: public void ~Sim(); @virtual vtpo=0 vfid=0 @loc=static @len=810 @rva=1660624
	//_Data: this+0x60, Member, Type: class Event<OnNewCarLoadedEvent>, evNewCarLoaded
	//_Data: this+0x78, Member, Type: class Event<OnReplayStatusChanged>, evOnReplayStatusChanged
	//_Data: this+0x90, Member, Type: class Event<bool>, evOnPauseModeChanged
	//_Data: this+0xA8, Member, Type: class Event<CollisionEvent>, evOnCollisionEvent
	//_Data: this+0xC0, Member, Type: class Event<OnNewSessionEvent>, evOnNewSession
	//_Data: this+0xD8, Member, Type: struct HDRLevels, hdrLevels
	//_Data: this+0xE0, Member, Type: class CommandManager, commandManager
	//_Data: this+0xF0, Member, Type: class OptionsManager, optionsManager
	//_Data: this+0x108, Member, Type: class ksgui::GameScreen *, gameScreen
	//_Data: this+0x110, Member, Type: class PauseMenu *, pauseMenu
	//_Data: this+0x118, Member, Type: class ESCMenu *, escMenu
	//_Data: this+0x120, Member, Type: class Node *, rootNode
	//_Data: this+0x128, Member, Type: class Node *, trackNode
	//_Data: this+0x130, Member, Type: class CarNodeSorter *, carsNode
	//_Data: this+0x138, Member, Type: class Node *, skidMarkNode
	//_Data: this+0x140, Member, Type: class Node *, particlesNode
	//_Data: this+0x148, Member, Type: class NodeEvent *, carFakeShadowsNode
	//_Data: this+0x150, Member, Type: class TrackAvatar *, track
	//_Data: this+0x158, Member, Type: class Node *, blurredNode
	//_Data: this+0x160, Member, Type: class Node *, unblurredNode
	//_Data: this+0x168, Member, Type: class DrivingAssistManager *, drivingAidsManager
	//_Data: this+0x170, Member, Type: class NodeEvent *, renderFinishedNodeEvent
	//_Data: this+0x178, Member, Type: class NodeEvent *, beforeCarsNode
	//_Data: this+0x180, Member, Type: class MirrorTextureRenderer *, mirrorTextureRenderer
	//_Data: this+0x188, Member, Type: class ACCameraManager *, cameraManager
	//_Data: this+0x190, Member, Type: class NodeDirtCamera *, cameraDirtNode
	//_Data: this+0x198, Member, Type: class SystemMessage *, systemMessage
	//_Data: this+0x1A0, Member, Type: class SystemNotification *, systemNotification
	//_Data: this+0x1A8, Member, Type: class RaceManager *, raceManager
	//_Data: this+0x1B0, Member, Type: class ReplayManager *, replayManager
	//_Data: this+0x1B8, Member, Type: class PhysicsAvatar *, physicsAvatar
	//_Data: this+0x1C0, Member, Type: class ScreenCapturer *, screenCapturer
	//_Data: this+0x1C8, Member, Type: class ACClient *, client
	//_Data: this+0x1D0, Member, Type: class PitStop *, pitStop
	//_Data: this+0x1D8, Member, Type: class TimeLimitedTest *, timeLimitedTest
	//_Data: this+0x1E0, Member, Type: bool, useProView
	//_Data: this+0x1E1, Member, Type: bool, isVrConnected
	//_Data: this+0x1E2, Member, Type: bool, isRoomVR
	//_Data: this+0x1E3, Member, Type: bool, isVirtualMirrorForced
	//_Data: static, [01559C12][0003:00046C12], Static Member, Type: bool, benchmarkMode
	//_Data: static, [0151AA50][0003:00007A50], Static Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, acVersionString
	//_Data: this+0x1E4, Member, Type: bool, useMousePitstop
	//_Data: this+0x1E8, Member, Type: class QuickMenu *, quickMenu
	//_Data: this+0x1F0, Member, Type: class MicroSectors *, microSectors
	//_Func: public void applyCustomWeather(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name); @loc=static @len=648 @rva=1671184
	//_Func: public void startGame(); @loc=static @len=203 @rva=1698560
	//_Func: public Camera * getSceneCamera(); @loc=static @len=8 @rva=1676848
	//_Func: public void update(float deltaT); @virtual vtpo=0 vfid=1 @loc=static @len=2483 @rva=1699728
	//_Func: public void render(float deltaT); @virtual vtpo=0 vfid=2 @loc=static @len=58 @rva=1696944
	//_Func: public void renderHUD(float deltaT); @virtual vtpo=0 vfid=3 @loc=static @len=120 @rva=1697008
	//_Func: public CarAvatar * addCar(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & model, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & config, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & skin); @loc=static @len=565 @rva=1669280
	//_Func: public CarAvatar * addRemoteSlaveCar(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public CarAvatar * addNetCar(ClientRemoteCarDef & desc, ACClient * client); @loc=static @len=986 @rva=1670192
	//_Func: public void renderScene(float deltaT); @loc=static @len=319 @rva=1697136
	//_Func: public void loadTrack(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & tname, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & config, int playerPitPosition); @loc=static @len=637 @rva=1680576
	//_Func: public CarAvatar * getCar(unsigned int index); @loc=static @len=41 @rva=1676000
	//_Func: public unsigned int getCarsCount(); @loc=static @len=19 @rva=210640
	//_Func: public int getConnectedCarsCount(); @loc=optimized @len=0 @rva=0
	//_Func: public void onPostLoad(); @loc=static @len=152 @rva=1695776
	//_Func: public CameraForward * createCamera(INIReaderDocuments & videoIni, float useBlur); @loc=static @len=2642 @rva=1671904
	//_Func: public void setSplashMessage(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & msg); @loc=static @len=125 @rva=1697888
	//_Func: public void setSplashLoadingCar(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & carUnixName); @loc=static @len=125 @rva=1697760
	//_Func: public void shutdown(); @virtual vtpo=0 vfid=5 @loc=static @len=286 @rva=1698272
	//_Func: public void onESCMenuTriggeredEvent(OnESCMenuTriggered  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public bool isInTripleScreenMode(); @loc=static @len=8 @rva=1680448
	//_Func: public unsigned int nextCar(unsigned int anIndex); @loc=static @len=455 @rva=1681216
	//_Func: public unsigned int previousCar(unsigned int anIndex); @loc=static @len=454 @rva=1696128
	//_Data: static, [01559C13][0003:00046C13], Static Member, Type: bool, forceOnline
	//_Func: public void writeOutputJson(); @loc=static @len=115 @rva=1702224
	//_Func: public bool isDisplayingResults(); @loc=static @len=18 @rva=503088
	//_Func: public void displayResults(bool  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void displayLeaderboard(bool value); @loc=static @len=54 @rva=280848
	//_Func: public void onKeyDown(const OnKeyEvent & message); @virtual vtpo=88 vfid=0 @loc=static @len=14045 @rva=1681728
	//_Func: public void onKeyChar(unsigned int key); @virtual vtpo=88 vfid=1 @loc=static @len=3 @rva=96368
	//_Func: public void onReplayModeChanged(const OnReplayStatusChanged & message); @loc=static @len=182 @rva=1695936
	//_Func: public Console & getConsole(); @loc=static @len=8 @rva=1676048
	//_Func: public TrackData getTrackData(); @loc=static @len=339 @rva=1676864
	//_Func: public void setPauseMode(bool mode); @loc=static @len=212 @rva=1697488
	//_Func: public void activateGameGui(); @loc=static @len=81 @rva=1669088
	//_Func: public void activatePauseMenu(); @loc=static @len=81 @rva=1669184
	//_Func: public void activateEscMenu(); @loc=static @len=81 @rva=1668992
	//_Func: public void setFocusedCarIndex(unsigned int aCarIndex); @loc=static @len=32 @rva=1697456
	//_Func: public unsigned int getFocusedCarIndex(); @loc=static @len=7 @rva=1676080
	//_Func: public void executeOnMainThread(std::function<void __cdecl(void)> * f); @loc=static @len=129 @rva=1675840
	//_Func: public void unloadMeshResources(Node * node); @loc=static @len=444 @rva=1699280
	//_Func: public Texture * getNationFlag(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & nationCode); @loc=static @len=731 @rva=1676112
	//_Func: public bool isVrRoom(); @loc=static @len=8 @rva=888336
	//_Data: this+0x1F8, Member, Type: bool, serializeForms
	//_Data: this+0x1FC, Member, Type: int, connectedCarsCount
	//_Data: this+0x200, Member, Type: bool, allowFreeCamera
	//_Data: this+0x201, Member, Type: bool, tripleScreenMode
	//_Data: this+0x202, Member, Type: bool, audioPerformanceSpew
	//_Data: this+0x208, Member, Type: class std::vector<CarAvatar *,std::allocator<CarAvatar *> >, cars
	//_Data: this+0x220, Member, Type: unsigned int, focusedCarIndex
	//_Data: this+0x224, Member, Type: float, cameraFadeTime
	//_Data: this+0x228, Member, Type: class Console *, console
	//_Data: this+0x230, Member, Type: class SimScreen *, simScreen
	//_Data: this+0x238, Member, Type: class CameraForward *, sceneCamera
	//_Data: this+0x240, Member, Type: class SkyBox *, skyBox
	//_Data: this+0x248, Member, Type: class ACErrorHandler *, errorHandler
	//_Data: this+0x250, Member, Type: class DebugVisualizer *, debugVisualizer
	//_Data: this+0x258, Member, Type: class ksgui::FormRenderStats *, formRenderStats
	//_Data: this+0x260, Member, Type: class EndSessionDisplayer *, endSessionDisplayer
	//_Data: this+0x268, Member, Type: class SessionLeaderboard *, leaderboard
	//_Data: this+0x270, Member, Type: class Trigger, changingCameraTrigger
	//_Data: this+0x280, Member, Type: class VirtualMirrorRenderer *, virtualMirrorRenderer
	//_Data: this+0x288, Member, Type: class BufferedChannel<std::function<void __cdecl(void)> >, chFunctions
	//_Data: this+0x2B0, Member, Type: float, lastDT
	//_Data: this+0x2B8, Member, Type: class NodeEvent *, node3DGUI
	//_Func: protected void initSceneGraph(); @loc=static @len=1321 @rva=1678704
	//_Func: protected void stepPhysicsEvent(); @loc=static @len=512 @rva=1698768
	//_Func: protected void initCubemaps(); @loc=static @len=860 @rva=1677216
	//_Func: protected void renderVirtualMirror(); @loc=optimized @len=0 @rva=0
	//_Func: protected void initHDRLevels(); @loc=static @len=616 @rva=1678080
	//_Func: protected void addForm(ksgui_Form * aForm, bool isInDevMode); @loc=static @len=82 @rva=1669856
	//_Func: protected void initStaticCubemap(); @loc=static @len=413 @rva=1680032
	//_Data: this+0x2C0, Member, Type: class std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,Texture,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,Texture> > >, flagMapCache
	//_Tag 11
	//_Func: public Sim & operator=(const Sim &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class Sim : public GameObject, public IKeyEventListener {
public:
	Event<OnNewCarLoadedEvent> evNewCarLoaded;
	Event<OnReplayStatusChanged> evOnReplayStatusChanged;
	Event<bool> evOnPauseModeChanged;
	Event<CollisionEvent> evOnCollisionEvent;
	Event<OnNewSessionEvent> evOnNewSession;
	HDRLevels hdrLevels;
	CommandManager commandManager;
	OptionsManager optionsManager;
	ksgui_GameScreen * gameScreen;
	PauseMenu * pauseMenu;
	ESCMenu * escMenu;
	Node * rootNode;
	Node * trackNode;
	CarNodeSorter * carsNode;
	Node * skidMarkNode;
	Node * particlesNode;
	NodeEvent * carFakeShadowsNode;
	TrackAvatar * track;
	Node * blurredNode;
	Node * unblurredNode;
	DrivingAssistManager * drivingAidsManager;
	NodeEvent * renderFinishedNodeEvent;
	NodeEvent * beforeCarsNode;
	MirrorTextureRenderer * mirrorTextureRenderer;
	ACCameraManager * cameraManager;
	NodeDirtCamera * cameraDirtNode;
	SystemMessage * systemMessage;
	SystemNotification * systemNotification;
	RaceManager * raceManager;
	ReplayManager * replayManager;
	PhysicsAvatar * physicsAvatar;
	ScreenCapturer * screenCapturer;
	ACClient * client;
	PitStop * pitStop;
	TimeLimitedTest * timeLimitedTest;
	bool useProView;
	bool isVrConnected;
	bool isRoomVR;
	bool isVirtualMirrorForced;
	bool useMousePitstop;
	QuickMenu * quickMenu;
	MicroSectors * microSectors;
	bool serializeForms;
	int connectedCarsCount;
	bool allowFreeCamera;
	bool tripleScreenMode;
	bool audioPerformanceSpew;
	std::vector<CarAvatar *,std::allocator<CarAvatar *> > cars;
	unsigned int focusedCarIndex;
	float cameraFadeTime;
	Console * console;
	SimScreen * simScreen;
	CameraForward * sceneCamera;
	SkyBox * skyBox;
	ACErrorHandler * errorHandler;
	DebugVisualizer * debugVisualizer;
	ksgui_FormRenderStats * formRenderStats;
	EndSessionDisplayer * endSessionDisplayer;
	SessionLeaderboard * leaderboard;
	Trigger changingCameraTrigger;
	VirtualMirrorRenderer * virtualMirrorRenderer;
	BufferedChannel<std::function<void __cdecl(void)> > chFunctions;
	float lastDT;
	NodeEvent * node3DGUI;
	std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,Texture,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,Texture> > > flagMapCache;
	inline Sim() { }
	inline Sim(const Sim& other) = default;
	inline Sim& operator=(const Sim& other) = default;
	inline void ctor(Game * igame) { typedef void (Sim::*_fpt)(Game *); auto _f=xcast<_fpt>(_drva(1646704)); (this->*_f)(igame); }
	virtual ~Sim();
	inline void dtor() { typedef void (Sim::*_fpt)(); auto _f=xcast<_fpt>(_drva(1660624)); (this->*_f)(); }
	inline void applyCustomWeather(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name) { typedef void (Sim::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(1671184)); return (this->*_f)(name); }
	inline void startGame() { typedef void (Sim::*_fpt)(); auto _f=xcast<_fpt>(_drva(1698560)); return (this->*_f)(); }
	inline Camera * getSceneCamera() { typedef Camera * (Sim::*_fpt)(); auto _f=xcast<_fpt>(_drva(1676848)); return (this->*_f)(); }
	virtual void update_vf1(float deltaT);
	inline void update_impl(float deltaT) { typedef void (Sim::*_fpt)(float); auto _f=xcast<_fpt>(_drva(1699728)); return (this->*_f)(deltaT); }
	inline void update(float deltaT) { typedef void (Sim::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(deltaT); }
	virtual void render_vf2(float deltaT);
	inline void render_impl(float deltaT) { typedef void (Sim::*_fpt)(float); auto _f=xcast<_fpt>(_drva(1696944)); return (this->*_f)(deltaT); }
	inline void render(float deltaT) { typedef void (Sim::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)(deltaT); }
	virtual void renderHUD_vf3(float deltaT);
	inline void renderHUD_impl(float deltaT) { typedef void (Sim::*_fpt)(float); auto _f=xcast<_fpt>(_drva(1697008)); return (this->*_f)(deltaT); }
	inline void renderHUD(float deltaT) { typedef void (Sim::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(deltaT); }
	inline CarAvatar * addCar(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & model, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & config, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & skin) { typedef CarAvatar * (Sim::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(1669280)); return (this->*_f)(model, config, skin); }
	inline CarAvatar * addNetCar(ClientRemoteCarDef & desc, ACClient * client) { typedef CarAvatar * (Sim::*_fpt)(ClientRemoteCarDef &, ACClient *); auto _f=xcast<_fpt>(_drva(1670192)); return (this->*_f)(desc, client); }
	inline void renderScene(float deltaT) { typedef void (Sim::*_fpt)(float); auto _f=xcast<_fpt>(_drva(1697136)); return (this->*_f)(deltaT); }
	inline void loadTrack(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & tname, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & config, int playerPitPosition) { typedef void (Sim::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, int); auto _f=xcast<_fpt>(_drva(1680576)); return (this->*_f)(tname, config, playerPitPosition); }
	inline CarAvatar * getCar(unsigned int index) { typedef CarAvatar * (Sim::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(1676000)); return (this->*_f)(index); }
	inline unsigned int getCarsCount() { typedef unsigned int (Sim::*_fpt)(); auto _f=xcast<_fpt>(_drva(210640)); return (this->*_f)(); }
	inline void onPostLoad() { typedef void (Sim::*_fpt)(); auto _f=xcast<_fpt>(_drva(1695776)); return (this->*_f)(); }
	inline CameraForward * createCamera(INIReaderDocuments & videoIni, float useBlur) { typedef CameraForward * (Sim::*_fpt)(INIReaderDocuments &, float); auto _f=xcast<_fpt>(_drva(1671904)); return (this->*_f)(videoIni, useBlur); }
	inline void setSplashMessage(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & msg) { typedef void (Sim::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(1697888)); return (this->*_f)(msg); }
	inline void setSplashLoadingCar(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & carUnixName) { typedef void (Sim::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(1697760)); return (this->*_f)(carUnixName); }
	virtual void shutdown_vf5();
	inline void shutdown_impl() { typedef void (Sim::*_fpt)(); auto _f=xcast<_fpt>(_drva(1698272)); return (this->*_f)(); }
	inline void shutdown() { typedef void (Sim::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 5)); return (this->*_f)(); }
	inline bool isInTripleScreenMode() { typedef bool (Sim::*_fpt)(); auto _f=xcast<_fpt>(_drva(1680448)); return (this->*_f)(); }
	inline unsigned int nextCar(unsigned int anIndex) { typedef unsigned int (Sim::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(1681216)); return (this->*_f)(anIndex); }
	inline unsigned int previousCar(unsigned int anIndex) { typedef unsigned int (Sim::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(1696128)); return (this->*_f)(anIndex); }
	inline void writeOutputJson() { typedef void (Sim::*_fpt)(); auto _f=xcast<_fpt>(_drva(1702224)); return (this->*_f)(); }
	inline bool isDisplayingResults() { typedef bool (Sim::*_fpt)(); auto _f=xcast<_fpt>(_drva(503088)); return (this->*_f)(); }
	inline void displayLeaderboard(bool value) { typedef void (Sim::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(280848)); return (this->*_f)(value); }
	virtual void onKeyDown_vf0(const OnKeyEvent & message);
	inline void onKeyDown_impl(const OnKeyEvent & message) { typedef void (Sim::*_fpt)(const OnKeyEvent &); auto _f=xcast<_fpt>(_drva(1681728)); return (this->*_f)(message); }
	inline void onKeyDown(const OnKeyEvent & message) { typedef void (Sim::*_fpt)(const OnKeyEvent &); auto _f=xcast<_fpt>(get_vfp(this, 0)); return (this->*_f)(message); }
	virtual void onKeyChar_vf1(unsigned int key);
	inline void onKeyChar_impl(unsigned int key) { typedef void (Sim::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(96368)); return (this->*_f)(key); }
	inline void onKeyChar(unsigned int key) { typedef void (Sim::*_fpt)(unsigned int); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(key); }
	inline void onReplayModeChanged(const OnReplayStatusChanged & message) { typedef void (Sim::*_fpt)(const OnReplayStatusChanged &); auto _f=xcast<_fpt>(_drva(1695936)); return (this->*_f)(message); }
	inline Console & getConsole() { typedef Console & (Sim::*_fpt)(); auto _f=xcast<_fpt>(_drva(1676048)); return (this->*_f)(); }
	inline TrackData getTrackData() { typedef TrackData (Sim::*_fpt)(); auto _f=xcast<_fpt>(_drva(1676864)); return (this->*_f)(); }
	inline void setPauseMode(bool mode) { typedef void (Sim::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(1697488)); return (this->*_f)(mode); }
	inline void activateGameGui() { typedef void (Sim::*_fpt)(); auto _f=xcast<_fpt>(_drva(1669088)); return (this->*_f)(); }
	inline void activatePauseMenu() { typedef void (Sim::*_fpt)(); auto _f=xcast<_fpt>(_drva(1669184)); return (this->*_f)(); }
	inline void activateEscMenu() { typedef void (Sim::*_fpt)(); auto _f=xcast<_fpt>(_drva(1668992)); return (this->*_f)(); }
	inline void setFocusedCarIndex(unsigned int aCarIndex) { typedef void (Sim::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(1697456)); return (this->*_f)(aCarIndex); }
	inline unsigned int getFocusedCarIndex() { typedef unsigned int (Sim::*_fpt)(); auto _f=xcast<_fpt>(_drva(1676080)); return (this->*_f)(); }
	inline void executeOnMainThread(std::function<void __cdecl(void)> * f) { typedef void (Sim::*_fpt)(std::function<void __cdecl(void)> *); auto _f=xcast<_fpt>(_drva(1675840)); return (this->*_f)(f); }
	inline void unloadMeshResources(Node * node) { typedef void (Sim::*_fpt)(Node *); auto _f=xcast<_fpt>(_drva(1699280)); return (this->*_f)(node); }
	inline Texture * getNationFlag(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & nationCode) { typedef Texture * (Sim::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(1676112)); return (this->*_f)(nationCode); }
	inline bool isVrRoom() { typedef bool (Sim::*_fpt)(); auto _f=xcast<_fpt>(_drva(888336)); return (this->*_f)(); }
	inline void initSceneGraph() { typedef void (Sim::*_fpt)(); auto _f=xcast<_fpt>(_drva(1678704)); return (this->*_f)(); }
	inline void stepPhysicsEvent() { typedef void (Sim::*_fpt)(); auto _f=xcast<_fpt>(_drva(1698768)); return (this->*_f)(); }
	inline void initCubemaps() { typedef void (Sim::*_fpt)(); auto _f=xcast<_fpt>(_drva(1677216)); return (this->*_f)(); }
	inline void initHDRLevels() { typedef void (Sim::*_fpt)(); auto _f=xcast<_fpt>(_drva(1678080)); return (this->*_f)(); }
	inline void addForm(ksgui_Form * aForm, bool isInDevMode) { typedef void (Sim::*_fpt)(ksgui_Form *, bool); auto _f=xcast<_fpt>(_drva(1669856)); return (this->*_f)(aForm, isInDevMode); }
	inline void initStaticCubemap() { typedef void (Sim::*_fpt)(); auto _f=xcast<_fpt>(_drva(1680032)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(Sim)==720),"bad size");
		static_assert((offsetof(Sim,evNewCarLoaded)==0x60),"bad off");
		static_assert((offsetof(Sim,evOnReplayStatusChanged)==0x78),"bad off");
		static_assert((offsetof(Sim,evOnPauseModeChanged)==0x90),"bad off");
		static_assert((offsetof(Sim,evOnCollisionEvent)==0xA8),"bad off");
		static_assert((offsetof(Sim,evOnNewSession)==0xC0),"bad off");
		static_assert((offsetof(Sim,hdrLevels)==0xD8),"bad off");
		static_assert((offsetof(Sim,commandManager)==0xE0),"bad off");
		static_assert((offsetof(Sim,optionsManager)==0xF0),"bad off");
		static_assert((offsetof(Sim,gameScreen)==0x108),"bad off");
		static_assert((offsetof(Sim,pauseMenu)==0x110),"bad off");
		static_assert((offsetof(Sim,escMenu)==0x118),"bad off");
		static_assert((offsetof(Sim,rootNode)==0x120),"bad off");
		static_assert((offsetof(Sim,trackNode)==0x128),"bad off");
		static_assert((offsetof(Sim,carsNode)==0x130),"bad off");
		static_assert((offsetof(Sim,skidMarkNode)==0x138),"bad off");
		static_assert((offsetof(Sim,particlesNode)==0x140),"bad off");
		static_assert((offsetof(Sim,carFakeShadowsNode)==0x148),"bad off");
		static_assert((offsetof(Sim,track)==0x150),"bad off");
		static_assert((offsetof(Sim,blurredNode)==0x158),"bad off");
		static_assert((offsetof(Sim,unblurredNode)==0x160),"bad off");
		static_assert((offsetof(Sim,drivingAidsManager)==0x168),"bad off");
		static_assert((offsetof(Sim,renderFinishedNodeEvent)==0x170),"bad off");
		static_assert((offsetof(Sim,beforeCarsNode)==0x178),"bad off");
		static_assert((offsetof(Sim,mirrorTextureRenderer)==0x180),"bad off");
		static_assert((offsetof(Sim,cameraManager)==0x188),"bad off");
		static_assert((offsetof(Sim,cameraDirtNode)==0x190),"bad off");
		static_assert((offsetof(Sim,systemMessage)==0x198),"bad off");
		static_assert((offsetof(Sim,systemNotification)==0x1A0),"bad off");
		static_assert((offsetof(Sim,raceManager)==0x1A8),"bad off");
		static_assert((offsetof(Sim,replayManager)==0x1B0),"bad off");
		static_assert((offsetof(Sim,physicsAvatar)==0x1B8),"bad off");
		static_assert((offsetof(Sim,screenCapturer)==0x1C0),"bad off");
		static_assert((offsetof(Sim,client)==0x1C8),"bad off");
		static_assert((offsetof(Sim,pitStop)==0x1D0),"bad off");
		static_assert((offsetof(Sim,timeLimitedTest)==0x1D8),"bad off");
		static_assert((offsetof(Sim,useProView)==0x1E0),"bad off");
		static_assert((offsetof(Sim,isVrConnected)==0x1E1),"bad off");
		static_assert((offsetof(Sim,isRoomVR)==0x1E2),"bad off");
		static_assert((offsetof(Sim,isVirtualMirrorForced)==0x1E3),"bad off");
		static_assert((offsetof(Sim,useMousePitstop)==0x1E4),"bad off");
		static_assert((offsetof(Sim,quickMenu)==0x1E8),"bad off");
		static_assert((offsetof(Sim,microSectors)==0x1F0),"bad off");
		static_assert((offsetof(Sim,serializeForms)==0x1F8),"bad off");
		static_assert((offsetof(Sim,connectedCarsCount)==0x1FC),"bad off");
		static_assert((offsetof(Sim,allowFreeCamera)==0x200),"bad off");
		static_assert((offsetof(Sim,tripleScreenMode)==0x201),"bad off");
		static_assert((offsetof(Sim,audioPerformanceSpew)==0x202),"bad off");
		static_assert((offsetof(Sim,cars)==0x208),"bad off");
		static_assert((offsetof(Sim,focusedCarIndex)==0x220),"bad off");
		static_assert((offsetof(Sim,cameraFadeTime)==0x224),"bad off");
		static_assert((offsetof(Sim,console)==0x228),"bad off");
		static_assert((offsetof(Sim,simScreen)==0x230),"bad off");
		static_assert((offsetof(Sim,sceneCamera)==0x238),"bad off");
		static_assert((offsetof(Sim,skyBox)==0x240),"bad off");
		static_assert((offsetof(Sim,errorHandler)==0x248),"bad off");
		static_assert((offsetof(Sim,debugVisualizer)==0x250),"bad off");
		static_assert((offsetof(Sim,formRenderStats)==0x258),"bad off");
		static_assert((offsetof(Sim,endSessionDisplayer)==0x260),"bad off");
		static_assert((offsetof(Sim,leaderboard)==0x268),"bad off");
		static_assert((offsetof(Sim,changingCameraTrigger)==0x270),"bad off");
		static_assert((offsetof(Sim,virtualMirrorRenderer)==0x280),"bad off");
		static_assert((offsetof(Sim,chFunctions)==0x288),"bad off");
		static_assert((offsetof(Sim,lastDT)==0x2B0),"bad off");
		static_assert((offsetof(Sim,node3DGUI)==0x2B8),"bad off");
		static_assert((offsetof(Sim,flagMapCache)==0x2C0),"bad off");
	};
};

//UDT: struct RenderContext @len=32
	//_Func: public void RenderContext(GraphicsManager *  _arg0, IMeshRenderFilter &  _arg1, MaterialFilter &  _arg2); @loc=optimized @len=0 @rva=0
	//_Data: this+0x0, Member, Type: class MaterialFilter &, materialFilter
	//_Data: this+0x8, Member, Type: class IMeshRenderFilter &, meshFilter
	//_Data: this+0x10, Member, Type: class GraphicsManager *, graphics
	//_Data: this+0x18, Member, Type: class Camera *, camera
//UDT;

struct RenderContext {
public:
	MaterialFilter & materialFilter;
	IMeshRenderFilter & meshFilter;
	GraphicsManager * graphics;
	Camera * camera;
	inline RenderContext() : materialFilter(*((MaterialFilter*)NULL)), meshFilter(*((IMeshRenderFilter*)NULL)) { }
	inline RenderContext(const RenderContext& other) = default;
	inline RenderContext& operator=(const RenderContext& other) = default;
	inline void _guard_obj() {
		static_assert((sizeof(RenderContext)==32),"bad size");
		static_assert((offsetof(RenderContext,graphics)==0x10),"bad off");
		static_assert((offsetof(RenderContext,camera)==0x18),"bad off");
	};
};

//UDT: struct BrakeSystem @len=1008
	//_Data: this+0x0, Member, Type: float, frontBias
	//_Data: this+0x4, Member, Type: float, brakePowerMultiplier
	//_Data: this+0x8, Member, Type: float, electronicOverride
	//_Data: this+0xC, Member, Type: float, handBrakeTorque
	//_Data: this+0x10, Member, Type: float, ebbInstant
	//_Data: this+0x18, Member, Type: struct BrakeDisc[0x4], discs
	//_Data: this+0x258, Member, Type: float, limitDown
	//_Data: this+0x25C, Member, Type: float, limitUp
	//_Data: this+0x260, Member, Type: float, rearCorrectionTorque
	//_Func: public void init(Car * car); @loc=static @len=466 @rva=2676368
	//_Func: public void step(float dt); @loc=static @len=731 @rva=2680384
	//_Func: public float getBrakePower(); @loc=static @len=9 @rva=2676256
	//_Func: public void setFrontBias(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void setManualFrontBias(int value); @loc=static @len=107 @rva=2680272
	//_Func: public float getFrontBias(); @loc=static @len=22 @rva=2676272
	//_Func: public void reset(); @loc=static @len=71 @rva=2679952
	//_Func: public bool isUsingEBB(); @loc=static @len=12 @rva=2879392
	//_Func: public void activateTempRunFile(bool mode); @loc=static @len=543 @rva=2675712
	//_Data: this+0x268, Member, Type: class Car *, car
	//_Data: this+0x270, Member, Type: float, brakePower
	//_Data: this+0x274, Member, Type: float, biasOverride
	//_Data: this+0x278, Member, Type: bool, hasCockpitBias
	//_Data: this+0x27C, Member, Type: float, biasStep
	//_Data: this+0x280, Member, Type: enum EBBMode, ebbMode
	//_Data: this+0x284, Member, Type: float, ebbFrontMultiplier
	//_Data: this+0x288, Member, Type: struct SteerBrake, steerBrake
	//_Data: this+0x2B8, Member, Type: bool, hasBrakeTempsData
	//_Data: this+0x2C0, Member, Type: class std::basic_ofstream<char,std::char_traits<char> >, tempRunFile
	//_Data: this+0x3C8, Member, Type: class DynamicController, ebbController
	//_Func: protected void loadINI(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * dataPath); @loc=static @len=3091 @rva=2676848
	//_Func: protected void stepTemps(float dt); @loc=static @len=417 @rva=2681120
	//_Func: protected void saveTempsRunFame(); @loc=static @len=227 @rva=2680032
	//_Func: public void BrakeSystem(const BrakeSystem &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void BrakeSystem(); @loc=static @len=220 @rva=2539040
	//_Func: public void ~BrakeSystem(); @loc=static @len=93 @rva=2547824
	//_Func: public BrakeSystem & operator=(const BrakeSystem &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct BrakeSystem {
public:
	float frontBias;
	float brakePowerMultiplier;
	float electronicOverride;
	float handBrakeTorque;
	float ebbInstant;
	BrakeDisc discs[4];
	float limitDown;
	float limitUp;
	float rearCorrectionTorque;
	Car * car;
	float brakePower;
	float biasOverride;
	bool hasCockpitBias;
	float biasStep;
	EBBMode ebbMode;
	float ebbFrontMultiplier;
	SteerBrake steerBrake;
	bool hasBrakeTempsData;
	std::basic_ofstream<char,std::char_traits<char> > tempRunFile;
	DynamicController ebbController;
	inline BrakeSystem() { }
	inline BrakeSystem(const BrakeSystem& other) = default;
	inline BrakeSystem& operator=(const BrakeSystem& other) = default;
	inline void init(Car * car) { typedef void (BrakeSystem::*_fpt)(Car *); auto _f=xcast<_fpt>(_drva(2676368)); return (this->*_f)(car); }
	inline void step(float dt) { typedef void (BrakeSystem::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2680384)); return (this->*_f)(dt); }
	inline float getBrakePower() { typedef float (BrakeSystem::*_fpt)(); auto _f=xcast<_fpt>(_drva(2676256)); return (this->*_f)(); }
	inline void setManualFrontBias(int value) { typedef void (BrakeSystem::*_fpt)(int); auto _f=xcast<_fpt>(_drva(2680272)); return (this->*_f)(value); }
	inline float getFrontBias() { typedef float (BrakeSystem::*_fpt)(); auto _f=xcast<_fpt>(_drva(2676272)); return (this->*_f)(); }
	inline void reset() { typedef void (BrakeSystem::*_fpt)(); auto _f=xcast<_fpt>(_drva(2679952)); return (this->*_f)(); }
	inline bool isUsingEBB() { typedef bool (BrakeSystem::*_fpt)(); auto _f=xcast<_fpt>(_drva(2879392)); return (this->*_f)(); }
	inline void activateTempRunFile(bool mode) { typedef void (BrakeSystem::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(2675712)); return (this->*_f)(mode); }
	inline void loadINI(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * dataPath) { typedef void (BrakeSystem::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *); auto _f=xcast<_fpt>(_drva(2676848)); return (this->*_f)(dataPath); }
	inline void stepTemps(float dt) { typedef void (BrakeSystem::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2681120)); return (this->*_f)(dt); }
	inline void saveTempsRunFame() { typedef void (BrakeSystem::*_fpt)(); auto _f=xcast<_fpt>(_drva(2680032)); return (this->*_f)(); }
	inline void ctor() { typedef void (BrakeSystem::*_fpt)(); auto _f=xcast<_fpt>(_drva(2539040)); (this->*_f)(); }
	inline void dtor() { typedef void (BrakeSystem::*_fpt)(); auto _f=xcast<_fpt>(_drva(2547824)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(BrakeSystem)==1008),"bad size");
		static_assert((offsetof(BrakeSystem,frontBias)==0x0),"bad off");
		static_assert((offsetof(BrakeSystem,brakePowerMultiplier)==0x4),"bad off");
		static_assert((offsetof(BrakeSystem,electronicOverride)==0x8),"bad off");
		static_assert((offsetof(BrakeSystem,handBrakeTorque)==0xC),"bad off");
		static_assert((offsetof(BrakeSystem,ebbInstant)==0x10),"bad off");
		static_assert((offsetof(BrakeSystem,discs)==0x18),"bad off");
		static_assert((offsetof(BrakeSystem,limitDown)==0x258),"bad off");
		static_assert((offsetof(BrakeSystem,limitUp)==0x25C),"bad off");
		static_assert((offsetof(BrakeSystem,rearCorrectionTorque)==0x260),"bad off");
		static_assert((offsetof(BrakeSystem,car)==0x268),"bad off");
		static_assert((offsetof(BrakeSystem,brakePower)==0x270),"bad off");
		static_assert((offsetof(BrakeSystem,biasOverride)==0x274),"bad off");
		static_assert((offsetof(BrakeSystem,hasCockpitBias)==0x278),"bad off");
		static_assert((offsetof(BrakeSystem,biasStep)==0x27C),"bad off");
		static_assert((offsetof(BrakeSystem,ebbMode)==0x280),"bad off");
		static_assert((offsetof(BrakeSystem,ebbFrontMultiplier)==0x284),"bad off");
		static_assert((offsetof(BrakeSystem,steerBrake)==0x288),"bad off");
		static_assert((offsetof(BrakeSystem,hasBrakeTempsData)==0x2B8),"bad off");
		static_assert((offsetof(BrakeSystem,tempRunFile)==0x2C0),"bad off");
		static_assert((offsetof(BrakeSystem,ebbController)==0x3C8),"bad off");
	};
};

//UDT: class CubeMapRenderer @len=992 @vfcount=1
	//_VTable: 
	//_Func: public void CubeMapRenderer(const CubeMapRenderer &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void CubeMapRenderer(GraphicsManager * graphics); @loc=static @len=1685 @rva=2221648
	//_Func: public void ~CubeMapRenderer(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=69 @rva=2223344
	//_Data: this+0x8, Member, Type: int, facesPerFrame
	//_Data: this+0x10, Member, Type: class Event<int>, evOnRenderBegin
	//_Data: this+0x28, Member, Type: class Event<int>, evOnRenderEnd
	//_Func: public void render(CubeMap * cubeMap, Node * root, Camera & sceneCamera); @loc=static @len=851 @rva=2223536
	//_Func: public void setCameraNearFarPlanes(float nearp, float farp); @loc=static @len=17 @rva=2224400
	//_Data: this+0x40, Member, Type: class GraphicsManager *, graphics
	//_Data: this+0x48, Member, Type: class mat44f[0x6], cameraMatrix
	//_Data: this+0x1C8, Member, Type: class Camera, camera
	//_Data: this+0x3D8, Member, Type: int, currentFace
	//_Func: protected void renderScene(int  _arg0, Node *  _arg1, Camera &  _arg2); @loc=optimized @len=0 @rva=0
	//_Func: public CubeMapRenderer & operator=(const CubeMapRenderer &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class CubeMapRenderer {
public:
	int facesPerFrame;
	Event<int> evOnRenderBegin;
	Event<int> evOnRenderEnd;
	GraphicsManager * graphics;
	mat44f cameraMatrix[6];
	Camera camera;
	int currentFace;
	inline CubeMapRenderer() { }
	inline CubeMapRenderer(const CubeMapRenderer& other) = default;
	inline CubeMapRenderer& operator=(const CubeMapRenderer& other) = default;
	inline void ctor(GraphicsManager * graphics) { typedef void (CubeMapRenderer::*_fpt)(GraphicsManager *); auto _f=xcast<_fpt>(_drva(2221648)); (this->*_f)(graphics); }
	virtual ~CubeMapRenderer();
	inline void dtor() { typedef void (CubeMapRenderer::*_fpt)(); auto _f=xcast<_fpt>(_drva(2223344)); (this->*_f)(); }
	inline void render(CubeMap * cubeMap, Node * root, Camera & sceneCamera) { typedef void (CubeMapRenderer::*_fpt)(CubeMap *, Node *, Camera &); auto _f=xcast<_fpt>(_drva(2223536)); return (this->*_f)(cubeMap, root, sceneCamera); }
	inline void setCameraNearFarPlanes(float nearp, float farp) { typedef void (CubeMapRenderer::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2224400)); return (this->*_f)(nearp, farp); }
	inline void _guard_obj() {
		static_assert((sizeof(CubeMapRenderer)==992),"bad size");
		static_assert((offsetof(CubeMapRenderer,facesPerFrame)==0x8),"bad off");
		static_assert((offsetof(CubeMapRenderer,evOnRenderBegin)==0x10),"bad off");
		static_assert((offsetof(CubeMapRenderer,evOnRenderEnd)==0x28),"bad off");
		static_assert((offsetof(CubeMapRenderer,graphics)==0x40),"bad off");
		static_assert((offsetof(CubeMapRenderer,cameraMatrix)==0x48),"bad off");
		static_assert((offsetof(CubeMapRenderer,camera)==0x1C8),"bad off");
		static_assert((offsetof(CubeMapRenderer,currentFace)==0x3D8),"bad off");
	};
};

//UDT: class Wing @len=784
	//_Data: this+0x0, Member, Type: struct WingData, data
	//_Data: this+0x250, Member, Type: struct WingState, status
	//_Data: this+0x298, Member, Type: class std::vector<DynamicWingController,std::allocator<DynamicWingController> >, dynamicControllers
	//_Data: this+0x2B0, Member, Type: class Car *, car
	//_Data: this+0x2B8, Member, Type: class RaceEngineer, engineer
	//_Data: this+0x2D0, Member, Type: float[0x5], damageCL
	//_Data: this+0x2E4, Member, Type: float[0x5], damageCD
	//_Data: this+0x2F8, Member, Type: bool, hasDamage
	//_Data: this+0x2FC, Member, Type: struct WingOverrideDef, overrideStatus
	//_Data: this+0x304, Member, Type: const float, SPEED_DAMAGE_COEFF
	//_Data: this+0x308, Member, Type: const float, SURFACE_DAMAGE_COEFF
	//_Func: public void Wing(const Wing & __that); @loc=static @len=294 @rva=2839136
	//_Func: public void Wing(Car * a_car, INIReader & ini, int index, bool isVertical); @loc=static @len=3958 @rva=2822976
	//_Func: public void ~Wing(); @loc=static @len=61 @rva=2827120
	//_Func: public void step(float dt); @loc=static @len=515 @rva=2829248
	//_Func: public void setOverrideAngle(float iangle); @loc=static @len=16 @rva=2829232
	//_Func: public void clearOverrides(); @loc=static @len=8 @rva=2829168
	//_Func: public float getCurrentModifiedAngle(); @loc=static @len=35 @rva=2829184
	//_Func: private void stepDynamicControllers(float dt); @loc=static @len=165 @rva=2829776
	//_Func: private void addDrag(vec3f & lv); @loc=static @len=776 @rva=2827296
	//_Func: private void addLift(vec3f & lv); @loc=static @len=1088 @rva=2828080
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class Wing {
public:
	WingData data;
	WingState status;
	std::vector<DynamicWingController,std::allocator<DynamicWingController> > dynamicControllers;
	Car * car;
	RaceEngineer engineer;
	float damageCL[5];
	float damageCD[5];
	bool hasDamage;
	WingOverrideDef overrideStatus;
	float SPEED_DAMAGE_COEFF;
	float SURFACE_DAMAGE_COEFF;
	inline Wing() { }
	inline Wing(const Wing& other) = default;
	inline Wing& operator=(const Wing& other) = default;
	inline void ctor(const Wing & __that) { typedef void (Wing::*_fpt)(const Wing &); auto _f=xcast<_fpt>(_drva(2839136)); (this->*_f)(__that); }
	inline void ctor(Car * a_car, INIReader & ini, int index, bool isVertical) { typedef void (Wing::*_fpt)(Car *, INIReader &, int, bool); auto _f=xcast<_fpt>(_drva(2822976)); (this->*_f)(a_car, ini, index, isVertical); }
	inline void dtor() { typedef void (Wing::*_fpt)(); auto _f=xcast<_fpt>(_drva(2827120)); (this->*_f)(); }
	inline void step(float dt) { typedef void (Wing::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2829248)); return (this->*_f)(dt); }
	inline void setOverrideAngle(float iangle) { typedef void (Wing::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2829232)); return (this->*_f)(iangle); }
	inline void clearOverrides() { typedef void (Wing::*_fpt)(); auto _f=xcast<_fpt>(_drva(2829168)); return (this->*_f)(); }
	inline float getCurrentModifiedAngle() { typedef float (Wing::*_fpt)(); auto _f=xcast<_fpt>(_drva(2829184)); return (this->*_f)(); }
	inline void stepDynamicControllers(float dt) { typedef void (Wing::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2829776)); return (this->*_f)(dt); }
	inline void addDrag(vec3f & lv) { typedef void (Wing::*_fpt)(vec3f &); auto _f=xcast<_fpt>(_drva(2827296)); return (this->*_f)(lv); }
	inline void addLift(vec3f & lv) { typedef void (Wing::*_fpt)(vec3f &); auto _f=xcast<_fpt>(_drva(2828080)); return (this->*_f)(lv); }
	inline void _guard_obj() {
		static_assert((sizeof(Wing)==784),"bad size");
		static_assert((offsetof(Wing,data)==0x0),"bad off");
		static_assert((offsetof(Wing,status)==0x250),"bad off");
		static_assert((offsetof(Wing,dynamicControllers)==0x298),"bad off");
		static_assert((offsetof(Wing,car)==0x2B0),"bad off");
		static_assert((offsetof(Wing,engineer)==0x2B8),"bad off");
		static_assert((offsetof(Wing,damageCL)==0x2D0),"bad off");
		static_assert((offsetof(Wing,damageCD)==0x2E4),"bad off");
		static_assert((offsetof(Wing,hasDamage)==0x2F8),"bad off");
		static_assert((offsetof(Wing,overrideStatus)==0x2FC),"bad off");
		static_assert((offsetof(Wing,SPEED_DAMAGE_COEFF)==0x304),"bad off");
		static_assert((offsetof(Wing,SURFACE_DAMAGE_COEFF)==0x308),"bad off");
	};
};

//UDT: class ERS @len=688 @multibase=2
	//_Base: class ITorqueGenerator @off=0 @len=8
	//_Base: class ICoastGenerator @off=8 @len=8
	//_Func: public void ERS(const ERS &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void ERS(); @loc=static @len=275 @rva=2692352
	//_Func: public void ~ERS(); @virtual vtpo=0 vfid=0 @loc=static @len=279 @rva=2692816
	//_Data: this+0x10, Member, Type: bool, present
	//_Data: this+0x14, Member, Type: float, kineticRecovery
	//_Data: this+0x18, Member, Type: struct ERSStatus, status
	//_Data: this+0x20, Member, Type: bool, isHeatCharginBattery
	//_Data: this+0x28, Member, Type: class std::vector<ERSPowerController,std::allocator<ERSPowerController> >, ersPowerControllers
	//_Data: this+0x40, Member, Type: class std::vector<ERSPowerController,std::allocator<ERSPowerController> >, ersPowerControllersFront
	//_Data: this+0x58, Member, Type: int, defaultPowerControllerIndex
	//_Data: this+0x5C, Member, Type: bool, isCharging
	//_Data: this+0x5D, Member, Type: struct ERSCockpitControls, cockpitControls
	//_Func: public void init(Car * car); @loc=static @len=4756 @rva=2694192
	//_Func: public void step(float dt); @loc=static @len=1505 @rva=2699488
	//_Func: public float getOutputTorque(); @virtual vtpo=0 vfid=1 @loc=static @len=82 @rva=2694096
	//_Func: public float getCoastTorque(); @virtual vtpo=8 vfid=1 @loc=static @len=139 @rva=2693952
	//_Func: public void reset(); @loc=static @len=28 @rva=2699168
	//_Func: public float getCharge(); @loc=optimized @len=0 @rva=0
	//_Func: public float getInput(); @loc=optimized @len=0 @rva=0
	//_Func: public float getCurrentJ(); @loc=optimized @len=0 @rva=0
	//_Func: public float getMaxJ(); @loc=optimized @len=0 @rva=0
	//_Func: public void setPowerController(int index); @loc=static @len=287 @rva=2699200
	//_Data: this+0x60, Member, Type: class Car *, car
	//_Data: this+0x68, Member, Type: double, chargeK
	//_Data: this+0x70, Member, Type: double, dischargeK
	//_Data: this+0x78, Member, Type: double, dischargeKFront
	//_Data: this+0x80, Member, Type: bool, hasButtonOverride
	//_Data: this+0x88, Member, Type: class Curve, torqueLUT
	//_Data: this+0x108, Member, Type: class Curve, coastLUT
	//_Data: this+0x188, Member, Type: class DynamicController, controller
	//_Data: this+0x1B0, Member, Type: class DynamicController, controllerFront
	//_Data: this+0x1D8, Member, Type: double, charge
	//_Data: this+0x1E0, Member, Type: float, maxJ
	//_Data: this+0x1E4, Member, Type: float, currentJ
	//_Data: this+0x1E8, Member, Type: float, input
	//_Data: this+0x1F0, Member, Type: double, heatChargeK
	//_Data: this+0x1F8, Member, Type: float, heatTorque
	//_Data: this+0x1FC, Member, Type: float, rearCorrectionTorque
	//_Data: this+0x200, Member, Type: class DynamicController, frontController
	//_Data: this+0x228, Member, Type: class Curve, frontTorqueLUT
	//_Data: this+0x2A8, Member, Type: float, frontTorqueVectoringBias
	//_Func: public ERS & operator=(const ERS &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class ERS : public ITorqueGenerator, public ICoastGenerator {
public:
	bool present;
	float kineticRecovery;
	ERSStatus status;
	bool isHeatCharginBattery;
	std::vector<ERSPowerController,std::allocator<ERSPowerController> > ersPowerControllers;
	std::vector<ERSPowerController,std::allocator<ERSPowerController> > ersPowerControllersFront;
	int defaultPowerControllerIndex;
	bool isCharging;
	ERSCockpitControls cockpitControls;
	Car * car;
	double chargeK;
	double dischargeK;
	double dischargeKFront;
	bool hasButtonOverride;
	Curve torqueLUT;
	Curve coastLUT;
	DynamicController controller;
	DynamicController controllerFront;
	double charge;
	float maxJ;
	float currentJ;
	float input;
	double heatChargeK;
	float heatTorque;
	float rearCorrectionTorque;
	DynamicController frontController;
	Curve frontTorqueLUT;
	float frontTorqueVectoringBias;
	inline ERS() { }
	inline ERS(const ERS& other) = default;
	inline ERS& operator=(const ERS& other) = default;
	inline void ctor() { typedef void (ERS::*_fpt)(); auto _f=xcast<_fpt>(_drva(2692352)); (this->*_f)(); }
	virtual ~ERS();
	inline void dtor() { typedef void (ERS::*_fpt)(); auto _f=xcast<_fpt>(_drva(2692816)); (this->*_f)(); }
	inline void init(Car * car) { typedef void (ERS::*_fpt)(Car *); auto _f=xcast<_fpt>(_drva(2694192)); return (this->*_f)(car); }
	inline void step(float dt) { typedef void (ERS::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2699488)); return (this->*_f)(dt); }
	virtual float getOutputTorque_vf1();
	inline float getOutputTorque_impl() { typedef float (ERS::*_fpt)(); auto _f=xcast<_fpt>(_drva(2694096)); return (this->*_f)(); }
	inline float getOutputTorque() { typedef float (ERS::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(); }
	virtual float getCoastTorque_vf1();
	inline float getCoastTorque_impl() { typedef float (ERS::*_fpt)(); auto _f=xcast<_fpt>(_drva(2693952)); return (this->*_f)(); }
	inline float getCoastTorque() { typedef float (ERS::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(); }
	inline void reset() { typedef void (ERS::*_fpt)(); auto _f=xcast<_fpt>(_drva(2699168)); return (this->*_f)(); }
	inline void setPowerController(int index) { typedef void (ERS::*_fpt)(int); auto _f=xcast<_fpt>(_drva(2699200)); return (this->*_f)(index); }
	inline void _guard_obj() {
		static_assert((sizeof(ERS)==688),"bad size");
		static_assert((offsetof(ERS,present)==0x10),"bad off");
		static_assert((offsetof(ERS,kineticRecovery)==0x14),"bad off");
		static_assert((offsetof(ERS,status)==0x18),"bad off");
		static_assert((offsetof(ERS,isHeatCharginBattery)==0x20),"bad off");
		static_assert((offsetof(ERS,ersPowerControllers)==0x28),"bad off");
		static_assert((offsetof(ERS,ersPowerControllersFront)==0x40),"bad off");
		static_assert((offsetof(ERS,defaultPowerControllerIndex)==0x58),"bad off");
		static_assert((offsetof(ERS,isCharging)==0x5C),"bad off");
		static_assert((offsetof(ERS,cockpitControls)==0x5D),"bad off");
		static_assert((offsetof(ERS,car)==0x60),"bad off");
		static_assert((offsetof(ERS,chargeK)==0x68),"bad off");
		static_assert((offsetof(ERS,dischargeK)==0x70),"bad off");
		static_assert((offsetof(ERS,dischargeKFront)==0x78),"bad off");
		static_assert((offsetof(ERS,hasButtonOverride)==0x80),"bad off");
		static_assert((offsetof(ERS,torqueLUT)==0x88),"bad off");
		static_assert((offsetof(ERS,coastLUT)==0x108),"bad off");
		static_assert((offsetof(ERS,controller)==0x188),"bad off");
		static_assert((offsetof(ERS,controllerFront)==0x1B0),"bad off");
		static_assert((offsetof(ERS,charge)==0x1D8),"bad off");
		static_assert((offsetof(ERS,maxJ)==0x1E0),"bad off");
		static_assert((offsetof(ERS,currentJ)==0x1E4),"bad off");
		static_assert((offsetof(ERS,input)==0x1E8),"bad off");
		static_assert((offsetof(ERS,heatChargeK)==0x1F0),"bad off");
		static_assert((offsetof(ERS,heatTorque)==0x1F8),"bad off");
		static_assert((offsetof(ERS,rearCorrectionTorque)==0x1FC),"bad off");
		static_assert((offsetof(ERS,frontController)==0x200),"bad off");
		static_assert((offsetof(ERS,frontTorqueLUT)==0x228),"bad off");
		static_assert((offsetof(ERS,frontTorqueVectoringBias)==0x2A8),"bad off");
	};
};

//UDT: class CameraShadowMapped @len=672 @vfcount=7
	//_Base: class Camera @off=0 @len=528
	//_Data: , Static Member, Type: const int, shadowMapPassNumber
	//_Func: public void CameraShadowMapped(const CameraShadowMapped &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void CameraShadowMapped(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & iname, GraphicsManager * gm); @loc=static @len=1026 @rva=2145744
	//_Func: public void ~CameraShadowMapped(); @virtual vtpo=0 vfid=0 @loc=static @len=274 @rva=2146784
	//_Data: this+0x210, Member, Type: class std::vector<ShadowMapSettings,std::allocator<ShadowMapSettings> >, shadowMapSettings
	//_Data: this+0x228, Member, Type: float, shadowBias
	//_Func: public void setShadowMapsSplits(float s1, float s2, float s3, float s4); @loc=static @len=166 @rva=2151920
	//_Func: public void setUniformShadowSplits(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void clearShadowRenderTargets(); @loc=optimized @len=0 @rva=0
	//_Func: public void render(Node * root, float dt); @virtual vtpo=0 vfid=1 @loc=static @len=95 @rva=2150080
	//_Data: this+0x230, Member, Type: class std::vector<RenderTarget *,std::allocator<RenderTarget *> >, shadowRT
	//_Data: this+0x248, Member, Type: class std::vector<mat44f,std::allocator<mat44f> >, shadowMatrices
	//_Data: this+0x260, Member, Type: class mat44f, stableShadowMatrix
	//_Func: protected void initShadowRenderTargets(); @loc=optimized @len=0 @rva=0
	//_Func: protected void beginShadowMapPass(int level, RenderContext * rc, const mat44f & cameraMatrix); @loc=static @len=667 @rva=2147568
	//_Func: protected void endShadowMapPass(int  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: protected void shadowMapPass(Node * root, float dt); @intro @virtual vtpo=0 vfid=5 @loc=static @len=567 @rva=2152096
	//_Func: protected void renderPass(Node * root, float dt); @intro @virtual vtpo=0 vfid=6 @loc=static @len=895 @rva=2150176
	//_Func: protected void createShadowMapMatrix(const mat44f & cameraMatrix, float nearp, float farp, vec3f lightDir, float cameraHeight, mat44f & view, mat44f & proj); @loc=static @len=1832 @rva=2148240
	//_Func: public CameraShadowMapped & operator=(const CameraShadowMapped &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class CameraShadowMapped : public Camera {
public:
	std::vector<ShadowMapSettings,std::allocator<ShadowMapSettings> > shadowMapSettings;
	float shadowBias;
	std::vector<RenderTarget *,std::allocator<RenderTarget *> > shadowRT;
	std::vector<mat44f,std::allocator<mat44f> > shadowMatrices;
	mat44f stableShadowMatrix;
	inline CameraShadowMapped() { }
	inline CameraShadowMapped(const CameraShadowMapped& other) = default;
	inline CameraShadowMapped& operator=(const CameraShadowMapped& other) = default;
	inline void ctor(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & iname, GraphicsManager * gm) { typedef void (CameraShadowMapped::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, GraphicsManager *); auto _f=xcast<_fpt>(_drva(2145744)); (this->*_f)(iname, gm); }
	virtual ~CameraShadowMapped();
	inline void dtor() { typedef void (CameraShadowMapped::*_fpt)(); auto _f=xcast<_fpt>(_drva(2146784)); (this->*_f)(); }
	inline void setShadowMapsSplits(float s1, float s2, float s3, float s4) { typedef void (CameraShadowMapped::*_fpt)(float, float, float, float); auto _f=xcast<_fpt>(_drva(2151920)); return (this->*_f)(s1, s2, s3, s4); }
	virtual void render_vf1(Node * root, float dt);
	inline void render_impl(Node * root, float dt) { typedef void (CameraShadowMapped::*_fpt)(Node *, float); auto _f=xcast<_fpt>(_drva(2150080)); return (this->*_f)(root, dt); }
	inline void render(Node * root, float dt) { typedef void (CameraShadowMapped::*_fpt)(Node *, float); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(root, dt); }
	inline void beginShadowMapPass(int level, RenderContext * rc, const mat44f & cameraMatrix) { typedef void (CameraShadowMapped::*_fpt)(int, RenderContext *, const mat44f &); auto _f=xcast<_fpt>(_drva(2147568)); return (this->*_f)(level, rc, cameraMatrix); }
	virtual void shadowMapPass_vf5(Node * root, float dt);
	inline void shadowMapPass_impl(Node * root, float dt) { typedef void (CameraShadowMapped::*_fpt)(Node *, float); auto _f=xcast<_fpt>(_drva(2152096)); return (this->*_f)(root, dt); }
	inline void shadowMapPass(Node * root, float dt) { typedef void (CameraShadowMapped::*_fpt)(Node *, float); auto _f=xcast<_fpt>(get_vfp(this, 5)); return (this->*_f)(root, dt); }
	virtual void renderPass_vf6(Node * root, float dt);
	inline void renderPass_impl(Node * root, float dt) { typedef void (CameraShadowMapped::*_fpt)(Node *, float); auto _f=xcast<_fpt>(_drva(2150176)); return (this->*_f)(root, dt); }
	inline void renderPass(Node * root, float dt) { typedef void (CameraShadowMapped::*_fpt)(Node *, float); auto _f=xcast<_fpt>(get_vfp(this, 6)); return (this->*_f)(root, dt); }
	inline void createShadowMapMatrix(const mat44f & cameraMatrix, float nearp, float farp, vec3f lightDir, float cameraHeight, mat44f & view, mat44f & proj) { typedef void (CameraShadowMapped::*_fpt)(const mat44f &, float, float, vec3f, float, mat44f &, mat44f &); auto _f=xcast<_fpt>(_drva(2148240)); return (this->*_f)(cameraMatrix, nearp, farp, lightDir, cameraHeight, view, proj); }
	inline void _guard_obj() {
		static_assert((sizeof(CameraShadowMapped)==672),"bad size");
		static_assert((offsetof(CameraShadowMapped,shadowMapSettings)==0x210),"bad off");
		static_assert((offsetof(CameraShadowMapped,shadowBias)==0x228),"bad off");
		static_assert((offsetof(CameraShadowMapped,shadowRT)==0x230),"bad off");
		static_assert((offsetof(CameraShadowMapped,shadowMatrices)==0x248),"bad off");
		static_assert((offsetof(CameraShadowMapped,stableShadowMatrix)==0x260),"bad off");
	};
};

//UDT: struct Engine @len=1000 @vfcount=3
	//_VTable: 
	//_Func: public void Engine(const Engine &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void Engine(); @loc=static @len=435 @rva=2642608
	//_Func: public void ~Engine(); @loc=static @len=235 @rva=2643264
	//_Data: this+0x8, Member, Type: struct acEngineData, data
	//_Data: this+0x130, Member, Type: struct EngineStatus, status
	//_Data: this+0x148, Member, Type: float, coastTorqueMultiplier
	//_Data: this+0x14C, Member, Type: float, limiterMultiplier
	//_Data: this+0x150, Member, Type: float, fuelPressure
	//_Data: this+0x154, Member, Type: float, bov
	//_Data: this+0x158, Member, Type: class std::vector<Turbo,std::allocator<Turbo> >, turbos
	//_Data: this+0x170, Member, Type: bool, isEngineStallEnabled
	//_Data: this+0x174, Member, Type: float, starterTorque
	//_Data: this+0x178, Member, Type: float, rpmDamageThreshold
	//_Data: this+0x17C, Member, Type: float, restrictor
	//_Data: this+0x180, Member, Type: struct PushToPass, p2p
	//_Func: public bool init(const char * carModel); @intro @virtual vtpo=0 vfid=0 @loc=static @len=3 @rva=706688
	//_Func: public void init(Car * car); @loc=static @len=114 @rva=2645520
	//_Func: public void addTorqueGenerator(ITorqueGenerator * generator); @loc=static @len=31 @rva=2644496
	//_Func: public void addCoastGenerator(ICoastGenerator * generator); @loc=static @len=31 @rva=2644464
	//_Func: public void setTurboBoostLevel(float value); @loc=static @len=73 @rva=2654352
	//_Func: public float getTurboBoostLevel(); @loc=static @len=58 @rva=2645440
	//_Func: public void step(SACEngineInput & input, float dt); @loc=static @len=1640 @rva=2654432
	//_Func: public int getLimiterRPM(); @intro @virtual vtpo=0 vfid=1 @loc=static @len=24 @rva=2644560
	//_Func: public bool isLimiterOn(); @intro @virtual vtpo=0 vfid=2 @loc=static @len=12 @rva=2645648
	//_Func: public float getAngularInertia(); @loc=optimized @len=0 @rva=0
	//_Func: public void setElectronicOverride(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public float getElectronicOverride(); @loc=optimized @len=0 @rva=0
	//_Func: public float getMaxPowerW(); @loc=static @len=79 @rva=2644608
	//_Func: public float getMaxTorqueNM(); @loc=static @len=9 @rva=2644688
	//_Func: public float getMaxPowerRPM(); @loc=static @len=9 @rva=2644592
	//_Func: public float getMaxTorqueRPM(); @loc=static @len=9 @rva=2644704
	//_Func: public float getTorqueAtRPM(float rpm, float gas); @loc=static @len=169 @rva=2645264
	//_Func: public int getDefaultEngineLimiter(); @loc=optimized @len=0 @rva=0
	//_Func: public void reset(); @loc=static @len=120 @rva=2654096
	//_Func: public float getGasUsage(); @loc=optimized @len=0 @rva=0
	//_Func: public float getLifeLeft(); @loc=optimized @len=0 @rva=0
	//_Func: public void setLifeLeft(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public bool isTurboAdjustableFromCockpit(); @loc=optimized @len=0 @rva=0
	//_Func: public float getMaxTurboBoost(bool with_wastegate); @loc=static @len=83 @rva=2644720
	//_Func: public float getSafeTurboLevel(); @loc=static @len=59 @rva=2644816
	//_Func: public void blowUp(); @loc=static @len=18 @rva=2644528
	//_Func: public float getThrottleResponseGas(float gas, float rpm); @loc=static @len=379 @rva=2644880
	//_Func: public int getCoastSettingsCount(); @loc=optimized @len=0 @rva=0
	//_Func: public void setCoastSettings(int s); @loc=static @len=124 @rva=2654224
	//_Func: public int getCoastSettingsIndex(); @loc=optimized @len=0 @rva=0
	//_Func: public bool hasTurboControllers(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x1A8, Member, Type: class std::vector<ITorqueGenerator *,std::allocator<ITorqueGenerator *> >, torqueGenerators
	//_Data: this+0x1C0, Member, Type: class std::vector<ICoastGenerator *,std::allocator<ICoastGenerator *> >, coastGenerators
	//_Data: this+0x1D8, Member, Type: bool, turboAdjustableFromCockpit
	//_Data: this+0x1DC, Member, Type: struct SACEngineInput, lastInput
	//_Data: this+0x1EC, Member, Type: int, defaultEngineLimiter
	//_Data: this+0x1F0, Member, Type: float, inertia
	//_Data: this+0x1F4, Member, Type: int, limiterOn
	//_Data: this+0x1F8, Member, Type: float, electronicOverride
	//_Data: this+0x1FC, Member, Type: float, maxPowerW_Dynamic
	//_Data: this+0x200, Member, Type: float, maxPowerW
	//_Data: this+0x204, Member, Type: float, maxTorqueNM
	//_Data: this+0x208, Member, Type: float, maxPowerRPM
	//_Data: this+0x20C, Member, Type: float, maxTorqueRPM
	//_Data: this+0x210, Member, Type: class PhysicsEngine *, physicsEngine
	//_Data: this+0x218, Member, Type: class Curve, throttleResponseCurve
	//_Data: this+0x298, Member, Type: class Curve, throttleResponseCurveMax
	//_Data: this+0x318, Member, Type: float, throttleResponseCurveMaxRef
	//_Data: this+0x31C, Member, Type: float, gasUsage
	//_Data: this+0x320, Member, Type: double, lifeLeft
	//_Data: this+0x328, Member, Type: float, turboBoostDamageThreshold
	//_Data: this+0x32C, Member, Type: float, turboBoostDamageK
	//_Data: this+0x330, Member, Type: float, rpmDamageK
	//_Data: this+0x334, Member, Type: float, bovThreshold
	//_Data: this+0x338, Member, Type: class Car *, car
	//_Data: this+0x340, Member, Type: class std::vector<TurboDynamicController,std::allocator<TurboDynamicController> >, turboControllers
	//_Data: this+0x358, Member, Type: float, gasCoastOffset
	//_Data: this+0x360, Member, Type: class Curve, gasCoastOffsetCurve
	//_Data: this+0x3E0, Member, Type: int, coastSettingsDefaultIndex
	//_Data: this+0x3E4, Member, Type: int, coastEntryRpm
	//_Func: private void stepP2P(float dt); @loc=static @len=418 @rva=2656080
	//_Func: private void loadINI(); @loc=static @len=7172 @rva=2646272
	//_Func: private void precalculatePowerAndTorque(); @loc=static @len=203 @rva=2653456
	//_Func: private void stepTurbos(); @loc=static @len=267 @rva=2656512
	//_Func: private CoastSettings loadCoastSettings(INIReader & r, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section); @loc=static @len=600 @rva=2645664
	//_Func: public Engine & operator=(const Engine &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct Engine {
public:
	acEngineData data;
	EngineStatus status;
	float coastTorqueMultiplier;
	float limiterMultiplier;
	float fuelPressure;
	float bov;
	std::vector<Turbo,std::allocator<Turbo> > turbos;
	bool isEngineStallEnabled;
	float starterTorque;
	float rpmDamageThreshold;
	float restrictor;
	PushToPass p2p;
	std::vector<ITorqueGenerator *,std::allocator<ITorqueGenerator *> > torqueGenerators;
	std::vector<ICoastGenerator *,std::allocator<ICoastGenerator *> > coastGenerators;
	bool turboAdjustableFromCockpit;
	SACEngineInput lastInput;
	int defaultEngineLimiter;
	float inertia;
	int limiterOn;
	float electronicOverride;
	float maxPowerW_Dynamic;
	float maxPowerW;
	float maxTorqueNM;
	float maxPowerRPM;
	float maxTorqueRPM;
	PhysicsEngine * physicsEngine;
	Curve throttleResponseCurve;
	Curve throttleResponseCurveMax;
	float throttleResponseCurveMaxRef;
	float gasUsage;
	double lifeLeft;
	float turboBoostDamageThreshold;
	float turboBoostDamageK;
	float rpmDamageK;
	float bovThreshold;
	Car * car;
	std::vector<TurboDynamicController,std::allocator<TurboDynamicController> > turboControllers;
	float gasCoastOffset;
	Curve gasCoastOffsetCurve;
	int coastSettingsDefaultIndex;
	int coastEntryRpm;
	inline Engine() { }
	inline Engine(const Engine& other) = default;
	inline Engine& operator=(const Engine& other) = default;
	inline void ctor() { typedef void (Engine::*_fpt)(); auto _f=xcast<_fpt>(_drva(2642608)); (this->*_f)(); }
	inline void dtor() { typedef void (Engine::*_fpt)(); auto _f=xcast<_fpt>(_drva(2643264)); (this->*_f)(); }
	virtual bool init_vf0(const char * carModel);
	inline bool init_impl(const char * carModel) { typedef bool (Engine::*_fpt)(const char *); auto _f=xcast<_fpt>(_drva(706688)); return (this->*_f)(carModel); }
	inline bool init(const char * carModel) { typedef bool (Engine::*_fpt)(const char *); auto _f=xcast<_fpt>(get_vfp(this, 0)); return (this->*_f)(carModel); }
	inline void init(Car * car) { typedef void (Engine::*_fpt)(Car *); auto _f=xcast<_fpt>(_drva(2645520)); return (this->*_f)(car); }
	inline void addTorqueGenerator(ITorqueGenerator * generator) { typedef void (Engine::*_fpt)(ITorqueGenerator *); auto _f=xcast<_fpt>(_drva(2644496)); return (this->*_f)(generator); }
	inline void addCoastGenerator(ICoastGenerator * generator) { typedef void (Engine::*_fpt)(ICoastGenerator *); auto _f=xcast<_fpt>(_drva(2644464)); return (this->*_f)(generator); }
	inline void setTurboBoostLevel(float value) { typedef void (Engine::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2654352)); return (this->*_f)(value); }
	inline float getTurboBoostLevel() { typedef float (Engine::*_fpt)(); auto _f=xcast<_fpt>(_drva(2645440)); return (this->*_f)(); }
	inline void step(SACEngineInput & input, float dt) { typedef void (Engine::*_fpt)(SACEngineInput &, float); auto _f=xcast<_fpt>(_drva(2654432)); return (this->*_f)(input, dt); }
	virtual int getLimiterRPM_vf1();
	inline int getLimiterRPM_impl() { typedef int (Engine::*_fpt)(); auto _f=xcast<_fpt>(_drva(2644560)); return (this->*_f)(); }
	inline int getLimiterRPM() { typedef int (Engine::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(); }
	virtual bool isLimiterOn_vf2();
	inline bool isLimiterOn_impl() { typedef bool (Engine::*_fpt)(); auto _f=xcast<_fpt>(_drva(2645648)); return (this->*_f)(); }
	inline bool isLimiterOn() { typedef bool (Engine::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)(); }
	inline float getMaxPowerW() { typedef float (Engine::*_fpt)(); auto _f=xcast<_fpt>(_drva(2644608)); return (this->*_f)(); }
	inline float getMaxTorqueNM() { typedef float (Engine::*_fpt)(); auto _f=xcast<_fpt>(_drva(2644688)); return (this->*_f)(); }
	inline float getMaxPowerRPM() { typedef float (Engine::*_fpt)(); auto _f=xcast<_fpt>(_drva(2644592)); return (this->*_f)(); }
	inline float getMaxTorqueRPM() { typedef float (Engine::*_fpt)(); auto _f=xcast<_fpt>(_drva(2644704)); return (this->*_f)(); }
	inline float getTorqueAtRPM(float rpm, float gas) { typedef float (Engine::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2645264)); return (this->*_f)(rpm, gas); }
	inline void reset() { typedef void (Engine::*_fpt)(); auto _f=xcast<_fpt>(_drva(2654096)); return (this->*_f)(); }
	inline float getMaxTurboBoost(bool with_wastegate) { typedef float (Engine::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(2644720)); return (this->*_f)(with_wastegate); }
	inline float getSafeTurboLevel() { typedef float (Engine::*_fpt)(); auto _f=xcast<_fpt>(_drva(2644816)); return (this->*_f)(); }
	inline void blowUp() { typedef void (Engine::*_fpt)(); auto _f=xcast<_fpt>(_drva(2644528)); return (this->*_f)(); }
	inline float getThrottleResponseGas(float gas, float rpm) { typedef float (Engine::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2644880)); return (this->*_f)(gas, rpm); }
	inline void setCoastSettings(int s) { typedef void (Engine::*_fpt)(int); auto _f=xcast<_fpt>(_drva(2654224)); return (this->*_f)(s); }
	inline void stepP2P(float dt) { typedef void (Engine::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2656080)); return (this->*_f)(dt); }
	inline void loadINI() { typedef void (Engine::*_fpt)(); auto _f=xcast<_fpt>(_drva(2646272)); return (this->*_f)(); }
	inline void precalculatePowerAndTorque() { typedef void (Engine::*_fpt)(); auto _f=xcast<_fpt>(_drva(2653456)); return (this->*_f)(); }
	inline void stepTurbos() { typedef void (Engine::*_fpt)(); auto _f=xcast<_fpt>(_drva(2656512)); return (this->*_f)(); }
	inline CoastSettings loadCoastSettings(INIReader & r, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & section) { typedef CoastSettings (Engine::*_fpt)(INIReader &, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2645664)); return (this->*_f)(r, section); }
	inline void _guard_obj() {
		static_assert((sizeof(Engine)==1000),"bad size");
		static_assert((offsetof(Engine,data)==0x8),"bad off");
		static_assert((offsetof(Engine,status)==0x130),"bad off");
		static_assert((offsetof(Engine,coastTorqueMultiplier)==0x148),"bad off");
		static_assert((offsetof(Engine,limiterMultiplier)==0x14C),"bad off");
		static_assert((offsetof(Engine,fuelPressure)==0x150),"bad off");
		static_assert((offsetof(Engine,bov)==0x154),"bad off");
		static_assert((offsetof(Engine,turbos)==0x158),"bad off");
		static_assert((offsetof(Engine,isEngineStallEnabled)==0x170),"bad off");
		static_assert((offsetof(Engine,starterTorque)==0x174),"bad off");
		static_assert((offsetof(Engine,rpmDamageThreshold)==0x178),"bad off");
		static_assert((offsetof(Engine,restrictor)==0x17C),"bad off");
		static_assert((offsetof(Engine,p2p)==0x180),"bad off");
		static_assert((offsetof(Engine,torqueGenerators)==0x1A8),"bad off");
		static_assert((offsetof(Engine,coastGenerators)==0x1C0),"bad off");
		static_assert((offsetof(Engine,turboAdjustableFromCockpit)==0x1D8),"bad off");
		static_assert((offsetof(Engine,lastInput)==0x1DC),"bad off");
		static_assert((offsetof(Engine,defaultEngineLimiter)==0x1EC),"bad off");
		static_assert((offsetof(Engine,inertia)==0x1F0),"bad off");
		static_assert((offsetof(Engine,limiterOn)==0x1F4),"bad off");
		static_assert((offsetof(Engine,electronicOverride)==0x1F8),"bad off");
		static_assert((offsetof(Engine,maxPowerW_Dynamic)==0x1FC),"bad off");
		static_assert((offsetof(Engine,maxPowerW)==0x200),"bad off");
		static_assert((offsetof(Engine,maxTorqueNM)==0x204),"bad off");
		static_assert((offsetof(Engine,maxPowerRPM)==0x208),"bad off");
		static_assert((offsetof(Engine,maxTorqueRPM)==0x20C),"bad off");
		static_assert((offsetof(Engine,physicsEngine)==0x210),"bad off");
		static_assert((offsetof(Engine,throttleResponseCurve)==0x218),"bad off");
		static_assert((offsetof(Engine,throttleResponseCurveMax)==0x298),"bad off");
		static_assert((offsetof(Engine,throttleResponseCurveMaxRef)==0x318),"bad off");
		static_assert((offsetof(Engine,gasUsage)==0x31C),"bad off");
		static_assert((offsetof(Engine,lifeLeft)==0x320),"bad off");
		static_assert((offsetof(Engine,turboBoostDamageThreshold)==0x328),"bad off");
		static_assert((offsetof(Engine,turboBoostDamageK)==0x32C),"bad off");
		static_assert((offsetof(Engine,rpmDamageK)==0x330),"bad off");
		static_assert((offsetof(Engine,bovThreshold)==0x334),"bad off");
		static_assert((offsetof(Engine,car)==0x338),"bad off");
		static_assert((offsetof(Engine,turboControllers)==0x340),"bad off");
		static_assert((offsetof(Engine,gasCoastOffset)==0x358),"bad off");
		static_assert((offsetof(Engine,gasCoastOffsetCurve)==0x360),"bad off");
		static_assert((offsetof(Engine,coastSettingsDefaultIndex)==0x3E0),"bad off");
		static_assert((offsetof(Engine,coastEntryRpm)==0x3E4),"bad off");
	};
};

//UDT: class DICarControl @len=2896 @vfcount=12
	//_Base: class ICarControlsProvider @off=0 @len=24
	//_Func: public void DICarControl(const DICarControl &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void DICarControl(); @loc=static @len=7692 @rva=515536
	//_Func: public void ~DICarControl(); @virtual vtpo=0 vfid=0 @loc=static @len=531 @rva=523232
	//_Data: this+0x18, Member, Type: class DirectInput *, directInput
	//_Data: this+0x20, Member, Type: class DIControlAxis, steer
	//_Data: this+0x70, Member, Type: class DIControlAxis, gas
	//_Data: this+0xC0, Member, Type: class DIControlAxis, brake
	//_Data: this+0x110, Member, Type: class DIControlAxis, clutch
	//_Data: this+0x160, Member, Type: class DIControlButton, glanceLeft
	//_Data: this+0x1B0, Member, Type: class DIControlButton, glanceRight
	//_Data: this+0x200, Member, Type: class DIControlButton, glanceBack
	//_Data: this+0x250, Member, Type: class DIControlButton, gearUp
	//_Data: this+0x2A0, Member, Type: class DIControlButton, gearDn
	//_Data: this+0x2F0, Member, Type: class DIControlButton, brakeBalanceUp
	//_Data: this+0x340, Member, Type: class DIControlButton, brakeBalanceDn
	//_Data: this+0x390, Member, Type: class DIControlButton, kers
	//_Data: this+0x3E0, Member, Type: class DIControlButton, drs
	//_Data: this+0x430, Member, Type: class DIControlButton, absUp
	//_Data: this+0x480, Member, Type: class DIControlButton, absDn
	//_Data: this+0x4D0, Member, Type: class DIControlButton, tcUp
	//_Data: this+0x520, Member, Type: class DIControlButton, tcDn
	//_Data: this+0x570, Member, Type: class DIControlButton, turboUp
	//_Data: this+0x5C0, Member, Type: class DIControlButton, turboDn
	//_Data: this+0x610, Member, Type: class DIControlButton, engineBrakeUp
	//_Data: this+0x660, Member, Type: class DIControlButton, engineBrakeDn
	//_Data: this+0x6B0, Member, Type: class DIControlButton, MGUKDeliveryUp
	//_Data: this+0x700, Member, Type: class DIControlButton, MGUKDeliveryDn
	//_Data: this+0x750, Member, Type: class DIControlButton, MGUKRecoveryUp
	//_Data: this+0x7A0, Member, Type: class DIControlButton, MGUKRecoveryDn
	//_Data: this+0x7F0, Member, Type: class DIControlButton, MGUHMode
	//_Data: this+0x840, Member, Type: class DIControlButton, actionTurnOnHeadlights
	//_Data: this+0x890, Member, Type: class DIControlButton, actionChangeCamera
	//_Data: this+0x8E0, Member, Type: class DIControlButton, actionHorn
	//_Data: this+0x930, Member, Type: class DIControlButton, actionFlashHeadlights
	//_Data: this+0x980, Member, Type: class DIControlButton, handBrake
	//_Data: this+0x9D0, Member, Type: class DIControlAxis, handBrakeAxis
	//_Data: this+0xA20, Member, Type: struct DIShifter, shifter
	//_Data: this+0xA50, Member, Type: float, ffGain
	//_Data: this+0xA54, Member, Type: float, steerScale
	//_Data: this+0xA58, Member, Type: float, steerLock
	//_Data: this+0xA5C, Member, Type: float, linearity
	//_Data: this+0xA60, Member, Type: float, speedSensitivity
	//_Data: this+0xA64, Member, Type: float, steerFilter
	//_Data: this+0xA68, Member, Type: struct FFUpgrades, ffUpgrades
	//_Data: this+0xA78, Member, Type: float, minFF
	//_Data: this+0xA7C, Member, Type: float, centerBoostGain
	//_Data: this+0xA80, Member, Type: float, centerBoostRange
	//_Data: this+0xA84, Member, Type: bool, useSoftLock
	//_Data: this+0xA88, Member, Type: class FFPostProcessor, ffPostProcessor
	//_Func: public void acquireControls(CarControls * controls, float dt, CarControlsInput * input); @virtual vtpo=0 vfid=1 @loc=static @len=1880 @rva=523888
	//_Func: public void sendFF(float ff, float damper, float userGain); @virtual vtpo=0 vfid=3 @loc=static @len=444 @rva=527936
	//_Func: public const char * getName(); @virtual vtpo=0 vfid=4 @loc=static @len=8 @rva=526240
	//_Func: public float getFFGlobalGain(); @virtual vtpo=0 vfid=5 @loc=static @len=9 @rva=526224
	//_Func: public void setEngineRPM(float rpm, float minRpm, float maxRpm); @virtual vtpo=0 vfid=10 @loc=static @len=14 @rva=528384
	//_Func: public bool getAction(DriverActions anAction); @virtual vtpo=0 vfid=2 @loc=static @len=440 @rva=525776
	//_Func: public void setVibrations(const VibrationDef & vibrations); @virtual vtpo=0 vfid=9 @loc=static @len=116 @rva=528400
	//_Func: public void onAutoShifterChanged(bool newmode); @virtual vtpo=0 vfid=7 @loc=static @len=29 @rva=527904
	//_Func: public bool isDeviceConnected(); @virtual vtpo=0 vfid=6 @loc=static @len=3 @rva=140928
	//_Data: this+0xB18, Member, Type: bool, validated
	//_Data: this+0xB1C, Member, Type: float, brakeGamma
	//_Data: this+0xB20, Member, Type: int, ffCounter
	//_Data: this+0xB24, Member, Type: int, ffInterval
	//_Data: this+0xB28, Member, Type: float, currentVibration
	//_Data: this+0xB2C, Member, Type: float, currentLock
	//_Data: this+0xB30, Member, Type: class Trigger, shiftUpTrigger
	//_Data: this+0xB3C, Member, Type: class Trigger, shiftDnTrigger
	//_Data: this+0xB48, Member, Type: class Speed, lastSpeed
	//_Func: protected void validate(); @loc=static @len=114 @rva=528528
	//_Func: protected void initShifter(INIReader & ini); @loc=static @len=1578 @rva=526320
	//_Func: public DICarControl & operator=(const DICarControl &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void __local_vftable_ctor_closure(); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class DICarControl : public ICarControlsProvider {
public:
	DirectInput * directInput;
	DIControlAxis steer;
	DIControlAxis gas;
	DIControlAxis brake;
	DIControlAxis clutch;
	DIControlButton glanceLeft;
	DIControlButton glanceRight;
	DIControlButton glanceBack;
	DIControlButton gearUp;
	DIControlButton gearDn;
	DIControlButton brakeBalanceUp;
	DIControlButton brakeBalanceDn;
	DIControlButton kers;
	DIControlButton drs;
	DIControlButton absUp;
	DIControlButton absDn;
	DIControlButton tcUp;
	DIControlButton tcDn;
	DIControlButton turboUp;
	DIControlButton turboDn;
	DIControlButton engineBrakeUp;
	DIControlButton engineBrakeDn;
	DIControlButton MGUKDeliveryUp;
	DIControlButton MGUKDeliveryDn;
	DIControlButton MGUKRecoveryUp;
	DIControlButton MGUKRecoveryDn;
	DIControlButton MGUHMode;
	DIControlButton actionTurnOnHeadlights;
	DIControlButton actionChangeCamera;
	DIControlButton actionHorn;
	DIControlButton actionFlashHeadlights;
	DIControlButton handBrake;
	DIControlAxis handBrakeAxis;
	DIShifter shifter;
	float ffGain;
	float steerScale;
	float steerLock;
	float linearity;
	float speedSensitivity;
	float steerFilter;
	FFUpgrades ffUpgrades;
	float minFF;
	float centerBoostGain;
	float centerBoostRange;
	bool useSoftLock;
	FFPostProcessor ffPostProcessor;
	bool validated;
	float brakeGamma;
	int ffCounter;
	int ffInterval;
	float currentVibration;
	float currentLock;
	Trigger shiftUpTrigger;
	Trigger shiftDnTrigger;
	Speed lastSpeed;
	inline DICarControl() { }
	inline DICarControl(const DICarControl& other) = default;
	inline DICarControl& operator=(const DICarControl& other) = default;
	inline void ctor() { typedef void (DICarControl::*_fpt)(); auto _f=xcast<_fpt>(_drva(515536)); (this->*_f)(); }
	virtual ~DICarControl();
	inline void dtor() { typedef void (DICarControl::*_fpt)(); auto _f=xcast<_fpt>(_drva(523232)); (this->*_f)(); }
	virtual void acquireControls_vf1(CarControls * controls, float dt, CarControlsInput * input);
	inline void acquireControls_impl(CarControls * controls, float dt, CarControlsInput * input) { typedef void (DICarControl::*_fpt)(CarControls *, float, CarControlsInput *); auto _f=xcast<_fpt>(_drva(523888)); return (this->*_f)(controls, dt, input); }
	inline void acquireControls(CarControls * controls, float dt, CarControlsInput * input) { typedef void (DICarControl::*_fpt)(CarControls *, float, CarControlsInput *); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(controls, dt, input); }
	virtual void sendFF_vf3(float ff, float damper, float userGain);
	inline void sendFF_impl(float ff, float damper, float userGain) { typedef void (DICarControl::*_fpt)(float, float, float); auto _f=xcast<_fpt>(_drva(527936)); return (this->*_f)(ff, damper, userGain); }
	inline void sendFF(float ff, float damper, float userGain) { typedef void (DICarControl::*_fpt)(float, float, float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(ff, damper, userGain); }
	virtual const char * getName_vf4();
	inline const char * getName_impl() { typedef const char * (DICarControl::*_fpt)(); auto _f=xcast<_fpt>(_drva(526240)); return (this->*_f)(); }
	inline const char * getName() { typedef const char * (DICarControl::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 4)); return (this->*_f)(); }
	virtual float getFFGlobalGain_vf5();
	inline float getFFGlobalGain_impl() { typedef float (DICarControl::*_fpt)(); auto _f=xcast<_fpt>(_drva(526224)); return (this->*_f)(); }
	inline float getFFGlobalGain() { typedef float (DICarControl::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 5)); return (this->*_f)(); }
	virtual void setEngineRPM_vf10(float rpm, float minRpm, float maxRpm);
	inline void setEngineRPM_impl(float rpm, float minRpm, float maxRpm) { typedef void (DICarControl::*_fpt)(float, float, float); auto _f=xcast<_fpt>(_drva(528384)); return (this->*_f)(rpm, minRpm, maxRpm); }
	inline void setEngineRPM(float rpm, float minRpm, float maxRpm) { typedef void (DICarControl::*_fpt)(float, float, float); auto _f=xcast<_fpt>(get_vfp(this, 10)); return (this->*_f)(rpm, minRpm, maxRpm); }
	virtual bool getAction_vf2(DriverActions anAction);
	inline bool getAction_impl(DriverActions anAction) { typedef bool (DICarControl::*_fpt)(DriverActions); auto _f=xcast<_fpt>(_drva(525776)); return (this->*_f)(anAction); }
	inline bool getAction(DriverActions anAction) { typedef bool (DICarControl::*_fpt)(DriverActions); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)(anAction); }
	virtual void setVibrations_vf9(const VibrationDef & vibrations);
	inline void setVibrations_impl(const VibrationDef & vibrations) { typedef void (DICarControl::*_fpt)(const VibrationDef &); auto _f=xcast<_fpt>(_drva(528400)); return (this->*_f)(vibrations); }
	inline void setVibrations(const VibrationDef & vibrations) { typedef void (DICarControl::*_fpt)(const VibrationDef &); auto _f=xcast<_fpt>(get_vfp(this, 9)); return (this->*_f)(vibrations); }
	virtual void onAutoShifterChanged_vf7(bool newmode);
	inline void onAutoShifterChanged_impl(bool newmode) { typedef void (DICarControl::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(527904)); return (this->*_f)(newmode); }
	inline void onAutoShifterChanged(bool newmode) { typedef void (DICarControl::*_fpt)(bool); auto _f=xcast<_fpt>(get_vfp(this, 7)); return (this->*_f)(newmode); }
	virtual bool isDeviceConnected_vf6();
	inline bool isDeviceConnected_impl() { typedef bool (DICarControl::*_fpt)(); auto _f=xcast<_fpt>(_drva(140928)); return (this->*_f)(); }
	inline bool isDeviceConnected() { typedef bool (DICarControl::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 6)); return (this->*_f)(); }
	inline void validate() { typedef void (DICarControl::*_fpt)(); auto _f=xcast<_fpt>(_drva(528528)); return (this->*_f)(); }
	inline void initShifter(INIReader & ini) { typedef void (DICarControl::*_fpt)(INIReader &); auto _f=xcast<_fpt>(_drva(526320)); return (this->*_f)(ini); }
	inline void _guard_obj() {
		static_assert((sizeof(DICarControl)==2896),"bad size");
		static_assert((offsetof(DICarControl,directInput)==0x18),"bad off");
		static_assert((offsetof(DICarControl,steer)==0x20),"bad off");
		static_assert((offsetof(DICarControl,gas)==0x70),"bad off");
		static_assert((offsetof(DICarControl,brake)==0xC0),"bad off");
		static_assert((offsetof(DICarControl,clutch)==0x110),"bad off");
		static_assert((offsetof(DICarControl,glanceLeft)==0x160),"bad off");
		static_assert((offsetof(DICarControl,glanceRight)==0x1B0),"bad off");
		static_assert((offsetof(DICarControl,glanceBack)==0x200),"bad off");
		static_assert((offsetof(DICarControl,gearUp)==0x250),"bad off");
		static_assert((offsetof(DICarControl,gearDn)==0x2A0),"bad off");
		static_assert((offsetof(DICarControl,brakeBalanceUp)==0x2F0),"bad off");
		static_assert((offsetof(DICarControl,brakeBalanceDn)==0x340),"bad off");
		static_assert((offsetof(DICarControl,kers)==0x390),"bad off");
		static_assert((offsetof(DICarControl,drs)==0x3E0),"bad off");
		static_assert((offsetof(DICarControl,absUp)==0x430),"bad off");
		static_assert((offsetof(DICarControl,absDn)==0x480),"bad off");
		static_assert((offsetof(DICarControl,tcUp)==0x4D0),"bad off");
		static_assert((offsetof(DICarControl,tcDn)==0x520),"bad off");
		static_assert((offsetof(DICarControl,turboUp)==0x570),"bad off");
		static_assert((offsetof(DICarControl,turboDn)==0x5C0),"bad off");
		static_assert((offsetof(DICarControl,engineBrakeUp)==0x610),"bad off");
		static_assert((offsetof(DICarControl,engineBrakeDn)==0x660),"bad off");
		static_assert((offsetof(DICarControl,MGUKDeliveryUp)==0x6B0),"bad off");
		static_assert((offsetof(DICarControl,MGUKDeliveryDn)==0x700),"bad off");
		static_assert((offsetof(DICarControl,MGUKRecoveryUp)==0x750),"bad off");
		static_assert((offsetof(DICarControl,MGUKRecoveryDn)==0x7A0),"bad off");
		static_assert((offsetof(DICarControl,MGUHMode)==0x7F0),"bad off");
		static_assert((offsetof(DICarControl,actionTurnOnHeadlights)==0x840),"bad off");
		static_assert((offsetof(DICarControl,actionChangeCamera)==0x890),"bad off");
		static_assert((offsetof(DICarControl,actionHorn)==0x8E0),"bad off");
		static_assert((offsetof(DICarControl,actionFlashHeadlights)==0x930),"bad off");
		static_assert((offsetof(DICarControl,handBrake)==0x980),"bad off");
		static_assert((offsetof(DICarControl,handBrakeAxis)==0x9D0),"bad off");
		static_assert((offsetof(DICarControl,shifter)==0xA20),"bad off");
		static_assert((offsetof(DICarControl,ffGain)==0xA50),"bad off");
		static_assert((offsetof(DICarControl,steerScale)==0xA54),"bad off");
		static_assert((offsetof(DICarControl,steerLock)==0xA58),"bad off");
		static_assert((offsetof(DICarControl,linearity)==0xA5C),"bad off");
		static_assert((offsetof(DICarControl,speedSensitivity)==0xA60),"bad off");
		static_assert((offsetof(DICarControl,steerFilter)==0xA64),"bad off");
		static_assert((offsetof(DICarControl,ffUpgrades)==0xA68),"bad off");
		static_assert((offsetof(DICarControl,minFF)==0xA78),"bad off");
		static_assert((offsetof(DICarControl,centerBoostGain)==0xA7C),"bad off");
		static_assert((offsetof(DICarControl,centerBoostRange)==0xA80),"bad off");
		static_assert((offsetof(DICarControl,useSoftLock)==0xA84),"bad off");
		static_assert((offsetof(DICarControl,ffPostProcessor)==0xA88),"bad off");
		static_assert((offsetof(DICarControl,validated)==0xB18),"bad off");
		static_assert((offsetof(DICarControl,brakeGamma)==0xB1C),"bad off");
		static_assert((offsetof(DICarControl,ffCounter)==0xB20),"bad off");
		static_assert((offsetof(DICarControl,ffInterval)==0xB24),"bad off");
		static_assert((offsetof(DICarControl,currentVibration)==0xB28),"bad off");
		static_assert((offsetof(DICarControl,currentLock)==0xB2C),"bad off");
		static_assert((offsetof(DICarControl,shiftUpTrigger)==0xB30),"bad off");
		static_assert((offsetof(DICarControl,shiftDnTrigger)==0xB3C),"bad off");
		static_assert((offsetof(DICarControl,lastSpeed)==0xB48),"bad off");
	};
};

//UDT: class Game @len=632 @vfcount=2
	//_VTable: 
	//_Func: public void Game(const Game &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void Game(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, VideoSettings & videoSettings); @loc=static @len=1554 @rva=2365568
	//_Func: public void ~Game(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=279 @rva=2367152
	//_Data: this+0x8, Member, Type: bool, isRenderingGui
	//_Data: this+0x9, Member, Type: bool, isSwappingBuffer
	//_Data: this+0xA, Member, Type: bool, isSuppressingAudioUpdate
	//_Data: this+0x10, Member, Type: class GameTime, gameTime
	//_Data: this+0x48, Member, Type: class RenderWindow, window
	//_Data: this+0x138, Member, Type: class GraphicsManager *, graphics
	//_Data: this+0x140, Member, Type: float, masterVolume
	//_Data: this+0x148, Member, Type: class AudioEngine *, audioEngine
	//_Data: this+0x150, Member, Type: struct GameStats, stats
	//_Data: this+0x178, Member, Type: class GameObject *, root
	//_Data: this+0x180, Member, Type: class ksgui::GUI *, gui
	//_Data: this+0x188, Member, Type: class KeyboardManager, keyboardManager
	//_Data: this+0x1B8, Member, Type: class JoypadManager, joypadManager
	//_Data: this+0x1C0, Member, Type: int, sleepTime
	//_Data: this+0x1C8, Member, Type: class Event<float>, evOnPreGUI
	//_Data: this+0x1E0, Member, Type: class Event<float>, evOnPostGui
	//_Data: this+0x1F8, Member, Type: class Event<float>, evOnRenderFinished
	//_Data: this+0x210, Member, Type: class Event<float>, evOnPostUpdate
	//_Data: this+0x228, Member, Type: class Event<double>, evOnBeginFrame
	//_Data: this+0x240, Member, Type: class Event<double>, evOnEndFrame
	//_Data: this+0x258, Member, Type: class Event<int>, evOnShutdownRequested
	//_Func: public void onIdle(); @loc=static @len=953 @rva=2369328
	//_Func: public void run(); @loc=static @len=248 @rva=2371248
	//_Func: public void shutdown(); @intro @virtual vtpo=0 vfid=1 @loc=static @len=8 @rva=2371504
	//_Func: public bool isGameClosing(); @loc=optimized @len=0 @rva=0
	//_Func: public void overrideGameClosing(bool  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void shutdownObject(GameObject * o); @loc=static @len=78 @rva=2371520
	//_Func: public void renderHUDOnDemand(float dt); @loc=static @len=15 @rva=2371232
	//_Func: public void onWindowResize(const OnWindowResizeEvent &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void onWindowClosed(const OnWindowClosedEvent &  _arg0); @loc=optimized @len=0 @rva=0
	//_Data: this+0x270, Member, Type: bool, isClosing
	//_Func: protected void update(GameObject * o, float dt); @loc=static @len=109 @rva=2371600
	//_Func: protected void render(GameObject * o, float dt); @loc=static @len=109 @rva=2370896
	//_Func: protected void renderHUD(GameObject * o, float dt); @loc=static @len=109 @rva=2371120
	//_Func: protected void renderAudio(GameObject * o, float dt); @loc=static @len=109 @rva=2371008
	//_Func: protected void deleteGameObjectRec(GameObject * go); @loc=static @len=123 @rva=2369200
	//_Func: public Game & operator=(const Game &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class Game {
public:
	bool isRenderingGui;
	bool isSwappingBuffer;
	bool isSuppressingAudioUpdate;
	GameTime gameTime;
	RenderWindow window;
	GraphicsManager * graphics;
	float masterVolume;
	AudioEngine * audioEngine;
	GameStats stats;
	GameObject * root;
	ksgui_GUI * gui;
	KeyboardManager keyboardManager;
	JoypadManager joypadManager;
	int sleepTime;
	Event<float> evOnPreGUI;
	Event<float> evOnPostGui;
	Event<float> evOnRenderFinished;
	Event<float> evOnPostUpdate;
	Event<double> evOnBeginFrame;
	Event<double> evOnEndFrame;
	Event<int> evOnShutdownRequested;
	bool isClosing;
	inline Game() { }
	inline Game(const Game& other) = default;
	inline Game& operator=(const Game& other) = default;
	inline void ctor(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, VideoSettings & videoSettings) { typedef void (Game::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, VideoSettings &); auto _f=xcast<_fpt>(_drva(2365568)); (this->*_f)(name, videoSettings); }
	virtual ~Game();
	inline void dtor() { typedef void (Game::*_fpt)(); auto _f=xcast<_fpt>(_drva(2367152)); (this->*_f)(); }
	inline void onIdle() { typedef void (Game::*_fpt)(); auto _f=xcast<_fpt>(_drva(2369328)); return (this->*_f)(); }
	inline void run() { typedef void (Game::*_fpt)(); auto _f=xcast<_fpt>(_drva(2371248)); return (this->*_f)(); }
	virtual void shutdown_vf1();
	inline void shutdown_impl() { typedef void (Game::*_fpt)(); auto _f=xcast<_fpt>(_drva(2371504)); return (this->*_f)(); }
	inline void shutdown() { typedef void (Game::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(); }
	inline void shutdownObject(GameObject * o) { typedef void (Game::*_fpt)(GameObject *); auto _f=xcast<_fpt>(_drva(2371520)); return (this->*_f)(o); }
	inline void renderHUDOnDemand(float dt) { typedef void (Game::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2371232)); return (this->*_f)(dt); }
	inline void update(GameObject * o, float dt) { typedef void (Game::*_fpt)(GameObject *, float); auto _f=xcast<_fpt>(_drva(2371600)); return (this->*_f)(o, dt); }
	inline void render(GameObject * o, float dt) { typedef void (Game::*_fpt)(GameObject *, float); auto _f=xcast<_fpt>(_drva(2370896)); return (this->*_f)(o, dt); }
	inline void renderHUD(GameObject * o, float dt) { typedef void (Game::*_fpt)(GameObject *, float); auto _f=xcast<_fpt>(_drva(2371120)); return (this->*_f)(o, dt); }
	inline void renderAudio(GameObject * o, float dt) { typedef void (Game::*_fpt)(GameObject *, float); auto _f=xcast<_fpt>(_drva(2371008)); return (this->*_f)(o, dt); }
	inline void deleteGameObjectRec(GameObject * go) { typedef void (Game::*_fpt)(GameObject *); auto _f=xcast<_fpt>(_drva(2369200)); return (this->*_f)(go); }
	inline void _guard_obj() {
		static_assert((sizeof(Game)==632),"bad size");
		static_assert((offsetof(Game,isRenderingGui)==0x8),"bad off");
		static_assert((offsetof(Game,isSwappingBuffer)==0x9),"bad off");
		static_assert((offsetof(Game,isSuppressingAudioUpdate)==0xA),"bad off");
		static_assert((offsetof(Game,gameTime)==0x10),"bad off");
		static_assert((offsetof(Game,window)==0x48),"bad off");
		static_assert((offsetof(Game,graphics)==0x138),"bad off");
		static_assert((offsetof(Game,masterVolume)==0x140),"bad off");
		static_assert((offsetof(Game,audioEngine)==0x148),"bad off");
		static_assert((offsetof(Game,stats)==0x150),"bad off");
		static_assert((offsetof(Game,root)==0x178),"bad off");
		static_assert((offsetof(Game,gui)==0x180),"bad off");
		static_assert((offsetof(Game,keyboardManager)==0x188),"bad off");
		static_assert((offsetof(Game,joypadManager)==0x1B8),"bad off");
		static_assert((offsetof(Game,sleepTime)==0x1C0),"bad off");
		static_assert((offsetof(Game,evOnPreGUI)==0x1C8),"bad off");
		static_assert((offsetof(Game,evOnPostGui)==0x1E0),"bad off");
		static_assert((offsetof(Game,evOnRenderFinished)==0x1F8),"bad off");
		static_assert((offsetof(Game,evOnPostUpdate)==0x210),"bad off");
		static_assert((offsetof(Game,evOnBeginFrame)==0x228),"bad off");
		static_assert((offsetof(Game,evOnEndFrame)==0x240),"bad off");
		static_assert((offsetof(Game,evOnShutdownRequested)==0x258),"bad off");
		static_assert((offsetof(Game,isClosing)==0x270),"bad off");
	};
};

//UDT: class CarAvatar @len=4776 @vfcount=6
	//_Base: class GameObject @off=0 @len=88
	//_Func: public void CarAvatar(const CarAvatar &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void CarAvatar(Sim * isim, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & unixName, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & config, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & skin); @loc=static @len=3097 @rva=840096
	//_Func: public void CarAvatar(Sim * isim, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & unixName, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & config, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & skin, ICarPhysicsStateProvider * physicsStateProvider); @loc=static @len=1567 @rva=843200
	//_Func: public void ~CarAvatar(); @virtual vtpo=0 vfid=0 @loc=static @len=865 @rva=846608
	//_Data: this+0x58, Member, Type: class EventTriggerOnChange<int>, evOnGearChanged
	//_Data: this+0x88, Member, Type: class Event<OnLapCompletedEvent>, evOnLapCompleted
	//_Data: this+0xA0, Member, Type: class Event<OnSectorSplitEvent>, evOnSectorSplit
	//_Data: this+0xB8, Member, Type: class Event<OnTyreCompoundChanged>, evOnTyreCompoundChanged
	//_Data: this+0xD0, Member, Type: class Event<bool>, evOnBackfireTriggered
	//_Data: this+0xE8, Member, Type: class Event<bool>, evOnDownshiftProtection
	//_Data: this+0x100, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, externalTyreCompoundShortName
	//_Data: this+0x120, Member, Type: class vec3f, mirrorPosition
	//_Data: this+0x130, Member, Type: class Sim *, sim
	//_Data: this+0x138, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, unixName
	//_Data: this+0x158, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, configName
	//_Data: this+0x178, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, guiName
	//_Data: this+0x198, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, guiShortName
	//_Data: this+0x1B8, Member, Type: class Node *, bodyTransform
	//_Data: this+0x1C0, Member, Type: class Node *, steerTransformHR
	//_Data: this+0x1C8, Member, Type: class Node *, steerTransformLR
	//_Data: this+0x1D0, Member, Type: class mat44f, orgSteerMatrix
	//_Data: this+0x210, Member, Type: class NodeBoundingSphere *, carNode
	//_Data: this+0x218, Member, Type: class vec3f, driverEyesPosition
	//_Data: this+0x224, Member, Type: class mat44f, bodyMatrix
	//_Data: this+0x268, Member, Type: struct CarPhysicsState, physicsState
	//_Data: this+0xDD8, Member, Type: struct AIState, aiState
	//_Data: this+0xE18, Member, Type: class CarAudioFMOD *, carAudioFMOD
	//_Data: this+0xE20, Member, Type: class SkidMarkBuffer *[0x4], skidMarkBuffers
	//_Data: this+0xE40, Member, Type: struct CarPhysicsInfo, physicsInfo
	//_Data: this+0xF80, Member, Type: class std::unique_ptr<RaceEngineer,std::default_delete<RaceEngineer> >, raceEngineer
	//_Data: this+0xF88, Member, Type: struct ModelBoundariesCoordinates, modelBoundaries
	//_Data: this+0xFA0, Member, Type: class std::vector<WingState,std::allocator<WingState> >, wingsStatus
	//_Data: this+0xFB8, Member, Type: float, onBoardExposure
	//_Data: this+0xFBC, Member, Type: float, outBoardExposure
	//_Data: this+0xFC0, Member, Type: float, dashBoardExposure
	//_Data: this+0xFC8, Member, Type: class std::vector<CameraCarDefinition,std::allocator<CameraCarDefinition> >, cameras
	//_Data: this+0xFE0, Member, Type: bool, isDriverHR
	//_Data: this+0xFE8, Member, Type: class DriverModel *, driverModel_HR
	//_Data: this+0xFF0, Member, Type: class DriverModel *, driverModel_LR
	//_Data: this+0xFF8, Member, Type: class ISuspensionAvatar *, suspensionAvatar
	//_Data: this+0x1000, Member, Type: bool, isBlackFlagged
	//_Data: this+0x1008, Member, Type: class NetCarStateProvider *, netCarStateProvider
	//_Data: this+0x1010, Member, Type: class CarLodManager *, lodManager
	//_Data: this+0x1018, Member, Type: class ConstrainedObjectsManager *, constrainedObjectManager
	//_Data: this+0x1020, Member, Type: class BufferedChannel<std::pair<int,int> >, chTyreCompound
	//_Func: public void setP2PActivations(int activations); @loc=static @len=132 @rva=894352
	//_Func: public void setP2PStartingActivations(int pos); @loc=static @len=142 @rva=894496
	//_Func: public void setRestrictor(float v); @loc=static @len=134 @rva=894640
	//_Func: public float getRestrictor(); @loc=static @len=45 @rva=865792
	//_Func: public void makeBodyMatrix(const mat44f & bm, mat44f & res); @loc=static @len=343 @rva=888512
	//_Func: public void setNewPhysicsState(CarPhysicsState & ps, float dt); @loc=static @len=361 @rva=893984
	//_Func: public DriverModel * getActiveDriverModel(); @loc=static @len=25 @rva=864432
	//_Func: public int getAILapsToComplete(); @loc=static @len=23 @rva=864400
	//_Func: public PitStopTime getPitstopTime(float fuel_requested, bool changeTyres, bool repairBody, bool repairEngine, bool repairSus, bool useRandomizer); @loc=static @len=133 @rva=865648
	//_Func: public bool isRequestingPitStop(); @loc=static @len=21 @rva=888176
	//_Func: public float modifyUserFFGain(float offset); @loc=static @len=200 @rva=889072
	//_Func: public void setUserFFGain(float gain); @loc=static @len=142 @rva=896336
	//_Func: public float getUserFFGain(); @loc=static @len=9 @rva=866960
	//_Func: public bool isCurrentLapValid(); @loc=static @len=75 @rva=887632
	//_Func: public void setSkin(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void setFFMult(float mult); @loc=static @len=134 @rva=893280
	//_Func: public float getFFMult(); @loc=static @len=25 @rva=865424
	//_Func: public void setTurboBoost(float value); @loc=static @len=490 @rva=895456
	//_Func: public std::pair<unsigned int,unsigned int> getTCMode(); @loc=static @len=56 @rva=866336
	//_Func: public std::pair<unsigned int,unsigned int> getABSMode(); @loc=static @len=56 @rva=864336
	//_Func: public bool isConnected(); @loc=static @len=15 @rva=887616
	//_Func: public bool isInPit(); @loc=static @len=94 @rva=887760
	//_Func: public void armFirstLap(); @loc=static @len=79 @rva=860928
	//_Func: public void setTyreCompound(unsigned int  _arg0, int  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public void setTyreCompound(unsigned int index, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name); @loc=static @len=369 @rva=895952
	//_Func: public std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getTyreCompound(unsigned int index, bool fullname); @loc=static @len=249 @rva=866688
	//_Func: public unsigned int getTyreCompoundIndex(unsigned int tyre_index); @loc=static @len=10 @rva=866944
	//_Func: public float getWingAngle(int wingIndex); @loc=static @len=63 @rva=866976
	//_Func: public ICarPhysicsStateProvider * getPhysicsStateProvider(); @loc=optimized @len=0 @rva=0
	//_Func: public CarColliderManager * getColliderManager(); @loc=static @len=20 @rva=864576
	//_Func: public void setDamageLevel(float lvl); @loc=static @len=134 @rva=892960
	//_Func: public int getGuid(); @loc=static @len=7 @rva=865536
	//_Func: public void update(float deltaT); @virtual vtpo=0 vfid=1 @loc=static @len=1453 @rva=899120
	//_Func: public void goToSpawnPosition(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & setName); @loc=static @len=134 @rva=867040
	//_Func: public bool isInSpawnPosition(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & setName); @loc=static @len=248 @rva=887872
	//_Func: public void setSpawnPositionIndex(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & setName, int index); @loc=static @len=352 @rva=894816
	//_Func: public void setControlsProvider(ICarControlsProvider * controls); @loc=static @len=133 @rva=892816
	//_Func: public vec3f getGraphicsOffset(); @loc=static @len=25 @rva=865504
	//_Func: public float getGraphicsPitchRotation(); @loc=optimized @len=0 @rva=0
	//_Func: public void setGraphicsPitchRotation(float v); @loc=static @len=9 @rva=893744
	//_Func: public void setGraphicsOffset(vec3f np); @loc=static @len=22 @rva=893712
	//_Func: public ICarControlsProvider * getControlsProvider(); @loc=static @len=19 @rva=864608
	//_Func: public std::vector<DebugLine,std::allocator<DebugLine> > getSuspensionDebugLines(int index); @loc=static @len=77 @rva=866256
	//_Func: public vec3f getRoadDirection(); @loc=static @len=110 @rva=865840
	//_Func: public SetupManager * getSetupManager(); @loc=static @len=20 @rva=866064
	//_Func: public void onPostLoad(); @loc=static @len=322 @rva=889520
	//_Func: public void onStartReplay(const bool & mode); @loc=static @len=283 @rva=889856
	//_Func: public void onStopReplay(const bool & mode); @loc=static @len=264 @rva=890144
	//_Func: public void onReplayRewind(const int &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public bool isAbsInAction(); @loc=static @len=83 @rva=887520
	//_Func: public void setAbsEnabled(bool mode, bool force); @loc=static @len=137 @rva=891840
	//_Func: public void cycleAbsMode(int value); @loc=static @len=394 @rva=862288
	//_Func: public bool isAbsAvailable(); @loc=static @len=21 @rva=887440
	//_Func: public bool isAbsEnabled(); @loc=static @len=40 @rva=887472
	//_Func: public bool isTcInAction(); @loc=static @len=21 @rva=888288
	//_Func: public void setTcEnabled(bool mode, bool force); @loc=static @len=137 @rva=895312
	//_Func: public void cycleTcMode(int value); @loc=static @len=394 @rva=863584
	//_Func: public bool isTcEnabled(); @loc=static @len=40 @rva=888240
	//_Func: public bool isTcAvailable(); @loc=static @len=21 @rva=888208
	//_Func: public bool isEdlEnabled(); @loc=static @len=40 @rva=887712
	//_Func: public void setEdlEnabled(bool  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public float getEdlOutLevel(); @loc=static @len=25 @rva=865392
	//_Func: public void setAutoBlip(bool mode); @loc=static @len=132 @rva=891984
	//_Func: public bool getAutoBlip(); @loc=static @len=21 @rva=864464
	//_Func: public float getStabilityControl(); @loc=static @len=25 @rva=866224
	//_Func: public void setStabilityControl(float gain); @loc=static @len=134 @rva=895168
	//_Func: public float getFrontBias(); @loc=optimized @len=0 @rva=0
	//_Func: public void setFrontBias(int value); @loc=static @len=132 @rva=893424
	//_Func: public void setAutoShifter(bool mode); @loc=static @len=132 @rva=892240
	//_Func: public bool getAutoShifter(); @loc=static @len=21 @rva=864496
	//_Func: public void setVisible(bool vis); @loc=static @len=115 @rva=896480
	//_Func: public bool isVisible(); @loc=static @len=15 @rva=888320
	//_Func: public void updateERSCharge(); @loc=static @len=88 @rva=906032
	//_Func: public float getERSNormalizedRecharge(); @loc=optimized @len=0 @rva=0
	//_Func: public void setHeadlights(bool value); @loc=static @len=132 @rva=893760
	//_Func: public void resetPenalty(bool isTotalReset); @loc=static @len=132 @rva=891616
	//_Func: public TimeTransponder * getTimeTransponder(); @loc=static @len=20 @rva=866656
	//_Func: public std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getScreenName(); @loc=static @len=100 @rva=865952
	//_Func: public void setAutoClutchEnabled(bool mode); @loc=static @len=112 @rva=892128
	//_Func: public float getPackerRange(int index); @loc=static @len=37 @rva=865600
	//_Data: this+0x1048, Member, Type: float, fuelInExhaust
	//_Func: public void initGhostCar(bool isRecording, bool isPlaying); @loc=static @len=212 @rva=881936
	//_Func: public void setControlsLock(bool value); @loc=static @len=132 @rva=892672
	//_Func: public void lockGearBox(bool  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void setGentleStop(bool mode); @loc=static @len=132 @rva=893568
	//_Func: public double hasPenalty(); @loc=static @len=20 @rva=867184
	//_Func: public bool isMinSpeedPenaltyClearDisabled(); @loc=static @len=19 @rva=888128
	//_Func: public std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getCurrentSkin(); @loc=static @len=61 @rva=618160
	//_Func: public void resetTimeTransponder(); @loc=static @len=79 @rva=891760
	//_Func: public void resetFlames(); @loc=static @len=115 @rva=891440
	//_Func: public void setDriverInfo(const DriverInfo & info); @loc=static @len=172 @rva=893104
	//_Func: public const DriverInfo & getDriverInfo(); @loc=static @len=8 @rva=287840
	//_Func: public float getGraphicSteerDeg(); @loc=static @len=37 @rva=865456
	//_Func: public int getSpawnPositionIndex(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * setName); @loc=static @len=115 @rva=866096
	//_Func: public void setSlipStreamEffects(float receive, float generationSpeedFactor); @loc=static @len=17 @rva=894784
	//_Func: public double getKmPerLiter(); @loc=static @len=48 @rva=865552
	//_Func: public void setBlackFlag(PenaltyDescription descr); @loc=static @len=132 @rva=892528
	//_Func: public void lockControlsUntilTime(double time, double start, bool forceToPits); @loc=static @len=150 @rva=888352
	//_Func: public bool isInPitlane(); @loc=static @len=8 @rva=887856
	//_Func: public void getPitlaneTimes(float &  _arg0, float &  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public Car * getPhysicsCar(); @loc=optimized @len=0 @rva=0
	//_Func: public void resetGuidCounter(); @pure @loc=optimized @len=0 @rva=0
	//_Func: public std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getCurrentCompoundShortName(); @loc=static @len=162 @rva=864768
	//_Func: public int getCurrentCompoundIdealPressure(unsigned short tyreIndex); @loc=static @len=125 @rva=864640
	//_Func: public int getCurrentCompoundStaticPressure(unsigned short tyreIndex); @loc=static @len=125 @rva=864944
	//_Func: public int getCurrentCompoundIndex(); @loc=optimized @len=0 @rva=0
	//_Func: public void getDistancesOnSpline(CarAvatar & car, float * frontDistance, float * backDistance); @loc=static @len=165 @rva=865072
	//_Func: public double getTimeDifferenceOnSpline(CarAvatar & car); @loc=static @len=255 @rva=866400
	//_Func: public float getBallastKG(); @loc=static @len=46 @rva=864528
	//_Func: public void setBallastKG(float ballast); @loc=static @len=134 @rva=892384
	//_Func: public std::vector<PenaltyRecord,std::allocator<PenaltyRecord> > getPenaltyRecords(); @loc=optimized @len=0 @rva=0
	//_Func: public float getFilteredSpeed(); @loc=optimized @len=0 @rva=0
	//_Func: public void setMultVolume(int value, bool active); @loc=static @len=65 @rva=893904
	//_Func: public void resetMultVolume(); @loc=static @len=35 @rva=891568
	//_Func: public INIReader openINI(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & filename); @loc=static @len=509 @rva=890416
	//_Func: public int cycleEngineBrake(int value); @loc=static @len=202 @rva=863376
	//_Func: public bool cycleERSHeatCharging(); @loc=static @len=155 @rva=862688
	//_Func: public std::pair<int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > cycleERSPower(int value); @loc=static @len=316 @rva=862848
	//_Func: public int cycleERSRecovery(int value); @loc=static @len=198 @rva=863168
	//_Func: public int getERSRecovery(); @loc=optimized @len=0 @rva=0
	//_Func: public std::pair<int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > getERSPower(); @loc=static @len=133 @rva=865248
	//_Func: public int getEngineBrakeSetting(); @loc=optimized @len=0 @rva=0
	//_Func: public bool getERSHeatCharging(); @loc=static @len=8 @rva=1243840
	//_Func: public bool getMandatoryPitstop(); @loc=optimized @len=0 @rva=0
	//_Func: public void setMandatoryPitstop(bool  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public float getLastPitstopTime(); @loc=optimized @len=0 @rva=0
	//_Func: public void setLastPitstopTime(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void resetPitTimes(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x104C, Member, Type: class vec3f, graphicsOffset
	//_Data: this+0x1058, Member, Type: float, graphicsPitchRotation
	//_Data: this+0x105C, Member, Type: float, userFFGain
	//_Data: this+0x1060, Member, Type: float, graphicSteerLockDegrees
	//_Data: this+0x1068, Member, Type: struct BackfireParams *, backfireParams
	//_Data: this+0x1070, Member, Type: class Node *, meshCollider
	//_Data: this+0x1078, Member, Type: class mat44f, pitPosition
	//_Data: this+0x10B8, Member, Type: struct DriverInfo, driverInfo
	//_Data: this+0x1138, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, currentSkin
	//_Data: static, [01559A94][0003:00046A94], Static Member, Type: int, guidCounter
	//_Data: this+0x1158, Member, Type: int, guid
	//_Data: this+0x1160, Member, Type: class Node *, modelLink
	//_Data: this+0x1168, Member, Type: class Car *, physics
	//_Data: this+0x1170, Member, Type: class vec3f[0x4], lastSkidPosition
	//_Data: this+0x11A0, Member, Type: class std::vector<IEventTrigger *,std::allocator<IEventTrigger *> >, eventTriggers
	//_Data: this+0x11B8, Member, Type: class ICarPhysicsStateProvider *, physicsStateProvider
	//_Data: this+0x11C0, Member, Type: bool, lockVirtualSteer
	//_Data: this+0x11C1, Member, Type: bool, hideArmsInCockpit
	//_Data: this+0x11C2, Member, Type: bool, hideSteer
	//_Data: this+0x11C8, Member, Type: class CarRaceInfo, raceInfo
	//_Data: this+0x11F0, Member, Type: class std::unique_ptr<PhysicsCarStateProvider,std::default_delete<PhysicsCarStateProvider> >, physicsCarStateProvider
	//_Data: this+0x11F8, Member, Type: class BufferedChannel<OnLapCompletedEvent>, lapQueue
	//_Data: this+0x1220, Member, Type: class BufferedChannel<OnSectorSplitEvent>, splitQueue
	//_Data: this+0x1248, Member, Type: class ICarPhysicsStateProvider *, nonReplayPhysicsStateProvider
	//_Data: this+0x1250, Member, Type: class Node *, beltOffNode
	//_Data: this+0x1258, Member, Type: class Node *, beltOnNode
	//_Data: this+0x1260, Member, Type: int[0x4], currentTyreCompoundIndex
	//_Data: this+0x1270, Member, Type: class CarAnimations *, carAnimations
	//_Data: this+0x1278, Member, Type: float, filteredSpeed
	//_Data: this+0x127C, Member, Type: int, currentEngineBrakeSetting
	//_Data: this+0x1280, Member, Type: bool, isHeatChargingBatteries
	//_Data: this+0x1284, Member, Type: int, currentERSPowerIndex
	//_Data: this+0x1288, Member, Type: int, currentERSRecovery
	//_Data: this+0x128C, Member, Type: float, lastERSBatteryCharge
	//_Data: this+0x1290, Member, Type: float, currentERSNormalizedRecharge
	//_Data: this+0x1294, Member, Type: bool, showDownShiftProtetion
	//_Data: this+0x1295, Member, Type: bool, mandatoryPitstopDone
	//_Data: this+0x1298, Member, Type: float, lastPitstopTime
	//_Data: this+0x129C, Member, Type: bool, inPitlane
	//_Data: this+0x129D, Member, Type: bool, wasInPitlane
	//_Data: this+0x12A0, Member, Type: float, pitLaneEntryTime
	//_Data: this+0x12A4, Member, Type: float, pitLaneExitTime
	//_Func: protected void forcePosition(const mat44f & matrix); @loc=static @len=287 @rva=864048
	//_Func: protected void initCommon(); @loc=static @len=2729 @rva=874208
	//_Func: protected void initCommonPostPhysics(); @loc=static @len=3480 @rva=876944
	//_Func: protected void init3D(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * skin); @loc=static @len=3110 @rva=867216
	//_Func: protected void initPhysics(); @loc=static @len=5154 @rva=882272
	//_Func: protected void updateSkidMarks(float dt); @loc=static @len=982 @rva=907136
	//_Func: protected void stepTriggers(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: protected void initDriver(); @loc=static @len=399 @rva=881536
	//_Func: protected void initCameraCar(); @loc=static @len=3871 @rva=870336
	//_Func: protected void initMirrorMaterials(); @loc=static @len=103 @rva=882160
	//_Func: protected void initControls(); @loc=static @len=1103 @rva=880432
	//_Func: protected void onNewSession(); @loc=static @len=238 @rva=889280
	//_Func: protected void updateFromChannels(float dt); @loc=static @len=817 @rva=906128
	//_Func: protected void checkACD(); @loc=static @len=679 @rva=861184
	//_Func: protected void updateInPitlaneState(float dt); @loc=static @len=171 @rva=906960
	//_Func: public CarAvatar & operator=(const CarAvatar &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class CarAvatar : public GameObject {
public:
	EventTriggerOnChange<int> evOnGearChanged;
	Event<OnLapCompletedEvent> evOnLapCompleted;
	Event<OnSectorSplitEvent> evOnSectorSplit;
	Event<OnTyreCompoundChanged> evOnTyreCompoundChanged;
	Event<bool> evOnBackfireTriggered;
	Event<bool> evOnDownshiftProtection;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > externalTyreCompoundShortName;
	vec3f mirrorPosition;
	Sim * sim;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > unixName;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > configName;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > guiName;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > guiShortName;
	Node * bodyTransform;
	Node * steerTransformHR;
	Node * steerTransformLR;
	mat44f orgSteerMatrix;
	NodeBoundingSphere * carNode;
	vec3f driverEyesPosition;
	mat44f bodyMatrix;
	CarPhysicsState physicsState;
	AIState aiState;
	CarAudioFMOD * carAudioFMOD;
	SkidMarkBuffer * skidMarkBuffers[4];
	CarPhysicsInfo physicsInfo;
	std::unique_ptr<RaceEngineer,std::default_delete<RaceEngineer> > raceEngineer;
	ModelBoundariesCoordinates modelBoundaries;
	std::vector<WingState,std::allocator<WingState> > wingsStatus;
	float onBoardExposure;
	float outBoardExposure;
	float dashBoardExposure;
	std::vector<CameraCarDefinition,std::allocator<CameraCarDefinition> > cameras;
	bool isDriverHR;
	DriverModel * driverModel_HR;
	DriverModel * driverModel_LR;
	ISuspensionAvatar * suspensionAvatar;
	bool isBlackFlagged;
	NetCarStateProvider * netCarStateProvider;
	CarLodManager * lodManager;
	ConstrainedObjectsManager * constrainedObjectManager;
	BufferedChannel<std::pair<int,int> > chTyreCompound;
	float fuelInExhaust;
	vec3f graphicsOffset;
	float graphicsPitchRotation;
	float userFFGain;
	float graphicSteerLockDegrees;
	BackfireParams * backfireParams;
	Node * meshCollider;
	mat44f pitPosition;
	DriverInfo driverInfo;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > currentSkin;
	int guid;
	Node * modelLink;
	Car * physics;
	vec3f lastSkidPosition[4];
	std::vector<IEventTrigger *,std::allocator<IEventTrigger *> > eventTriggers;
	ICarPhysicsStateProvider * physicsStateProvider;
	bool lockVirtualSteer;
	bool hideArmsInCockpit;
	bool hideSteer;
	CarRaceInfo raceInfo;
	std::unique_ptr<PhysicsCarStateProvider,std::default_delete<PhysicsCarStateProvider> > physicsCarStateProvider;
	BufferedChannel<OnLapCompletedEvent> lapQueue;
	BufferedChannel<OnSectorSplitEvent> splitQueue;
	ICarPhysicsStateProvider * nonReplayPhysicsStateProvider;
	Node * beltOffNode;
	Node * beltOnNode;
	int currentTyreCompoundIndex[4];
	CarAnimations * carAnimations;
	float filteredSpeed;
	int currentEngineBrakeSetting;
	bool isHeatChargingBatteries;
	int currentERSPowerIndex;
	int currentERSRecovery;
	float lastERSBatteryCharge;
	float currentERSNormalizedRecharge;
	bool showDownShiftProtetion;
	bool mandatoryPitstopDone;
	float lastPitstopTime;
	bool inPitlane;
	bool wasInPitlane;
	float pitLaneEntryTime;
	float pitLaneExitTime;
	inline CarAvatar() { }
	inline CarAvatar(const CarAvatar& other) = default;
	inline CarAvatar& operator=(const CarAvatar& other) = default;
	inline void ctor(Sim * isim, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & unixName, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & config, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & skin) { typedef void (CarAvatar::*_fpt)(Sim *, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(840096)); (this->*_f)(isim, unixName, config, skin); }
	inline void ctor(Sim * isim, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & unixName, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & config, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & skin, ICarPhysicsStateProvider * physicsStateProvider) { typedef void (CarAvatar::*_fpt)(Sim *, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, ICarPhysicsStateProvider *); auto _f=xcast<_fpt>(_drva(843200)); (this->*_f)(isim, unixName, config, skin, physicsStateProvider); }
	virtual ~CarAvatar();
	inline void dtor() { typedef void (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(846608)); (this->*_f)(); }
	inline void setP2PActivations(int activations) { typedef void (CarAvatar::*_fpt)(int); auto _f=xcast<_fpt>(_drva(894352)); return (this->*_f)(activations); }
	inline void setP2PStartingActivations(int pos) { typedef void (CarAvatar::*_fpt)(int); auto _f=xcast<_fpt>(_drva(894496)); return (this->*_f)(pos); }
	inline void setRestrictor(float v) { typedef void (CarAvatar::*_fpt)(float); auto _f=xcast<_fpt>(_drva(894640)); return (this->*_f)(v); }
	inline float getRestrictor() { typedef float (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(865792)); return (this->*_f)(); }
	inline void makeBodyMatrix(const mat44f & bm, mat44f & res) { typedef void (CarAvatar::*_fpt)(const mat44f &, mat44f &); auto _f=xcast<_fpt>(_drva(888512)); return (this->*_f)(bm, res); }
	inline void setNewPhysicsState(CarPhysicsState & ps, float dt) { typedef void (CarAvatar::*_fpt)(CarPhysicsState &, float); auto _f=xcast<_fpt>(_drva(893984)); return (this->*_f)(ps, dt); }
	inline DriverModel * getActiveDriverModel() { typedef DriverModel * (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(864432)); return (this->*_f)(); }
	inline int getAILapsToComplete() { typedef int (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(864400)); return (this->*_f)(); }
	inline PitStopTime getPitstopTime(float fuel_requested, bool changeTyres, bool repairBody, bool repairEngine, bool repairSus, bool useRandomizer) { typedef PitStopTime (CarAvatar::*_fpt)(float, bool, bool, bool, bool, bool); auto _f=xcast<_fpt>(_drva(865648)); return (this->*_f)(fuel_requested, changeTyres, repairBody, repairEngine, repairSus, useRandomizer); }
	inline bool isRequestingPitStop() { typedef bool (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(888176)); return (this->*_f)(); }
	inline float modifyUserFFGain(float offset) { typedef float (CarAvatar::*_fpt)(float); auto _f=xcast<_fpt>(_drva(889072)); return (this->*_f)(offset); }
	inline void setUserFFGain(float gain) { typedef void (CarAvatar::*_fpt)(float); auto _f=xcast<_fpt>(_drva(896336)); return (this->*_f)(gain); }
	inline float getUserFFGain() { typedef float (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(866960)); return (this->*_f)(); }
	inline bool isCurrentLapValid() { typedef bool (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(887632)); return (this->*_f)(); }
	inline void setFFMult(float mult) { typedef void (CarAvatar::*_fpt)(float); auto _f=xcast<_fpt>(_drva(893280)); return (this->*_f)(mult); }
	inline float getFFMult() { typedef float (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(865424)); return (this->*_f)(); }
	inline void setTurboBoost(float value) { typedef void (CarAvatar::*_fpt)(float); auto _f=xcast<_fpt>(_drva(895456)); return (this->*_f)(value); }
	inline std::pair<unsigned int,unsigned int> getTCMode() { typedef std::pair<unsigned int,unsigned int> (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(866336)); return (this->*_f)(); }
	inline std::pair<unsigned int,unsigned int> getABSMode() { typedef std::pair<unsigned int,unsigned int> (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(864336)); return (this->*_f)(); }
	inline bool isConnected() { typedef bool (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(887616)); return (this->*_f)(); }
	inline bool isInPit() { typedef bool (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(887760)); return (this->*_f)(); }
	inline void armFirstLap() { typedef void (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(860928)); return (this->*_f)(); }
	inline void setTyreCompound(unsigned int index, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & name) { typedef void (CarAvatar::*_fpt)(unsigned int, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(895952)); return (this->*_f)(index, name); }
	inline std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getTyreCompound(unsigned int index, bool fullname) { typedef std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > (CarAvatar::*_fpt)(unsigned int, bool); auto _f=xcast<_fpt>(_drva(866688)); return (this->*_f)(index, fullname); }
	inline unsigned int getTyreCompoundIndex(unsigned int tyre_index) { typedef unsigned int (CarAvatar::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(866944)); return (this->*_f)(tyre_index); }
	inline float getWingAngle(int wingIndex) { typedef float (CarAvatar::*_fpt)(int); auto _f=xcast<_fpt>(_drva(866976)); return (this->*_f)(wingIndex); }
	inline CarColliderManager * getColliderManager() { typedef CarColliderManager * (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(864576)); return (this->*_f)(); }
	inline void setDamageLevel(float lvl) { typedef void (CarAvatar::*_fpt)(float); auto _f=xcast<_fpt>(_drva(892960)); return (this->*_f)(lvl); }
	inline int getGuid() { typedef int (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(865536)); return (this->*_f)(); }
	virtual void update_vf1(float deltaT);
	inline void update_impl(float deltaT) { typedef void (CarAvatar::*_fpt)(float); auto _f=xcast<_fpt>(_drva(899120)); return (this->*_f)(deltaT); }
	inline void update(float deltaT) { typedef void (CarAvatar::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(deltaT); }
	inline void goToSpawnPosition(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & setName) { typedef void (CarAvatar::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(867040)); return (this->*_f)(setName); }
	inline bool isInSpawnPosition(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & setName) { typedef bool (CarAvatar::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(887872)); return (this->*_f)(setName); }
	inline void setSpawnPositionIndex(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & setName, int index) { typedef void (CarAvatar::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, int); auto _f=xcast<_fpt>(_drva(894816)); return (this->*_f)(setName, index); }
	inline void setControlsProvider(ICarControlsProvider * controls) { typedef void (CarAvatar::*_fpt)(ICarControlsProvider *); auto _f=xcast<_fpt>(_drva(892816)); return (this->*_f)(controls); }
	inline vec3f getGraphicsOffset() { typedef vec3f (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(865504)); return (this->*_f)(); }
	inline void setGraphicsPitchRotation(float v) { typedef void (CarAvatar::*_fpt)(float); auto _f=xcast<_fpt>(_drva(893744)); return (this->*_f)(v); }
	inline void setGraphicsOffset(vec3f np) { typedef void (CarAvatar::*_fpt)(vec3f); auto _f=xcast<_fpt>(_drva(893712)); return (this->*_f)(np); }
	inline ICarControlsProvider * getControlsProvider() { typedef ICarControlsProvider * (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(864608)); return (this->*_f)(); }
	inline std::vector<DebugLine,std::allocator<DebugLine> > getSuspensionDebugLines(int index) { typedef std::vector<DebugLine,std::allocator<DebugLine> > (CarAvatar::*_fpt)(int); auto _f=xcast<_fpt>(_drva(866256)); return (this->*_f)(index); }
	inline vec3f getRoadDirection() { typedef vec3f (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(865840)); return (this->*_f)(); }
	inline SetupManager * getSetupManager() { typedef SetupManager * (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(866064)); return (this->*_f)(); }
	inline void onPostLoad() { typedef void (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(889520)); return (this->*_f)(); }
	inline void onStartReplay(const bool & mode) { typedef void (CarAvatar::*_fpt)(const bool &); auto _f=xcast<_fpt>(_drva(889856)); return (this->*_f)(mode); }
	inline void onStopReplay(const bool & mode) { typedef void (CarAvatar::*_fpt)(const bool &); auto _f=xcast<_fpt>(_drva(890144)); return (this->*_f)(mode); }
	inline bool isAbsInAction() { typedef bool (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(887520)); return (this->*_f)(); }
	inline void setAbsEnabled(bool mode, bool force) { typedef void (CarAvatar::*_fpt)(bool, bool); auto _f=xcast<_fpt>(_drva(891840)); return (this->*_f)(mode, force); }
	inline void cycleAbsMode(int value) { typedef void (CarAvatar::*_fpt)(int); auto _f=xcast<_fpt>(_drva(862288)); return (this->*_f)(value); }
	inline bool isAbsAvailable() { typedef bool (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(887440)); return (this->*_f)(); }
	inline bool isAbsEnabled() { typedef bool (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(887472)); return (this->*_f)(); }
	inline bool isTcInAction() { typedef bool (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(888288)); return (this->*_f)(); }
	inline void setTcEnabled(bool mode, bool force) { typedef void (CarAvatar::*_fpt)(bool, bool); auto _f=xcast<_fpt>(_drva(895312)); return (this->*_f)(mode, force); }
	inline void cycleTcMode(int value) { typedef void (CarAvatar::*_fpt)(int); auto _f=xcast<_fpt>(_drva(863584)); return (this->*_f)(value); }
	inline bool isTcEnabled() { typedef bool (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(888240)); return (this->*_f)(); }
	inline bool isTcAvailable() { typedef bool (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(888208)); return (this->*_f)(); }
	inline bool isEdlEnabled() { typedef bool (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(887712)); return (this->*_f)(); }
	inline float getEdlOutLevel() { typedef float (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(865392)); return (this->*_f)(); }
	inline void setAutoBlip(bool mode) { typedef void (CarAvatar::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(891984)); return (this->*_f)(mode); }
	inline bool getAutoBlip() { typedef bool (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(864464)); return (this->*_f)(); }
	inline float getStabilityControl() { typedef float (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(866224)); return (this->*_f)(); }
	inline void setStabilityControl(float gain) { typedef void (CarAvatar::*_fpt)(float); auto _f=xcast<_fpt>(_drva(895168)); return (this->*_f)(gain); }
	inline void setFrontBias(int value) { typedef void (CarAvatar::*_fpt)(int); auto _f=xcast<_fpt>(_drva(893424)); return (this->*_f)(value); }
	inline void setAutoShifter(bool mode) { typedef void (CarAvatar::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(892240)); return (this->*_f)(mode); }
	inline bool getAutoShifter() { typedef bool (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(864496)); return (this->*_f)(); }
	inline void setVisible(bool vis) { typedef void (CarAvatar::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(896480)); return (this->*_f)(vis); }
	inline bool isVisible() { typedef bool (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(888320)); return (this->*_f)(); }
	inline void updateERSCharge() { typedef void (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(906032)); return (this->*_f)(); }
	inline void setHeadlights(bool value) { typedef void (CarAvatar::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(893760)); return (this->*_f)(value); }
	inline void resetPenalty(bool isTotalReset) { typedef void (CarAvatar::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(891616)); return (this->*_f)(isTotalReset); }
	inline TimeTransponder * getTimeTransponder() { typedef TimeTransponder * (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(866656)); return (this->*_f)(); }
	inline std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getScreenName() { typedef std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(865952)); return (this->*_f)(); }
	inline void setAutoClutchEnabled(bool mode) { typedef void (CarAvatar::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(892128)); return (this->*_f)(mode); }
	inline float getPackerRange(int index) { typedef float (CarAvatar::*_fpt)(int); auto _f=xcast<_fpt>(_drva(865600)); return (this->*_f)(index); }
	inline void initGhostCar(bool isRecording, bool isPlaying) { typedef void (CarAvatar::*_fpt)(bool, bool); auto _f=xcast<_fpt>(_drva(881936)); return (this->*_f)(isRecording, isPlaying); }
	inline void setControlsLock(bool value) { typedef void (CarAvatar::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(892672)); return (this->*_f)(value); }
	inline void setGentleStop(bool mode) { typedef void (CarAvatar::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(893568)); return (this->*_f)(mode); }
	inline double hasPenalty() { typedef double (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(867184)); return (this->*_f)(); }
	inline bool isMinSpeedPenaltyClearDisabled() { typedef bool (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(888128)); return (this->*_f)(); }
	inline std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getCurrentSkin() { typedef std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(618160)); return (this->*_f)(); }
	inline void resetTimeTransponder() { typedef void (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(891760)); return (this->*_f)(); }
	inline void resetFlames() { typedef void (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(891440)); return (this->*_f)(); }
	inline void setDriverInfo(const DriverInfo & info) { typedef void (CarAvatar::*_fpt)(const DriverInfo &); auto _f=xcast<_fpt>(_drva(893104)); return (this->*_f)(info); }
	inline const DriverInfo & getDriverInfo() { typedef const DriverInfo & (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(287840)); return (this->*_f)(); }
	inline float getGraphicSteerDeg() { typedef float (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(865456)); return (this->*_f)(); }
	inline int getSpawnPositionIndex(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * setName) { typedef int (CarAvatar::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *); auto _f=xcast<_fpt>(_drva(866096)); return (this->*_f)(setName); }
	inline void setSlipStreamEffects(float receive, float generationSpeedFactor) { typedef void (CarAvatar::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(894784)); return (this->*_f)(receive, generationSpeedFactor); }
	inline double getKmPerLiter() { typedef double (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(865552)); return (this->*_f)(); }
	inline void setBlackFlag(PenaltyDescription descr) { typedef void (CarAvatar::*_fpt)(PenaltyDescription); auto _f=xcast<_fpt>(_drva(892528)); return (this->*_f)(descr); }
	inline void lockControlsUntilTime(double time, double start, bool forceToPits) { typedef void (CarAvatar::*_fpt)(double, double, bool); auto _f=xcast<_fpt>(_drva(888352)); return (this->*_f)(time, start, forceToPits); }
	inline bool isInPitlane() { typedef bool (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(887856)); return (this->*_f)(); }
	inline std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getCurrentCompoundShortName() { typedef std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(864768)); return (this->*_f)(); }
	inline int getCurrentCompoundIdealPressure(unsigned short tyreIndex) { typedef int (CarAvatar::*_fpt)(unsigned short); auto _f=xcast<_fpt>(_drva(864640)); return (this->*_f)(tyreIndex); }
	inline int getCurrentCompoundStaticPressure(unsigned short tyreIndex) { typedef int (CarAvatar::*_fpt)(unsigned short); auto _f=xcast<_fpt>(_drva(864944)); return (this->*_f)(tyreIndex); }
	inline void getDistancesOnSpline(CarAvatar & car, float * frontDistance, float * backDistance) { typedef void (CarAvatar::*_fpt)(CarAvatar &, float *, float *); auto _f=xcast<_fpt>(_drva(865072)); return (this->*_f)(car, frontDistance, backDistance); }
	inline double getTimeDifferenceOnSpline(CarAvatar & car) { typedef double (CarAvatar::*_fpt)(CarAvatar &); auto _f=xcast<_fpt>(_drva(866400)); return (this->*_f)(car); }
	inline float getBallastKG() { typedef float (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(864528)); return (this->*_f)(); }
	inline void setBallastKG(float ballast) { typedef void (CarAvatar::*_fpt)(float); auto _f=xcast<_fpt>(_drva(892384)); return (this->*_f)(ballast); }
	inline void setMultVolume(int value, bool active) { typedef void (CarAvatar::*_fpt)(int, bool); auto _f=xcast<_fpt>(_drva(893904)); return (this->*_f)(value, active); }
	inline void resetMultVolume() { typedef void (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(891568)); return (this->*_f)(); }
	inline INIReader openINI(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & filename) { typedef INIReader (CarAvatar::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(890416)); return (this->*_f)(filename); }
	inline int cycleEngineBrake(int value) { typedef int (CarAvatar::*_fpt)(int); auto _f=xcast<_fpt>(_drva(863376)); return (this->*_f)(value); }
	inline bool cycleERSHeatCharging() { typedef bool (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(862688)); return (this->*_f)(); }
	inline std::pair<int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > cycleERSPower(int value) { typedef std::pair<int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > (CarAvatar::*_fpt)(int); auto _f=xcast<_fpt>(_drva(862848)); return (this->*_f)(value); }
	inline int cycleERSRecovery(int value) { typedef int (CarAvatar::*_fpt)(int); auto _f=xcast<_fpt>(_drva(863168)); return (this->*_f)(value); }
	inline std::pair<int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > getERSPower() { typedef std::pair<int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(865248)); return (this->*_f)(); }
	inline bool getERSHeatCharging() { typedef bool (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(1243840)); return (this->*_f)(); }
	inline void forcePosition(const mat44f & matrix) { typedef void (CarAvatar::*_fpt)(const mat44f &); auto _f=xcast<_fpt>(_drva(864048)); return (this->*_f)(matrix); }
	inline void initCommon() { typedef void (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(874208)); return (this->*_f)(); }
	inline void initCommonPostPhysics() { typedef void (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(876944)); return (this->*_f)(); }
	inline void init3D(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * skin) { typedef void (CarAvatar::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *); auto _f=xcast<_fpt>(_drva(867216)); return (this->*_f)(skin); }
	inline void initPhysics() { typedef void (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(882272)); return (this->*_f)(); }
	inline void updateSkidMarks(float dt) { typedef void (CarAvatar::*_fpt)(float); auto _f=xcast<_fpt>(_drva(907136)); return (this->*_f)(dt); }
	inline void initDriver() { typedef void (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(881536)); return (this->*_f)(); }
	inline void initCameraCar() { typedef void (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(870336)); return (this->*_f)(); }
	inline void initMirrorMaterials() { typedef void (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(882160)); return (this->*_f)(); }
	inline void initControls() { typedef void (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(880432)); return (this->*_f)(); }
	inline void onNewSession() { typedef void (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(889280)); return (this->*_f)(); }
	inline void updateFromChannels(float dt) { typedef void (CarAvatar::*_fpt)(float); auto _f=xcast<_fpt>(_drva(906128)); return (this->*_f)(dt); }
	inline void checkACD() { typedef void (CarAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(861184)); return (this->*_f)(); }
	inline void updateInPitlaneState(float dt) { typedef void (CarAvatar::*_fpt)(float); auto _f=xcast<_fpt>(_drva(906960)); return (this->*_f)(dt); }
	inline void _guard_obj() {
		static_assert((sizeof(CarAvatar)==4776),"bad size");
		static_assert((offsetof(CarAvatar,evOnGearChanged)==0x58),"bad off");
		static_assert((offsetof(CarAvatar,evOnLapCompleted)==0x88),"bad off");
		static_assert((offsetof(CarAvatar,evOnSectorSplit)==0xA0),"bad off");
		static_assert((offsetof(CarAvatar,evOnTyreCompoundChanged)==0xB8),"bad off");
		static_assert((offsetof(CarAvatar,evOnBackfireTriggered)==0xD0),"bad off");
		static_assert((offsetof(CarAvatar,evOnDownshiftProtection)==0xE8),"bad off");
		static_assert((offsetof(CarAvatar,externalTyreCompoundShortName)==0x100),"bad off");
		static_assert((offsetof(CarAvatar,mirrorPosition)==0x120),"bad off");
		static_assert((offsetof(CarAvatar,sim)==0x130),"bad off");
		static_assert((offsetof(CarAvatar,unixName)==0x138),"bad off");
		static_assert((offsetof(CarAvatar,configName)==0x158),"bad off");
		static_assert((offsetof(CarAvatar,guiName)==0x178),"bad off");
		static_assert((offsetof(CarAvatar,guiShortName)==0x198),"bad off");
		static_assert((offsetof(CarAvatar,bodyTransform)==0x1B8),"bad off");
		static_assert((offsetof(CarAvatar,steerTransformHR)==0x1C0),"bad off");
		static_assert((offsetof(CarAvatar,steerTransformLR)==0x1C8),"bad off");
		static_assert((offsetof(CarAvatar,orgSteerMatrix)==0x1D0),"bad off");
		static_assert((offsetof(CarAvatar,carNode)==0x210),"bad off");
		static_assert((offsetof(CarAvatar,driverEyesPosition)==0x218),"bad off");
		static_assert((offsetof(CarAvatar,bodyMatrix)==0x224),"bad off");
		static_assert((offsetof(CarAvatar,physicsState)==0x268),"bad off");
		static_assert((offsetof(CarAvatar,aiState)==0xDD8),"bad off");
		static_assert((offsetof(CarAvatar,carAudioFMOD)==0xE18),"bad off");
		static_assert((offsetof(CarAvatar,skidMarkBuffers)==0xE20),"bad off");
		static_assert((offsetof(CarAvatar,physicsInfo)==0xE40),"bad off");
		static_assert((offsetof(CarAvatar,raceEngineer)==0xF80),"bad off");
		static_assert((offsetof(CarAvatar,modelBoundaries)==0xF88),"bad off");
		static_assert((offsetof(CarAvatar,wingsStatus)==0xFA0),"bad off");
		static_assert((offsetof(CarAvatar,onBoardExposure)==0xFB8),"bad off");
		static_assert((offsetof(CarAvatar,outBoardExposure)==0xFBC),"bad off");
		static_assert((offsetof(CarAvatar,dashBoardExposure)==0xFC0),"bad off");
		static_assert((offsetof(CarAvatar,cameras)==0xFC8),"bad off");
		static_assert((offsetof(CarAvatar,isDriverHR)==0xFE0),"bad off");
		static_assert((offsetof(CarAvatar,driverModel_HR)==0xFE8),"bad off");
		static_assert((offsetof(CarAvatar,driverModel_LR)==0xFF0),"bad off");
		static_assert((offsetof(CarAvatar,suspensionAvatar)==0xFF8),"bad off");
		static_assert((offsetof(CarAvatar,isBlackFlagged)==0x1000),"bad off");
		static_assert((offsetof(CarAvatar,netCarStateProvider)==0x1008),"bad off");
		static_assert((offsetof(CarAvatar,lodManager)==0x1010),"bad off");
		static_assert((offsetof(CarAvatar,constrainedObjectManager)==0x1018),"bad off");
		static_assert((offsetof(CarAvatar,chTyreCompound)==0x1020),"bad off");
		static_assert((offsetof(CarAvatar,fuelInExhaust)==0x1048),"bad off");
		static_assert((offsetof(CarAvatar,graphicsOffset)==0x104C),"bad off");
		static_assert((offsetof(CarAvatar,graphicsPitchRotation)==0x1058),"bad off");
		static_assert((offsetof(CarAvatar,userFFGain)==0x105C),"bad off");
		static_assert((offsetof(CarAvatar,graphicSteerLockDegrees)==0x1060),"bad off");
		static_assert((offsetof(CarAvatar,backfireParams)==0x1068),"bad off");
		static_assert((offsetof(CarAvatar,meshCollider)==0x1070),"bad off");
		static_assert((offsetof(CarAvatar,pitPosition)==0x1078),"bad off");
		static_assert((offsetof(CarAvatar,driverInfo)==0x10B8),"bad off");
		static_assert((offsetof(CarAvatar,currentSkin)==0x1138),"bad off");
		static_assert((offsetof(CarAvatar,guid)==0x1158),"bad off");
		static_assert((offsetof(CarAvatar,modelLink)==0x1160),"bad off");
		static_assert((offsetof(CarAvatar,physics)==0x1168),"bad off");
		static_assert((offsetof(CarAvatar,lastSkidPosition)==0x1170),"bad off");
		static_assert((offsetof(CarAvatar,eventTriggers)==0x11A0),"bad off");
		static_assert((offsetof(CarAvatar,physicsStateProvider)==0x11B8),"bad off");
		static_assert((offsetof(CarAvatar,lockVirtualSteer)==0x11C0),"bad off");
		static_assert((offsetof(CarAvatar,hideArmsInCockpit)==0x11C1),"bad off");
		static_assert((offsetof(CarAvatar,hideSteer)==0x11C2),"bad off");
		static_assert((offsetof(CarAvatar,raceInfo)==0x11C8),"bad off");
		static_assert((offsetof(CarAvatar,physicsCarStateProvider)==0x11F0),"bad off");
		static_assert((offsetof(CarAvatar,lapQueue)==0x11F8),"bad off");
		static_assert((offsetof(CarAvatar,splitQueue)==0x1220),"bad off");
		static_assert((offsetof(CarAvatar,nonReplayPhysicsStateProvider)==0x1248),"bad off");
		static_assert((offsetof(CarAvatar,beltOffNode)==0x1250),"bad off");
		static_assert((offsetof(CarAvatar,beltOnNode)==0x1258),"bad off");
		static_assert((offsetof(CarAvatar,currentTyreCompoundIndex)==0x1260),"bad off");
		static_assert((offsetof(CarAvatar,carAnimations)==0x1270),"bad off");
		static_assert((offsetof(CarAvatar,filteredSpeed)==0x1278),"bad off");
		static_assert((offsetof(CarAvatar,currentEngineBrakeSetting)==0x127C),"bad off");
		static_assert((offsetof(CarAvatar,isHeatChargingBatteries)==0x1280),"bad off");
		static_assert((offsetof(CarAvatar,currentERSPowerIndex)==0x1284),"bad off");
		static_assert((offsetof(CarAvatar,currentERSRecovery)==0x1288),"bad off");
		static_assert((offsetof(CarAvatar,lastERSBatteryCharge)==0x128C),"bad off");
		static_assert((offsetof(CarAvatar,currentERSNormalizedRecharge)==0x1290),"bad off");
		static_assert((offsetof(CarAvatar,showDownShiftProtetion)==0x1294),"bad off");
		static_assert((offsetof(CarAvatar,mandatoryPitstopDone)==0x1295),"bad off");
		static_assert((offsetof(CarAvatar,lastPitstopTime)==0x1298),"bad off");
		static_assert((offsetof(CarAvatar,inPitlane)==0x129C),"bad off");
		static_assert((offsetof(CarAvatar,wasInPitlane)==0x129D),"bad off");
		static_assert((offsetof(CarAvatar,pitLaneEntryTime)==0x12A0),"bad off");
		static_assert((offsetof(CarAvatar,pitLaneExitTime)==0x12A4),"bad off");
	};
};

//UDT: class DICommandManager @len=40
	//_Func: public void DICommandManager(const DICommandManager &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void DICommandManager(Game & game); @loc=static @len=910 @rva=528720
	//_Func: public void ~DICommandManager(); @loc=static @len=53 @rva=650384
	//_Func: public void step(); @loc=static @len=204 @rva=530224
	//_Data: this+0x0, Member, Type: class DirectInput *, directInput
	//_Data: this+0x8, Member, Type: class std::vector<DICommand,std::allocator<DICommand> >, commands
	//_Data: this+0x20, Member, Type: class Game &, game
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class DICommandManager {
public:
	DirectInput * directInput;
	std::vector<DICommand,std::allocator<DICommand> > commands;
	Game & game;
	inline DICommandManager() : game(*((Game*)NULL)) { }
	inline DICommandManager(const DICommandManager& other) = default;
	inline DICommandManager& operator=(const DICommandManager& other) = default;
	inline void ctor(Game & game) { typedef void (DICommandManager::*_fpt)(Game &); auto _f=xcast<_fpt>(_drva(528720)); (this->*_f)(game); }
	inline void dtor() { typedef void (DICommandManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(650384)); (this->*_f)(); }
	inline void step() { typedef void (DICommandManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(530224)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(DICommandManager)==40),"bad size");
		static_assert((offsetof(DICommandManager,directInput)==0x0),"bad off");
		static_assert((offsetof(DICommandManager,commands)==0x8),"bad off");
	};
};

//UDT: struct AeroMap @len=112
	//_Func: public void ~AeroMap(); @loc=static @len=9 @rva=2839440
	//_Data: this+0x0, Member, Type: float, referenceArea
	//_Data: this+0x4, Member, Type: float, CD
	//_Data: this+0x8, Member, Type: float, CL
	//_Data: this+0xC, Member, Type: float, frontShare
	//_Data: this+0x10, Member, Type: float, CDX
	//_Data: this+0x14, Member, Type: float, CDY
	//_Data: this+0x18, Member, Type: float, CDA
	//_Data: this+0x20, Member, Type: class IRigidBody *, carBody
	//_Data: this+0x28, Member, Type: float, dynamicCD
	//_Data: this+0x2C, Member, Type: float, dynamicCL
	//_Data: this+0x30, Member, Type: float, airDensity
	//_Data: this+0x38, Member, Type: class std::vector<Wing,std::allocator<Wing> >, wings
	//_Func: public void init(Car * a_car, const vec3f & frontAP, const vec3f & rearAP, std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * dataPath); @loc=static @len=164 @rva=2841760
	//_Func: public void step(float dt); @loc=static @len=135 @rva=2847056
	//_Func: public std::vector<WingState,std::allocator<WingState> > getWingStatus(); @loc=static @len=213 @rva=2841536
	//_Func: public float getCurrentLiftKG(); @loc=static @len=36 @rva=2841488
	//_Func: public float getCurrentDragKG(); @loc=static @len=36 @rva=2841440
	//_Data: this+0x50, Member, Type: class vec3f, frontApplicationPoint
	//_Data: this+0x5C, Member, Type: class vec3f, rearApplicationPoint
	//_Data: this+0x68, Member, Type: class Car *, car
	//_Func: protected void addDrag(const vec3f & lv); @loc=static @len=551 @rva=2840672
	//_Func: protected void addLift(const vec3f & localVelocity); @loc=static @len=194 @rva=2841232
	//_Func: protected void loadINI(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & dataPath); @loc=static @len=4692 @rva=2841936
	//_Func: public void AeroMap(const AeroMap &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void AeroMap(); @loc=optimized @len=0 @rva=0
	//_Func: public AeroMap & operator=(const AeroMap &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct AeroMap {
public:
	float referenceArea;
	float CD;
	float CL;
	float frontShare;
	float CDX;
	float CDY;
	float CDA;
	IRigidBody * carBody;
	float dynamicCD;
	float dynamicCL;
	float airDensity;
	std::vector<Wing,std::allocator<Wing> > wings;
	vec3f frontApplicationPoint;
	vec3f rearApplicationPoint;
	Car * car;
	inline AeroMap() { }
	inline AeroMap(const AeroMap& other) = default;
	inline AeroMap& operator=(const AeroMap& other) = default;
	inline void dtor() { typedef void (AeroMap::*_fpt)(); auto _f=xcast<_fpt>(_drva(2839440)); (this->*_f)(); }
	inline void init(Car * a_car, const vec3f & frontAP, const vec3f & rearAP, std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * dataPath) { typedef void (AeroMap::*_fpt)(Car *, const vec3f &, const vec3f &, std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *); auto _f=xcast<_fpt>(_drva(2841760)); return (this->*_f)(a_car, frontAP, rearAP, dataPath); }
	inline void step(float dt) { typedef void (AeroMap::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2847056)); return (this->*_f)(dt); }
	inline std::vector<WingState,std::allocator<WingState> > getWingStatus() { typedef std::vector<WingState,std::allocator<WingState> > (AeroMap::*_fpt)(); auto _f=xcast<_fpt>(_drva(2841536)); return (this->*_f)(); }
	inline float getCurrentLiftKG() { typedef float (AeroMap::*_fpt)(); auto _f=xcast<_fpt>(_drva(2841488)); return (this->*_f)(); }
	inline float getCurrentDragKG() { typedef float (AeroMap::*_fpt)(); auto _f=xcast<_fpt>(_drva(2841440)); return (this->*_f)(); }
	inline void addDrag(const vec3f & lv) { typedef void (AeroMap::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2840672)); return (this->*_f)(lv); }
	inline void addLift(const vec3f & localVelocity) { typedef void (AeroMap::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2841232)); return (this->*_f)(localVelocity); }
	inline void loadINI(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & dataPath) { typedef void (AeroMap::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2841936)); return (this->*_f)(dataPath); }
	inline void _guard_obj() {
		static_assert((sizeof(AeroMap)==112),"bad size");
		static_assert((offsetof(AeroMap,referenceArea)==0x0),"bad off");
		static_assert((offsetof(AeroMap,CD)==0x4),"bad off");
		static_assert((offsetof(AeroMap,CL)==0x8),"bad off");
		static_assert((offsetof(AeroMap,frontShare)==0xC),"bad off");
		static_assert((offsetof(AeroMap,CDX)==0x10),"bad off");
		static_assert((offsetof(AeroMap,CDY)==0x14),"bad off");
		static_assert((offsetof(AeroMap,CDA)==0x18),"bad off");
		static_assert((offsetof(AeroMap,carBody)==0x20),"bad off");
		static_assert((offsetof(AeroMap,dynamicCD)==0x28),"bad off");
		static_assert((offsetof(AeroMap,dynamicCL)==0x2C),"bad off");
		static_assert((offsetof(AeroMap,airDensity)==0x30),"bad off");
		static_assert((offsetof(AeroMap,wings)==0x38),"bad off");
		static_assert((offsetof(AeroMap,frontApplicationPoint)==0x50),"bad off");
		static_assert((offsetof(AeroMap,rearApplicationPoint)==0x5C),"bad off");
		static_assert((offsetof(AeroMap,car)==0x68),"bad off");
	};
};

//UDT: class CameraForward @len=1928 @vfcount=11
	//_Base: class CameraShadowMapped @off=0 @len=672
	//_Func: public void CameraForward(const CameraForward &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void CameraForward(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & iname, GraphicsManager * graphics, bool auseBlur); @loc=static @len=1333 @rva=2224688
	//_Func: public void ~CameraForward(); @virtual vtpo=0 vfid=0 @loc=static @len=337 @rva=2226032
	//_Data: this+0x2A0, Member, Type: float, blurQuality
	//_Data: this+0x2A4, Member, Type: float, blurRadialSpeed
	//_Data: this+0x2A8, Member, Type: bool, useRadialBlur
	//_Data: this+0x2A9, Member, Type: bool, chromaticAberrationEnabled
	//_Data: this+0x2AA, Member, Type: bool, lensFlare
	//_Data: this+0x2B0, Member, Type: class CubeMapRenderer, cubeMapRenderer
	//_Data: this+0x690, Member, Type: class CubeMap *, cubeMap
	//_Func: public PostProcess * getPostProcessByShader(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: protected void render(Node * node, float dt); @virtual vtpo=0 vfid=1 @loc=static @len=3 @rva=96368
	//_Func: public void render(Node * blurred, Node * unblurred, Node * shadow, float dt); @intro @virtual vtpo=0 vfid=7 @loc=static @len=405 @rva=2227264
	//_Func: public void resetHDR(); @intro @virtual vtpo=0 vfid=8 @loc=static @len=17 @rva=2228560
	//_Func: public void setHighPassThreshold(float t); @loc=static @len=18 @rva=2228784
	//_Func: public void setBloomLevel(float bl); @loc=static @len=18 @rva=2228624
	//_Func: public void setBloomBaseLevel(float bl); @loc=static @len=18 @rva=2228592
	//_Func: public float getBloomLevel(); @loc=optimized @len=0 @rva=0
	//_Func: public float getBloomBaseLevel(); @loc=optimized @len=0 @rva=0
	//_Func: public float getHighPassThreshold(); @loc=optimized @len=0 @rva=0
	//_Func: public void setCubemapSize(unsigned int size); @loc=static @len=119 @rva=2228656
	//_Func: public void setTripleScreenEnabled(bool  _arg0); @loc=optimized @len=0 @rva=0
	//_Data: this+0x698, Member, Type: bool, tripleScreenAvailable
	//_Data: this+0x6A0, Member, Type: class PostProcess *, postProcessChain
	//_Data: this+0x6A8, Member, Type: class RenderTarget *[0x2], postTempTargets
	//_Data: this+0x6B8, Member, Type: class RenderTarget *, rtBlur
	//_Data: this+0x6C0, Member, Type: int, postRenderTargetIndex
	//_Data: this+0x6C8, Member, Type: class std::vector<PostProcess *,std::allocator<PostProcess *> >, postProcesses
	//_Data: this+0x6E0, Member, Type: class HDR *, hdr
	//_Data: this+0x6E8, Member, Type: bool, useBlur
	//_Data: this+0x6F0, Member, Type: class Shader *, blurShader
	//_Data: this+0x6F8, Member, Type: class Shader *, blurShaderRadial
	//_Data: this+0x700, Member, Type: class ShaderVariable *, svRadialSpeed
	//_Data: this+0x708, Member, Type: class ShaderVariable *, svProjInv
	//_Data: this+0x710, Member, Type: class ShaderVariable *, svProj
	//_Data: this+0x718, Member, Type: class ShaderVariable *, svCameraVelocity
	//_Data: this+0x720, Member, Type: class ShaderVariable *, svCameraAngularVelocity
	//_Data: this+0x728, Member, Type: class ShaderVariable *, svQuality
	//_Data: this+0x730, Member, Type: class ShaderVariable *, svFpsCorrection
	//_Data: this+0x738, Member, Type: class mat44f, lastWorldMatrix
	//_Data: this+0x778, Member, Type: class PostProcessFXAA *, ppFXAA
	//_Data: this+0x780, Member, Type: float, currentBlurAngle
	//_Func: protected void renderBlurred(Node * blurred, Node * unblurred, Node * transparent, float dt); @loc=static @len=879 @rva=2227680
	//_Func: protected void initPostProcessChain(); @loc=optimized @len=0 @rva=0
	//_Func: protected void preparePostRenderTargets(); @loc=static @len=193 @rva=2226880
	//_Func: protected void renderPost(PostProcess *  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: protected void buildPostProcessChain(); @loc=optimized @len=0 @rva=0
	//_Func: protected void onResize(const OnWindowResize & message); @intro @virtual vtpo=0 vfid=9 @loc=static @len=301 @rva=2226576
	//_Func: protected void renderBlurTripleScreen(int  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: protected void setSolveBlurRenderTarget(); @intro @virtual vtpo=0 vfid=10 @loc=static @len=42 @rva=2228816
	//_Func: protected void solveBlur(float dt); @loc=static @len=2298 @rva=2228864
	//_Func: public CameraForward & operator=(const CameraForward &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class CameraForward : public CameraShadowMapped {
public:
	float blurQuality;
	float blurRadialSpeed;
	bool useRadialBlur;
	bool chromaticAberrationEnabled;
	bool lensFlare;
	CubeMapRenderer cubeMapRenderer;
	CubeMap * cubeMap;
	bool tripleScreenAvailable;
	PostProcess * postProcessChain;
	RenderTarget * postTempTargets[2];
	RenderTarget * rtBlur;
	int postRenderTargetIndex;
	std::vector<PostProcess *,std::allocator<PostProcess *> > postProcesses;
	HDR * hdr;
	bool useBlur;
	Shader * blurShader;
	Shader * blurShaderRadial;
	ShaderVariable * svRadialSpeed;
	ShaderVariable * svProjInv;
	ShaderVariable * svProj;
	ShaderVariable * svCameraVelocity;
	ShaderVariable * svCameraAngularVelocity;
	ShaderVariable * svQuality;
	ShaderVariable * svFpsCorrection;
	mat44f lastWorldMatrix;
	PostProcessFXAA * ppFXAA;
	float currentBlurAngle;
	inline CameraForward() { }
	inline CameraForward(const CameraForward& other) = default;
	inline CameraForward& operator=(const CameraForward& other) = default;
	inline void ctor(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & iname, GraphicsManager * graphics, bool auseBlur) { typedef void (CameraForward::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, GraphicsManager *, bool); auto _f=xcast<_fpt>(_drva(2224688)); (this->*_f)(iname, graphics, auseBlur); }
	virtual ~CameraForward();
	inline void dtor() { typedef void (CameraForward::*_fpt)(); auto _f=xcast<_fpt>(_drva(2226032)); (this->*_f)(); }
	virtual void render_vf1(Node * node, float dt);
	inline void render_impl(Node * node, float dt) { typedef void (CameraForward::*_fpt)(Node *, float); auto _f=xcast<_fpt>(_drva(96368)); return (this->*_f)(node, dt); }
	inline void render(Node * node, float dt) { typedef void (CameraForward::*_fpt)(Node *, float); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(node, dt); }
	virtual void render_vf7(Node * blurred, Node * unblurred, Node * shadow, float dt);
	inline void render_impl(Node * blurred, Node * unblurred, Node * shadow, float dt) { typedef void (CameraForward::*_fpt)(Node *, Node *, Node *, float); auto _f=xcast<_fpt>(_drva(2227264)); return (this->*_f)(blurred, unblurred, shadow, dt); }
	inline void render(Node * blurred, Node * unblurred, Node * shadow, float dt) { typedef void (CameraForward::*_fpt)(Node *, Node *, Node *, float); auto _f=xcast<_fpt>(get_vfp(this, 7)); return (this->*_f)(blurred, unblurred, shadow, dt); }
	virtual void resetHDR_vf8();
	inline void resetHDR_impl() { typedef void (CameraForward::*_fpt)(); auto _f=xcast<_fpt>(_drva(2228560)); return (this->*_f)(); }
	inline void resetHDR() { typedef void (CameraForward::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 8)); return (this->*_f)(); }
	inline void setHighPassThreshold(float t) { typedef void (CameraForward::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2228784)); return (this->*_f)(t); }
	inline void setBloomLevel(float bl) { typedef void (CameraForward::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2228624)); return (this->*_f)(bl); }
	inline void setBloomBaseLevel(float bl) { typedef void (CameraForward::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2228592)); return (this->*_f)(bl); }
	inline void setCubemapSize(unsigned int size) { typedef void (CameraForward::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(2228656)); return (this->*_f)(size); }
	inline void renderBlurred(Node * blurred, Node * unblurred, Node * transparent, float dt) { typedef void (CameraForward::*_fpt)(Node *, Node *, Node *, float); auto _f=xcast<_fpt>(_drva(2227680)); return (this->*_f)(blurred, unblurred, transparent, dt); }
	inline void preparePostRenderTargets() { typedef void (CameraForward::*_fpt)(); auto _f=xcast<_fpt>(_drva(2226880)); return (this->*_f)(); }
	virtual void onResize_vf9(const OnWindowResize & message);
	inline void onResize_impl(const OnWindowResize & message) { typedef void (CameraForward::*_fpt)(const OnWindowResize &); auto _f=xcast<_fpt>(_drva(2226576)); return (this->*_f)(message); }
	inline void onResize(const OnWindowResize & message) { typedef void (CameraForward::*_fpt)(const OnWindowResize &); auto _f=xcast<_fpt>(get_vfp(this, 9)); return (this->*_f)(message); }
	virtual void setSolveBlurRenderTarget_vf10();
	inline void setSolveBlurRenderTarget_impl() { typedef void (CameraForward::*_fpt)(); auto _f=xcast<_fpt>(_drva(2228816)); return (this->*_f)(); }
	inline void setSolveBlurRenderTarget() { typedef void (CameraForward::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 10)); return (this->*_f)(); }
	inline void solveBlur(float dt) { typedef void (CameraForward::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2228864)); return (this->*_f)(dt); }
	inline void _guard_obj() {
		static_assert((sizeof(CameraForward)==1928),"bad size");
		static_assert((offsetof(CameraForward,blurQuality)==0x2A0),"bad off");
		static_assert((offsetof(CameraForward,blurRadialSpeed)==0x2A4),"bad off");
		static_assert((offsetof(CameraForward,useRadialBlur)==0x2A8),"bad off");
		static_assert((offsetof(CameraForward,chromaticAberrationEnabled)==0x2A9),"bad off");
		static_assert((offsetof(CameraForward,lensFlare)==0x2AA),"bad off");
		static_assert((offsetof(CameraForward,cubeMapRenderer)==0x2B0),"bad off");
		static_assert((offsetof(CameraForward,cubeMap)==0x690),"bad off");
		static_assert((offsetof(CameraForward,tripleScreenAvailable)==0x698),"bad off");
		static_assert((offsetof(CameraForward,postProcessChain)==0x6A0),"bad off");
		static_assert((offsetof(CameraForward,postTempTargets)==0x6A8),"bad off");
		static_assert((offsetof(CameraForward,rtBlur)==0x6B8),"bad off");
		static_assert((offsetof(CameraForward,postRenderTargetIndex)==0x6C0),"bad off");
		static_assert((offsetof(CameraForward,postProcesses)==0x6C8),"bad off");
		static_assert((offsetof(CameraForward,hdr)==0x6E0),"bad off");
		static_assert((offsetof(CameraForward,useBlur)==0x6E8),"bad off");
		static_assert((offsetof(CameraForward,blurShader)==0x6F0),"bad off");
		static_assert((offsetof(CameraForward,blurShaderRadial)==0x6F8),"bad off");
		static_assert((offsetof(CameraForward,svRadialSpeed)==0x700),"bad off");
		static_assert((offsetof(CameraForward,svProjInv)==0x708),"bad off");
		static_assert((offsetof(CameraForward,svProj)==0x710),"bad off");
		static_assert((offsetof(CameraForward,svCameraVelocity)==0x718),"bad off");
		static_assert((offsetof(CameraForward,svCameraAngularVelocity)==0x720),"bad off");
		static_assert((offsetof(CameraForward,svQuality)==0x728),"bad off");
		static_assert((offsetof(CameraForward,svFpsCorrection)==0x730),"bad off");
		static_assert((offsetof(CameraForward,lastWorldMatrix)==0x738),"bad off");
		static_assert((offsetof(CameraForward,ppFXAA)==0x778),"bad off");
		static_assert((offsetof(CameraForward,currentBlurAngle)==0x780),"bad off");
	};
};

//UDT: struct Drivetrain @len=1608
	//_Func: public void ~Drivetrain(); @loc=static @len=195 @rva=2514976
	//_Data: this+0x0, Member, Type: bool, isGearGrinding
	//_Data: this+0x4, Member, Type: float, finalRatio
	//_Data: this+0x8, Member, Type: struct GearElement, engine
	//_Data: this+0x20, Member, Type: struct GearElement, drive
	//_Data: this+0x38, Member, Type: struct GearElement, outShaftL
	//_Data: this+0x50, Member, Type: struct GearElement, outShaftR
	//_Data: this+0x68, Member, Type: struct GearElement, outShaftLF
	//_Data: this+0x80, Member, Type: struct GearElement, outShaftRF
	//_Data: this+0x98, Member, Type: class std::vector<SGearRatio,std::allocator<SGearRatio> >, gears
	//_Data: this+0xB0, Member, Type: double, rootVelocity
	//_Data: this+0xB8, Member, Type: bool, clutchOpenState
	//_Data: this+0xC0, Member, Type: double, ratio
	//_Data: this+0xC8, Member, Type: float, diffPowerRamp
	//_Data: this+0xCC, Member, Type: float, diffCoastRamp
	//_Data: this+0xD0, Member, Type: float, diffPreLoad
	//_Data: this+0xD4, Member, Type: enum DifferentialType, diffType
	//_Data: this+0xD8, Member, Type: double, cutOff
	//_Data: this+0xE0, Member, Type: struct Engine, acEngine
	//_Data: this+0x4C8, Member, Type: bool, isShifterSupported
	//_Data: this+0x4D0, Member, Type: double, clutchMaxTorque
	//_Data: this+0x4D8, Member, Type: float, totalTorque
	//_Data: this+0x4DC, Member, Type: float, awdFrontShare
	//_Data: this+0x4E0, Member, Type: struct DifferentialSetting, awdFrontDiff
	//_Data: this+0x4F0, Member, Type: struct DifferentialSetting, awdRearDiff
	//_Data: this+0x500, Member, Type: struct DifferentialSetting, awdCenterDiff
	//_Data: this+0x510, Member, Type: struct DownshiftProtection, downshiftProtection
	//_Data: this+0x520, Member, Type: struct AWD2Data, awd2
	//_Data: this+0x538, Member, Type: float, currentClutchTorque
	//_Data: this+0x540, Member, Type: class std::function<void __cdecl(void)>, downshiftProtectionFunction
	//_Data: this+0x560, Member, Type: class Event<OnGearRequestEvent>, evOnGearRequest
	//_Func: public void init(Car * car); @loc=static @len=682 @rva=2518464
	//_Func: public void reset(); @loc=static @len=81 @rva=2527872
	//_Func: public void addGear(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, double ratio); @loc=static @len=237 @rva=2516336
	//_Func: public void step(float dt); @loc=static @len=201 @rva=2535728
	//_Func: public bool hasDynamicControllers(); @loc=static @len=46 @rva=2518416
	//_Func: public SGearRatio getCurrentGear(); @loc=static @len=88 @rva=2517776
	//_Func: public void setCurrentGear(int index, bool force); @loc=static @len=400 @rva=2527968
	//_Func: public bool gearUp(); @loc=static @len=288 @rva=2517488
	//_Func: public bool gearDown(); @loc=static @len=905 @rva=2516576
	//_Func: public int getCurrentGearIndex(); @loc=optimized @len=0 @rva=0
	//_Func: public bool isChangingGear(); @loc=static @len=12 @rva=2519984
	//_Func: public TractionType getTractionType(); @loc=static @len=7 @rva=2608000
	//_Func: public float getEngineRPM(); @loc=static @len=26 @rva=2517888
	//_Func: public float getDrivetrainSpeed(); @loc=static @len=10 @rva=2517872
	//_Func: public void setGearRatio(int index, float value); @loc=static @len=104 @rva=2528368
	//_Func: public bool hasAutoCutoff(); @loc=optimized @len=0 @rva=0
	//_Func: public void forceAutoCutoffTime(double value); @loc=static @len=9 @rva=864032
	//_Func: public void addWheelTorqueGenerator(ITorqueGenerator *  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public float getRpmWindowStatus(); @loc=static @len=21 @rva=2518384
	//_Func: public double getGearUpTime(); @loc=optimized @len=0 @rva=0
	//_Func: public double getGearDnTime(); @loc=static @len=9 @rva=2741824
	//_Func: public float projectRPMAtDownshift(); @loc=static @len=112 @rva=2526944
	//_Data: this+0x578, Member, Type: class Car *, car
	//_Data: this+0x580, Member, Type: enum TractionType, tractionType
	//_Data: this+0x584, Member, Type: int, currentGear
	//_Data: this+0x588, Member, Type: double, lastRatio
	//_Data: this+0x590, Member, Type: struct Tyre *, tyreLeft
	//_Data: this+0x598, Member, Type: struct Tyre *, tyreRight
	//_Data: this+0x5A0, Member, Type: struct GearRequestStatus, gearRequest
	//_Data: this+0x5C0, Member, Type: double, gearUpTime
	//_Data: this+0x5C8, Member, Type: double, gearDnTime
	//_Data: this+0x5D0, Member, Type: double, autoCutOffTime
	//_Data: this+0x5D8, Member, Type: double, validShiftRPMWindow
	//_Data: this+0x5E0, Member, Type: double, controlsWindowGain
	//_Data: this+0x5E8, Member, Type: class std::vector<ITorqueGenerator *,std::allocator<ITorqueGenerator *> >, wheelTorqueGenerators
	//_Data: this+0x600, Member, Type: double, damageRpmWindow
	//_Data: this+0x608, Member, Type: double, orgRpmWindow
	//_Data: this+0x610, Member, Type: int[0x4], lockCounter
	//_Data: this+0x620, Member, Type: struct DrivetrainControllers, controllers
	//_Data: this+0x640, Member, Type: float, clutchInertia
	//_Data: this+0x644, Member, Type: float, locClutch
	//_Func: protected double getInertiaFromEngine(); @loc=static @len=119 @rva=2517920
	//_Func: protected double getInertiaFromWheels(); @loc=static @len=328 @rva=2518048
	//_Func: protected void updateElementsStatus(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: protected void stepEngine(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: protected void reallignSpeeds(float dt); @loc=static @len=333 @rva=2527488
	//_Func: protected void stepClutch(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: protected void stepGearRequests(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: protected void loadINI(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & dataPath); @loc=static @len=6813 @rva=2520128
	//_Func: protected bool isGearboxLocked(); @loc=static @len=125 @rva=2520000
	//_Func: protected void accelerateDrivetrainBlock(double acc, bool fromEngine); @loc=static @len=174 @rva=2516160
	//_Func: protected void accelerateFromWheels(double  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: protected void setDrivenTyres(Tyre *  _arg0, Tyre *  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: protected void step2WD(float dt); @loc=static @len=3381 @rva=2528480
	//_Func: protected void step4WD(float dt); @loc=static @len=2907 @rva=2531872
	//_Func: protected void step4WD_new(float dt); @loc=static @len=930 @rva=2534784
	//_Func: protected void initControllers(); @loc=static @len=827 @rva=2519152
	//_Func: protected void stepControllers(float dt); @loc=static @len=239 @rva=2535936
	//_Func: protected double getClutchTorque(); @loc=optimized @len=0 @rva=0
	//_Func: public void Drivetrain(const Drivetrain &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void Drivetrain(); @loc=static @len=505 @rva=2545776
	//_Func: public Drivetrain & operator=(const Drivetrain &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

struct Drivetrain {
public:
	bool isGearGrinding;
	float finalRatio;
	GearElement engine;
	GearElement drive;
	GearElement outShaftL;
	GearElement outShaftR;
	GearElement outShaftLF;
	GearElement outShaftRF;
	std::vector<SGearRatio,std::allocator<SGearRatio> > gears;
	double rootVelocity;
	bool clutchOpenState;
	double ratio;
	float diffPowerRamp;
	float diffCoastRamp;
	float diffPreLoad;
	DifferentialType diffType;
	double cutOff;
	Engine acEngine;
	bool isShifterSupported;
	double clutchMaxTorque;
	float totalTorque;
	float awdFrontShare;
	DifferentialSetting awdFrontDiff;
	DifferentialSetting awdRearDiff;
	DifferentialSetting awdCenterDiff;
	DownshiftProtection downshiftProtection;
	AWD2Data awd2;
	float currentClutchTorque;
	std::function<void __cdecl(void)> downshiftProtectionFunction;
	Event<OnGearRequestEvent> evOnGearRequest;
	Car * car;
	TractionType tractionType;
	int currentGear;
	double lastRatio;
	Tyre * tyreLeft;
	Tyre * tyreRight;
	GearRequestStatus gearRequest;
	double gearUpTime;
	double gearDnTime;
	double autoCutOffTime;
	double validShiftRPMWindow;
	double controlsWindowGain;
	std::vector<ITorqueGenerator *,std::allocator<ITorqueGenerator *> > wheelTorqueGenerators;
	double damageRpmWindow;
	double orgRpmWindow;
	int lockCounter[4];
	DrivetrainControllers controllers;
	float clutchInertia;
	float locClutch;
	inline Drivetrain() { }
	inline Drivetrain(const Drivetrain& other) = default;
	inline Drivetrain& operator=(const Drivetrain& other) = default;
	inline void dtor() { typedef void (Drivetrain::*_fpt)(); auto _f=xcast<_fpt>(_drva(2514976)); (this->*_f)(); }
	inline void init(Car * car) { typedef void (Drivetrain::*_fpt)(Car *); auto _f=xcast<_fpt>(_drva(2518464)); return (this->*_f)(car); }
	inline void reset() { typedef void (Drivetrain::*_fpt)(); auto _f=xcast<_fpt>(_drva(2527872)); return (this->*_f)(); }
	inline void addGear(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name, double ratio) { typedef void (Drivetrain::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *, double); auto _f=xcast<_fpt>(_drva(2516336)); return (this->*_f)(name, ratio); }
	inline void step(float dt) { typedef void (Drivetrain::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2535728)); return (this->*_f)(dt); }
	inline bool hasDynamicControllers() { typedef bool (Drivetrain::*_fpt)(); auto _f=xcast<_fpt>(_drva(2518416)); return (this->*_f)(); }
	inline SGearRatio getCurrentGear() { typedef SGearRatio (Drivetrain::*_fpt)(); auto _f=xcast<_fpt>(_drva(2517776)); return (this->*_f)(); }
	inline void setCurrentGear(int index, bool force) { typedef void (Drivetrain::*_fpt)(int, bool); auto _f=xcast<_fpt>(_drva(2527968)); return (this->*_f)(index, force); }
	inline bool gearUp() { typedef bool (Drivetrain::*_fpt)(); auto _f=xcast<_fpt>(_drva(2517488)); return (this->*_f)(); }
	inline bool gearDown() { typedef bool (Drivetrain::*_fpt)(); auto _f=xcast<_fpt>(_drva(2516576)); return (this->*_f)(); }
	inline bool isChangingGear() { typedef bool (Drivetrain::*_fpt)(); auto _f=xcast<_fpt>(_drva(2519984)); return (this->*_f)(); }
	inline TractionType getTractionType() { typedef TractionType (Drivetrain::*_fpt)(); auto _f=xcast<_fpt>(_drva(2608000)); return (this->*_f)(); }
	inline float getEngineRPM() { typedef float (Drivetrain::*_fpt)(); auto _f=xcast<_fpt>(_drva(2517888)); return (this->*_f)(); }
	inline float getDrivetrainSpeed() { typedef float (Drivetrain::*_fpt)(); auto _f=xcast<_fpt>(_drva(2517872)); return (this->*_f)(); }
	inline void setGearRatio(int index, float value) { typedef void (Drivetrain::*_fpt)(int, float); auto _f=xcast<_fpt>(_drva(2528368)); return (this->*_f)(index, value); }
	inline void forceAutoCutoffTime(double value) { typedef void (Drivetrain::*_fpt)(double); auto _f=xcast<_fpt>(_drva(864032)); return (this->*_f)(value); }
	inline float getRpmWindowStatus() { typedef float (Drivetrain::*_fpt)(); auto _f=xcast<_fpt>(_drva(2518384)); return (this->*_f)(); }
	inline double getGearDnTime() { typedef double (Drivetrain::*_fpt)(); auto _f=xcast<_fpt>(_drva(2741824)); return (this->*_f)(); }
	inline float projectRPMAtDownshift() { typedef float (Drivetrain::*_fpt)(); auto _f=xcast<_fpt>(_drva(2526944)); return (this->*_f)(); }
	inline double getInertiaFromEngine() { typedef double (Drivetrain::*_fpt)(); auto _f=xcast<_fpt>(_drva(2517920)); return (this->*_f)(); }
	inline double getInertiaFromWheels() { typedef double (Drivetrain::*_fpt)(); auto _f=xcast<_fpt>(_drva(2518048)); return (this->*_f)(); }
	inline void reallignSpeeds(float dt) { typedef void (Drivetrain::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2527488)); return (this->*_f)(dt); }
	inline void loadINI(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & dataPath) { typedef void (Drivetrain::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2520128)); return (this->*_f)(dataPath); }
	inline bool isGearboxLocked() { typedef bool (Drivetrain::*_fpt)(); auto _f=xcast<_fpt>(_drva(2520000)); return (this->*_f)(); }
	inline void accelerateDrivetrainBlock(double acc, bool fromEngine) { typedef void (Drivetrain::*_fpt)(double, bool); auto _f=xcast<_fpt>(_drva(2516160)); return (this->*_f)(acc, fromEngine); }
	inline void step2WD(float dt) { typedef void (Drivetrain::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2528480)); return (this->*_f)(dt); }
	inline void step4WD(float dt) { typedef void (Drivetrain::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2531872)); return (this->*_f)(dt); }
	inline void step4WD_new(float dt) { typedef void (Drivetrain::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2534784)); return (this->*_f)(dt); }
	inline void initControllers() { typedef void (Drivetrain::*_fpt)(); auto _f=xcast<_fpt>(_drva(2519152)); return (this->*_f)(); }
	inline void stepControllers(float dt) { typedef void (Drivetrain::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2535936)); return (this->*_f)(dt); }
	inline void ctor() { typedef void (Drivetrain::*_fpt)(); auto _f=xcast<_fpt>(_drva(2545776)); (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(Drivetrain)==1608),"bad size");
		static_assert((offsetof(Drivetrain,isGearGrinding)==0x0),"bad off");
		static_assert((offsetof(Drivetrain,finalRatio)==0x4),"bad off");
		static_assert((offsetof(Drivetrain,engine)==0x8),"bad off");
		static_assert((offsetof(Drivetrain,drive)==0x20),"bad off");
		static_assert((offsetof(Drivetrain,outShaftL)==0x38),"bad off");
		static_assert((offsetof(Drivetrain,outShaftR)==0x50),"bad off");
		static_assert((offsetof(Drivetrain,outShaftLF)==0x68),"bad off");
		static_assert((offsetof(Drivetrain,outShaftRF)==0x80),"bad off");
		static_assert((offsetof(Drivetrain,gears)==0x98),"bad off");
		static_assert((offsetof(Drivetrain,rootVelocity)==0xB0),"bad off");
		static_assert((offsetof(Drivetrain,clutchOpenState)==0xB8),"bad off");
		static_assert((offsetof(Drivetrain,ratio)==0xC0),"bad off");
		static_assert((offsetof(Drivetrain,diffPowerRamp)==0xC8),"bad off");
		static_assert((offsetof(Drivetrain,diffCoastRamp)==0xCC),"bad off");
		static_assert((offsetof(Drivetrain,diffPreLoad)==0xD0),"bad off");
		static_assert((offsetof(Drivetrain,diffType)==0xD4),"bad off");
		static_assert((offsetof(Drivetrain,cutOff)==0xD8),"bad off");
		static_assert((offsetof(Drivetrain,acEngine)==0xE0),"bad off");
		static_assert((offsetof(Drivetrain,isShifterSupported)==0x4C8),"bad off");
		static_assert((offsetof(Drivetrain,clutchMaxTorque)==0x4D0),"bad off");
		static_assert((offsetof(Drivetrain,totalTorque)==0x4D8),"bad off");
		static_assert((offsetof(Drivetrain,awdFrontShare)==0x4DC),"bad off");
		static_assert((offsetof(Drivetrain,awdFrontDiff)==0x4E0),"bad off");
		static_assert((offsetof(Drivetrain,awdRearDiff)==0x4F0),"bad off");
		static_assert((offsetof(Drivetrain,awdCenterDiff)==0x500),"bad off");
		static_assert((offsetof(Drivetrain,downshiftProtection)==0x510),"bad off");
		static_assert((offsetof(Drivetrain,awd2)==0x520),"bad off");
		static_assert((offsetof(Drivetrain,currentClutchTorque)==0x538),"bad off");
		static_assert((offsetof(Drivetrain,downshiftProtectionFunction)==0x540),"bad off");
		static_assert((offsetof(Drivetrain,evOnGearRequest)==0x560),"bad off");
		static_assert((offsetof(Drivetrain,car)==0x578),"bad off");
		static_assert((offsetof(Drivetrain,tractionType)==0x580),"bad off");
		static_assert((offsetof(Drivetrain,currentGear)==0x584),"bad off");
		static_assert((offsetof(Drivetrain,lastRatio)==0x588),"bad off");
		static_assert((offsetof(Drivetrain,tyreLeft)==0x590),"bad off");
		static_assert((offsetof(Drivetrain,tyreRight)==0x598),"bad off");
		static_assert((offsetof(Drivetrain,gearRequest)==0x5A0),"bad off");
		static_assert((offsetof(Drivetrain,gearUpTime)==0x5C0),"bad off");
		static_assert((offsetof(Drivetrain,gearDnTime)==0x5C8),"bad off");
		static_assert((offsetof(Drivetrain,autoCutOffTime)==0x5D0),"bad off");
		static_assert((offsetof(Drivetrain,validShiftRPMWindow)==0x5D8),"bad off");
		static_assert((offsetof(Drivetrain,controlsWindowGain)==0x5E0),"bad off");
		static_assert((offsetof(Drivetrain,wheelTorqueGenerators)==0x5E8),"bad off");
		static_assert((offsetof(Drivetrain,damageRpmWindow)==0x600),"bad off");
		static_assert((offsetof(Drivetrain,orgRpmWindow)==0x608),"bad off");
		static_assert((offsetof(Drivetrain,lockCounter)==0x610),"bad off");
		static_assert((offsetof(Drivetrain,controllers)==0x620),"bad off");
		static_assert((offsetof(Drivetrain,clutchInertia)==0x640),"bad off");
		static_assert((offsetof(Drivetrain,locClutch)==0x644),"bad off");
	};
};

//UDT: class PhysicsDriveThread @len=184
	//_Func: public void PhysicsDriveThread(const PhysicsDriveThread &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void PhysicsDriveThread(PhysicsEngine & aphysicsEngine, Game & agame); @loc=static @len=1339 @rva=1190496
	//_Func: public void ~PhysicsDriveThread(); @loc=static @len=66 @rva=1191856
	//_Data: this+0x0, Member, Type: bool, hasStarted
	//_Data: this+0x4, Member, Type: struct std::atomic<unsigned int>, physicsLateLoops
	//_Data: this+0x8, Member, Type: struct std::atomic<int>, occupancy
	//_Data: this+0xC, Member, Type: struct std::atomic<float>, cpuTimeAtomic
	//_Data: this+0x10, Member, Type: class Event<double>, evPhysicsStepCompleted
	//_Data: this+0x28, Member, Type: double, timeScale
	//_Data: this+0x30, Member, Type: bool, useDirectInput
	//_Func: public void start(); @loc=static @len=217 @rva=1193088
	//_Func: public void pause(); @loc=static @len=5 @rva=1192256
	//_Func: public void stop(); @loc=static @len=91 @rva=1194016
	//_Data: this+0x34, Member, Type: float, cpuTimeLocal
	//_Data: this+0x38, Member, Type: bool, shuttingDown
	//_Data: this+0x40, Member, Type: double, currentTime
	//_Data: this+0x48, Member, Type: double, startTime
	//_Data: this+0x50, Member, Type: class PhysicsEngine &, engine
	//_Func: private void run(); @loc=static @len=807 @rva=1192272
	//_Data: this+0x58, Member, Type: bool, isPaused
	//_Data: this+0x60, Member, Type: class TimerProcess *, tProcess
	//_Func: private void step(); @loc=static @len=703 @rva=1193312
	//_Data: this+0x68, Member, Type: class std::thread, thread
	//_Data: this+0x78, Member, Type: bool, useTimerProcess
	//_Data: this+0x79, Member, Type: bool, setAffinityMask
	//_Data: this+0x7A, Member, Type: bool, isPhysicsInitialized
	//_Data: this+0x80, Member, Type: double, lastStepTimestamp
	//_Data: this+0x88, Member, Type: class DirectInput *, directInput
	//_Data: this+0x90, Member, Type: class DICommandManager, diCommandManager
	//_Func: public PhysicsDriveThread & operator=(const PhysicsDriveThread &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class PhysicsDriveThread {
public:
	bool hasStarted;
	std::atomic<unsigned int> physicsLateLoops;
	std::atomic<int> occupancy;
	std::atomic<float> cpuTimeAtomic;
	Event<double> evPhysicsStepCompleted;
	double timeScale;
	bool useDirectInput;
	float cpuTimeLocal;
	bool shuttingDown;
	double currentTime;
	double startTime;
	PhysicsEngine & engine;
	bool isPaused;
	TimerProcess * tProcess;
	std::thread thread;
	bool useTimerProcess;
	bool setAffinityMask;
	bool isPhysicsInitialized;
	double lastStepTimestamp;
	DirectInput * directInput;
	DICommandManager diCommandManager;
	inline PhysicsDriveThread() : engine(*((PhysicsEngine*)NULL)) { }
	inline PhysicsDriveThread(const PhysicsDriveThread& other) = default;
	inline PhysicsDriveThread& operator=(const PhysicsDriveThread& other) = default;
	inline void ctor(PhysicsEngine & aphysicsEngine, Game & agame) { typedef void (PhysicsDriveThread::*_fpt)(PhysicsEngine &, Game &); auto _f=xcast<_fpt>(_drva(1190496)); (this->*_f)(aphysicsEngine, agame); }
	inline void dtor() { typedef void (PhysicsDriveThread::*_fpt)(); auto _f=xcast<_fpt>(_drva(1191856)); (this->*_f)(); }
	inline void start() { typedef void (PhysicsDriveThread::*_fpt)(); auto _f=xcast<_fpt>(_drva(1193088)); return (this->*_f)(); }
	inline void pause() { typedef void (PhysicsDriveThread::*_fpt)(); auto _f=xcast<_fpt>(_drva(1192256)); return (this->*_f)(); }
	inline void stop() { typedef void (PhysicsDriveThread::*_fpt)(); auto _f=xcast<_fpt>(_drva(1194016)); return (this->*_f)(); }
	inline void run() { typedef void (PhysicsDriveThread::*_fpt)(); auto _f=xcast<_fpt>(_drva(1192272)); return (this->*_f)(); }
	inline void step() { typedef void (PhysicsDriveThread::*_fpt)(); auto _f=xcast<_fpt>(_drva(1193312)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(PhysicsDriveThread)==184),"bad size");
		static_assert((offsetof(PhysicsDriveThread,hasStarted)==0x0),"bad off");
		static_assert((offsetof(PhysicsDriveThread,physicsLateLoops)==0x4),"bad off");
		static_assert((offsetof(PhysicsDriveThread,occupancy)==0x8),"bad off");
		static_assert((offsetof(PhysicsDriveThread,cpuTimeAtomic)==0xC),"bad off");
		static_assert((offsetof(PhysicsDriveThread,evPhysicsStepCompleted)==0x10),"bad off");
		static_assert((offsetof(PhysicsDriveThread,timeScale)==0x28),"bad off");
		static_assert((offsetof(PhysicsDriveThread,useDirectInput)==0x30),"bad off");
		static_assert((offsetof(PhysicsDriveThread,cpuTimeLocal)==0x34),"bad off");
		static_assert((offsetof(PhysicsDriveThread,shuttingDown)==0x38),"bad off");
		static_assert((offsetof(PhysicsDriveThread,currentTime)==0x40),"bad off");
		static_assert((offsetof(PhysicsDriveThread,startTime)==0x48),"bad off");
		static_assert((offsetof(PhysicsDriveThread,isPaused)==0x58),"bad off");
		static_assert((offsetof(PhysicsDriveThread,tProcess)==0x60),"bad off");
		static_assert((offsetof(PhysicsDriveThread,thread)==0x68),"bad off");
		static_assert((offsetof(PhysicsDriveThread,useTimerProcess)==0x78),"bad off");
		static_assert((offsetof(PhysicsDriveThread,setAffinityMask)==0x79),"bad off");
		static_assert((offsetof(PhysicsDriveThread,isPhysicsInitialized)==0x7A),"bad off");
		static_assert((offsetof(PhysicsDriveThread,lastStepTimestamp)==0x80),"bad off");
		static_assert((offsetof(PhysicsDriveThread,directInput)==0x88),"bad off");
		static_assert((offsetof(PhysicsDriveThread,diCommandManager)==0x90),"bad off");
	};
};

//UDT: class Car @len=16032 @vfcount=1
	//_VTable: 
	//_Func: public void Car(const Car &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void Car(PhysicsEngine * iengine, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & iunixName, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & config); @loc=static @len=6315 @rva=2539264
	//_Func: public void ~Car(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=1894 @rva=2547920
	//_Data: this+0x8, Member, Type: float, finalSteerAngleSignal
	//_Data: this+0xC, Member, Type: float, powerClassIndex
	//_Data: this+0x10, Member, Type: class Event<OnStepCompleteEvent>, evOnStepComplete
	//_Data: this+0x28, Member, Type: class Event<OnControlsProviderChanged>, evOnControlsProviderChanged
	//_Data: this+0x40, Member, Type: class Event<OnLapCompletedEvent>, evOnLapCompleted
	//_Data: this+0x58, Member, Type: class Event<OnSectorSplitEvent>, evOnSectorSplit
	//_Data: this+0x70, Member, Type: class Event<vec3f>, evOnForcedPositionCompleted
	//_Data: this+0x88, Member, Type: class Event<std::pair<int,int> >, evOnTyreCompoundChanged
	//_Data: this+0xA0, Member, Type: class Event<OnCollisionEvent>, evOnCollisionEvent
	//_Data: this+0xB8, Member, Type: class Event<double>, evOnJumpStartEvent
	//_Data: this+0xD0, Member, Type: class Event<std::pair<int,int> >, evOnPush2Pass
	//_Data: this+0xE8, Member, Type: float, carHalfWidth
	//_Data: this+0xEC, Member, Type: float, userFFGain
	//_Data: this+0xF0, Member, Type: bool, isRetired
	//_Data: this+0xF8, Member, Type: class std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, tyreCompounds
	//_Data: this+0x110, Member, Type: void *, tag
	//_Data: this+0x118, Member, Type: class IRigidBody *, body
	//_Data: this+0x120, Member, Type: class IRigidBody *, fuelTankBody
	//_Data: this+0x128, Member, Type: class IRigidBody *, rigidAxle
	//_Data: this+0x130, Member, Type: class IJoint *, fuelTankJoint
	//_Data: this+0x138, Member, Type: class PhysicsEngine *, ksPhysics
	//_Data: this+0x140, Member, Type: class CarControls, controls
	//_Data: this+0x174, Member, Type: float, steerLock
	//_Data: this+0x178, Member, Type: float, steerRatio
	//_Data: this+0x17C, Member, Type: float, steerLinearRatio
	//_Data: this+0x180, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, unixName
	//_Data: this+0x1A0, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, configName
	//_Data: this+0x1C0, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, carDataPath
	//_Data: this+0x1E0, Member, Type: float, mass
	//_Data: this+0x1E4, Member, Type: float, ffMult
	//_Data: this+0x1E8, Member, Type: class vec3f, accG
	//_Data: this+0x1F8, Member, Type: struct TimeTransponder, transponder
	//_Data: this+0x290, Member, Type: struct CarColliderManager, colliderManager
	//_Data: this+0x310, Member, Type: struct Drivetrain, drivetrain
	//_Data: this+0x958, Member, Type: struct ABS, abs
	//_Data: this+0xA00, Member, Type: struct TractionControl, tractionControl
	//_Data: this+0xAA8, Member, Type: struct SpeedLimiter, speedLimiter
	//_Data: this+0xAB8, Member, Type: struct AeroMap, aeroMap
	//_Data: this+0xB28, Member, Type: struct Tyre[0x4], tyres
	//_Data: this+0x2C88, Member, Type: class std::vector<ISuspension *,std::allocator<ISuspension *> >, suspensions
	//_Data: this+0x2CA0, Member, Type: struct BrakeSystem, brakeSystem
	//_Data: this+0x3090, Member, Type: struct Autoclutch, autoClutch
	//_Data: this+0x3238, Member, Type: unsigned int, physicsGUID
	//_Data: this+0x3240, Member, Type: struct Telemetry, telemetry
	//_Data: this+0x3340, Member, Type: struct AutoBlip, autoBlip
	//_Data: this+0x33E8, Member, Type: struct AutoShifter, autoShift
	//_Data: this+0x3410, Member, Type: struct GearChanger, gearChanger
	//_Data: this+0x3428, Member, Type: struct EDL, edl
	//_Data: this+0x3460, Member, Type: struct AntirollBar[0x2], antirollBars
	//_Data: this+0x34F0, Member, Type: struct StabilityControl, stabilityControl
	//_Data: this+0x3508, Member, Type: double, lastCollisionTime
	//_Data: this+0x3510, Member, Type: struct DriftModeComponent, driftMode
	//_Data: this+0x3560, Member, Type: struct PerformanceMeter, performanceMeter
	//_Data: this+0x35D0, Member, Type: struct SetupManager, setupManager
	//_Data: this+0x3620, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, screenName
	//_Data: this+0x3640, Member, Type: struct DRS, drs
	//_Data: this+0x3670, Member, Type: class Kers, kers
	//_Data: this+0x3768, Member, Type: class ERS, ers
	//_Data: this+0x3A18, Member, Type: struct LapInvalidator, lapInvalidator
	//_Data: this+0x3A38, Member, Type: struct PenaltyManager, penaltyManager
	//_Data: this+0x3A80, Member, Type: bool, isGearboxLocked
	//_Data: this+0x3A81, Member, Type: bool, isGentleStopping
	//_Data: this+0x3A88, Member, Type: double, penaltyPerfTarget
	//_Data: this+0x3A90, Member, Type: class mat44f, pitPosition
	//_Data: this+0x3AD0, Member, Type: struct SplineLocatorData, splineLocatorData
	//_Data: this+0x3AF8, Member, Type: struct FuelLapEvaluator, fuelLapEvaluator
	//_Data: this+0x3B40, Member, Type: struct HeaveSpring[0x2], heaveSprings
	//_Data: this+0x3BF0, Member, Type: struct SteeringSystem, steeringSystem
	//_Data: this+0x3C30, Member, Type: double, lastCollisionWithCarTime
	//_Data: this+0x3C38, Member, Type: enum SuspensionType, suspensionTypeF
	//_Data: this+0x3C3C, Member, Type: enum SuspensionType, suspensionTypeR
	//_Data: this+0x3C40, Member, Type: float, axleTorqueReaction
	//_Data: this+0x3C44, Member, Type: float, lastGyroFF
	//_Data: this+0x3C48, Member, Type: float, lastFF
	//_Data: this+0x3C4C, Member, Type: float, lastPureMZFF
	//_Data: this+0x3C50, Member, Type: class ThermalObject, water
	//_Data: this+0x3C70, Member, Type: float, steerAssist
	//_Data: this+0x3C74, Member, Type: bool, isRequestingPitStop
	//_Data: this+0x3C78, Member, Type: int, aiLapsToComplete
	//_Data: this+0x3C7C, Member, Type: bool, lightsOn
	//_Data: this+0x3C80, Member, Type: struct CarCollisionBounds, bounds
	//_Data: this+0x3CA8, Member, Type: struct SlipStream, slipStream
	//_Data: this+0x3D10, Member, Type: enum TorqueModeEX, torqueModeEx
	//_Func: public void stepPreCacheValues(float dt); @loc=static @len=290 @rva=2582720
	//_Func: public void setBlackFlag(bool isflagged, PenaltyDescription type); @loc=static @len=120 @rva=2578928
	//_Func: public void setSimplePhysics(bool  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public int setFuelForLaps(int laps, float mult); @loc=static @len=321 @rva=2579296
	//_Func: public float getFuelPerLap(); @loc=static @len=43 @rva=2558928
	//_Func: public float getBackDistanceFromCar(Car * car); @loc=static @len=71 @rva=2556768
	//_Func: public float getForwardDistanceFromCar(Car *  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public bool isInPitLane(); @loc=static @len=74 @rva=2573536
	//_Func: public vec3f getRidePickupPoint(int  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public double getFuel(); @loc=optimized @len=0 @rva=0
	//_Func: public void forceFuel(double  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void setHeadlights(bool  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public double getMaxFuel(); @loc=optimized @len=0 @rva=0
	//_Func: public bool isInPits(); @loc=static @len=147 @rva=2573616
	//_Func: public void setDamageLevel(float v, int index); @loc=static @len=13 @rva=2579280
	//_Func: public void setDamageLevel(float v); @loc=static @len=41 @rva=2579232
	//_Func: public void resetSuspensionDamageLevel(); @loc=static @len=104 @rva=2578800
	//_Func: public void setEngineLifeleft(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void onCollisionCallBack(void * userData0, void * shape0, void * userData1, void * shape1, vec3f normal, vec3f pos, float depth); @loc=static @len=1499 @rva=2573904
	//_Func: public void reset(); @loc=static @len=125 @rva=2578656
	//_Func: public void getTyreThermalState(int index, TyreThermalState * state); @loc=static @len=389 @rva=2566064
	//_Func: public bool isSleeping(); @loc=static @len=16 @rva=2573792
	//_Func: public void step(float dt); @loc=static @len=1836 @rva=2579872
	//_Func: public void postStep(float dt); @loc=static @len=605 @rva=2577456
	//_Func: public void getPhysicsState(CarPhysicsState & state); @loc=static @len=4323 @rva=2559344
	//_Func: public void getAIState(AIState * state); @loc=static @len=275 @rva=2556480
	//_Func: public void setControllerProvider(ICarControlsProvider * cp); @loc=static @len=169 @rva=2579056
	//_Func: public void setExternalControl(bool  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public Speed getSpeed(); @loc=static @len=27 @rva=2564448
	//_Func: public float getCGHeight(); @loc=static @len=102 @rva=2556848
	//_Func: public vec3f getVelocity(); @loc=static @len=31 @rva=2566464
	//_Func: public vec3f getLocalVelocity(); @loc=static @len=34 @rva=2559264
	//_Func: public float getSteerFF(); @loc=static @len=865 @rva=2564480
	//_Func: public vec3f getLocalAngularVelocity(); @loc=static @len=34 @rva=2559216
	//_Func: public ICarControlsProvider * getControlsProvider(); @loc=static @len=8 @rva=2557520
	//_Func: public float getTotalMass(bool withFuel); @loc=static @len=303 @rva=2565488
	//_Func: public mat44f getTyreMatrix(int index); @loc=static @len=258 @rva=2565792
	//_Func: public mat44f getSuspensionMatrix(unsigned int index); @loc=static @len=86 @rva=2565360
	//_Func: public plane4f getGroundPlane(); @loc=optimized @len=0 @rva=0
	//_Func: public void getWingState(std::vector<WingState,std::allocator<WingState> > & ws); @loc=static @len=83 @rva=2566688
	//_Func: public float getDamageLevel(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void forcePosition(const vec3f & pos, bool invalidateTransponder); @loc=static @len=550 @rva=2555408
	//_Func: public void forceRotation(const vec3f & ihed); @loc=static @len=499 @rva=2555968
	//_Func: public float getRequestedFuel(); @loc=optimized @len=0 @rva=0
	//_Func: public void setRequestedFuel(float value, bool changeValue); @loc=static @len=93 @rva=2579632
	//_Func: public void initColliderMesh(Mesh * mesh, mat44f & bodyMatrix); @loc=static @len=1046 @rva=2571040
	//_Func: public mat44f getColliderBodyMatrix(); @loc=optimized @len=0 @rva=0
	//_Func: public float getFuelConsumptionK(); @loc=optimized @len=0 @rva=0
	//_Func: public float computeRideHeight(int zone, const plane4f & groundPlane); @loc=static @len=370 @rva=2555024
	//_Func: public void setSlipStreamEffects(float receive, float generationSpeedFactor); @loc=static @len=88 @rva=2579776
	//_Func: public float getFrontWheelAngle(); @loc=static @len=571 @rva=2558352
	//_Func: public void addPenalty(double ptime); @loc=static @len=174 @rva=2553504
	//_Func: public void clearPenalty(); @loc=static @len=63 @rva=2554960
	//_Func: public bool isMinSpeedPenaltyClearDisabled(); @loc=static @len=8 @rva=2573776
	//_Func: public double getPenaltyTime(); @loc=static @len=22 @rva=2559312
	//_Func: public bool isBlackFlagged(); @loc=optimized @len=0 @rva=0
	//_Func: public void lockControlsFor(double  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void lockControlsUntil(double time, double start); @loc=static @len=69 @rva=2573824
	//_Func: public void lockControls(bool lock); @loc=static @len=7 @rva=2573808
	//_Func: public bool getControlsLocked(); @loc=optimized @len=0 @rva=0
	//_Func: public float getBallastKG(); @loc=optimized @len=0 @rva=0
	//_Func: public void setBallastKG(float kg); @loc=static @len=9 @rva=2578912
	//_Func: public float getRestrictor(); @loc=static @len=23 @rva=2564416
	//_Func: public void setRestrictor(float value); @loc=static @len=47 @rva=2579728
	//_Func: public void activateP2P(); @loc=optimized @len=0 @rva=0
	//_Func: public void setP2Pactivations(int  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getConfigPath(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & filename); @loc=static @len=552 @rva=2556960
	//_Func: public PitStopTime getPitstopTime(float fuel_to_add, bool changeTyres, bool repairBody, bool repairEngine, bool repairSus, bool useRandomizer); @loc=static @len=733 @rva=2563680
	//_Func: public float getWheelSterAngleDEG(int index); @loc=static @len=180 @rva=2566496
	//_Func: public float getFinalFF(); @loc=static @len=48 @rva=2558304
	//_Func: public void setGridPosition(const vec3f &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public PitStopTimings getPitStopTiming(); @loc=optimized @len=0 @rva=0
	//_Func: public void getEngagement(float engagement_length, float * left, float * right); @loc=static @len=760 @rva=2557536
	//_Func: public void resetSplineLocator(); @loc=static @len=12 @rva=2578784
	//_Func: public float getTotalKM(); @loc=static @len=21 @rva=2565456
	//_Func: public vec3f getGroundWindVector(); @loc=static @len=236 @rva=2558976
	//_Data: this+0x3D14, Member, Type: bool, isControlsLocked
	//_Data: this+0x3D18, Member, Type: double, lockControlsTime
	//_Data: this+0x3D20, Member, Type: bool, blackFlagged
	//_Data: this+0x3D28, Member, Type: double, penaltyTimeAccumulator
	//_Data: this+0x3D30, Member, Type: double, penaltyTime
	//_Data: this+0x3D38, Member, Type: float, expectedFuelPerLap
	//_Data: this+0x3D3C, Member, Type: class mat44f, meshColliderBodyMatrix
	//_Data: this+0x3D80, Member, Type: class ICarControlsProvider *, controlsProvider
	//_Data: this+0x3D88, Member, Type: class vec3f, lastVelocity
	//_Data: this+0x3D94, Member, Type: int, sleepingFrames
	//_Data: this+0x3D98, Member, Type: float, mzCurrent
	//_Data: this+0x3D9C, Member, Type: class vec3f, bodyInertia
	//_Data: this+0x3DA8, Member, Type: class vec3f, explicitInertia
	//_Data: this+0x3DB8, Member, Type: double, fuel
	//_Data: this+0x3DC0, Member, Type: double, fuelConsumptionK
	//_Data: this+0x3DC8, Member, Type: double, maxFuel
	//_Data: this+0x3DD0, Member, Type: float, requestedFuel
	//_Data: this+0x3DD8, Member, Type: double, lastBodyMassUpdateTime
	//_Data: this+0x3DE0, Member, Type: float[0x5], damageZoneLevel
	//_Data: this+0x3DF4, Member, Type: class vec3f[0x2], ridePickupPoint
	//_Data: this+0x3E0C, Member, Type: class vec3f, fuelTankPos
	//_Data: this+0x3E18, Member, Type: float, vibrationPhase
	//_Data: this+0x3E1C, Member, Type: float, slipVibrationPhase
	//_Data: this+0x3E20, Member, Type: float, flatSpotPhase
	//_Data: this+0x3E24, Member, Type: float, slipStreamEffectGain
	//_Data: this+0x3E28, Member, Type: int, framesToSleep
	//_Data: this+0x3E2C, Member, Type: bool, disableMinSpeedPenaltyClear
	//_Data: this+0x3E30, Member, Type: float, ballastKG
	//_Data: this+0x3E34, Member, Type: float, lastSteerPosition
	//_Data: this+0x3E38, Member, Type: struct SplineLocator, splineLocator
	//_Data: this+0x3E68, Member, Type: bool, isCollisionOffForPits
	//_Data: this+0x3E6C, Member, Type: struct PitStopTimings, pitTimings
	//_Data: this+0x3E80, Member, Type: class vec3f, gridPosition
	//_Data: this+0x3E8C, Member, Type: bool, hasGridPosition
	//_Data: this+0x3E8D, Member, Type: bool, lastLigthSwitchState
	//_Data: this+0x3E90, Member, Type: struct PhysicsValueCache, valueCache
	//_Data: this+0x3E94, Member, Type: float, fuelKG
	//_Data: this+0x3E98, Member, Type: bool, externalControl
	//_Func: protected void pollControls(float dt); @loc=static @len=1457 @rva=2575984
	//_Func: protected void initControls(); @loc=optimized @len=0 @rva=0
	//_Func: protected void initCarData(); @loc=static @len=3727 @rva=2566960
	//_Func: protected void initCarDataPath(); @loc=static @len=348 @rva=2570688
	//_Func: protected void buildARBS(); @loc=static @len=1047 @rva=2553680
	//_Func: protected void initAeroMap(); @loc=static @len=171 @rva=2566784
	//_Func: protected float calcBodyMass(); @loc=static @len=102 @rva=2554736
	//_Func: protected void updateBodyMass(); @loc=static @len=381 @rva=2583664
	//_Func: protected void updateAirPressure(); @loc=static @len=396 @rva=2583264
	//_Func: protected void initHeaveSprings(); @loc=static @len=217 @rva=2572096
	//_Func: protected void onTyresStepCompleted(); @loc=static @len=414 @rva=2575568
	//_Func: protected void onNewSession(const SessionInfo & si); @loc=static @len=155 @rva=2575408
	//_Func: protected void stepThermalObjects(float dt); @loc=static @len=225 @rva=2583024
	//_Func: protected void stepComponents(float dt); @loc=static @len=675 @rva=2581712
	//_Func: protected void updateColliderStatus(float dt); @loc=static @len=533 @rva=2584048
	//_Func: protected void initPitstopTimings(); @loc=static @len=1203 @rva=2572320
	//_Func: protected void stepJumpStart(float dt); @loc=static @len=311 @rva=2582400
	//_Func: public Car & operator=(const Car &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class Car {
public:
	float finalSteerAngleSignal;
	float powerClassIndex;
	Event<OnStepCompleteEvent> evOnStepComplete;
	Event<OnControlsProviderChanged> evOnControlsProviderChanged;
	Event<OnLapCompletedEvent> evOnLapCompleted;
	Event<OnSectorSplitEvent> evOnSectorSplit;
	Event<vec3f> evOnForcedPositionCompleted;
	Event<std::pair<int,int> > evOnTyreCompoundChanged;
	Event<OnCollisionEvent> evOnCollisionEvent;
	Event<double> evOnJumpStartEvent;
	Event<std::pair<int,int> > evOnPush2Pass;
	float carHalfWidth;
	float userFFGain;
	bool isRetired;
	std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > tyreCompounds;
	void * tag;
	IRigidBody * body;
	IRigidBody * fuelTankBody;
	IRigidBody * rigidAxle;
	IJoint * fuelTankJoint;
	PhysicsEngine * ksPhysics;
	CarControls controls;
	float steerLock;
	float steerRatio;
	float steerLinearRatio;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > unixName;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > configName;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > carDataPath;
	float mass;
	float ffMult;
	vec3f accG;
	TimeTransponder transponder;
	CarColliderManager colliderManager;
	Drivetrain drivetrain;
	ABS abs;
	TractionControl tractionControl;
	SpeedLimiter speedLimiter;
	AeroMap aeroMap;
	Tyre tyres[4];
	std::vector<ISuspension *,std::allocator<ISuspension *> > suspensions;
	BrakeSystem brakeSystem;
	Autoclutch autoClutch;
	unsigned int physicsGUID;
	Telemetry telemetry;
	AutoBlip autoBlip;
	AutoShifter autoShift;
	GearChanger gearChanger;
	EDL edl;
	AntirollBar antirollBars[2];
	StabilityControl stabilityControl;
	double lastCollisionTime;
	DriftModeComponent driftMode;
	PerformanceMeter performanceMeter;
	SetupManager setupManager;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > screenName;
	DRS drs;
	Kers kers;
	ERS ers;
	LapInvalidator lapInvalidator;
	PenaltyManager penaltyManager;
	bool isGearboxLocked;
	bool isGentleStopping;
	double penaltyPerfTarget;
	mat44f pitPosition;
	SplineLocatorData splineLocatorData;
	FuelLapEvaluator fuelLapEvaluator;
	HeaveSpring heaveSprings[2];
	SteeringSystem steeringSystem;
	double lastCollisionWithCarTime;
	SuspensionType suspensionTypeF;
	SuspensionType suspensionTypeR;
	float axleTorqueReaction;
	float lastGyroFF;
	float lastFF;
	float lastPureMZFF;
	ThermalObject water;
	float steerAssist;
	bool isRequestingPitStop;
	int aiLapsToComplete;
	bool lightsOn;
	CarCollisionBounds bounds;
	SlipStream slipStream;
	TorqueModeEX torqueModeEx;
	bool isControlsLocked;
	double lockControlsTime;
	bool blackFlagged;
	double penaltyTimeAccumulator;
	double penaltyTime;
	float expectedFuelPerLap;
	mat44f meshColliderBodyMatrix;
	ICarControlsProvider * controlsProvider;
	vec3f lastVelocity;
	int sleepingFrames;
	float mzCurrent;
	vec3f bodyInertia;
	vec3f explicitInertia;
	double fuel;
	double fuelConsumptionK;
	double maxFuel;
	float requestedFuel;
	double lastBodyMassUpdateTime;
	float damageZoneLevel[5];
	vec3f ridePickupPoint[2];
	vec3f fuelTankPos;
	float vibrationPhase;
	float slipVibrationPhase;
	float flatSpotPhase;
	float slipStreamEffectGain;
	int framesToSleep;
	bool disableMinSpeedPenaltyClear;
	float ballastKG;
	float lastSteerPosition;
	SplineLocator splineLocator;
	bool isCollisionOffForPits;
	PitStopTimings pitTimings;
	vec3f gridPosition;
	bool hasGridPosition;
	bool lastLigthSwitchState;
	PhysicsValueCache valueCache;
	float fuelKG;
	bool externalControl;
	inline Car() { }
	inline Car(const Car& other) = default;
	inline Car& operator=(const Car& other) = default;
	inline void ctor(PhysicsEngine * iengine, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & iunixName, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & config) { typedef void (Car::*_fpt)(PhysicsEngine *, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2539264)); (this->*_f)(iengine, iunixName, config); }
	virtual ~Car();
	inline void dtor() { typedef void (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2547920)); (this->*_f)(); }
	inline void stepPreCacheValues(float dt) { typedef void (Car::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2582720)); return (this->*_f)(dt); }
	inline void setBlackFlag(bool isflagged, PenaltyDescription type) { typedef void (Car::*_fpt)(bool, PenaltyDescription); auto _f=xcast<_fpt>(_drva(2578928)); return (this->*_f)(isflagged, type); }
	inline int setFuelForLaps(int laps, float mult) { typedef int (Car::*_fpt)(int, float); auto _f=xcast<_fpt>(_drva(2579296)); return (this->*_f)(laps, mult); }
	inline float getFuelPerLap() { typedef float (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2558928)); return (this->*_f)(); }
	inline float getBackDistanceFromCar(Car * car) { typedef float (Car::*_fpt)(Car *); auto _f=xcast<_fpt>(_drva(2556768)); return (this->*_f)(car); }
	inline bool isInPitLane() { typedef bool (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2573536)); return (this->*_f)(); }
	inline bool isInPits() { typedef bool (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2573616)); return (this->*_f)(); }
	inline void setDamageLevel(float v, int index) { typedef void (Car::*_fpt)(float, int); auto _f=xcast<_fpt>(_drva(2579280)); return (this->*_f)(v, index); }
	inline void setDamageLevel(float v) { typedef void (Car::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2579232)); return (this->*_f)(v); }
	inline void resetSuspensionDamageLevel() { typedef void (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2578800)); return (this->*_f)(); }
	inline void onCollisionCallBack(void * userData0, void * shape0, void * userData1, void * shape1, vec3f normal, vec3f pos, float depth) { typedef void (Car::*_fpt)(void *, void *, void *, void *, vec3f, vec3f, float); auto _f=xcast<_fpt>(_drva(2573904)); return (this->*_f)(userData0, shape0, userData1, shape1, normal, pos, depth); }
	inline void reset() { typedef void (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2578656)); return (this->*_f)(); }
	inline void getTyreThermalState(int index, TyreThermalState * state) { typedef void (Car::*_fpt)(int, TyreThermalState *); auto _f=xcast<_fpt>(_drva(2566064)); return (this->*_f)(index, state); }
	inline bool isSleeping() { typedef bool (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2573792)); return (this->*_f)(); }
	inline void step(float dt) { typedef void (Car::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2579872)); return (this->*_f)(dt); }
	inline void postStep(float dt) { typedef void (Car::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2577456)); return (this->*_f)(dt); }
	inline void getPhysicsState(CarPhysicsState & state) { typedef void (Car::*_fpt)(CarPhysicsState &); auto _f=xcast<_fpt>(_drva(2559344)); return (this->*_f)(state); }
	inline void getAIState(AIState * state) { typedef void (Car::*_fpt)(AIState *); auto _f=xcast<_fpt>(_drva(2556480)); return (this->*_f)(state); }
	inline void setControllerProvider(ICarControlsProvider * cp) { typedef void (Car::*_fpt)(ICarControlsProvider *); auto _f=xcast<_fpt>(_drva(2579056)); return (this->*_f)(cp); }
	inline Speed getSpeed() { typedef Speed (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2564448)); return (this->*_f)(); }
	inline float getCGHeight() { typedef float (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2556848)); return (this->*_f)(); }
	inline vec3f getVelocity() { typedef vec3f (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2566464)); return (this->*_f)(); }
	inline vec3f getLocalVelocity() { typedef vec3f (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2559264)); return (this->*_f)(); }
	inline float getSteerFF() { typedef float (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2564480)); return (this->*_f)(); }
	inline vec3f getLocalAngularVelocity() { typedef vec3f (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2559216)); return (this->*_f)(); }
	inline ICarControlsProvider * getControlsProvider() { typedef ICarControlsProvider * (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2557520)); return (this->*_f)(); }
	inline float getTotalMass(bool withFuel) { typedef float (Car::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(2565488)); return (this->*_f)(withFuel); }
	inline mat44f getTyreMatrix(int index) { typedef mat44f (Car::*_fpt)(int); auto _f=xcast<_fpt>(_drva(2565792)); return (this->*_f)(index); }
	inline mat44f getSuspensionMatrix(unsigned int index) { typedef mat44f (Car::*_fpt)(unsigned int); auto _f=xcast<_fpt>(_drva(2565360)); return (this->*_f)(index); }
	inline void getWingState(std::vector<WingState,std::allocator<WingState> > & ws) { typedef void (Car::*_fpt)(std::vector<WingState,std::allocator<WingState> > &); auto _f=xcast<_fpt>(_drva(2566688)); return (this->*_f)(ws); }
	inline void forcePosition(const vec3f & pos, bool invalidateTransponder) { typedef void (Car::*_fpt)(const vec3f &, bool); auto _f=xcast<_fpt>(_drva(2555408)); return (this->*_f)(pos, invalidateTransponder); }
	inline void forceRotation(const vec3f & ihed) { typedef void (Car::*_fpt)(const vec3f &); auto _f=xcast<_fpt>(_drva(2555968)); return (this->*_f)(ihed); }
	inline void setRequestedFuel(float value, bool changeValue) { typedef void (Car::*_fpt)(float, bool); auto _f=xcast<_fpt>(_drva(2579632)); return (this->*_f)(value, changeValue); }
	inline void initColliderMesh(Mesh * mesh, mat44f & bodyMatrix) { typedef void (Car::*_fpt)(Mesh *, mat44f &); auto _f=xcast<_fpt>(_drva(2571040)); return (this->*_f)(mesh, bodyMatrix); }
	inline float computeRideHeight(int zone, const plane4f & groundPlane) { typedef float (Car::*_fpt)(int, const plane4f &); auto _f=xcast<_fpt>(_drva(2555024)); return (this->*_f)(zone, groundPlane); }
	inline void setSlipStreamEffects(float receive, float generationSpeedFactor) { typedef void (Car::*_fpt)(float, float); auto _f=xcast<_fpt>(_drva(2579776)); return (this->*_f)(receive, generationSpeedFactor); }
	inline float getFrontWheelAngle() { typedef float (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2558352)); return (this->*_f)(); }
	inline void addPenalty(double ptime) { typedef void (Car::*_fpt)(double); auto _f=xcast<_fpt>(_drva(2553504)); return (this->*_f)(ptime); }
	inline void clearPenalty() { typedef void (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2554960)); return (this->*_f)(); }
	inline bool isMinSpeedPenaltyClearDisabled() { typedef bool (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2573776)); return (this->*_f)(); }
	inline double getPenaltyTime() { typedef double (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2559312)); return (this->*_f)(); }
	inline void lockControlsUntil(double time, double start) { typedef void (Car::*_fpt)(double, double); auto _f=xcast<_fpt>(_drva(2573824)); return (this->*_f)(time, start); }
	inline void lockControls(bool lock) { typedef void (Car::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(2573808)); return (this->*_f)(lock); }
	inline void setBallastKG(float kg) { typedef void (Car::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2578912)); return (this->*_f)(kg); }
	inline float getRestrictor() { typedef float (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2564416)); return (this->*_f)(); }
	inline void setRestrictor(float value) { typedef void (Car::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2579728)); return (this->*_f)(value); }
	inline std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getConfigPath(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & filename) { typedef std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > (Car::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2556960)); return (this->*_f)(filename); }
	inline PitStopTime getPitstopTime(float fuel_to_add, bool changeTyres, bool repairBody, bool repairEngine, bool repairSus, bool useRandomizer) { typedef PitStopTime (Car::*_fpt)(float, bool, bool, bool, bool, bool); auto _f=xcast<_fpt>(_drva(2563680)); return (this->*_f)(fuel_to_add, changeTyres, repairBody, repairEngine, repairSus, useRandomizer); }
	inline float getWheelSterAngleDEG(int index) { typedef float (Car::*_fpt)(int); auto _f=xcast<_fpt>(_drva(2566496)); return (this->*_f)(index); }
	inline float getFinalFF() { typedef float (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2558304)); return (this->*_f)(); }
	inline void getEngagement(float engagement_length, float * left, float * right) { typedef void (Car::*_fpt)(float, float *, float *); auto _f=xcast<_fpt>(_drva(2557536)); return (this->*_f)(engagement_length, left, right); }
	inline void resetSplineLocator() { typedef void (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2578784)); return (this->*_f)(); }
	inline float getTotalKM() { typedef float (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2565456)); return (this->*_f)(); }
	inline vec3f getGroundWindVector() { typedef vec3f (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2558976)); return (this->*_f)(); }
	inline void pollControls(float dt) { typedef void (Car::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2575984)); return (this->*_f)(dt); }
	inline void initCarData() { typedef void (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2566960)); return (this->*_f)(); }
	inline void initCarDataPath() { typedef void (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2570688)); return (this->*_f)(); }
	inline void buildARBS() { typedef void (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2553680)); return (this->*_f)(); }
	inline void initAeroMap() { typedef void (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2566784)); return (this->*_f)(); }
	inline float calcBodyMass() { typedef float (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2554736)); return (this->*_f)(); }
	inline void updateBodyMass() { typedef void (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2583664)); return (this->*_f)(); }
	inline void updateAirPressure() { typedef void (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2583264)); return (this->*_f)(); }
	inline void initHeaveSprings() { typedef void (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2572096)); return (this->*_f)(); }
	inline void onTyresStepCompleted() { typedef void (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2575568)); return (this->*_f)(); }
	inline void onNewSession(const SessionInfo & si) { typedef void (Car::*_fpt)(const SessionInfo &); auto _f=xcast<_fpt>(_drva(2575408)); return (this->*_f)(si); }
	inline void stepThermalObjects(float dt) { typedef void (Car::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2583024)); return (this->*_f)(dt); }
	inline void stepComponents(float dt) { typedef void (Car::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2581712)); return (this->*_f)(dt); }
	inline void updateColliderStatus(float dt) { typedef void (Car::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2584048)); return (this->*_f)(dt); }
	inline void initPitstopTimings() { typedef void (Car::*_fpt)(); auto _f=xcast<_fpt>(_drva(2572320)); return (this->*_f)(); }
	inline void stepJumpStart(float dt) { typedef void (Car::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2582400)); return (this->*_f)(dt); }
	inline void _guard_obj() {
		static_assert((sizeof(Car)==16032),"bad size");
		static_assert((offsetof(Car,finalSteerAngleSignal)==0x8),"bad off");
		static_assert((offsetof(Car,powerClassIndex)==0xC),"bad off");
		static_assert((offsetof(Car,evOnStepComplete)==0x10),"bad off");
		static_assert((offsetof(Car,evOnControlsProviderChanged)==0x28),"bad off");
		static_assert((offsetof(Car,evOnLapCompleted)==0x40),"bad off");
		static_assert((offsetof(Car,evOnSectorSplit)==0x58),"bad off");
		static_assert((offsetof(Car,evOnForcedPositionCompleted)==0x70),"bad off");
		static_assert((offsetof(Car,evOnTyreCompoundChanged)==0x88),"bad off");
		static_assert((offsetof(Car,evOnCollisionEvent)==0xA0),"bad off");
		static_assert((offsetof(Car,evOnJumpStartEvent)==0xB8),"bad off");
		static_assert((offsetof(Car,evOnPush2Pass)==0xD0),"bad off");
		static_assert((offsetof(Car,carHalfWidth)==0xE8),"bad off");
		static_assert((offsetof(Car,userFFGain)==0xEC),"bad off");
		static_assert((offsetof(Car,isRetired)==0xF0),"bad off");
		static_assert((offsetof(Car,tyreCompounds)==0xF8),"bad off");
		static_assert((offsetof(Car,tag)==0x110),"bad off");
		static_assert((offsetof(Car,body)==0x118),"bad off");
		static_assert((offsetof(Car,fuelTankBody)==0x120),"bad off");
		static_assert((offsetof(Car,rigidAxle)==0x128),"bad off");
		static_assert((offsetof(Car,fuelTankJoint)==0x130),"bad off");
		static_assert((offsetof(Car,ksPhysics)==0x138),"bad off");
		static_assert((offsetof(Car,controls)==0x140),"bad off");
		static_assert((offsetof(Car,steerLock)==0x174),"bad off");
		static_assert((offsetof(Car,steerRatio)==0x178),"bad off");
		static_assert((offsetof(Car,steerLinearRatio)==0x17C),"bad off");
		static_assert((offsetof(Car,unixName)==0x180),"bad off");
		static_assert((offsetof(Car,configName)==0x1A0),"bad off");
		static_assert((offsetof(Car,carDataPath)==0x1C0),"bad off");
		static_assert((offsetof(Car,mass)==0x1E0),"bad off");
		static_assert((offsetof(Car,ffMult)==0x1E4),"bad off");
		static_assert((offsetof(Car,accG)==0x1E8),"bad off");
		static_assert((offsetof(Car,transponder)==0x1F8),"bad off");
		static_assert((offsetof(Car,colliderManager)==0x290),"bad off");
		static_assert((offsetof(Car,drivetrain)==0x310),"bad off");
		static_assert((offsetof(Car,abs)==0x958),"bad off");
		static_assert((offsetof(Car,tractionControl)==0xA00),"bad off");
		static_assert((offsetof(Car,speedLimiter)==0xAA8),"bad off");
		static_assert((offsetof(Car,aeroMap)==0xAB8),"bad off");
		static_assert((offsetof(Car,tyres)==0xB28),"bad off");
		static_assert((offsetof(Car,suspensions)==0x2C88),"bad off");
		static_assert((offsetof(Car,brakeSystem)==0x2CA0),"bad off");
		static_assert((offsetof(Car,autoClutch)==0x3090),"bad off");
		static_assert((offsetof(Car,physicsGUID)==0x3238),"bad off");
		static_assert((offsetof(Car,telemetry)==0x3240),"bad off");
		static_assert((offsetof(Car,autoBlip)==0x3340),"bad off");
		static_assert((offsetof(Car,autoShift)==0x33E8),"bad off");
		static_assert((offsetof(Car,gearChanger)==0x3410),"bad off");
		static_assert((offsetof(Car,edl)==0x3428),"bad off");
		static_assert((offsetof(Car,antirollBars)==0x3460),"bad off");
		static_assert((offsetof(Car,stabilityControl)==0x34F0),"bad off");
		static_assert((offsetof(Car,lastCollisionTime)==0x3508),"bad off");
		static_assert((offsetof(Car,driftMode)==0x3510),"bad off");
		static_assert((offsetof(Car,performanceMeter)==0x3560),"bad off");
		static_assert((offsetof(Car,setupManager)==0x35D0),"bad off");
		static_assert((offsetof(Car,screenName)==0x3620),"bad off");
		static_assert((offsetof(Car,drs)==0x3640),"bad off");
		static_assert((offsetof(Car,kers)==0x3670),"bad off");
		static_assert((offsetof(Car,ers)==0x3768),"bad off");
		static_assert((offsetof(Car,lapInvalidator)==0x3A18),"bad off");
		static_assert((offsetof(Car,penaltyManager)==0x3A38),"bad off");
		static_assert((offsetof(Car,isGearboxLocked)==0x3A80),"bad off");
		static_assert((offsetof(Car,isGentleStopping)==0x3A81),"bad off");
		static_assert((offsetof(Car,penaltyPerfTarget)==0x3A88),"bad off");
		static_assert((offsetof(Car,pitPosition)==0x3A90),"bad off");
		static_assert((offsetof(Car,splineLocatorData)==0x3AD0),"bad off");
		static_assert((offsetof(Car,fuelLapEvaluator)==0x3AF8),"bad off");
		static_assert((offsetof(Car,heaveSprings)==0x3B40),"bad off");
		static_assert((offsetof(Car,steeringSystem)==0x3BF0),"bad off");
		static_assert((offsetof(Car,lastCollisionWithCarTime)==0x3C30),"bad off");
		static_assert((offsetof(Car,suspensionTypeF)==0x3C38),"bad off");
		static_assert((offsetof(Car,suspensionTypeR)==0x3C3C),"bad off");
		static_assert((offsetof(Car,axleTorqueReaction)==0x3C40),"bad off");
		static_assert((offsetof(Car,lastGyroFF)==0x3C44),"bad off");
		static_assert((offsetof(Car,lastFF)==0x3C48),"bad off");
		static_assert((offsetof(Car,lastPureMZFF)==0x3C4C),"bad off");
		static_assert((offsetof(Car,water)==0x3C50),"bad off");
		static_assert((offsetof(Car,steerAssist)==0x3C70),"bad off");
		static_assert((offsetof(Car,isRequestingPitStop)==0x3C74),"bad off");
		static_assert((offsetof(Car,aiLapsToComplete)==0x3C78),"bad off");
		static_assert((offsetof(Car,lightsOn)==0x3C7C),"bad off");
		static_assert((offsetof(Car,bounds)==0x3C80),"bad off");
		static_assert((offsetof(Car,slipStream)==0x3CA8),"bad off");
		static_assert((offsetof(Car,torqueModeEx)==0x3D10),"bad off");
		static_assert((offsetof(Car,isControlsLocked)==0x3D14),"bad off");
		static_assert((offsetof(Car,lockControlsTime)==0x3D18),"bad off");
		static_assert((offsetof(Car,blackFlagged)==0x3D20),"bad off");
		static_assert((offsetof(Car,penaltyTimeAccumulator)==0x3D28),"bad off");
		static_assert((offsetof(Car,penaltyTime)==0x3D30),"bad off");
		static_assert((offsetof(Car,expectedFuelPerLap)==0x3D38),"bad off");
		static_assert((offsetof(Car,meshColliderBodyMatrix)==0x3D3C),"bad off");
		static_assert((offsetof(Car,controlsProvider)==0x3D80),"bad off");
		static_assert((offsetof(Car,lastVelocity)==0x3D88),"bad off");
		static_assert((offsetof(Car,sleepingFrames)==0x3D94),"bad off");
		static_assert((offsetof(Car,mzCurrent)==0x3D98),"bad off");
		static_assert((offsetof(Car,bodyInertia)==0x3D9C),"bad off");
		static_assert((offsetof(Car,explicitInertia)==0x3DA8),"bad off");
		static_assert((offsetof(Car,fuel)==0x3DB8),"bad off");
		static_assert((offsetof(Car,fuelConsumptionK)==0x3DC0),"bad off");
		static_assert((offsetof(Car,maxFuel)==0x3DC8),"bad off");
		static_assert((offsetof(Car,requestedFuel)==0x3DD0),"bad off");
		static_assert((offsetof(Car,lastBodyMassUpdateTime)==0x3DD8),"bad off");
		static_assert((offsetof(Car,damageZoneLevel)==0x3DE0),"bad off");
		static_assert((offsetof(Car,ridePickupPoint)==0x3DF4),"bad off");
		static_assert((offsetof(Car,fuelTankPos)==0x3E0C),"bad off");
		static_assert((offsetof(Car,vibrationPhase)==0x3E18),"bad off");
		static_assert((offsetof(Car,slipVibrationPhase)==0x3E1C),"bad off");
		static_assert((offsetof(Car,flatSpotPhase)==0x3E20),"bad off");
		static_assert((offsetof(Car,slipStreamEffectGain)==0x3E24),"bad off");
		static_assert((offsetof(Car,framesToSleep)==0x3E28),"bad off");
		static_assert((offsetof(Car,disableMinSpeedPenaltyClear)==0x3E2C),"bad off");
		static_assert((offsetof(Car,ballastKG)==0x3E30),"bad off");
		static_assert((offsetof(Car,lastSteerPosition)==0x3E34),"bad off");
		static_assert((offsetof(Car,splineLocator)==0x3E38),"bad off");
		static_assert((offsetof(Car,isCollisionOffForPits)==0x3E68),"bad off");
		static_assert((offsetof(Car,pitTimings)==0x3E6C),"bad off");
		static_assert((offsetof(Car,gridPosition)==0x3E80),"bad off");
		static_assert((offsetof(Car,hasGridPosition)==0x3E8C),"bad off");
		static_assert((offsetof(Car,lastLigthSwitchState)==0x3E8D),"bad off");
		static_assert((offsetof(Car,valueCache)==0x3E90),"bad off");
		static_assert((offsetof(Car,fuelKG)==0x3E94),"bad off");
		static_assert((offsetof(Car,externalControl)==0x3E98),"bad off");
	};
};

//UDT: class DRSManager @len=56
	//_Func: public void DRSManager(const DRSManager &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void DRSManager(PhysicsEngine & engine); @loc=static @len=836 @rva=2592416
	//_Func: public void ~DRSManager(); @loc=static @len=71 @rva=2593264
	//_Func: public void step(float dt); @loc=static @len=3 @rva=96368
	//_Func: public void setZones(std::vector<DRSZone,std::allocator<DRSZone> > & zv); @loc=static @len=9 @rva=2594048
	//_Func: public bool isDRSAvailable(const Car & car); @loc=static @len=98 @rva=2593936
	//_Func: public bool hasDRSZones(); @loc=optimized @len=0 @rva=0
	//_Func: public bool wasRaceSwitchedOn(const Car & car); @loc=static @len=69 @rva=2594064
	//_Data: this+0x0, Member, Type: class std::vector<DRSDetection,std::allocator<DRSDetection> >, detections
	//_Data: this+0x18, Member, Type: class PhysicsEngine &, engine
	//_Data: this+0x20, Member, Type: class std::vector<DRSZone,std::allocator<DRSZone> >, zones
	//_Func: private bool isZoneAvailable(const Car &  _arg0, int  _arg1); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @loc=optimized @len=0 @rva=0
//UDT;

class DRSManager {
public:
	std::vector<DRSDetection,std::allocator<DRSDetection> > detections;
	PhysicsEngine & engine;
	std::vector<DRSZone,std::allocator<DRSZone> > zones;
	inline DRSManager() : engine(*((PhysicsEngine*)NULL)) { }
	inline DRSManager(const DRSManager& other) = default;
	inline DRSManager& operator=(const DRSManager& other) = default;
	inline void ctor(PhysicsEngine & engine) { typedef void (DRSManager::*_fpt)(PhysicsEngine &); auto _f=xcast<_fpt>(_drva(2592416)); (this->*_f)(engine); }
	inline void dtor() { typedef void (DRSManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(2593264)); (this->*_f)(); }
	inline void step(float dt) { typedef void (DRSManager::*_fpt)(float); auto _f=xcast<_fpt>(_drva(96368)); return (this->*_f)(dt); }
	inline void setZones(std::vector<DRSZone,std::allocator<DRSZone> > & zv) { typedef void (DRSManager::*_fpt)(std::vector<DRSZone,std::allocator<DRSZone> > &); auto _f=xcast<_fpt>(_drva(2594048)); return (this->*_f)(zv); }
	inline bool isDRSAvailable(const Car & car) { typedef bool (DRSManager::*_fpt)(const Car &); auto _f=xcast<_fpt>(_drva(2593936)); return (this->*_f)(car); }
	inline bool wasRaceSwitchedOn(const Car & car) { typedef bool (DRSManager::*_fpt)(const Car &); auto _f=xcast<_fpt>(_drva(2594064)); return (this->*_f)(car); }
	inline void _guard_obj() {
		static_assert((sizeof(DRSManager)==56),"bad size");
		static_assert((offsetof(DRSManager,detections)==0x0),"bad off");
		static_assert((offsetof(DRSManager,zones)==0x20),"bad off");
	};
};

//UDT: class SurfacesManager @len=32 @vfcount=1
	//_VTable: 
	//_Func: public void SurfacesManager(const SurfacesManager &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void SurfacesManager(TrackAvatar & track); @loc=static @len=1462 @rva=1763760
	//_Func: public void ~SurfacesManager(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=55 @rva=1765248
	//_Func: public SurfaceDef getSurface(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name); @loc=static @len=1927 @rva=1766208
	//_Func: public std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,SurfaceDef,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,SurfaceDef> > > * getSurfacesMap(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x8, Member, Type: class std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,SurfaceDef,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,SurfaceDef> > >, surfaces
	//_Data: this+0x18, Member, Type: bool, enableCrash
	//_Func: protected void loadSurfaceDefinitions(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * filename); @loc=static @len=2638 @rva=1768144
	//_Func: public SurfacesManager & operator=(const SurfacesManager &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class SurfacesManager {
public:
	std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,SurfaceDef,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,SurfaceDef> > > surfaces;
	bool enableCrash;
	inline SurfacesManager() { }
	inline SurfacesManager(const SurfacesManager& other) = default;
	inline SurfacesManager& operator=(const SurfacesManager& other) = default;
	inline void ctor(TrackAvatar & track) { typedef void (SurfacesManager::*_fpt)(TrackAvatar &); auto _f=xcast<_fpt>(_drva(1763760)); (this->*_f)(track); }
	virtual ~SurfacesManager();
	inline void dtor() { typedef void (SurfacesManager::*_fpt)(); auto _f=xcast<_fpt>(_drva(1765248)); (this->*_f)(); }
	inline SurfaceDef getSurface(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * name) { typedef SurfaceDef (SurfacesManager::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *); auto _f=xcast<_fpt>(_drva(1766208)); return (this->*_f)(name); }
	inline void loadSurfaceDefinitions(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * filename) { typedef void (SurfacesManager::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *); auto _f=xcast<_fpt>(_drva(1768144)); return (this->*_f)(filename); }
	inline void _guard_obj() {
		static_assert((sizeof(SurfacesManager)==32),"bad size");
		static_assert((offsetof(SurfacesManager,surfaces)==0x8),"bad off");
		static_assert((offsetof(SurfacesManager,enableCrash)==0x18),"bad off");
	};
};

//UDT: class AISplineRecorder @len=1096 @vfcount=1
	//_VTable: 
	//_Func: public void AISplineRecorder(const AISplineRecorder &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void AISplineRecorder(PhysicsEngine * pe, Track & track); @loc=static @len=303 @rva=2702320
	//_Func: public void ~AISplineRecorder(); @intro @virtual vtpo=0 vfid=0 @loc=static @len=617 @rva=2702624
	//_Data: this+0x8, Member, Type: bool, isActive
	//_Func: public void step(float dt); @loc=static @len=706 @rva=2715488
	//_Func: public AISpline * getBestLapSpline(); @loc=static @len=8 @rva=2707872
	//_Func: public AISpline * getPitLaneSpline(); @loc=static @len=8 @rva=2708144
	//_Func: public const InterpolatingSpline & getLeftSpline(); @loc=static @len=8 @rva=3019440
	//_Func: public const InterpolatingSpline & getRightSpline(); @loc=static @len=8 @rva=3019456
	//_Func: public void save(bool updateFile); @loc=static @len=1000 @rva=2714336
	//_Func: public void beginPitLaneSpline(); @loc=static @len=101 @rva=2707488
	//_Func: public void endPitLaneSpline(); @loc=static @len=130 @rva=2707728
	//_Func: public void startRecording(); @loc=static @len=87 @rva=2715392
	//_Func: public float getPitLaneSplineAttachPoint(); @loc=optimized @len=0 @rva=0
	//_Func: public void onLapCompleted(const OnLapCompletedEvent & message); @loc=static @len=267 @rva=2713440
	//_Func: public float getHintAtSplinePos(float normalizedPos); @loc=static @len=51 @rva=2708016
	//_Func: public float getBrakeHintAtSplinePos(float normalizedPos); @loc=static @len=51 @rva=2707888
	//_Func: public bool getDangerAtSplinePos(float normalizedPos, float * left, float * right); @loc=static @len=60 @rva=2707952
	//_Func: public float getMaxSpeedHintAtSplinePos(float normalizedPos); @loc=static @len=51 @rva=2708080
	//_Data: this+0x10, Member, Type: class AISpline, splineCurrent
	//_Data: this+0xF0, Member, Type: class AISpline, bestLapSpline
	//_Data: this+0x1D0, Member, Type: class AISpline, pitLaneSpline
	//_Data: this+0x2B0, Member, Type: class InterpolatingSpline, leftSpline
	//_Data: this+0x320, Member, Type: class InterpolatingSpline, rightSpline
	//_Data: this+0x390, Member, Type: class PhysicsEngine *, physicsEngine
	//_Data: this+0x398, Member, Type: float, recordingStep
	//_Data: this+0x39C, Member, Type: bool, isSaveNeeded
	//_Data: this+0x3A0, Member, Type: class Track &, track
	//_Data: this+0x3A8, Member, Type: class Car *, car
	//_Data: this+0x3B0, Member, Type: bool, isRecordingPitlane
	//_Data: this+0x3B8, Member, Type: class ThreadMutex, mutex
	//_Data: this+0x3E0, Member, Type: float, pitLaneSplineAttachPoint
	//_Data: this+0x3E8, Member, Type: class std::vector<AISplineHint,std::allocator<AISplineHint> >, hints
	//_Data: this+0x400, Member, Type: class std::vector<AISplineHint,std::allocator<AISplineHint> >, hintsBrake
	//_Data: this+0x418, Member, Type: class std::vector<AISplineDanger,std::allocator<AISplineDanger> >, hintsDanger
	//_Data: this+0x430, Member, Type: class std::vector<AISplineHint,std::allocator<AISplineHint> >, hintsMaxSpeed
	//_Func: protected void computeAdditionalPayloadInfo(AISpline &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: protected void load(); @loc=static @len=931 @rva=2708160
	//_Func: protected void loadPitLaneSpline(); @loc=static @len=636 @rva=2712064
	//_Func: protected void recomputeSidesFromCsv(); @loc=static @len=613 @rva=2713712
	//_Func: protected void loadSideSpline(InterpolatingSpline & is, std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * filename); @loc=static @len=733 @rva=2712704
	//_Func: protected void loadHints(); @loc=static @len=2957 @rva=2709104
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class AISplineRecorder {
public:
	bool isActive;
	AISpline splineCurrent;
	AISpline bestLapSpline;
	AISpline pitLaneSpline;
	InterpolatingSpline leftSpline;
	InterpolatingSpline rightSpline;
	PhysicsEngine * physicsEngine;
	float recordingStep;
	bool isSaveNeeded;
	Track & track;
	Car * car;
	bool isRecordingPitlane;
	ThreadMutex mutex;
	float pitLaneSplineAttachPoint;
	std::vector<AISplineHint,std::allocator<AISplineHint> > hints;
	std::vector<AISplineHint,std::allocator<AISplineHint> > hintsBrake;
	std::vector<AISplineDanger,std::allocator<AISplineDanger> > hintsDanger;
	std::vector<AISplineHint,std::allocator<AISplineHint> > hintsMaxSpeed;
	inline AISplineRecorder() : track(*((Track*)NULL)) { }
	inline AISplineRecorder(const AISplineRecorder& other) = default;
	inline AISplineRecorder& operator=(const AISplineRecorder& other) = default;
	inline void ctor(PhysicsEngine * pe, Track & track) { typedef void (AISplineRecorder::*_fpt)(PhysicsEngine *, Track &); auto _f=xcast<_fpt>(_drva(2702320)); (this->*_f)(pe, track); }
	virtual ~AISplineRecorder();
	inline void dtor() { typedef void (AISplineRecorder::*_fpt)(); auto _f=xcast<_fpt>(_drva(2702624)); (this->*_f)(); }
	inline void step(float dt) { typedef void (AISplineRecorder::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2715488)); return (this->*_f)(dt); }
	inline AISpline * getBestLapSpline() { typedef AISpline * (AISplineRecorder::*_fpt)(); auto _f=xcast<_fpt>(_drva(2707872)); return (this->*_f)(); }
	inline AISpline * getPitLaneSpline() { typedef AISpline * (AISplineRecorder::*_fpt)(); auto _f=xcast<_fpt>(_drva(2708144)); return (this->*_f)(); }
	inline const InterpolatingSpline & getLeftSpline() { typedef const InterpolatingSpline & (AISplineRecorder::*_fpt)(); auto _f=xcast<_fpt>(_drva(3019440)); return (this->*_f)(); }
	inline const InterpolatingSpline & getRightSpline() { typedef const InterpolatingSpline & (AISplineRecorder::*_fpt)(); auto _f=xcast<_fpt>(_drva(3019456)); return (this->*_f)(); }
	inline void save(bool updateFile) { typedef void (AISplineRecorder::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(2714336)); return (this->*_f)(updateFile); }
	inline void beginPitLaneSpline() { typedef void (AISplineRecorder::*_fpt)(); auto _f=xcast<_fpt>(_drva(2707488)); return (this->*_f)(); }
	inline void endPitLaneSpline() { typedef void (AISplineRecorder::*_fpt)(); auto _f=xcast<_fpt>(_drva(2707728)); return (this->*_f)(); }
	inline void startRecording() { typedef void (AISplineRecorder::*_fpt)(); auto _f=xcast<_fpt>(_drva(2715392)); return (this->*_f)(); }
	inline void onLapCompleted(const OnLapCompletedEvent & message) { typedef void (AISplineRecorder::*_fpt)(const OnLapCompletedEvent &); auto _f=xcast<_fpt>(_drva(2713440)); return (this->*_f)(message); }
	inline float getHintAtSplinePos(float normalizedPos) { typedef float (AISplineRecorder::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2708016)); return (this->*_f)(normalizedPos); }
	inline float getBrakeHintAtSplinePos(float normalizedPos) { typedef float (AISplineRecorder::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2707888)); return (this->*_f)(normalizedPos); }
	inline bool getDangerAtSplinePos(float normalizedPos, float * left, float * right) { typedef bool (AISplineRecorder::*_fpt)(float, float *, float *); auto _f=xcast<_fpt>(_drva(2707952)); return (this->*_f)(normalizedPos, left, right); }
	inline float getMaxSpeedHintAtSplinePos(float normalizedPos) { typedef float (AISplineRecorder::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2708080)); return (this->*_f)(normalizedPos); }
	inline void load() { typedef void (AISplineRecorder::*_fpt)(); auto _f=xcast<_fpt>(_drva(2708160)); return (this->*_f)(); }
	inline void loadPitLaneSpline() { typedef void (AISplineRecorder::*_fpt)(); auto _f=xcast<_fpt>(_drva(2712064)); return (this->*_f)(); }
	inline void recomputeSidesFromCsv() { typedef void (AISplineRecorder::*_fpt)(); auto _f=xcast<_fpt>(_drva(2713712)); return (this->*_f)(); }
	inline void loadSideSpline(InterpolatingSpline & is, std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * filename) { typedef void (AISplineRecorder::*_fpt)(InterpolatingSpline &, std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *); auto _f=xcast<_fpt>(_drva(2712704)); return (this->*_f)(is, filename); }
	inline void loadHints() { typedef void (AISplineRecorder::*_fpt)(); auto _f=xcast<_fpt>(_drva(2709104)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(AISplineRecorder)==1096),"bad size");
		static_assert((offsetof(AISplineRecorder,isActive)==0x8),"bad off");
		static_assert((offsetof(AISplineRecorder,splineCurrent)==0x10),"bad off");
		static_assert((offsetof(AISplineRecorder,bestLapSpline)==0xF0),"bad off");
		static_assert((offsetof(AISplineRecorder,pitLaneSpline)==0x1D0),"bad off");
		static_assert((offsetof(AISplineRecorder,leftSpline)==0x2B0),"bad off");
		static_assert((offsetof(AISplineRecorder,rightSpline)==0x320),"bad off");
		static_assert((offsetof(AISplineRecorder,physicsEngine)==0x390),"bad off");
		static_assert((offsetof(AISplineRecorder,recordingStep)==0x398),"bad off");
		static_assert((offsetof(AISplineRecorder,isSaveNeeded)==0x39C),"bad off");
		static_assert((offsetof(AISplineRecorder,car)==0x3A8),"bad off");
		static_assert((offsetof(AISplineRecorder,isRecordingPitlane)==0x3B0),"bad off");
		static_assert((offsetof(AISplineRecorder,mutex)==0x3B8),"bad off");
		static_assert((offsetof(AISplineRecorder,pitLaneSplineAttachPoint)==0x3E0),"bad off");
		static_assert((offsetof(AISplineRecorder,hints)==0x3E8),"bad off");
		static_assert((offsetof(AISplineRecorder,hintsBrake)==0x400),"bad off");
		static_assert((offsetof(AISplineRecorder,hintsDanger)==0x418),"bad off");
		static_assert((offsetof(AISplineRecorder,hintsMaxSpeed)==0x430),"bad off");
	};
};

//UDT: class Track @len=328 @vfcount=4
	//_Base: class IRayTrackCollisionProvider @off=0 @len=8
	//_Func: public void Track(const Track &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void Track(PhysicsEngine * pe, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & iname, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & config); @loc=static @len=929 @rva=2584832
	//_Func: public void ~Track(); @virtual vtpo=0 vfid=0 @loc=static @len=561 @rva=2585856
	//_Data: this+0x8, Member, Type: class PhysicsEngine *, ksPhysics
	//_Data: this+0x10, Member, Type: class std::vector<ICollisionObject *,std::allocator<ICollisionObject *> >, surfaces
	//_Data: this+0x28, Member, Type: class std::vector<TimeLine,std::allocator<TimeLine> >, timeLines
	//_Data: this+0x40, Member, Type: class mat44f, worldMatrix
	//_Data: this+0x80, Member, Type: class std::unique_ptr<AISplineRecorder,std::default_delete<AISplineRecorder> >, aiSplineRecorder
	//_Data: this+0x88, Member, Type: bool, isOpen
	//_Data: this+0x90, Member, Type: class std::unique_ptr<DRSManager,std::default_delete<DRSManager> >, drsMamanger
	//_Data: this+0x98, Member, Type: class std::vector<SplineIndexBound,std::allocator<SplineIndexBound> >, startingBounds
	//_Func: public std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getDataFolder(); @loc=static @len=61 @rva=1817456
	//_Func: public std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getName(); @loc=static @len=61 @rva=2676304
	//_Func: public std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getConfig(); @loc=optimized @len=0 @rva=0
	//_Func: public void setWorldMatrix(mat44f  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public unsigned __int64 addSurface(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & iname, float * vertices, int numVertices, unsigned short * indices, int indexCount, const SurfaceDef & surfaceDef, unsigned int sector_id); @loc=static @len=491 @rva=2588240
	//_Func: public bool rayCast(const vec3f & org, const vec3f & dir, RayCastResult * result, float length); @virtual vtpo=0 vfid=1 @loc=static @len=199 @rva=2591664
	//_Func: public bool rayCastWithRayCaster(const vec3f & org, const vec3f & dir, RayCastResult * result, float length, IRayCaster * rayCaster); @virtual vtpo=0 vfid=2 @loc=static @len=124 @rva=2591872
	//_Func: public IRayCaster * createRayCaster(float length); @virtual vtpo=0 vfid=3 @loc=static @len=46 @rva=2589168
	//_Func: public void addTimeLine(const vec3f & p1, const vec3f & p2, TimeLineType type); @loc=static @len=431 @rva=2588736
	//_Func: public void initAISpline(); @loc=static @len=96 @rva=2589344
	//_Func: public void step(float dt); @loc=static @len=317 @rva=2592032
	//_Func: public float getDynamicGripLevel(); @loc=optimized @len=0 @rva=0
	//_Func: public bool isDynamic(); @loc=optimized @len=0 @rva=0
	//_Func: public void setGripLevelExternal(float grip); @loc=static @len=18 @rva=2592000
	//_Func: public int getSector(float normalizedPosition); @loc=static @len=119 @rva=2589216
	//_Func: public int getSectorsCount(); @loc=optimized @len=0 @rva=0
	//_Data: this+0xB0, Member, Type: struct DynamicTrackData, dynamicTrack
	//_Data: this+0xC8, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, name
	//_Data: this+0xE8, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, config
	//_Data: this+0x108, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, dataFolder
	//_Data: this+0x128, Member, Type: float, dynamicGripLevel
	//_Data: this+0x130, Member, Type: class std::vector<float,std::allocator<float> >, sectorsNormalizedPositions
	//_Func: protected void initDynamicTrack(); @loc=static @len=1167 @rva=2589440
	//_Func: protected void initStartingBounds(); @loc=static @len=747 @rva=2590608
	//_Func: public Track & operator=(const Track &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class Track : public IRayTrackCollisionProvider {
public:
	PhysicsEngine * ksPhysics;
	std::vector<ICollisionObject *,std::allocator<ICollisionObject *> > surfaces;
	std::vector<TimeLine,std::allocator<TimeLine> > timeLines;
	mat44f worldMatrix;
	std::unique_ptr<AISplineRecorder,std::default_delete<AISplineRecorder> > aiSplineRecorder;
	bool isOpen;
	std::unique_ptr<DRSManager,std::default_delete<DRSManager> > drsMamanger;
	std::vector<SplineIndexBound,std::allocator<SplineIndexBound> > startingBounds;
	DynamicTrackData dynamicTrack;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > name;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > config;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > dataFolder;
	float dynamicGripLevel;
	std::vector<float,std::allocator<float> > sectorsNormalizedPositions;
	inline Track() { }
	inline Track(const Track& other) = default;
	inline Track& operator=(const Track& other) = default;
	inline void ctor(PhysicsEngine * pe, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & iname, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & config) { typedef void (Track::*_fpt)(PhysicsEngine *, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(2584832)); (this->*_f)(pe, iname, config); }
	virtual ~Track();
	inline void dtor() { typedef void (Track::*_fpt)(); auto _f=xcast<_fpt>(_drva(2585856)); (this->*_f)(); }
	inline std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getDataFolder() { typedef std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > (Track::*_fpt)(); auto _f=xcast<_fpt>(_drva(1817456)); return (this->*_f)(); }
	inline std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getName() { typedef std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > (Track::*_fpt)(); auto _f=xcast<_fpt>(_drva(2676304)); return (this->*_f)(); }
	inline unsigned __int64 addSurface(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & iname, float * vertices, int numVertices, unsigned short * indices, int indexCount, const SurfaceDef & surfaceDef, unsigned int sector_id) { typedef unsigned __int64 (Track::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, float *, int, unsigned short *, int, const SurfaceDef &, unsigned int); auto _f=xcast<_fpt>(_drva(2588240)); return (this->*_f)(iname, vertices, numVertices, indices, indexCount, surfaceDef, sector_id); }
	virtual bool rayCast_vf1(const vec3f & org, const vec3f & dir, RayCastResult * result, float length);
	inline bool rayCast_impl(const vec3f & org, const vec3f & dir, RayCastResult * result, float length) { typedef bool (Track::*_fpt)(const vec3f &, const vec3f &, RayCastResult *, float); auto _f=xcast<_fpt>(_drva(2591664)); return (this->*_f)(org, dir, result, length); }
	inline bool rayCast(const vec3f & org, const vec3f & dir, RayCastResult * result, float length) { typedef bool (Track::*_fpt)(const vec3f &, const vec3f &, RayCastResult *, float); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(org, dir, result, length); }
	virtual bool rayCastWithRayCaster_vf2(const vec3f & org, const vec3f & dir, RayCastResult * result, float length, IRayCaster * rayCaster);
	inline bool rayCastWithRayCaster_impl(const vec3f & org, const vec3f & dir, RayCastResult * result, float length, IRayCaster * rayCaster) { typedef bool (Track::*_fpt)(const vec3f &, const vec3f &, RayCastResult *, float, IRayCaster *); auto _f=xcast<_fpt>(_drva(2591872)); return (this->*_f)(org, dir, result, length, rayCaster); }
	inline bool rayCastWithRayCaster(const vec3f & org, const vec3f & dir, RayCastResult * result, float length, IRayCaster * rayCaster) { typedef bool (Track::*_fpt)(const vec3f &, const vec3f &, RayCastResult *, float, IRayCaster *); auto _f=xcast<_fpt>(get_vfp(this, 2)); return (this->*_f)(org, dir, result, length, rayCaster); }
	virtual IRayCaster * createRayCaster_vf3(float length);
	inline IRayCaster * createRayCaster_impl(float length) { typedef IRayCaster * (Track::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2589168)); return (this->*_f)(length); }
	inline IRayCaster * createRayCaster(float length) { typedef IRayCaster * (Track::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 3)); return (this->*_f)(length); }
	inline void addTimeLine(const vec3f & p1, const vec3f & p2, TimeLineType type) { typedef void (Track::*_fpt)(const vec3f &, const vec3f &, TimeLineType); auto _f=xcast<_fpt>(_drva(2588736)); return (this->*_f)(p1, p2, type); }
	inline void initAISpline() { typedef void (Track::*_fpt)(); auto _f=xcast<_fpt>(_drva(2589344)); return (this->*_f)(); }
	inline void step(float dt) { typedef void (Track::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2592032)); return (this->*_f)(dt); }
	inline void setGripLevelExternal(float grip) { typedef void (Track::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2592000)); return (this->*_f)(grip); }
	inline int getSector(float normalizedPosition) { typedef int (Track::*_fpt)(float); auto _f=xcast<_fpt>(_drva(2589216)); return (this->*_f)(normalizedPosition); }
	inline void initDynamicTrack() { typedef void (Track::*_fpt)(); auto _f=xcast<_fpt>(_drva(2589440)); return (this->*_f)(); }
	inline void initStartingBounds() { typedef void (Track::*_fpt)(); auto _f=xcast<_fpt>(_drva(2590608)); return (this->*_f)(); }
	inline void _guard_obj() {
		static_assert((sizeof(Track)==328),"bad size");
		static_assert((offsetof(Track,ksPhysics)==0x8),"bad off");
		static_assert((offsetof(Track,surfaces)==0x10),"bad off");
		static_assert((offsetof(Track,timeLines)==0x28),"bad off");
		static_assert((offsetof(Track,worldMatrix)==0x40),"bad off");
		static_assert((offsetof(Track,aiSplineRecorder)==0x80),"bad off");
		static_assert((offsetof(Track,isOpen)==0x88),"bad off");
		static_assert((offsetof(Track,drsMamanger)==0x90),"bad off");
		static_assert((offsetof(Track,startingBounds)==0x98),"bad off");
		static_assert((offsetof(Track,dynamicTrack)==0xB0),"bad off");
		static_assert((offsetof(Track,name)==0xC8),"bad off");
		static_assert((offsetof(Track,config)==0xE8),"bad off");
		static_assert((offsetof(Track,dataFolder)==0x108),"bad off");
		static_assert((offsetof(Track,dynamicGripLevel)==0x128),"bad off");
		static_assert((offsetof(Track,sectorsNormalizedPositions)==0x130),"bad off");
	};
};

//UDT: class TrackAvatar @len=776 @vfcount=6
	//_Base: class GameObject @off=0 @len=88
	//_Func: public void TrackAvatar(const TrackAvatar &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void TrackAvatar(Sim * isim, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & iunixName, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & config); @loc=static @len=5425 @rva=1856080
	//_Func: public void ~TrackAvatar(); @virtual vtpo=0 vfid=0 @loc=static @len=449 @rva=1861680
	//_Data: this+0x58, Member, Type: class IdealLine *, idealLine
	//_Data: this+0x60, Member, Type: class std::vector<TrackObject *,std::allocator<TrackObject *> >, trackObjects
	//_Data: this+0x78, Member, Type: struct TrackInfo, info
	//_Func: public std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getDataFolder(); @loc=static @len=38 @rva=1867872
	//_Func: public void shutdown(); @virtual vtpo=0 vfid=5 @loc=static @len=3 @rva=96368
	//_Func: public mat44f getSpawnPosition(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & setName, unsigned int index); @loc=static @len=238 @rva=1868288
	//_Func: public void addTrackTestObject(vec3f  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public int getMaxSlotsAvailable(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & setName); @loc=static @len=34 @rva=1867920
	//_Func: public AISpline * getAISpline(); @loc=static @len=12 @rva=1867792
	//_Func: public AISplineRecorder * getSplineRecorder(); @loc=static @len=8 @rva=1868528
	//_Func: public void initRespawnPositionSet(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & setName); @loc=static @len=966 @rva=1882304
	//_Func: public IRayTrackCollisionProvider * getRayTrackCollisionProvider(); @loc=optimized @len=0 @rva=0
	//_Func: public void initPitCrew(); @loc=static @len=4741 @rva=1877552
	//_Func: public int getNumberOfSectors(); @loc=optimized @len=0 @rva=0
	//_Func: public SunPosition_Location getTrackLocation(); @loc=optimized @len=0 @rva=0
	//_Func: public std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getSectorDescription(float normalizedPosition); @loc=static @len=311 @rva=1867968
	//_Func: public void setPlayerPitPosition(int  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public int getSector(float  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void update(float dt); @virtual vtpo=0 vfid=1 @loc=static @len=275 @rva=1886736
	//_Func: public std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getConfig(); @loc=static @len=61 @rva=1867808
	//_Func: public bool hasDRSZones(); @loc=optimized @len=0 @rva=0
	//_Func: public void setDynamicGrooveVisibility(bool visibility); @loc=static @len=12 @rva=1886720
	//_Func: public SurfacesManager * getSurfaceManager(); @loc=optimized @len=0 @rva=0
	//_Data: this+0x80, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, unixName
	//_Data: this+0xA0, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, config
	//_Data: this+0xC0, Member, Type: int, playerPitPosition
	//_Data: this+0xC8, Member, Type: struct SunPosition::Location, trackLocation
	//_Data: this+0xE8, Member, Type: class Sim *, sim
	//_Data: this+0xF0, Member, Type: class Model *, model
	//_Data: this+0xF8, Member, Type: class Track, physicsTrack
	//_Data: this+0x240, Member, Type: class std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::vector<Node *,std::allocator<Node *> >,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,std::vector<Node *,std::allocator<Node *> > > > >, spawnPositions
	//_Data: this+0x250, Member, Type: class SurfacesManager, surfacesManager
	//_Data: this+0x270, Member, Type: class DisplayList *, displayList
	//_Data: this+0x278, Member, Type: class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, igPhysicalizePrefix
	//_Data: this+0x298, Member, Type: class GridSpaceDisplayer *, spacePartitioner
	//_Data: this+0x2A0, Member, Type: class std::vector<LollipopCrew *,std::allocator<LollipopCrew *> >, lollipopCrews
	//_Data: this+0x2B8, Member, Type: struct TrackPhysicsStats, physicsStats
	//_Data: this+0x2D0, Member, Type: class std::vector<DynamicTrackObject,std::allocator<DynamicTrackObject> >, dynamicObjects
	//_Data: this+0x2E8, Member, Type: class DynamicTrackManager *, dynamicTrackManager
	//_Tag 11
	//_Data: this+0x2F0, Member, Type: class std::vector<TrackAvatar::SectorDescription,std::allocator<TrackAvatar::SectorDescription> >, sectorDescriptions
	//_Func: protected void initSurfaceDefinitions(); @loc=optimized @len=0 @rva=0
	//_Func: protected void init3D(); @loc=static @len=4345 @rva=1869632
	//_Func: protected void initPhysics(); @loc=static @len=494 @rva=1877056
	//_Func: protected void processPhysicsNode(Node * node); @loc=static @len=376 @rva=1885664
	//_Func: protected void addPhysicsMesh(Mesh * mesh, unsigned int sector_id); @loc=static @len=542 @rva=1865952
	//_Func: protected SurfaceDef getSurfaceDescFromMeshName(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * meshname); @loc=static @len=1087 @rva=1868544
	//_Func: protected void initTimeLines(); @loc=static @len=2122 @rva=1883280
	//_Func: protected void initDynamicObjects(); @loc=static @len=3063 @rva=1873984
	//_Func: protected void updateDynamicObjects(float dt); @loc=static @len=149 @rva=1887024
	//_Func: public TrackAvatar & operator=(const TrackAvatar &  _arg0); @loc=optimized @len=0 @rva=0
	//_Func: public void * __vecDelDtor(unsigned int  _arg0); @intro @virtual vtpo=0 vfid=0 @loc=optimized @len=0 @rva=0
//UDT;

class TrackAvatar : public GameObject {
public:
	IdealLine * idealLine;
	std::vector<TrackObject *,std::allocator<TrackObject *> > trackObjects;
	TrackInfo info;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > unixName;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > config;
	int playerPitPosition;
	SunPosition_Location trackLocation;
	Sim * sim;
	Model * model;
	Track physicsTrack;
	std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::vector<Node *,std::allocator<Node *> >,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,std::vector<Node *,std::allocator<Node *> > > > > spawnPositions;
	SurfacesManager surfacesManager;
	DisplayList * displayList;
	std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > igPhysicalizePrefix;
	GridSpaceDisplayer * spacePartitioner;
	std::vector<LollipopCrew *,std::allocator<LollipopCrew *> > lollipopCrews;
	TrackPhysicsStats physicsStats;
	std::vector<DynamicTrackObject,std::allocator<DynamicTrackObject> > dynamicObjects;
	DynamicTrackManager * dynamicTrackManager;
	std::vector<TrackAvatar_SectorDescription,std::allocator<TrackAvatar_SectorDescription> > sectorDescriptions;
	inline TrackAvatar() { }
	inline TrackAvatar(const TrackAvatar& other) = default;
	inline TrackAvatar& operator=(const TrackAvatar& other) = default;
	inline void ctor(Sim * isim, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & iunixName, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & config) { typedef void (TrackAvatar::*_fpt)(Sim *, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(1856080)); (this->*_f)(isim, iunixName, config); }
	virtual ~TrackAvatar();
	inline void dtor() { typedef void (TrackAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(1861680)); (this->*_f)(); }
	inline std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getDataFolder() { typedef std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > (TrackAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(1867872)); return (this->*_f)(); }
	virtual void shutdown_vf5();
	inline void shutdown_impl() { typedef void (TrackAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(96368)); return (this->*_f)(); }
	inline void shutdown() { typedef void (TrackAvatar::*_fpt)(); auto _f=xcast<_fpt>(get_vfp(this, 5)); return (this->*_f)(); }
	inline mat44f getSpawnPosition(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & setName, unsigned int index) { typedef mat44f (TrackAvatar::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &, unsigned int); auto _f=xcast<_fpt>(_drva(1868288)); return (this->*_f)(setName, index); }
	inline int getMaxSlotsAvailable(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & setName) { typedef int (TrackAvatar::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(1867920)); return (this->*_f)(setName); }
	inline AISpline * getAISpline() { typedef AISpline * (TrackAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(1867792)); return (this->*_f)(); }
	inline AISplineRecorder * getSplineRecorder() { typedef AISplineRecorder * (TrackAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(1868528)); return (this->*_f)(); }
	inline void initRespawnPositionSet(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & setName) { typedef void (TrackAvatar::*_fpt)(const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &); auto _f=xcast<_fpt>(_drva(1882304)); return (this->*_f)(setName); }
	inline void initPitCrew() { typedef void (TrackAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(1877552)); return (this->*_f)(); }
	inline std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getSectorDescription(float normalizedPosition) { typedef std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > (TrackAvatar::*_fpt)(float); auto _f=xcast<_fpt>(_drva(1867968)); return (this->*_f)(normalizedPosition); }
	virtual void update_vf1(float dt);
	inline void update_impl(float dt) { typedef void (TrackAvatar::*_fpt)(float); auto _f=xcast<_fpt>(_drva(1886736)); return (this->*_f)(dt); }
	inline void update(float dt) { typedef void (TrackAvatar::*_fpt)(float); auto _f=xcast<_fpt>(get_vfp(this, 1)); return (this->*_f)(dt); }
	inline std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > getConfig() { typedef std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > (TrackAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(1867808)); return (this->*_f)(); }
	inline void setDynamicGrooveVisibility(bool visibility) { typedef void (TrackAvatar::*_fpt)(bool); auto _f=xcast<_fpt>(_drva(1886720)); return (this->*_f)(visibility); }
	inline void init3D() { typedef void (TrackAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(1869632)); return (this->*_f)(); }
	inline void initPhysics() { typedef void (TrackAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(1877056)); return (this->*_f)(); }
	inline void processPhysicsNode(Node * node) { typedef void (TrackAvatar::*_fpt)(Node *); auto _f=xcast<_fpt>(_drva(1885664)); return (this->*_f)(node); }
	inline void addPhysicsMesh(Mesh * mesh, unsigned int sector_id) { typedef void (TrackAvatar::*_fpt)(Mesh *, unsigned int); auto _f=xcast<_fpt>(_drva(1865952)); return (this->*_f)(mesh, sector_id); }
	inline SurfaceDef getSurfaceDescFromMeshName(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * meshname) { typedef SurfaceDef (TrackAvatar::*_fpt)(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *); auto _f=xcast<_fpt>(_drva(1868544)); return (this->*_f)(meshname); }
	inline void initTimeLines() { typedef void (TrackAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(1883280)); return (this->*_f)(); }
	inline void initDynamicObjects() { typedef void (TrackAvatar::*_fpt)(); auto _f=xcast<_fpt>(_drva(1873984)); return (this->*_f)(); }
	inline void updateDynamicObjects(float dt) { typedef void (TrackAvatar::*_fpt)(float); auto _f=xcast<_fpt>(_drva(1887024)); return (this->*_f)(dt); }
	inline void _guard_obj() {
		static_assert((sizeof(TrackAvatar)==776),"bad size");
		static_assert((offsetof(TrackAvatar,idealLine)==0x58),"bad off");
		static_assert((offsetof(TrackAvatar,trackObjects)==0x60),"bad off");
		static_assert((offsetof(TrackAvatar,info)==0x78),"bad off");
		static_assert((offsetof(TrackAvatar,unixName)==0x80),"bad off");
		static_assert((offsetof(TrackAvatar,config)==0xA0),"bad off");
		static_assert((offsetof(TrackAvatar,playerPitPosition)==0xC0),"bad off");
		static_assert((offsetof(TrackAvatar,trackLocation)==0xC8),"bad off");
		static_assert((offsetof(TrackAvatar,sim)==0xE8),"bad off");
		static_assert((offsetof(TrackAvatar,model)==0xF0),"bad off");
		static_assert((offsetof(TrackAvatar,physicsTrack)==0xF8),"bad off");
		static_assert((offsetof(TrackAvatar,spawnPositions)==0x240),"bad off");
		static_assert((offsetof(TrackAvatar,surfacesManager)==0x250),"bad off");
		static_assert((offsetof(TrackAvatar,displayList)==0x270),"bad off");
		static_assert((offsetof(TrackAvatar,igPhysicalizePrefix)==0x278),"bad off");
		static_assert((offsetof(TrackAvatar,spacePartitioner)==0x298),"bad off");
		static_assert((offsetof(TrackAvatar,lollipopCrews)==0x2A0),"bad off");
		static_assert((offsetof(TrackAvatar,physicsStats)==0x2B8),"bad off");
		static_assert((offsetof(TrackAvatar,dynamicObjects)==0x2D0),"bad off");
		static_assert((offsetof(TrackAvatar,dynamicTrackManager)==0x2E8),"bad off");
		static_assert((offsetof(TrackAvatar,sectorDescriptions)==0x2F0),"bad off");
	};
};

